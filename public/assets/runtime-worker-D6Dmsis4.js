var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a2, _b2, _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options2, _toString, _emptyExt, _AST_instances, fillNegs_fn, _AST_static, parseAST_fn, partsToRegExp_fn, parseGlob_fn;
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const finalizer = Symbol("Comlink.finalizer");
const throwMarker = Symbol("Comlink.thrown");
const isObject$1 = (val) => typeof val === "object" && val !== null || typeof val === "function";
const proxyTransferHandler = {
  canHandle: (val) => isObject$1(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
const throwTransferHandler = {
  canHandle: (value2) => isObject$1(value2) && throwMarker in value2,
  serialize({ value: value2 }) {
    let serialized;
    if (value2 instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value2.message,
          name: value2.name,
          stack: value2.stack
        }
      };
    } else {
      serialized = { isError: false, value: value2 };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
const transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep2 = globalThis, allowedOrigins = ["*"]) {
  ep2.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id: id2, type: type2, path: path2 } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path2.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path2.reduce((obj2, prop) => obj2[prop], obj);
      switch (type2) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path2.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value2 = new rawValue(...argumentList);
            returnValue = proxy(value2);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value2) {
      returnValue = { value: value2, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value2) => {
      return { value: value2, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep2.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
      if (type2 === "RELEASE") {
        ep2.removeEventListener("message", callback);
        closeEndPoint(ep2);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep2.postMessage(Object.assign(Object.assign({}, wireValue), { id: id2 }), transferables);
    });
  });
  if (ep2.start) {
    ep2.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep2, target) {
  const pendingListeners = /* @__PURE__ */ new Map();
  ep2.addEventListener("message", function handleMessage(ev) {
    const { data: data2 } = ev;
    if (!data2 || !data2.id) {
      return;
    }
    const resolver = pendingListeners.get(data2.id);
    if (!resolver) {
      return;
    }
    try {
      resolver(data2);
    } finally {
      pendingListeners.delete(data2.id);
    }
  });
  return createProxy(ep2, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep2) {
  return requestResponseMessage(ep2, /* @__PURE__ */ new Map(), {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep2);
  });
}
const proxyCounter = /* @__PURE__ */ new WeakMap();
const proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep2) => {
  const newCount = (proxyCounter.get(ep2) || 0) - 1;
  proxyCounter.set(ep2, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep2);
  }
});
function registerProxy(proxy2, ep2) {
  const newCount = (proxyCounter.get(ep2) || 0) + 1;
  proxyCounter.set(ep2, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep2, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep2, pendingListeners, path2 = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep2);
          pendingListeners.clear();
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path2.length === 0) {
          return { then: () => proxy2 };
        }
        const r2 = requestResponseMessage(ep2, pendingListeners, {
          type: "GET",
          path: path2.map((p) => p.toString())
        }).then(fromWireValue);
        return r2.then.bind(r2);
      }
      return createProxy(ep2, pendingListeners, [...path2, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value2, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep2, pendingListeners, {
        type: "SET",
        path: [...path2, prop].map((p) => p.toString()),
        value: value2
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path2[path2.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep2, pendingListeners, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep2, pendingListeners, path2.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep2, pendingListeners, {
        type: "APPLY",
        path: path2.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep2, pendingListeners, {
        type: "CONSTRUCT",
        path: path2.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep2);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v2) => v2[0]), myFlat(processed.map((v2) => v2[1]))];
}
const transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value2) {
  for (const [name2, handler] of transferHandlers) {
    if (handler.canHandle(value2)) {
      const [serializedValue, transferables] = handler.serialize(value2);
      return [
        {
          type: "HANDLER",
          name: name2,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value: value2
    },
    transferCache.get(value2) || []
  ];
}
function fromWireValue(value2) {
  switch (value2.type) {
    case "HANDLER":
      return transferHandlers.get(value2.name).deserialize(value2.value);
    case "RAW":
      return value2.value;
  }
}
function requestResponseMessage(ep2, pendingListeners, msg, transfers) {
  return new Promise((resolve2) => {
    const id2 = generateUUID();
    pendingListeners.set(id2, resolve2);
    if (ep2.start) {
      ep2.start();
    }
    ep2.postMessage(Object.assign({ id: id2 }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}
const CHUNK = 8192;
function uint8ToBase64(bytes) {
  const parts = [];
  for (let i2 = 0; i2 < bytes.length; i2 += CHUNK) {
    parts.push(String.fromCharCode.apply(null, Array.from(bytes.subarray(i2, i2 + CHUNK))));
  }
  return btoa(parts.join(""));
}
function base64ToUint8(base642) {
  const binary = atob(base642);
  const bytes = new Uint8Array(binary.length);
  for (let i2 = 0; i2 < binary.length; i2++) {
    bytes[i2] = binary.charCodeAt(i2);
  }
  return bytes;
}
function uint8ToHex(bytes) {
  const hex = new Array(bytes.length);
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex[i2] = bytes[i2].toString(16).padStart(2, "0");
  }
  return hex.join("");
}
function uint8ToBinaryString(bytes) {
  const parts = [];
  for (let i2 = 0; i2 < bytes.length; i2 += CHUNK) {
    parts.push(String.fromCharCode.apply(null, Array.from(bytes.subarray(i2, i2 + CHUNK))));
  }
  return parts.join("");
}
function createNodeError(code2, syscall, path2, message) {
  const errno = {
    ENOENT: -2,
    ENOTDIR: -20,
    EISDIR: -21,
    EEXIST: -17,
    ENOTEMPTY: -39
  };
  const messages2 = {
    ENOENT: "no such file or directory",
    ENOTDIR: "not a directory",
    EISDIR: "is a directory",
    EEXIST: "file already exists",
    ENOTEMPTY: "directory not empty"
  };
  const err2 = new Error(
    `${code2}: ${messages2[code2]}, ${syscall} '${path2}'`
  );
  err2.code = code2;
  err2.errno = errno[code2];
  err2.syscall = syscall;
  err2.path = path2;
  return err2;
}
class VirtualFS {
  constructor() {
    __publicField(this, "root");
    __publicField(this, "encoder", new TextEncoder());
    __publicField(this, "decoder", new TextDecoder());
    __publicField(this, "watchers", /* @__PURE__ */ new Map());
    __publicField(this, "eventListeners", /* @__PURE__ */ new Map());
    this.root = {
      type: "directory",
      children: /* @__PURE__ */ new Map(),
      mtime: Date.now()
    };
  }
  on(event, listener) {
    if (!this.eventListeners.has(event)) {
      this.eventListeners.set(event, /* @__PURE__ */ new Set());
    }
    this.eventListeners.get(event).add(listener);
    return this;
  }
  off(event, listener) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      listeners.delete(listener);
    }
    return this;
  }
  emit(event, ...args) {
    const listeners = this.eventListeners.get(event);
    if (listeners) {
      for (const listener of listeners) {
        try {
          listener(...args);
        } catch (err2) {
          console.error("Error in VFS event listener:", err2);
        }
      }
    }
  }
  /**
   * Serialize the entire file tree to a snapshot (for worker transfer)
   */
  toSnapshot() {
    const files = [];
    this.serializeNode("/", this.root, files);
    return { files };
  }
  serializeNode(path2, node2, files) {
    if (node2.type === "file") {
      let content = "";
      if (node2.content && node2.content.length > 0) {
        content = uint8ToBase64(node2.content);
      }
      files.push({ path: path2, type: "file", content });
    } else if (node2.type === "directory") {
      files.push({ path: path2, type: "directory" });
      if (node2.children) {
        for (const [name2, child] of node2.children) {
          const childPath = path2 === "/" ? `/${name2}` : `${path2}/${name2}`;
          this.serializeNode(childPath, child, files);
        }
      }
    }
  }
  /**
   * Create a VirtualFS from a snapshot
   */
  static fromSnapshot(snapshot) {
    const vfs2 = new VirtualFS();
    const sortedFiles = snapshot.files.map((entry, i2) => ({ entry, depth: entry.path.split("/").length, i: i2 })).sort((a, b) => a.depth - b.depth || a.i - b.i).map((x2) => x2.entry);
    for (const entry of sortedFiles) {
      if (entry.path === "/") continue;
      if (entry.type === "directory") {
        vfs2.mkdirSync(entry.path, { recursive: true });
      } else if (entry.type === "file") {
        let content;
        if (entry.content) {
          content = base64ToUint8(entry.content);
        } else {
          content = new Uint8Array(0);
        }
        const parentPath = entry.path.substring(0, entry.path.lastIndexOf("/")) || "/";
        if (parentPath !== "/" && !vfs2.existsSync(parentPath)) {
          vfs2.mkdirSync(parentPath, { recursive: true });
        }
        vfs2.writeFileSyncInternal(entry.path, content, false);
      }
    }
    return vfs2;
  }
  /**
   * Internal write that optionally emits events
   */
  writeFileSyncInternal(path2, data2, emitEvent) {
    const normalized = this.normalizePath(path2);
    const parentPath = this.getParentPath(normalized);
    const basename2 = this.getBasename(normalized);
    if (!basename2) {
      throw new Error(`EISDIR: illegal operation on a directory, '${path2}'`);
    }
    const parent = this.ensureDirectory(parentPath);
    const existed = parent.children.has(basename2);
    const content = typeof data2 === "string" ? this.encoder.encode(data2) : data2;
    parent.children.set(basename2, {
      type: "file",
      content,
      mtime: Date.now()
    });
    if (emitEvent) {
      this.notifyWatchers(normalized, existed ? "change" : "rename");
      this.emit("change", normalized, typeof data2 === "string" ? data2 : this.decoder.decode(data2));
    }
  }
  /**
   * Normalize path - resolve . and .. segments, ensure leading /
   */
  normalizePath(path2) {
    if (!path2.startsWith("/")) {
      path2 = "/" + path2;
    }
    const parts = path2.split("/").filter(Boolean);
    const resolved = [];
    for (const part of parts) {
      if (part === "..") {
        resolved.pop();
      } else if (part !== ".") {
        resolved.push(part);
      }
    }
    return "/" + resolved.join("/");
  }
  /**
   * Get path segments from normalized path
   */
  getPathSegments(path2) {
    return this.normalizePath(path2).split("/").filter(Boolean);
  }
  /**
   * Get parent directory path
   */
  getParentPath(path2) {
    const normalized = this.normalizePath(path2);
    const lastSlash = normalized.lastIndexOf("/");
    return lastSlash <= 0 ? "/" : normalized.slice(0, lastSlash);
  }
  /**
   * Get basename from path
   */
  getBasename(path2) {
    const normalized = this.normalizePath(path2);
    const lastSlash = normalized.lastIndexOf("/");
    return normalized.slice(lastSlash + 1);
  }
  /**
   * Get node at path, returns undefined if not found
   */
  getNode(path2) {
    const segments = this.getPathSegments(path2);
    let current2 = this.root;
    for (const segment of segments) {
      if (current2.type !== "directory" || !current2.children) {
        return void 0;
      }
      const child = current2.children.get(segment);
      if (!child) {
        return void 0;
      }
      current2 = child;
    }
    return current2;
  }
  /**
   * Get or create directory at path (for mkdir -p behavior)
   */
  ensureDirectory(path2) {
    const segments = this.getPathSegments(path2);
    let current2 = this.root;
    for (const segment of segments) {
      if (!current2.children) {
        current2.children = /* @__PURE__ */ new Map();
      }
      let child = current2.children.get(segment);
      if (!child) {
        child = { type: "directory", children: /* @__PURE__ */ new Map(), mtime: Date.now() };
        current2.children.set(segment, child);
      } else if (child.type !== "directory") {
        throw new Error(`ENOTDIR: not a directory, '${path2}'`);
      }
      current2 = child;
    }
    return current2;
  }
  /**
   * Check if path exists
   */
  existsSync(path2) {
    return this.getNode(path2) !== void 0;
  }
  /**
   * Get stats for path
   */
  statSync(path2) {
    var _a3;
    const node2 = this.getNode(path2);
    if (!node2) {
      throw createNodeError("ENOENT", "stat", path2);
    }
    const size = node2.type === "file" ? ((_a3 = node2.content) == null ? void 0 : _a3.length) || 0 : 0;
    const mtime = node2.mtime;
    return {
      isFile: () => node2.type === "file",
      isDirectory: () => node2.type === "directory",
      isSymbolicLink: () => false,
      isBlockDevice: () => false,
      isCharacterDevice: () => false,
      isFIFO: () => false,
      isSocket: () => false,
      size,
      mode: node2.type === "directory" ? 493 : 420,
      mtime: new Date(mtime),
      atime: new Date(mtime),
      ctime: new Date(mtime),
      birthtime: new Date(mtime),
      mtimeMs: mtime,
      atimeMs: mtime,
      ctimeMs: mtime,
      birthtimeMs: mtime,
      nlink: 1,
      uid: 1e3,
      gid: 1e3,
      dev: 0,
      ino: 0,
      rdev: 0,
      blksize: 4096,
      blocks: Math.ceil(size / 512)
    };
  }
  /**
   * lstatSync - same as statSync for our virtual FS (no symlinks)
   */
  lstatSync(path2) {
    return this.statSync(path2);
  }
  readFileSync(path2, encoding) {
    const node2 = this.getNode(path2);
    if (!node2) {
      throw createNodeError("ENOENT", "open", path2);
    }
    if (node2.type !== "file") {
      throw createNodeError("EISDIR", "read", path2);
    }
    const content = node2.content || new Uint8Array(0);
    if (encoding === "utf8" || encoding === "utf-8") {
      return this.decoder.decode(content);
    }
    return content;
  }
  /**
   * Write data to file, creating parent directories as needed
   */
  writeFileSync(path2, data2) {
    this.writeFileSyncInternal(path2, data2, true);
  }
  /**
   * Create directory, optionally with recursive parent creation
   */
  mkdirSync(path2, options2) {
    const normalized = this.normalizePath(path2);
    if (options2 == null ? void 0 : options2.recursive) {
      this.ensureDirectory(normalized);
      return;
    }
    const parentPath = this.getParentPath(normalized);
    const basename2 = this.getBasename(normalized);
    if (!basename2) {
      return;
    }
    const parent = this.getNode(parentPath);
    if (!parent) {
      throw createNodeError("ENOENT", "mkdir", parentPath);
    }
    if (parent.type !== "directory") {
      throw createNodeError("ENOTDIR", "mkdir", parentPath);
    }
    if (parent.children.has(basename2)) {
      throw createNodeError("EEXIST", "mkdir", path2);
    }
    parent.children.set(basename2, {
      type: "directory",
      children: /* @__PURE__ */ new Map(),
      mtime: Date.now()
    });
  }
  /**
   * Read directory contents
   */
  readdirSync(path2) {
    const node2 = this.getNode(path2);
    if (!node2) {
      throw createNodeError("ENOENT", "scandir", path2);
    }
    if (node2.type !== "directory") {
      throw createNodeError("ENOTDIR", "scandir", path2);
    }
    return Array.from(node2.children.keys());
  }
  /**
   * Remove file
   */
  unlinkSync(path2) {
    const normalized = this.normalizePath(path2);
    const parentPath = this.getParentPath(normalized);
    const basename2 = this.getBasename(normalized);
    const parent = this.getNode(parentPath);
    if (!parent || parent.type !== "directory") {
      throw createNodeError("ENOENT", "unlink", path2);
    }
    const node2 = parent.children.get(basename2);
    if (!node2) {
      throw createNodeError("ENOENT", "unlink", path2);
    }
    if (node2.type !== "file") {
      throw createNodeError("EISDIR", "unlink", path2);
    }
    parent.children.delete(basename2);
    this.notifyWatchers(normalized, "rename");
    this.emit("delete", normalized);
  }
  /**
   * Remove directory (must be empty)
   */
  rmdirSync(path2) {
    const normalized = this.normalizePath(path2);
    const parentPath = this.getParentPath(normalized);
    const basename2 = this.getBasename(normalized);
    if (!basename2) {
      throw new Error(`EPERM: operation not permitted, '${path2}'`);
    }
    const parent = this.getNode(parentPath);
    if (!parent || parent.type !== "directory") {
      throw createNodeError("ENOENT", "rmdir", path2);
    }
    const node2 = parent.children.get(basename2);
    if (!node2) {
      throw createNodeError("ENOENT", "rmdir", path2);
    }
    if (node2.type !== "directory") {
      throw createNodeError("ENOTDIR", "rmdir", path2);
    }
    if (node2.children.size > 0) {
      throw createNodeError("ENOTEMPTY", "rmdir", path2);
    }
    parent.children.delete(basename2);
  }
  /**
   * Rename/move file or directory
   */
  renameSync(oldPath, newPath) {
    const normalizedOld = this.normalizePath(oldPath);
    const normalizedNew = this.normalizePath(newPath);
    const oldParentPath = this.getParentPath(normalizedOld);
    const oldBasename = this.getBasename(normalizedOld);
    const newParentPath = this.getParentPath(normalizedNew);
    const newBasename = this.getBasename(normalizedNew);
    const oldParent = this.getNode(oldParentPath);
    if (!oldParent || oldParent.type !== "directory") {
      throw createNodeError("ENOENT", "rename", oldPath);
    }
    const node2 = oldParent.children.get(oldBasename);
    if (!node2) {
      throw createNodeError("ENOENT", "rename", oldPath);
    }
    const newParent = this.ensureDirectory(newParentPath);
    oldParent.children.delete(oldBasename);
    newParent.children.set(newBasename, node2);
    this.notifyWatchers(normalizedOld, "rename");
    this.notifyWatchers(normalizedNew, "rename");
  }
  /**
   * Read file with optional options parameter
   */
  readFile(path2, optionsOrCallback, callback) {
    const actualCallback = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
    const options2 = typeof optionsOrCallback === "object" ? optionsOrCallback : void 0;
    try {
      const data2 = (options2 == null ? void 0 : options2.encoding) ? this.readFileSync(path2, options2.encoding) : this.readFileSync(path2);
      if (actualCallback) {
        setTimeout(() => actualCallback(null, data2), 0);
      }
    } catch (err2) {
      if (actualCallback) {
        setTimeout(() => actualCallback(err2), 0);
      }
    }
  }
  /**
   * Async stat
   */
  stat(path2, callback) {
    try {
      const stats = this.statSync(path2);
      setTimeout(() => callback(null, stats), 0);
    } catch (err2) {
      setTimeout(() => callback(err2), 0);
    }
  }
  /**
   * Async lstat
   */
  lstat(path2, callback) {
    this.stat(path2, callback);
  }
  /**
   * Async readdir
   */
  readdir(path2, optionsOrCallback, callback) {
    const actualCallback = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
    try {
      const files = this.readdirSync(path2);
      if (actualCallback) {
        setTimeout(() => actualCallback(null, files), 0);
      }
    } catch (err2) {
      if (actualCallback) {
        setTimeout(() => actualCallback(err2), 0);
      }
    }
  }
  /**
   * Async realpath
   */
  realpath(path2, callback) {
    try {
      const resolved = this.realpathSync(path2);
      setTimeout(() => callback(null, resolved), 0);
    } catch (err2) {
      setTimeout(() => callback(err2), 0);
    }
  }
  /**
   * Sync realpath - in our VFS, just normalize the path
   */
  realpathSync(path2) {
    const normalized = this.normalizePath(path2);
    if (!this.existsSync(normalized)) {
      throw createNodeError("ENOENT", "realpath", path2);
    }
    return normalized;
  }
  /**
   * Watch for file changes
   */
  watch(filename2, optionsOrListener, listener) {
    const normalized = this.normalizePath(filename2);
    let options2 = {};
    let actualListener;
    if (typeof optionsOrListener === "function") {
      actualListener = optionsOrListener;
    } else if (optionsOrListener) {
      options2 = optionsOrListener;
      actualListener = listener;
    } else {
      actualListener = listener;
    }
    const entry = {
      listener: actualListener || (() => {
      }),
      recursive: options2.recursive || false,
      closed: false
    };
    if (!this.watchers.has(normalized)) {
      this.watchers.set(normalized, /* @__PURE__ */ new Set());
    }
    this.watchers.get(normalized).add(entry);
    const watcher = {
      close: () => {
        entry.closed = true;
        const watcherSet = this.watchers.get(normalized);
        if (watcherSet) {
          watcherSet.delete(entry);
          if (watcherSet.size === 0) {
            this.watchers.delete(normalized);
          }
        }
      },
      ref: () => watcher,
      unref: () => watcher
    };
    return watcher;
  }
  /**
   * Notify watchers of file changes
   */
  notifyWatchers(path2, eventType) {
    const normalized = this.normalizePath(path2);
    const basename2 = this.getBasename(normalized);
    const directWatchers = this.watchers.get(normalized);
    if (directWatchers) {
      for (const entry of directWatchers) {
        if (!entry.closed) {
          try {
            entry.listener(eventType, basename2);
          } catch (err2) {
            console.error("Error in file watcher:", err2);
          }
        }
      }
    }
    let currentPath = this.getParentPath(normalized);
    let relativePath = basename2;
    while (currentPath) {
      const parentWatchers = this.watchers.get(currentPath);
      if (parentWatchers) {
        for (const entry of parentWatchers) {
          if (!entry.closed) {
            const isDirectChild = this.getParentPath(normalized) === currentPath;
            if (entry.recursive || isDirectChild) {
              try {
                entry.listener(eventType, relativePath);
              } catch (err2) {
                console.error("Error in file watcher:", err2);
              }
            }
          }
        }
      }
      if (currentPath === "/") break;
      relativePath = this.getBasename(currentPath) + "/" + relativePath;
      currentPath = this.getParentPath(currentPath);
    }
  }
  /**
   * Access check - in our VFS, always succeeds if file exists
   */
  accessSync(path2, mode) {
    if (!this.existsSync(path2)) {
      throw createNodeError("ENOENT", "access", path2);
    }
  }
  /**
   * Async access
   */
  access(path2, modeOrCallback, callback) {
    const actualCallback = typeof modeOrCallback === "function" ? modeOrCallback : callback;
    try {
      this.accessSync(path2);
      if (actualCallback) setTimeout(() => actualCallback(null), 0);
    } catch (err2) {
      if (actualCallback) setTimeout(() => actualCallback(err2), 0);
    }
  }
  /**
   * Copy file
   */
  copyFileSync(src, dest) {
    const content = this.readFileSync(src);
    this.writeFileSync(dest, content);
  }
  /**
   * Create read stream - simplified implementation
   */
  createReadStream(path2) {
    const self = this;
    const listeners = {};
    const stream = {
      on(event, cb2) {
        if (!listeners[event]) listeners[event] = [];
        listeners[event].push(cb2);
        return stream;
      },
      pipe(dest) {
        return dest;
      }
    };
    setTimeout(() => {
      var _a3, _b3, _c2;
      try {
        const data2 = self.readFileSync(path2);
        (_a3 = listeners["data"]) == null ? void 0 : _a3.forEach((cb2) => cb2(data2));
        (_b3 = listeners["end"]) == null ? void 0 : _b3.forEach((cb2) => cb2());
      } catch (err2) {
        (_c2 = listeners["error"]) == null ? void 0 : _c2.forEach((cb2) => cb2(err2));
      }
    }, 0);
    return stream;
  }
  /**
   * Create write stream - simplified implementation
   */
  createWriteStream(path2) {
    const self = this;
    const chunks = [];
    const listeners = {};
    const encoder = new TextEncoder();
    return {
      write(data2) {
        const chunk = typeof data2 === "string" ? encoder.encode(data2) : data2;
        chunks.push(chunk);
        return true;
      },
      end(data2) {
        var _a3, _b3;
        if (data2) {
          const chunk = typeof data2 === "string" ? encoder.encode(data2) : data2;
          chunks.push(chunk);
        }
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const combined = new Uint8Array(totalLength);
        let offset2 = 0;
        for (const chunk of chunks) {
          combined.set(chunk, offset2);
          offset2 += chunk.length;
        }
        self.writeFileSync(path2, combined);
        (_a3 = listeners["finish"]) == null ? void 0 : _a3.forEach((cb2) => cb2());
        (_b3 = listeners["close"]) == null ? void 0 : _b3.forEach((cb2) => cb2());
      },
      on(event, cb2) {
        if (!listeners[event]) listeners[event] = [];
        listeners[event].push(cb2);
        return this;
      }
    };
  }
}
function simpleHash(str) {
  let hash = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    hash = (hash << 5) - hash + str.charCodeAt(i2);
    hash |= 0;
  }
  return hash.toString(36);
}
const _decoder$2 = new TextDecoder();
const _encoder$1 = new TextEncoder();
class Dirent {
  constructor(name2, isDirectory, isFile) {
    __publicField(this, "name");
    __publicField(this, "_isDirectory");
    __publicField(this, "_isFile");
    this.name = name2;
    this._isDirectory = isDirectory;
    this._isFile = isFile;
  }
  isDirectory() {
    return this._isDirectory;
  }
  isFile() {
    return this._isFile;
  }
  isBlockDevice() {
    return false;
  }
  isCharacterDevice() {
    return false;
  }
  isFIFO() {
    return false;
  }
  isSocket() {
    return false;
  }
  isSymbolicLink() {
    return false;
  }
}
function createBuffer(data2) {
  const buffer = data2;
  Object.defineProperty(buffer, "toString", {
    value: function(encoding) {
      if (encoding === "utf8" || encoding === "utf-8" || !encoding) {
        return _decoder$2.decode(this);
      }
      if (encoding === "base64") {
        return uint8ToBase64(this);
      }
      if (encoding === "hex") {
        return uint8ToHex(this);
      }
      throw new Error(`Unsupported encoding: ${encoding}`);
    },
    writable: true,
    configurable: true
  });
  return buffer;
}
function toPath(pathLike, getCwd) {
  let path2;
  if (typeof pathLike === "string") {
    path2 = pathLike;
  } else if (pathLike instanceof URL) {
    if (pathLike.protocol === "file:") {
      path2 = decodeURIComponent(pathLike.pathname);
    } else {
      throw new Error(`Unsupported URL protocol: ${pathLike.protocol}`);
    }
  } else if (Buffer.isBuffer(pathLike)) {
    path2 = pathLike.toString("utf8");
  } else if (pathLike && typeof pathLike === "object" && "toString" in pathLike) {
    path2 = String(pathLike);
  } else {
    throw new TypeError(`Path must be a string, URL, or Buffer. Received: ${typeof pathLike}`);
  }
  if (!path2.startsWith("/") && getCwd) {
    const cwd = getCwd();
    path2 = cwd.endsWith("/") ? cwd + path2 : cwd + "/" + path2;
  }
  return path2;
}
const fdMap = /* @__PURE__ */ new Map();
let nextFd = 3;
const callTracker = {
  statSync: /* @__PURE__ */ new Map(),
  readdirSync: /* @__PURE__ */ new Map(),
  lastReset: Date.now()
};
function trackCall(method, path2) {
  var _a3;
  const now = Date.now();
  if (now - callTracker.lastReset > 500) {
    callTracker.statSync.clear();
    callTracker.readdirSync.clear();
    callTracker.lastReset = now;
  }
  const map = callTracker[method];
  const count = (map.get(path2) || 0) + 1;
  map.set(path2, count);
  if (count === 10 && path2.includes("_generated")) {
    console.warn(`[fs] ${method} called ${count}x on ${path2}`);
    const err2 = new Error();
    console.log(`[fs] Stack at ${count} calls:`, (_a3 = err2.stack) == null ? void 0 : _a3.split("\n").slice(1, 10).join("\n"));
  }
  if (count === 50) {
    console.warn(`[fs] Potential infinite loop: ${method} called ${count}+ times on ${path2}`);
  }
}
function createFsShim(vfs2, getCwd) {
  const resolvePath = (pathLike) => toPath(pathLike, getCwd);
  const constants2 = {
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1
  };
  const promises2 = {
    readFile(pathLike, encodingOrOptions) {
      return new Promise((resolve2, reject) => {
        try {
          const path2 = resolvePath(pathLike);
          let encoding;
          if (typeof encodingOrOptions === "string") {
            encoding = encodingOrOptions;
          } else if (encodingOrOptions == null ? void 0 : encodingOrOptions.encoding) {
            encoding = encodingOrOptions.encoding;
          }
          if (encoding === "utf8" || encoding === "utf-8") {
            resolve2(vfs2.readFileSync(path2, "utf8"));
          } else {
            resolve2(createBuffer(vfs2.readFileSync(path2)));
          }
        } catch (err2) {
          reject(err2);
        }
      });
    },
    writeFile(pathLike, data2) {
      return new Promise((resolve2, reject) => {
        try {
          vfs2.writeFileSync(resolvePath(pathLike), data2);
          resolve2();
        } catch (err2) {
          reject(err2);
        }
      });
    },
    stat(pathLike) {
      return new Promise((resolve2, reject) => {
        try {
          const path2 = typeof pathLike === "string" ? pathLike : resolvePath(pathLike);
          resolve2(vfs2.statSync(path2));
        } catch (err2) {
          reject(err2);
        }
      });
    },
    lstat(pathLike) {
      return this.stat(resolvePath(pathLike));
    },
    readdir(pathLike, options2) {
      return new Promise((resolve2, reject) => {
        try {
          const path2 = resolvePath(pathLike);
          const entries = vfs2.readdirSync(path2);
          const opts = typeof options2 === "string" ? {} : options2;
          if (opts == null ? void 0 : opts.withFileTypes) {
            const dirents = entries.map((name2) => {
              const entryPath = path2.endsWith("/") ? path2 + name2 : path2 + "/" + name2;
              let isDir = false;
              let isFile = false;
              try {
                const stat = vfs2.statSync(entryPath);
                isDir = stat.isDirectory();
                isFile = stat.isFile();
              } catch {
                isFile = true;
              }
              return new Dirent(name2, isDir, isFile);
            });
            resolve2(dirents);
          } else {
            resolve2(entries);
          }
        } catch (err2) {
          reject(err2);
        }
      });
    },
    mkdir(pathLike, options2) {
      return new Promise((resolve2, reject) => {
        try {
          vfs2.mkdirSync(resolvePath(pathLike), options2);
          resolve2();
        } catch (err2) {
          reject(err2);
        }
      });
    },
    unlink(pathLike) {
      return new Promise((resolve2, reject) => {
        try {
          vfs2.unlinkSync(resolvePath(pathLike));
          resolve2();
        } catch (err2) {
          reject(err2);
        }
      });
    },
    rmdir(path2) {
      return new Promise((resolve2, reject) => {
        try {
          vfs2.rmdirSync(path2);
          resolve2();
        } catch (err2) {
          reject(err2);
        }
      });
    },
    rename(oldPath, newPath) {
      return new Promise((resolve2, reject) => {
        try {
          vfs2.renameSync(oldPath, newPath);
          resolve2();
        } catch (err2) {
          reject(err2);
        }
      });
    },
    access(path2, mode) {
      return new Promise((resolve2, reject) => {
        try {
          vfs2.accessSync(path2, mode);
          resolve2();
        } catch (err2) {
          reject(err2);
        }
      });
    },
    realpath(path2) {
      return new Promise((resolve2, reject) => {
        try {
          resolve2(vfs2.realpathSync(path2));
        } catch (err2) {
          reject(err2);
        }
      });
    },
    copyFile(src, dest) {
      return new Promise((resolve2, reject) => {
        try {
          vfs2.copyFileSync(src, dest);
          resolve2();
        } catch (err2) {
          reject(err2);
        }
      });
    }
  };
  return {
    readFileSync(pathLike, encodingOrOptions) {
      const path2 = resolvePath(pathLike);
      let encoding;
      if (typeof encodingOrOptions === "string") {
        encoding = encodingOrOptions;
      } else if (encodingOrOptions == null ? void 0 : encodingOrOptions.encoding) {
        encoding = encodingOrOptions.encoding;
      }
      if (encoding === "utf8" || encoding === "utf-8") {
        return vfs2.readFileSync(path2, "utf8");
      }
      const data2 = vfs2.readFileSync(path2);
      return createBuffer(data2);
    },
    writeFileSync(pathLike, data2) {
      if (typeof pathLike === "number") {
        const fd2 = pathLike;
        const entry = fdMap.get(fd2);
        if (!entry) {
          const err2 = new Error(`EBADF: bad file descriptor, write`);
          err2.code = "EBADF";
          err2.errno = -9;
          throw err2;
        }
        const bytes = typeof data2 === "string" ? _encoder$1.encode(data2) : data2;
        entry.content = new Uint8Array(bytes);
        entry.position = bytes.length;
        return;
      }
      const path2 = resolvePath(pathLike);
      vfs2.writeFileSync(path2, data2);
    },
    existsSync(pathLike) {
      return vfs2.existsSync(resolvePath(pathLike));
    },
    mkdirSync(pathLike, options2) {
      const path2 = resolvePath(pathLike);
      vfs2.mkdirSync(path2, options2);
    },
    readdirSync(pathLike, options2) {
      const path2 = resolvePath(pathLike);
      trackCall("readdirSync", path2);
      const entries = vfs2.readdirSync(path2);
      const opts = typeof options2 === "string" ? {} : options2;
      if (opts == null ? void 0 : opts.withFileTypes) {
        const dirents = entries.map((name2) => {
          const entryPath = path2.endsWith("/") ? path2 + name2 : path2 + "/" + name2;
          let isDir = false;
          let isFile = false;
          try {
            const stat = vfs2.statSync(entryPath);
            isDir = stat.isDirectory();
            isFile = stat.isFile();
          } catch {
            isFile = true;
          }
          return new Dirent(name2, isDir, isFile);
        });
        if (path2.includes("_generated")) {
          console.log(`[fs] readdirSync(${path2}, withFileTypes) -> [${dirents.map((d) => d.name).join(", ")}]`);
        }
        return dirents;
      }
      if (path2.includes("_generated")) {
        console.log(`[fs] readdirSync(${path2}) -> [${entries.join(", ")}]`);
      }
      return entries;
    },
    statSync(pathLike) {
      const origPath = typeof pathLike === "string" ? pathLike : String(pathLike);
      const path2 = resolvePath(pathLike);
      trackCall("statSync", path2);
      const result = vfs2.statSync(path2);
      if (path2.includes("_generated")) {
        const wasRemapped = origPath !== path2;
        console.log(`[fs] statSync(${origPath}${wasRemapped ? " -> " + path2 : ""}) -> isDir: ${result.isDirectory()}`);
      }
      return result;
    },
    lstatSync(pathLike) {
      return vfs2.lstatSync(resolvePath(pathLike));
    },
    fstatSync(fd2) {
      const entry = fdMap.get(fd2);
      if (!entry) {
        const err2 = new Error(`EBADF: bad file descriptor, fstat`);
        err2.code = "EBADF";
        err2.errno = -9;
        throw err2;
      }
      return vfs2.statSync(entry.path);
    },
    openSync(pathLike, flags, _mode) {
      const path2 = resolvePath(pathLike);
      const flagStr = typeof flags === "number" ? "r" : flags;
      const exists = vfs2.existsSync(path2);
      const isWriteMode = flagStr.includes("w") || flagStr.includes("a");
      const isReadMode = flagStr.includes("r") && !flagStr.includes("+");
      if (!exists && isReadMode) {
        const err2 = new Error(`ENOENT: no such file or directory, open '${path2}'`);
        err2.code = "ENOENT";
        err2.errno = -2;
        err2.path = path2;
        throw err2;
      }
      let content;
      if (exists && !flagStr.includes("w")) {
        content = vfs2.readFileSync(path2);
      } else {
        content = new Uint8Array(0);
        if (isWriteMode) {
          const parentPath = path2.substring(0, path2.lastIndexOf("/")) || "/";
          if (!vfs2.existsSync(parentPath)) {
            vfs2.mkdirSync(parentPath, { recursive: true });
          }
        }
      }
      const fd2 = nextFd++;
      fdMap.set(fd2, {
        path: path2,
        position: flagStr.includes("a") ? content.length : 0,
        flags: flagStr,
        content: new Uint8Array(content)
      });
      return fd2;
    },
    closeSync(fd2) {
      const entry = fdMap.get(fd2);
      if (!entry) {
        return;
      }
      if (entry.flags.includes("w") || entry.flags.includes("a") || entry.flags.includes("+")) {
        vfs2.writeFileSync(entry.path, entry.content);
      }
      fdMap.delete(fd2);
    },
    readSync(fd2, buffer, offset2, length2, position) {
      const entry = fdMap.get(fd2);
      if (!entry) {
        const err2 = new Error(`EBADF: bad file descriptor, read`);
        err2.code = "EBADF";
        err2.errno = -9;
        throw err2;
      }
      const readPos = position !== null ? position : entry.position;
      const bytesToRead = Math.min(length2, entry.content.length - readPos);
      if (bytesToRead <= 0) {
        return 0;
      }
      for (let i2 = 0; i2 < bytesToRead; i2++) {
        buffer[offset2 + i2] = entry.content[readPos + i2];
      }
      if (position === null) {
        entry.position += bytesToRead;
      }
      return bytesToRead;
    },
    writeSync(fd2, buffer, offset2, length2, position) {
      const entry = fdMap.get(fd2);
      if (!entry) {
        const err2 = new Error(`EBADF: bad file descriptor, write`);
        err2.code = "EBADF";
        err2.errno = -9;
        throw err2;
      }
      let data2;
      if (typeof buffer === "string") {
        data2 = _encoder$1.encode(buffer);
        offset2 = 0;
        length2 = data2.length;
      } else {
        data2 = buffer;
        offset2 = offset2 ?? 0;
        length2 = length2 ?? data2.length - offset2;
      }
      const writePos = position !== null && position !== void 0 ? position : entry.position;
      const endPos = writePos + length2;
      if (endPos > entry.content.length) {
        const newContent = new Uint8Array(endPos);
        newContent.set(entry.content);
        entry.content = newContent;
      }
      for (let i2 = 0; i2 < length2; i2++) {
        entry.content[writePos + i2] = data2[offset2 + i2];
      }
      if (position === null || position === void 0) {
        entry.position = endPos;
      }
      return length2;
    },
    ftruncateSync(fd2, len = 0) {
      const entry = fdMap.get(fd2);
      if (!entry) {
        const err2 = new Error(`EBADF: bad file descriptor, ftruncate`);
        err2.code = "EBADF";
        err2.errno = -9;
        throw err2;
      }
      if (len < entry.content.length) {
        entry.content = entry.content.slice(0, len);
      } else if (len > entry.content.length) {
        const newContent = new Uint8Array(len);
        newContent.set(entry.content);
        entry.content = newContent;
      }
    },
    fsyncSync(_fd) {
    },
    fdatasyncSync(_fd) {
    },
    mkdtempSync(prefix) {
      const suffix = Math.random().toString(36).slice(2, 8);
      const tempDir = `${prefix}${suffix}`;
      const resolvedPath2 = resolvePath(tempDir);
      vfs2.mkdirSync(resolvedPath2, { recursive: true });
      return resolvedPath2;
    },
    rmSync(pathLike, options2) {
      const path2 = resolvePath(pathLike);
      if (!vfs2.existsSync(path2)) {
        if (options2 == null ? void 0 : options2.force) return;
        throw createNodeError("ENOENT", "rm", path2);
      }
      const stats = vfs2.statSync(path2);
      if (stats.isDirectory()) {
        if (options2 == null ? void 0 : options2.recursive) {
          const entries = vfs2.readdirSync(path2);
          for (const entry of entries) {
            const entryPath = path2.endsWith("/") ? path2 + entry : path2 + "/" + entry;
            this.rmSync(entryPath, options2);
          }
          vfs2.rmdirSync(path2);
        } else {
          throw createNodeError("EISDIR", "rm", path2);
        }
      } else {
        vfs2.unlinkSync(path2);
      }
    },
    unlinkSync(pathLike) {
      const path2 = resolvePath(pathLike);
      if (path2.includes("_generated")) {
        console.log(`[fs] unlinkSync(${path2})`);
      }
      vfs2.unlinkSync(path2);
    },
    rmdirSync(pathLike) {
      vfs2.rmdirSync(resolvePath(pathLike));
    },
    renameSync(oldPathLike, newPathLike) {
      vfs2.renameSync(resolvePath(oldPathLike), resolvePath(newPathLike));
    },
    realpathSync: Object.assign(
      function realpathSync(pathLike) {
        return vfs2.realpathSync(resolvePath(pathLike));
      },
      {
        native(pathLike) {
          return vfs2.realpathSync(resolvePath(pathLike));
        }
      }
    ),
    accessSync(pathLike, _mode) {
      vfs2.accessSync(resolvePath(pathLike));
    },
    copyFileSync(srcLike, destLike) {
      const src = resolvePath(srcLike);
      const dest = resolvePath(destLike);
      const data2 = vfs2.readFileSync(src);
      vfs2.writeFileSync(dest, data2);
    },
    watch(pathLike, optionsOrListener, listener) {
      return vfs2.watch(resolvePath(pathLike), optionsOrListener, listener);
    },
    readFile(pathLike, optionsOrCallback, callback) {
      const path2 = resolvePath(pathLike);
      vfs2.readFile(path2, optionsOrCallback, callback);
    },
    stat(pathLike, callback) {
      vfs2.stat(resolvePath(pathLike), callback);
    },
    lstat(pathLike, callback) {
      vfs2.lstat(resolvePath(pathLike), callback);
    },
    readdir(pathLike, optionsOrCallback, callback) {
      const cb2 = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
      const opts = typeof optionsOrCallback === "function" ? void 0 : optionsOrCallback;
      const path2 = resolvePath(pathLike);
      try {
        const entries = vfs2.readdirSync(path2);
        if (opts == null ? void 0 : opts.withFileTypes) {
          const dirents = entries.map((name2) => {
            const entryPath = path2.endsWith("/") ? path2 + name2 : path2 + "/" + name2;
            let isDir = false;
            let isFile = false;
            try {
              const stat = vfs2.statSync(entryPath);
              isDir = stat.isDirectory();
              isFile = stat.isFile();
            } catch {
              isFile = true;
            }
            return new Dirent(name2, isDir, isFile);
          });
          cb2 == null ? void 0 : cb2(null, dirents);
        } else {
          cb2 == null ? void 0 : cb2(null, entries);
        }
      } catch (err2) {
        cb2 == null ? void 0 : cb2(err2);
      }
    },
    realpath(pathLike, callback) {
      vfs2.realpath(resolvePath(pathLike), callback);
    },
    access(pathLike, modeOrCallback, callback) {
      vfs2.access(resolvePath(pathLike), modeOrCallback, callback);
    },
    createReadStream(pathLike) {
      return vfs2.createReadStream(resolvePath(pathLike));
    },
    createWriteStream(pathLike) {
      return vfs2.createWriteStream(resolvePath(pathLike));
    },
    promises: promises2,
    constants: constants2
  };
}
const sep$1 = "/";
const delimiter = ":";
function normalize(path2) {
  if (!path2) return ".";
  const isAbsolute2 = path2.startsWith("/");
  const parts = path2.split("/").filter(Boolean);
  const resolved = [];
  for (const part of parts) {
    if (part === "..") {
      if (resolved.length > 0 && resolved[resolved.length - 1] !== "..") {
        resolved.pop();
      } else if (!isAbsolute2) {
        resolved.push("..");
      }
    } else if (part !== ".") {
      resolved.push(part);
    }
  }
  let result = resolved.join("/");
  if (isAbsolute2) {
    result = "/" + result;
  }
  return result || ".";
}
function join$1(...paths) {
  if (paths.length === 0) return ".";
  return normalize(paths.filter(Boolean).join("/"));
}
function resolve$2(...paths) {
  let resolvedPath2 = "";
  for (let i2 = paths.length - 1; i2 >= 0 && !resolvedPath2.startsWith("/"); i2--) {
    const path2 = paths[i2];
    if (!path2) continue;
    resolvedPath2 = path2 + (resolvedPath2 ? "/" + resolvedPath2 : "");
  }
  if (!resolvedPath2.startsWith("/")) {
    const cwd = typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/";
    resolvedPath2 = cwd + (resolvedPath2 ? "/" + resolvedPath2 : "");
  }
  return normalize(resolvedPath2);
}
function isAbsolute(path2) {
  return path2.startsWith("/");
}
function dirname(path2) {
  if (!path2) return ".";
  const normalized = normalize(path2);
  const lastSlash = normalized.lastIndexOf("/");
  if (lastSlash === -1) return ".";
  if (lastSlash === 0) return "/";
  return normalized.slice(0, lastSlash);
}
function basename(path2, ext2) {
  if (!path2) return "";
  const normalized = normalize(path2);
  let base = normalized.slice(normalized.lastIndexOf("/") + 1);
  if (ext2 && base.endsWith(ext2)) {
    base = base.slice(0, -ext2.length);
  }
  return base;
}
function extname(path2) {
  const base = basename(path2);
  const dotIndex = base.lastIndexOf(".");
  if (dotIndex <= 0) return "";
  return base.slice(dotIndex);
}
function relative(from, to2) {
  from = resolve$2(from);
  to2 = resolve$2(to2);
  if (from === to2) return "";
  const fromParts = from.split("/").filter(Boolean);
  const toParts = to2.split("/").filter(Boolean);
  let commonLength = 0;
  for (let i2 = 0; i2 < Math.min(fromParts.length, toParts.length); i2++) {
    if (fromParts[i2] !== toParts[i2]) break;
    commonLength++;
  }
  const upCount = fromParts.length - commonLength;
  const remainingPath = toParts.slice(commonLength);
  const result = [...Array(upCount).fill(".."), ...remainingPath];
  return result.join("/") || ".";
}
function parse$R(path2) {
  const normalized = normalize(path2);
  const isAbs = isAbsolute(normalized);
  const dir = dirname(normalized);
  const base = basename(normalized);
  const ext2 = extname(normalized);
  const name2 = base.slice(0, base.length - ext2.length);
  return {
    root: isAbs ? "/" : "",
    dir,
    base,
    ext: ext2,
    name: name2
  };
}
function format$2(pathObject) {
  const dir = pathObject.dir || pathObject.root || "";
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir) return base;
  if (dir === pathObject.root) return dir + base;
  return dir + "/" + base;
}
const posix = {
  sep: sep$1,
  delimiter,
  normalize,
  join: join$1,
  resolve: resolve$2,
  isAbsolute,
  dirname,
  basename,
  extname,
  relative,
  parse: parse$R,
  format: format$2
};
const win32 = {
  sep: "\\",
  delimiter: ";",
  normalize,
  join: join$1,
  resolve: resolve$2,
  isAbsolute,
  dirname,
  basename,
  extname,
  relative,
  parse: parse$R,
  format: format$2
};
var path$1 = {
  sep: sep$1,
  delimiter,
  normalize,
  join: join$1,
  resolve: resolve$2,
  isAbsolute,
  dirname,
  basename,
  extname,
  relative,
  parse: parse$R,
  format: format$2,
  posix,
  win32
};
var pathShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  basename,
  default: path$1,
  delimiter,
  dirname,
  extname,
  format: format$2,
  isAbsolute,
  join: join$1,
  normalize,
  parse: parse$R,
  posix,
  relative,
  resolve: resolve$2,
  sep: sep$1,
  win32
});
const kEvents = Symbol("events");
const kMaxListeners = Symbol("maxListeners");
_b2 = kEvents, _a2 = kMaxListeners;
class EventEmitter {
  constructor() {
    __publicField(this, _b2);
    __publicField(this, _a2);
  }
  // Helper to get events map, creating it if needed
  _getEvents() {
    const self = this;
    if (!self[kEvents]) {
      self[kEvents] = /* @__PURE__ */ new Map();
    }
    return self[kEvents];
  }
  on(event, listener) {
    return this.addListener(event, listener);
  }
  addListener(event, listener) {
    const events2 = this._getEvents();
    if (!events2.has(event)) {
      events2.set(event, []);
    }
    events2.get(event).push(listener);
    return this;
  }
  once(event, listener) {
    const onceWrapper = (...args) => {
      this.removeListener(event, onceWrapper);
      listener.apply(this, args);
    };
    return this.addListener(event, onceWrapper);
  }
  off(event, listener) {
    return this.removeListener(event, listener);
  }
  removeListener(event, listener) {
    const events2 = this._getEvents();
    const listeners = events2.get(event);
    if (listeners) {
      const index2 = listeners.indexOf(listener);
      if (index2 !== -1) {
        listeners.splice(index2, 1);
      }
    }
    return this;
  }
  removeAllListeners(event) {
    const events2 = this._getEvents();
    if (event) {
      events2.delete(event);
    } else {
      events2.clear();
    }
    return this;
  }
  emit(event, ...args) {
    const events2 = this._getEvents();
    const listeners = events2.get(event);
    if (!listeners || listeners.length === 0) {
      if (event === "error") {
        const err2 = args[0];
        if (err2 instanceof Error) {
          throw err2;
        }
        throw new Error("Unhandled error event");
      }
      return false;
    }
    for (const listener of [...listeners]) {
      try {
        listener.apply(this, args);
      } catch (err2) {
        console.error("Error in event listener:", err2);
      }
    }
    return true;
  }
  listeners(event) {
    const events2 = this._getEvents();
    return [...events2.get(event) || []];
  }
  rawListeners(event) {
    return this.listeners(event);
  }
  listenerCount(event) {
    var _a3;
    const events2 = this._getEvents();
    return ((_a3 = events2.get(event)) == null ? void 0 : _a3.length) || 0;
  }
  eventNames() {
    const events2 = this._getEvents();
    return [...events2.keys()];
  }
  setMaxListeners(n2) {
    this[kMaxListeners] = n2;
    return this;
  }
  getMaxListeners() {
    return this[kMaxListeners] || 10;
  }
  prependListener(event, listener) {
    const events2 = this._getEvents();
    if (!events2.has(event)) {
      events2.set(event, []);
    }
    events2.get(event).unshift(listener);
    return this;
  }
  prependOnceListener(event, listener) {
    const onceWrapper = (...args) => {
      this.removeListener(event, onceWrapper);
      listener.apply(this, args);
    };
    return this.prependListener(event, onceWrapper);
  }
  // Static methods for compatibility
  static listenerCount(emitter, event) {
    return emitter.listenerCount(event);
  }
}
const events = EventEmitter;
events.EventEmitter = EventEmitter;
events.once = async (emitter, event) => {
  return new Promise((resolve2, reject) => {
    const onEvent = (...args) => {
      emitter.removeListener("error", onError);
      resolve2(args);
    };
    const onError = (...args) => {
      emitter.removeListener(event, onEvent);
      reject(args[0]);
    };
    emitter.once(event, onEvent);
    emitter.once("error", onError);
  });
};
events.on = (emitter, event) => {
  const iterator = {
    async next() {
      return new Promise((resolve2) => {
        emitter.once(event, (...args) => resolve2({ value: args, done: false }));
      });
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  return iterator;
};
events.getEventListeners = (emitter, event) => emitter.listeners(event);
events.listenerCount = (emitter, event) => emitter.listenerCount(event);
function createProcessStream(isWritable, writeImpl) {
  const emitter = new EventEmitter();
  const stream = {
    isTTY: false,
    on(event, listener) {
      emitter.on(event, listener);
      return stream;
    },
    once(event, listener) {
      emitter.once(event, listener);
      return stream;
    },
    off(event, listener) {
      emitter.off(event, listener);
      return stream;
    },
    emit(event, ...args) {
      return emitter.emit(event, ...args);
    },
    addListener(event, listener) {
      emitter.addListener(event, listener);
      return stream;
    },
    removeListener(event, listener) {
      emitter.removeListener(event, listener);
      return stream;
    },
    removeAllListeners(event) {
      emitter.removeAllListeners(event);
      return stream;
    },
    setMaxListeners(n2) {
      emitter.setMaxListeners(n2);
      return stream;
    },
    getMaxListeners() {
      return emitter.getMaxListeners();
    },
    listenerCount(event) {
      return emitter.listenerCount(event);
    },
    listeners(event) {
      return emitter.listeners(event);
    },
    rawListeners(event) {
      return emitter.rawListeners(event);
    },
    prependListener(event, listener) {
      emitter.prependListener(event, listener);
      return stream;
    },
    prependOnceListener(event, listener) {
      emitter.prependOnceListener(event, listener);
      return stream;
    },
    eventNames() {
      return emitter.eventNames();
    },
    pause() {
      return stream;
    },
    resume() {
      return stream;
    },
    setEncoding(_encoding) {
      return stream;
    },
    // Default write implementation (no-op for readable streams)
    write(_data, _encoding, callback) {
      if (callback) queueMicrotask(callback);
      return true;
    },
    end(_data, callback) {
      if (callback) queueMicrotask(callback);
    },
    // Default read implementation (for stdin)
    read() {
      return null;
    },
    setRawMode(_mode) {
      return stream;
    }
  };
  if (isWritable && writeImpl) {
    stream.write = (data2, _encoding, callback) => {
      const result = writeImpl(typeof data2 === "string" ? data2 : data2.toString());
      if (callback) queueMicrotask(callback);
      return result;
    };
  }
  return stream;
}
function createProcess(options2) {
  let currentDir2 = (options2 == null ? void 0 : options2.cwd) || "/";
  const env = {
    NODE_ENV: "development",
    PATH: "/usr/local/bin:/usr/bin:/bin",
    HOME: "/",
    ...options2 == null ? void 0 : options2.env
  };
  const emitter = new EventEmitter();
  const startTime = Date.now();
  const proc = {
    env,
    cwd() {
      if (!proc._cwdCallCount) proc._cwdCallCount = 0;
      proc._cwdCallCount++;
      if (proc._cwdCallCount <= 5 || proc._cwdCallCount % 100 === 0) {
        console.log(`[process] cwd() called (${proc._cwdCallCount}x), returning:`, currentDir2);
      }
      return currentDir2;
    },
    chdir(directory) {
      console.log("[process] chdir called:", directory, "from:", currentDir2);
      if (!directory.startsWith("/")) {
        directory = currentDir2 + "/" + directory;
      }
      currentDir2 = directory;
      console.log("[process] chdir result:", currentDir2);
    },
    platform: "linux",
    // Pretend to be linux for better compatibility
    version: "v20.0.0",
    versions: { node: "20.0.0", v8: "11.3.244.8", uv: "1.44.2" },
    argv: ["node", "/index.js"],
    argv0: "node",
    execPath: "/usr/local/bin/node",
    execArgv: [],
    pid: 1,
    ppid: 0,
    exit(code2 = 0) {
      emitter.emit("exit", code2);
      if (options2 == null ? void 0 : options2.onExit) {
        options2.onExit(code2);
      }
      throw new Error(`Process exited with code ${code2}`);
    },
    nextTick(callback, ...args) {
      queueMicrotask(() => callback(...args));
    },
    stdout: createProcessStream(true, (data2) => {
      if (options2 == null ? void 0 : options2.onStdout) {
        options2.onStdout(data2);
      } else {
        console.log(data2);
      }
      return true;
    }),
    stderr: createProcessStream(true, (data2) => {
      if (options2 == null ? void 0 : options2.onStderr) {
        options2.onStderr(data2);
      } else {
        console.error(data2);
      }
      return true;
    }),
    stdin: createProcessStream(false),
    hrtime: Object.assign(
      function hrtime(time2) {
        const now = performance.now();
        const seconds = Math.floor(now / 1e3);
        const nanoseconds = Math.floor(now % 1e3 * 1e6);
        if (time2) {
          const diffSeconds = seconds - time2[0];
          const diffNanos = nanoseconds - time2[1];
          return [diffSeconds, diffNanos];
        }
        return [seconds, nanoseconds];
      },
      {
        bigint: () => BigInt(Math.floor(performance.now() * 1e6))
      }
    ),
    memoryUsage() {
      return {
        rss: 50 * 1024 * 1024,
        heapTotal: 30 * 1024 * 1024,
        heapUsed: 20 * 1024 * 1024,
        external: 1 * 1024 * 1024,
        arrayBuffers: 0
      };
    },
    uptime() {
      return (Date.now() - startTime) / 1e3;
    },
    cpuUsage() {
      return { user: 0, system: 0 };
    },
    // EventEmitter methods - delegate to emitter but return proc for chaining
    on(event, listener) {
      emitter.on(event, listener);
      return proc;
    },
    once(event, listener) {
      emitter.once(event, listener);
      return proc;
    },
    off(event, listener) {
      emitter.off(event, listener);
      return proc;
    },
    emit(event, ...args) {
      return emitter.emit(event, ...args);
    },
    addListener(event, listener) {
      emitter.addListener(event, listener);
      return proc;
    },
    removeListener(event, listener) {
      emitter.removeListener(event, listener);
      return proc;
    },
    removeAllListeners(event) {
      emitter.removeAllListeners(event);
      return proc;
    },
    listeners(event) {
      return emitter.listeners(event);
    },
    listenerCount(event) {
      return emitter.listenerCount(event);
    },
    prependListener(event, listener) {
      emitter.prependListener(event, listener);
      return proc;
    },
    prependOnceListener(event, listener) {
      emitter.prependOnceListener(event, listener);
      return proc;
    },
    eventNames() {
      return emitter.eventNames();
    },
    setMaxListeners(n2) {
      emitter.setMaxListeners(n2);
      return proc;
    },
    getMaxListeners() {
      return emitter.getMaxListeners();
    }
  };
  return proc;
}
createProcess();
const _encoder = new TextEncoder();
const _decoder$1 = new TextDecoder("utf-8");
class Readable extends EventEmitter {
  constructor() {
    super();
    __publicField(this, "_buffer", []);
    __publicField(this, "_ended", false);
    __publicField(this, "_flowing", false);
    __publicField(this, "_endEmitted", false);
    __publicField(this, "readable", true);
    __publicField(this, "readableEnded", false);
    __publicField(this, "readableFlowing", null);
  }
  // Internal method to add listener without triggering auto-flow
  _addListenerInternal(event, listener) {
    EventEmitter.prototype.addListener.call(this, event, listener);
    return this;
  }
  // Override on() to auto-flow when 'data' listener is added
  on(event, listener) {
    this._addListenerInternal(event, listener);
    if (event === "data" && !this._flowing) {
      queueMicrotask(() => {
        if (this.listenerCount("data") > 0 && !this._flowing) {
          this.resume();
        }
      });
    }
    return this;
  }
  // Also handle addListener (alias for on)
  addListener(event, listener) {
    return this.on(event, listener);
  }
  push(chunk) {
    if (chunk === null) {
      this._ended = true;
      this.readableEnded = true;
      this.readable = false;
      if (this._flowing && this._buffer.length === 0 && !this._endEmitted) {
        this._endEmitted = true;
        queueMicrotask(() => this.emit("end"));
      }
      return false;
    }
    const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
    this._buffer.push(buffer);
    if (this._flowing) {
      queueMicrotask(() => {
        this._flushBuffer();
      });
    }
    return true;
  }
  _flushBuffer() {
    while (this._buffer.length > 0 && this._flowing) {
      const data2 = this._buffer.shift();
      this.emit("data", data2);
    }
    if (this._ended && this._buffer.length === 0 && !this._endEmitted) {
      this._endEmitted = true;
      this.emit("end");
    }
  }
  read(size) {
    if (this._buffer.length === 0) {
      return null;
    }
    if (size === void 0) {
      const result = Buffer.concat(this._buffer);
      this._buffer = [];
      return result;
    }
    const chunks = [];
    let remaining = size;
    while (remaining > 0 && this._buffer.length > 0) {
      const chunk = this._buffer[0];
      if (chunk.length <= remaining) {
        chunks.push(this._buffer.shift());
        remaining -= chunk.length;
      } else {
        chunks.push(chunk.slice(0, remaining));
        this._buffer[0] = chunk.slice(remaining);
        remaining = 0;
      }
    }
    return chunks.length > 0 ? Buffer.concat(chunks) : null;
  }
  resume() {
    this._flowing = true;
    this.readableFlowing = true;
    this._flushBuffer();
    return this;
  }
  pause() {
    this._flowing = false;
    this.readableFlowing = false;
    return this;
  }
  pipe(destination) {
    this.on("data", (chunk) => {
      destination.write(chunk);
    });
    this.on("end", () => {
      destination.end();
    });
    this.resume();
    return destination;
  }
  unpipe(destination) {
    this.removeAllListeners("data");
    this.removeAllListeners("end");
    return this;
  }
  setEncoding(encoding) {
    return this;
  }
  destroy(error) {
    this._buffer = [];
    this._ended = true;
    this.readable = false;
    if (error) {
      this.emit("error", error);
    }
    this.emit("close");
    return this;
  }
  /**
   * Creates a Readable stream from an iterable or async iterable
   * @param iterable - An iterable or async iterable to create the stream from
   * @param options - Optional stream options
   */
  static from(iterable, options2) {
    const readable = new Readable();
    (async () => {
      try {
        for await (const chunk of iterable) {
          if (chunk !== null && chunk !== void 0) {
            const data2 = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
            readable.push(data2);
          }
        }
        readable.push(null);
      } catch (err2) {
        readable.destroy(err2);
      }
    })();
    return readable;
  }
}
class Writable extends EventEmitter {
  constructor() {
    super();
    __publicField(this, "_chunks", []);
    __publicField(this, "_ended", false);
    __publicField(this, "writable", true);
    __publicField(this, "writableEnded", false);
    __publicField(this, "writableFinished", false);
  }
  write(chunk, encodingOrCallback, callback) {
    if (this._ended) {
      const error = new Error("write after end");
      if (typeof encodingOrCallback === "function") {
        encodingOrCallback(error);
      } else if (callback) {
        callback(error);
      }
      return false;
    }
    const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
    this._chunks.push(buffer);
    const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
    if (cb2) {
      queueMicrotask(() => cb2(null));
    }
    return true;
  }
  end(chunkOrCallback, encodingOrCallback, callback) {
    if (typeof chunkOrCallback === "function") {
      callback = chunkOrCallback;
    } else if (chunkOrCallback !== void 0) {
      this.write(chunkOrCallback);
    }
    if (typeof encodingOrCallback === "function") {
      callback = encodingOrCallback;
    }
    this._ended = true;
    this.writable = false;
    this.writableEnded = true;
    queueMicrotask(() => {
      this.writableFinished = true;
      this.emit("finish");
      if (callback) {
        callback();
      }
    });
    return this;
  }
  getBuffer() {
    return Buffer.concat(this._chunks);
  }
  getBufferAsString(encoding = "utf8") {
    return this.getBuffer().toString(encoding);
  }
  destroy(error) {
    this._chunks = [];
    this._ended = true;
    this.writable = false;
    if (error) {
      this.emit("error", error);
    }
    this.emit("close");
    return this;
  }
  cork() {
  }
  uncork() {
  }
  setDefaultEncoding(encoding) {
    return this;
  }
}
class Duplex extends Readable {
  constructor() {
    super(...arguments);
    __publicField(this, "_writeChunks", []);
    __publicField(this, "_writeEnded", false);
    __publicField(this, "writable", true);
    __publicField(this, "writableEnded", false);
    __publicField(this, "writableFinished", false);
  }
  write(chunk, encodingOrCallback, callback) {
    if (this._writeEnded) {
      return false;
    }
    const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
    this._writeChunks.push(buffer);
    const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
    if (cb2) {
      queueMicrotask(() => cb2(null));
    }
    return true;
  }
  end(chunkOrCallback, encodingOrCallback, callback) {
    if (typeof chunkOrCallback === "function") {
      callback = chunkOrCallback;
    } else if (chunkOrCallback !== void 0) {
      this.write(chunkOrCallback);
    }
    this._writeEnded = true;
    this.writable = false;
    this.writableEnded = true;
    queueMicrotask(() => {
      this.writableFinished = true;
      this.emit("finish");
      if (callback) {
        callback();
      }
    });
    return this;
  }
}
class PassThrough extends Duplex {
  constructor() {
    super();
  }
  write(chunk, encodingOrCallback, callback) {
    const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
    this.push(buffer);
    const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
    if (cb2) {
      queueMicrotask(() => cb2(null));
    }
    return true;
  }
}
class Transform extends Duplex {
  constructor() {
    super();
  }
  _transform(chunk, encoding, callback) {
    callback(null, chunk);
  }
  _flush(callback) {
    callback(null);
  }
  write(chunk, encodingOrCallback, callback) {
    const buffer = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
    const encoding = typeof encodingOrCallback === "string" ? encodingOrCallback : "utf8";
    const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
    this._transform(buffer, encoding, (error, data2) => {
      if (error) {
        if (cb2) cb2(error);
        return;
      }
      if (data2) {
        this.push(data2);
      }
      if (cb2) cb2(null);
    });
    return true;
  }
  end(chunkOrCallback, encodingOrCallback, callback) {
    this._flush((error, data2) => {
      if (data2) {
        this.push(data2);
      }
    });
    return super.end(chunkOrCallback, encodingOrCallback, callback);
  }
}
class Stream extends EventEmitter {
  pipe(destination) {
    return destination;
  }
}
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.Stream = Stream;
Stream.from = Readable.from;
const promises$2 = {
  pipeline: async (...streams) => {
    return Promise.resolve();
  },
  finished: async (stream) => {
    return Promise.resolve();
  }
};
function pipeline(...args) {
  const callback = args[args.length - 1];
  if (typeof callback === "function") {
    setTimeout(() => callback(), 0);
  }
  return args[args.length - 2] || args[0];
}
function finished(stream, callback) {
  setTimeout(() => callback(), 0);
  return () => {
  };
}
const _BufferPolyfill = class _BufferPolyfill extends Uint8Array {
  static from(value2, encodingOrMapfn, thisArg) {
    if (typeof encodingOrMapfn === "function") {
      const arrayLike = value2;
      const mapped = Array.from(arrayLike, encodingOrMapfn, thisArg);
      return new _BufferPolyfill(mapped);
    }
    const data2 = value2;
    const encoding = encodingOrMapfn;
    if (Array.isArray(data2)) {
      return new _BufferPolyfill(data2);
    }
    if (typeof data2 === "string") {
      const enc = (encoding || "utf8").toLowerCase();
      if (enc === "base64" || enc === "base64url") {
        let base642 = data2;
        if (enc === "base64url") {
          base642 = data2.replace(/-/g, "+").replace(/_/g, "/");
          while (base642.length % 4 !== 0) {
            base642 += "=";
          }
        }
        const binary = atob(base642);
        const bytes2 = new Uint8Array(binary.length);
        for (let i2 = 0; i2 < binary.length; i2++) {
          bytes2[i2] = binary.charCodeAt(i2);
        }
        return new _BufferPolyfill(bytes2);
      }
      if (enc === "hex") {
        const bytes2 = new Uint8Array(data2.length / 2);
        for (let i2 = 0; i2 < data2.length; i2 += 2) {
          bytes2[i2 / 2] = parseInt(data2.slice(i2, i2 + 2), 16);
        }
        return new _BufferPolyfill(bytes2);
      }
      if (enc === "latin1" || enc === "binary") {
        const bytes2 = new Uint8Array(data2.length);
        for (let i2 = 0; i2 < data2.length; i2++) {
          bytes2[i2] = data2.charCodeAt(i2) & 255;
        }
        return new _BufferPolyfill(bytes2);
      }
      const bytes = _encoder.encode(data2);
      return new _BufferPolyfill(bytes);
    }
    if (data2 instanceof ArrayBuffer) {
      return new _BufferPolyfill(data2);
    }
    return new _BufferPolyfill(data2);
  }
  static alloc(size, fill) {
    const buffer = new _BufferPolyfill(size);
    if (fill !== void 0) {
      buffer.fill(fill);
    }
    return buffer;
  }
  static allocUnsafe(size) {
    return new _BufferPolyfill(size);
  }
  static allocUnsafeSlow(size) {
    return new _BufferPolyfill(size);
  }
  static concat(buffers) {
    const totalLength = buffers.reduce((sum, buf) => sum + buf.length, 0);
    const result = new _BufferPolyfill(totalLength);
    let offset2 = 0;
    for (const buf of buffers) {
      result.set(buf, offset2);
      offset2 += buf.length;
    }
    return result;
  }
  static isBuffer(obj) {
    return obj instanceof _BufferPolyfill || obj instanceof Uint8Array;
  }
  static isEncoding(encoding) {
    return ["utf8", "utf-8", "ascii", "latin1", "binary", "base64", "base64url", "hex"].includes(encoding.toLowerCase());
  }
  static byteLength(string, encoding) {
    const enc = (encoding || "utf8").toLowerCase();
    if (enc === "base64" || enc === "base64url") {
      const base642 = string.replace(/[=]/g, "");
      return Math.floor(base642.length * 3 / 4);
    }
    if (enc === "hex") {
      return string.length / 2;
    }
    return _encoder.encode(string).length;
  }
  toString(encoding = "utf8") {
    const enc = (encoding || "utf8").toLowerCase();
    if (enc === "base64") {
      return uint8ToBase64(this);
    }
    if (enc === "base64url") {
      return uint8ToBase64(this).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    }
    if (enc === "hex") {
      return uint8ToHex(this);
    }
    if (enc === "latin1" || enc === "binary") {
      return uint8ToBinaryString(this);
    }
    return _decoder$1.decode(this);
  }
  slice(start, end) {
    return new _BufferPolyfill(super.slice(start, end));
  }
  subarray(start, end) {
    return new _BufferPolyfill(super.subarray(start, end));
  }
  write(string, offset2) {
    const bytes = _encoder.encode(string);
    this.set(bytes, offset2 || 0);
    return bytes.length;
  }
  copy(target, targetStart, sourceStart, sourceEnd) {
    const src = this.subarray(sourceStart || 0, sourceEnd);
    target.set(src, targetStart || 0);
    return src.length;
  }
  compare(otherBuffer) {
    const len = Math.min(this.length, otherBuffer.length);
    for (let i2 = 0; i2 < len; i2++) {
      if (this[i2] < otherBuffer[i2]) return -1;
      if (this[i2] > otherBuffer[i2]) return 1;
    }
    if (this.length < otherBuffer.length) return -1;
    if (this.length > otherBuffer.length) return 1;
    return 0;
  }
  equals(otherBuffer) {
    return this.compare(otherBuffer) === 0;
  }
  toJSON() {
    return {
      type: "Buffer",
      data: Array.from(this)
    };
  }
  // Add Object prototype methods that TypedArrays don't have directly
  hasOwnProperty(prop) {
    return Object.prototype.hasOwnProperty.call(this, prop);
  }
  readUInt8(offset2) {
    return this[offset2];
  }
  readUInt16BE(offset2) {
    return this[offset2] << 8 | this[offset2 + 1];
  }
  readUInt16LE(offset2) {
    return this[offset2] | this[offset2 + 1] << 8;
  }
  readUInt32BE(offset2) {
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  }
  readUInt32LE(offset2) {
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  }
  writeUInt8(value2, offset2) {
    this[offset2] = value2 & 255;
    return offset2 + 1;
  }
  writeUInt16BE(value2, offset2) {
    this[offset2] = value2 >> 8 & 255;
    this[offset2 + 1] = value2 & 255;
    return offset2 + 2;
  }
  writeUInt16LE(value2, offset2) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >> 8 & 255;
    return offset2 + 2;
  }
  writeUInt32BE(value2, offset2) {
    this[offset2] = value2 >> 24 & 255;
    this[offset2 + 1] = value2 >> 16 & 255;
    this[offset2 + 2] = value2 >> 8 & 255;
    this[offset2 + 3] = value2 & 255;
    return offset2 + 4;
  }
  writeUInt32LE(value2, offset2) {
    this[offset2] = value2 & 255;
    this[offset2 + 1] = value2 >> 8 & 255;
    this[offset2 + 2] = value2 >> 16 & 255;
    this[offset2 + 3] = value2 >> 24 & 255;
    return offset2 + 4;
  }
  // Lowercase aliases for UInt methods (Node.js Buffer API compatibility)
  readUint8(offset2) {
    return this.readUInt8(offset2);
  }
  readUint16BE(offset2) {
    return this.readUInt16BE(offset2);
  }
  readUint16LE(offset2) {
    return this.readUInt16LE(offset2);
  }
  readUint32BE(offset2) {
    return this.readUInt32BE(offset2);
  }
  readUint32LE(offset2) {
    return this.readUInt32LE(offset2);
  }
  writeUint8(value2, offset2) {
    return this.writeUInt8(value2, offset2);
  }
  writeUint16BE(value2, offset2) {
    return this.writeUInt16BE(value2, offset2);
  }
  writeUint16LE(value2, offset2) {
    return this.writeUInt16LE(value2, offset2);
  }
  writeUint32BE(value2, offset2) {
    return this.writeUInt32BE(value2, offset2);
  }
  writeUint32LE(value2, offset2) {
    return this.writeUInt32LE(value2, offset2);
  }
  // Signed integer methods
  readInt8(offset2) {
    const val = this[offset2];
    return val & 128 ? val - 256 : val;
  }
  readInt16BE(offset2) {
    const val = this.readUInt16BE(offset2);
    return val & 32768 ? val - 65536 : val;
  }
  readInt16LE(offset2) {
    const val = this.readUInt16LE(offset2);
    return val & 32768 ? val - 65536 : val;
  }
  readInt32BE(offset2) {
    const val = this.readUInt32BE(offset2);
    return val | 0;
  }
  readInt32LE(offset2) {
    const val = this.readUInt32LE(offset2);
    return val | 0;
  }
  writeInt8(value2, offset2) {
    this[offset2] = value2 & 255;
    return offset2 + 1;
  }
  writeInt16BE(value2, offset2) {
    return this.writeUInt16BE(value2 & 65535, offset2);
  }
  writeInt16LE(value2, offset2) {
    return this.writeUInt16LE(value2 & 65535, offset2);
  }
  writeInt32BE(value2, offset2) {
    return this.writeUInt32BE(value2 >>> 0, offset2);
  }
  writeInt32LE(value2, offset2) {
    return this.writeUInt32LE(value2 >>> 0, offset2);
  }
  // BigInt methods (64-bit)
  readBigUInt64LE(offset2) {
    const lo2 = BigInt(this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24) & 0xffffffffn;
    const hi2 = BigInt(this[offset2 + 4] | this[offset2 + 5] << 8 | this[offset2 + 6] << 16 | this[offset2 + 7] << 24) & 0xffffffffn;
    return lo2 | hi2 << 32n;
  }
  readBigUInt64BE(offset2) {
    const hi2 = BigInt(this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]) & 0xffffffffn;
    const lo2 = BigInt(this[offset2 + 4] << 24 | this[offset2 + 5] << 16 | this[offset2 + 6] << 8 | this[offset2 + 7]) & 0xffffffffn;
    return lo2 | hi2 << 32n;
  }
  readBigInt64LE(offset2) {
    const val = this.readBigUInt64LE(offset2);
    if (val >= 0x8000000000000000n) {
      return val - 0x10000000000000000n;
    }
    return val;
  }
  readBigInt64BE(offset2) {
    const val = this.readBigUInt64BE(offset2);
    if (val >= 0x8000000000000000n) {
      return val - 0x10000000000000000n;
    }
    return val;
  }
  writeBigUInt64LE(value2, offset2) {
    const lo2 = value2 & 0xffffffffn;
    const hi2 = value2 >> 32n & 0xffffffffn;
    this[offset2] = Number(lo2 & 0xffn);
    this[offset2 + 1] = Number(lo2 >> 8n & 0xffn);
    this[offset2 + 2] = Number(lo2 >> 16n & 0xffn);
    this[offset2 + 3] = Number(lo2 >> 24n & 0xffn);
    this[offset2 + 4] = Number(hi2 & 0xffn);
    this[offset2 + 5] = Number(hi2 >> 8n & 0xffn);
    this[offset2 + 6] = Number(hi2 >> 16n & 0xffn);
    this[offset2 + 7] = Number(hi2 >> 24n & 0xffn);
    return offset2 + 8;
  }
  writeBigUInt64BE(value2, offset2) {
    const lo2 = value2 & 0xffffffffn;
    const hi2 = value2 >> 32n & 0xffffffffn;
    this[offset2] = Number(hi2 >> 24n & 0xffn);
    this[offset2 + 1] = Number(hi2 >> 16n & 0xffn);
    this[offset2 + 2] = Number(hi2 >> 8n & 0xffn);
    this[offset2 + 3] = Number(hi2 & 0xffn);
    this[offset2 + 4] = Number(lo2 >> 24n & 0xffn);
    this[offset2 + 5] = Number(lo2 >> 16n & 0xffn);
    this[offset2 + 6] = Number(lo2 >> 8n & 0xffn);
    this[offset2 + 7] = Number(lo2 & 0xffn);
    return offset2 + 8;
  }
  writeBigInt64LE(value2, offset2) {
    const unsigned = value2 < 0n ? value2 + 0x10000000000000000n : value2;
    return this.writeBigUInt64LE(unsigned, offset2);
  }
  writeBigInt64BE(value2, offset2) {
    const unsigned = value2 < 0n ? value2 + 0x10000000000000000n : value2;
    return this.writeBigUInt64BE(unsigned, offset2);
  }
  // Lowercase aliases for BigInt methods (Node.js Buffer API compatibility)
  readBigUint64LE(offset2) {
    return this.readBigUInt64LE(offset2);
  }
  readBigUint64BE(offset2) {
    return this.readBigUInt64BE(offset2);
  }
  writeBigUint64LE(value2, offset2) {
    return this.writeBigUInt64LE(value2, offset2);
  }
  writeBigUint64BE(value2, offset2) {
    return this.writeBigUInt64BE(value2, offset2);
  }
  // Float methods
  readFloatLE(offset2) {
    const view = new DataView(this.buffer, this.byteOffset + offset2, 4);
    return view.getFloat32(0, true);
  }
  readFloatBE(offset2) {
    const view = new DataView(this.buffer, this.byteOffset + offset2, 4);
    return view.getFloat32(0, false);
  }
  readDoubleLE(offset2) {
    const view = new DataView(this.buffer, this.byteOffset + offset2, 8);
    return view.getFloat64(0, true);
  }
  readDoubleBE(offset2) {
    const view = new DataView(this.buffer, this.byteOffset + offset2, 8);
    return view.getFloat64(0, false);
  }
  writeFloatLE(value2, offset2) {
    const view = new DataView(this.buffer, this.byteOffset + offset2, 4);
    view.setFloat32(0, value2, true);
    return offset2 + 4;
  }
  writeFloatBE(value2, offset2) {
    const view = new DataView(this.buffer, this.byteOffset + offset2, 4);
    view.setFloat32(0, value2, false);
    return offset2 + 4;
  }
  writeDoubleLE(value2, offset2) {
    const view = new DataView(this.buffer, this.byteOffset + offset2, 8);
    view.setFloat64(0, value2, true);
    return offset2 + 8;
  }
  writeDoubleBE(value2, offset2) {
    const view = new DataView(this.buffer, this.byteOffset + offset2, 8);
    view.setFloat64(0, value2, false);
    return offset2 + 8;
  }
  // Variable-length unsigned integer methods
  readUIntLE(offset2, byteLength) {
    let val = 0;
    let mul = 1;
    for (let i2 = 0; i2 < byteLength; i2++) {
      val += this[offset2 + i2] * mul;
      mul *= 256;
    }
    return val;
  }
  readUintLE(offset2, byteLength) {
    return this.readUIntLE(offset2, byteLength);
  }
  readUIntBE(offset2, byteLength) {
    let val = 0;
    let mul = 1;
    for (let i2 = byteLength - 1; i2 >= 0; i2--) {
      val += this[offset2 + i2] * mul;
      mul *= 256;
    }
    return val;
  }
  readUintBE(offset2, byteLength) {
    return this.readUIntBE(offset2, byteLength);
  }
  readIntLE(offset2, byteLength) {
    let val = this.readUIntLE(offset2, byteLength);
    const limit = Math.pow(2, byteLength * 8 - 1);
    if (val >= limit) {
      val -= Math.pow(2, byteLength * 8);
    }
    return val;
  }
  readIntBE(offset2, byteLength) {
    let val = this.readUIntBE(offset2, byteLength);
    const limit = Math.pow(2, byteLength * 8 - 1);
    if (val >= limit) {
      val -= Math.pow(2, byteLength * 8);
    }
    return val;
  }
  writeUIntLE(value2, offset2, byteLength) {
    let val = value2;
    for (let i2 = 0; i2 < byteLength; i2++) {
      this[offset2 + i2] = val & 255;
      val = Math.floor(val / 256);
    }
    return offset2 + byteLength;
  }
  writeUintLE(value2, offset2, byteLength) {
    return this.writeUIntLE(value2, offset2, byteLength);
  }
  writeUIntBE(value2, offset2, byteLength) {
    let val = value2;
    for (let i2 = byteLength - 1; i2 >= 0; i2--) {
      this[offset2 + i2] = val & 255;
      val = Math.floor(val / 256);
    }
    return offset2 + byteLength;
  }
  writeUintBE(value2, offset2, byteLength) {
    return this.writeUIntBE(value2, offset2, byteLength);
  }
  writeIntLE(value2, offset2, byteLength) {
    let val = value2;
    if (val < 0) {
      val += Math.pow(2, byteLength * 8);
    }
    return this.writeUIntLE(val, offset2, byteLength);
  }
  writeIntBE(value2, offset2, byteLength) {
    let val = value2;
    if (val < 0) {
      val += Math.pow(2, byteLength * 8);
    }
    return this.writeUIntBE(val, offset2, byteLength);
  }
  // Swap methods
  swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 2) {
      const a = this[i2];
      this[i2] = this[i2 + 1];
      this[i2 + 1] = a;
    }
    return this;
  }
  swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 4) {
      const a = this[i2];
      const b = this[i2 + 1];
      this[i2] = this[i2 + 3];
      this[i2 + 1] = this[i2 + 2];
      this[i2 + 2] = b;
      this[i2 + 3] = a;
    }
    return this;
  }
  swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len; i2 += 8) {
      const a = this[i2];
      const b = this[i2 + 1];
      const c = this[i2 + 2];
      const d = this[i2 + 3];
      this[i2] = this[i2 + 7];
      this[i2 + 1] = this[i2 + 6];
      this[i2 + 2] = this[i2 + 5];
      this[i2 + 3] = this[i2 + 4];
      this[i2 + 4] = d;
      this[i2 + 5] = c;
      this[i2 + 6] = b;
      this[i2 + 7] = a;
    }
    return this;
  }
};
// BYTES_PER_ELEMENT for TypedArray compatibility
__publicField(_BufferPolyfill, "BYTES_PER_ELEMENT", 1);
let BufferPolyfill = _BufferPolyfill;
if (typeof globalThis.Buffer === "undefined") {
  globalThis.Buffer = BufferPolyfill;
}
Stream.pipeline = pipeline;
Stream.finished = finished;
Stream.promises = promises$2;
let Socket$1 = class Socket2 extends Duplex {
  constructor(options2) {
    super();
    __publicField(this, "_connecting", false);
    __publicField(this, "_connected", false);
    __publicField(this, "_destroyed", false);
    __publicField(this, "_remoteAddress", "");
    __publicField(this, "_remotePort", 0);
    __publicField(this, "_localAddress", "127.0.0.1");
    __publicField(this, "_localPort", 0);
    __publicField(this, "localAddress", "127.0.0.1");
    __publicField(this, "localPort", 0);
    __publicField(this, "remoteAddress");
    __publicField(this, "remotePort");
    __publicField(this, "remoteFamily");
    __publicField(this, "connecting", false);
    __publicField(this, "destroyed", false);
    __publicField(this, "readyState", "closed");
  }
  connect(portOrOptions, hostOrCallback, callback) {
    let port;
    let host = "127.0.0.1";
    let cb2;
    if (typeof portOrOptions === "number") {
      port = portOrOptions;
      if (typeof hostOrCallback === "string") {
        host = hostOrCallback;
        cb2 = callback;
      } else {
        cb2 = hostOrCallback;
      }
    } else {
      port = portOrOptions.port;
      host = portOrOptions.host || "127.0.0.1";
      cb2 = typeof hostOrCallback === "function" ? hostOrCallback : callback;
    }
    this._connecting = true;
    this.connecting = true;
    this._remoteAddress = host;
    this._remotePort = port;
    this.remoteAddress = host;
    this.remotePort = port;
    this.remoteFamily = "IPv4";
    this.readyState = "opening";
    queueMicrotask(() => {
      this._connecting = false;
      this._connected = true;
      this.connecting = false;
      this.readyState = "open";
      this.emit("connect");
      if (cb2) cb2();
    });
    return this;
  }
  address() {
    if (!this._connected) return null;
    return {
      address: this._localAddress,
      family: "IPv4",
      port: this._localPort
    };
  }
  setEncoding(encoding) {
    return this;
  }
  setTimeout(timeout, callback) {
    if (callback) {
      this.once("timeout", callback);
    }
    return this;
  }
  setNoDelay(noDelay) {
    return this;
  }
  setKeepAlive(enable, initialDelay) {
    return this;
  }
  ref() {
    return this;
  }
  unref() {
    return this;
  }
  destroy(error) {
    if (this._destroyed) return this;
    this._destroyed = true;
    this._connected = false;
    this.destroyed = true;
    this.readyState = "closed";
    if (error) {
      this.emit("error", error);
    }
    queueMicrotask(() => {
      this.emit("close", !!error);
    });
    return this;
  }
  // Internal: simulate receiving data from remote
  _receiveData(data2) {
    const buffer = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
    this.push(buffer);
  }
  // Internal: signal end of remote data
  _receiveEnd() {
    this.push(null);
  }
};
let Server$3 = class Server2 extends EventEmitter {
  constructor(optionsOrConnectionListener, connectionListener) {
    super();
    __publicField(this, "_listening", false);
    __publicField(this, "_address", null);
    __publicField(this, "_connections", /* @__PURE__ */ new Set());
    __publicField(this, "_maxConnections", Infinity);
    __publicField(this, "listening", false);
    __publicField(this, "maxConnections");
    let listener;
    if (typeof optionsOrConnectionListener === "function") {
      listener = optionsOrConnectionListener;
    } else {
      listener = connectionListener;
    }
    if (listener) {
      this.on("connection", listener);
    }
  }
  listen(portOrOptions, hostOrCallback, backlogOrCallback, callback) {
    let port = 0;
    let host = "0.0.0.0";
    let cb2;
    if (typeof portOrOptions === "number") {
      port = portOrOptions;
      if (typeof hostOrCallback === "string") {
        host = hostOrCallback;
        if (typeof backlogOrCallback === "function") {
          cb2 = backlogOrCallback;
        } else {
          cb2 = callback;
        }
      } else if (typeof hostOrCallback === "function") {
        cb2 = hostOrCallback;
      } else if (typeof hostOrCallback === "number") {
        cb2 = typeof backlogOrCallback === "function" ? backlogOrCallback : callback;
      } else {
        if (typeof backlogOrCallback === "function") {
          cb2 = backlogOrCallback;
        } else if (typeof callback === "function") {
          cb2 = callback;
        }
      }
    } else if (portOrOptions) {
      port = portOrOptions.port || 0;
      host = portOrOptions.host || "0.0.0.0";
      cb2 = typeof hostOrCallback === "function" ? hostOrCallback : callback;
    }
    if (port === 0) {
      port = 3e3 + Math.floor(Math.random() * 1e3);
    }
    this._address = {
      address: host,
      family: "IPv4",
      port
    };
    this._listening = true;
    this.listening = true;
    queueMicrotask(() => {
      this.emit("listening");
      if (cb2) cb2();
    });
    return this;
  }
  address() {
    return this._address;
  }
  close(callback) {
    this._listening = false;
    this.listening = false;
    for (const socket of this._connections) {
      socket.destroy();
    }
    this._connections.clear();
    queueMicrotask(() => {
      this.emit("close");
      if (callback) callback();
    });
    return this;
  }
  getConnections(callback) {
    callback(null, this._connections.size);
  }
  ref() {
    return this;
  }
  unref() {
    return this;
  }
  // Internal: handle incoming connection
  _handleConnection(socket) {
    if (!this._listening) {
      socket.destroy();
      return;
    }
    this._connections.add(socket);
    socket.on("close", () => {
      this._connections.delete(socket);
    });
    this.emit("connection", socket);
  }
};
function createServer$3(optionsOrConnectionListener, connectionListener) {
  return new Server$3(optionsOrConnectionListener, connectionListener);
}
function createConnection(portOrOptions, hostOrCallback, callback) {
  const socket = new Socket$1();
  return socket.connect(portOrOptions, hostOrCallback, callback);
}
const connect$2 = createConnection;
function isIP(input) {
  if (/^(\d{1,3}\.){3}\d{1,3}$/.test(input)) {
    return 4;
  }
  if (/^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/.test(input)) {
    return 6;
  }
  return 0;
}
function isIPv4(input) {
  return isIP(input) === 4;
}
function isIPv6(input) {
  return isIP(input) === 6;
}
var net = {
  Socket: Socket$1,
  Server: Server$3,
  createServer: createServer$3,
  createConnection,
  connect: connect$2,
  isIP,
  isIPv4,
  isIPv6
};
var netShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Server: Server$3,
  Socket: Socket$1,
  connect: connect$2,
  createConnection,
  createServer: createServer$3,
  default: net,
  isIP,
  isIPv4,
  isIPv6
});
function randomBytes(size) {
  const array = new Uint8Array(size);
  crypto.getRandomValues(array);
  return BufferPolyfill.from(array);
}
function randomFillSync(buffer, offset2, size) {
  const start = offset2 || 0;
  const len = size !== void 0 ? size : buffer.length - start;
  const view = new Uint8Array(buffer.buffer, buffer.byteOffset + start, len);
  crypto.getRandomValues(view);
  return buffer;
}
function randomUUID() {
  return crypto.randomUUID();
}
function randomInt(min, max) {
  if (max === void 0) {
    max = min;
    min = 0;
  }
  const range2 = max - min;
  const array = new Uint32Array(1);
  crypto.getRandomValues(array);
  return min + array[0] % range2;
}
function getRandomValues(array) {
  return crypto.getRandomValues(array);
}
function createHash(algorithm) {
  return new Hash$2(algorithm);
}
let Hash$2 = class Hash2 {
  constructor(algorithm) {
    __publicField(this, "algorithm");
    __publicField(this, "data", []);
    this.algorithm = normalizeHashAlgorithm(algorithm);
  }
  update(data2, encoding) {
    let buffer;
    if (typeof data2 === "string") {
      if (encoding === "base64") {
        buffer = BufferPolyfill.from(atob(data2));
      } else {
        buffer = BufferPolyfill.from(data2);
      }
    } else {
      buffer = BufferPolyfill.from(data2);
    }
    this.data.push(buffer);
    return this;
  }
  async digestAsync(encoding) {
    const combined = concatBuffers(this.data);
    const dataBuffer = new Uint8Array(combined).buffer;
    const hashBuffer = await crypto.subtle.digest(this.algorithm, dataBuffer);
    return encodeResult(new Uint8Array(hashBuffer), encoding);
  }
  digest(encoding) {
    const combined = concatBuffers(this.data);
    const hash = syncHash(combined, this.algorithm);
    return encodeResult(hash, encoding);
  }
};
function createHmac(algorithm, key) {
  return new Hmac(algorithm, key);
}
class Hmac {
  constructor(algorithm, key) {
    __publicField(this, "algorithm");
    __publicField(this, "key");
    __publicField(this, "data", []);
    this.algorithm = normalizeHashAlgorithm(algorithm);
    this.key = typeof key === "string" ? BufferPolyfill.from(key) : key;
  }
  update(data2, encoding) {
    const buffer = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
    this.data.push(buffer);
    return this;
  }
  async digestAsync(encoding) {
    const combined = concatBuffers(this.data);
    const keyBuffer = new Uint8Array(this.key).buffer;
    const dataBuffer = new Uint8Array(combined).buffer;
    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      keyBuffer,
      { name: "HMAC", hash: this.algorithm },
      false,
      ["sign"]
    );
    const signature = await crypto.subtle.sign("HMAC", cryptoKey, dataBuffer);
    return encodeResult(new Uint8Array(signature), encoding);
  }
  digest(encoding) {
    const combined = concatBuffers(this.data);
    const hash = syncHmac(combined, this.key, this.algorithm);
    return encodeResult(hash, encoding);
  }
}
async function pbkdf2Async(password, salt, iterations, keylen, digest) {
  const passwordBuffer = typeof password === "string" ? BufferPolyfill.from(password) : password instanceof Uint8Array ? password : BufferPolyfill.from(password);
  const saltBuffer = typeof salt === "string" ? BufferPolyfill.from(salt) : salt instanceof Uint8Array ? salt : BufferPolyfill.from(salt);
  const passwordArrayBuffer = new Uint8Array(passwordBuffer).buffer;
  const saltArrayBuffer = new Uint8Array(saltBuffer).buffer;
  const key = await crypto.subtle.importKey(
    "raw",
    passwordArrayBuffer,
    "PBKDF2",
    false,
    ["deriveBits"]
  );
  const derivedBits = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt: saltArrayBuffer,
      iterations,
      hash: normalizeHashAlgorithm(digest)
    },
    key,
    keylen * 8
    // Convert bytes to bits
  );
  return BufferPolyfill.from(derivedBits);
}
function pbkdf2(password, salt, iterations, keylen, digest, callback) {
  pbkdf2Async(password, salt, iterations, keylen, digest).then((key) => callback(null, key)).catch((err2) => callback(err2, BufferPolyfill.alloc(0)));
}
function pbkdf2Sync(password, salt, iterations, keylen, digest) {
  const passwordBuffer = typeof password === "string" ? BufferPolyfill.from(password) : password;
  const saltBuffer = typeof salt === "string" ? BufferPolyfill.from(salt) : salt;
  const hashAlg = normalizeHashAlgorithm(digest);
  let hashLen;
  if (hashAlg.includes("512")) {
    hashLen = 64;
  } else if (hashAlg.includes("384")) {
    hashLen = 48;
  } else if (hashAlg.includes("1") || hashAlg === "SHA-1") {
    hashLen = 20;
  } else {
    hashLen = 32;
  }
  const numBlocks = Math.ceil(keylen / hashLen);
  const derivedKey = new Uint8Array(numBlocks * hashLen);
  for (let blockNum = 1; blockNum <= numBlocks; blockNum++) {
    const blockNumBuf = new Uint8Array(4);
    blockNumBuf[0] = blockNum >>> 24 & 255;
    blockNumBuf[1] = blockNum >>> 16 & 255;
    blockNumBuf[2] = blockNum >>> 8 & 255;
    blockNumBuf[3] = blockNum & 255;
    const saltWithBlock = new Uint8Array(saltBuffer.length + 4);
    saltWithBlock.set(saltBuffer);
    saltWithBlock.set(blockNumBuf, saltBuffer.length);
    let u = syncHmac(saltWithBlock, passwordBuffer, hashAlg);
    const block = new Uint8Array(u);
    for (let i2 = 1; i2 < iterations; i2++) {
      u = syncHmac(u, passwordBuffer, hashAlg);
      for (let j2 = 0; j2 < block.length; j2++) {
        block[j2] ^= u[j2];
      }
    }
    derivedKey.set(block, (blockNum - 1) * hashLen);
  }
  return BufferPolyfill.from(derivedKey.slice(0, keylen));
}
function sign(algorithm, data2, key, callback) {
  const keyInfo = extractKeyInfo(key);
  const alg = algorithm || keyInfo.algorithm;
  if (!alg) {
    const error = new Error("Algorithm must be specified");
    if (callback) {
      callback(error, null);
      return;
    }
    throw error;
  }
  if (callback) {
    signAsync(alg, data2, keyInfo).then((sig) => callback(null, sig)).catch((err2) => callback(err2, null));
    return;
  }
  const result = signSync(alg, data2, keyInfo);
  return result;
}
function verify(algorithm, data2, key, signature, callback) {
  const keyInfo = extractKeyInfo(key);
  const alg = algorithm || keyInfo.algorithm;
  if (!alg) {
    const error = new Error("Algorithm must be specified");
    if (callback) {
      callback(error, false);
      return;
    }
    throw error;
  }
  if (callback) {
    verifyAsync(alg, data2, keyInfo, signature).then((result) => callback(null, result)).catch((err2) => callback(err2, false));
    return;
  }
  return verifySync(alg, data2, keyInfo, signature);
}
function createSign(algorithm) {
  return new Sign(algorithm);
}
function createVerify(algorithm) {
  return new Verify(algorithm);
}
class Sign extends EventEmitter {
  constructor(algorithm) {
    super();
    __publicField(this, "algorithm");
    __publicField(this, "data", []);
    this.algorithm = algorithm;
  }
  update(data2, encoding) {
    const buffer = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
    this.data.push(buffer);
    return this;
  }
  sign(privateKey, outputEncoding) {
    const combined = concatBuffers(this.data);
    const keyInfo = extractKeyInfo(privateKey);
    const signature = signSync(this.algorithm, combined, keyInfo);
    if (outputEncoding === "base64") {
      return btoa(String.fromCharCode(...signature));
    }
    if (outputEncoding === "hex") {
      return Array.from(signature).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    return signature;
  }
}
class Verify extends EventEmitter {
  constructor(algorithm) {
    super();
    __publicField(this, "algorithm");
    __publicField(this, "data", []);
    this.algorithm = algorithm;
  }
  update(data2, encoding) {
    const buffer = typeof data2 === "string" ? BufferPolyfill.from(data2) : data2;
    this.data.push(buffer);
    return this;
  }
  verify(publicKey, signature, signatureEncoding) {
    const combined = concatBuffers(this.data);
    const keyInfo = extractKeyInfo(publicKey);
    let sig;
    if (typeof signature === "string") {
      if (signatureEncoding === "base64") {
        sig = BufferPolyfill.from(atob(signature));
      } else if (signatureEncoding === "hex") {
        sig = BufferPolyfill.from(signature.match(/.{2}/g).map((byte) => parseInt(byte, 16)));
      } else {
        sig = BufferPolyfill.from(signature);
      }
    } else {
      sig = signature;
    }
    return verifySync(this.algorithm, combined, keyInfo, sig);
  }
}
class KeyObject {
  constructor(type2, keyData, algorithm) {
    __publicField(this, "_keyData");
    __publicField(this, "_type");
    __publicField(this, "_algorithm");
    this._type = type2;
    this._keyData = keyData;
    this._algorithm = algorithm;
  }
  get type() {
    return this._type;
  }
  get asymmetricKeyType() {
    var _a3, _b3, _c2, _d2;
    if (this._type === "secret") return void 0;
    if ((_a3 = this._algorithm) == null ? void 0 : _a3.includes("RSA")) return "rsa";
    if (((_b3 = this._algorithm) == null ? void 0 : _b3.includes("EC")) || ((_c2 = this._algorithm) == null ? void 0 : _c2.includes("ES"))) return "ec";
    if ((_d2 = this._algorithm) == null ? void 0 : _d2.includes("Ed")) return "ed25519";
    return void 0;
  }
  get symmetricKeySize() {
    if (this._type !== "secret") return void 0;
    if (this._keyData instanceof Uint8Array) {
      return this._keyData.length * 8;
    }
    return void 0;
  }
  export(options2) {
    if (this._keyData instanceof Uint8Array) {
      return BufferPolyfill.from(this._keyData);
    }
    throw new Error("Cannot export CryptoKey synchronously");
  }
}
function createSecretKey(key, encoding) {
  const keyBuffer = typeof key === "string" ? BufferPolyfill.from(key, encoding) : key;
  return new KeyObject("secret", keyBuffer);
}
function createPublicKey(key) {
  const keyInfo = extractKeyInfo(key);
  return new KeyObject("public", keyInfo.keyData, keyInfo.algorithm);
}
function createPrivateKey(key) {
  const keyInfo = extractKeyInfo(key);
  return new KeyObject("private", keyInfo.keyData, keyInfo.algorithm);
}
function timingSafeEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  let result = 0;
  for (let i2 = 0; i2 < a.length; i2++) {
    result |= a[i2] ^ b[i2];
  }
  return result === 0;
}
function getCiphers$1() {
  return ["aes-128-cbc", "aes-256-cbc", "aes-128-gcm", "aes-256-gcm"];
}
function getHashes() {
  return ["sha1", "sha256", "sha384", "sha512"];
}
const constants$5 = {
  SSL_OP_ALL: 0,
  RSA_PKCS1_PADDING: 1,
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_PKCS1_PSS_PADDING: 6
};
function normalizeHashAlgorithm(alg) {
  const normalized = alg.toUpperCase().replace(/[^A-Z0-9]/g, "");
  switch (normalized) {
    case "SHA1":
      return "SHA-1";
    case "SHA256":
      return "SHA-256";
    case "SHA384":
      return "SHA-384";
    case "SHA512":
      return "SHA-512";
    case "MD5":
      return "MD5";
    default:
      return alg;
  }
}
function getWebCryptoAlgorithm(nodeAlgorithm) {
  var _a3, _b3, _c2, _d2;
  const alg = nodeAlgorithm.toUpperCase().replace(/[^A-Z0-9]/g, "");
  if (alg.includes("RSA")) {
    if (alg.includes("PSS")) {
      const hash2 = ((_a3 = alg.match(/SHA(\d+)/)) == null ? void 0 : _a3[0]) || "SHA-256";
      return { name: "RSA-PSS", hash: `SHA-${hash2.replace("SHA", "")}` };
    }
    const hash = ((_b3 = alg.match(/SHA(\d+)/)) == null ? void 0 : _b3[0]) || "SHA-256";
    return { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${hash.replace("SHA", "")}` };
  }
  if (alg.startsWith("ES") || alg.includes("ECDSA")) {
    const bits = ((_c2 = alg.match(/\d+/)) == null ? void 0 : _c2[0]) || "256";
    const hash = bits === "512" ? "SHA-512" : bits === "384" ? "SHA-384" : "SHA-256";
    return { name: "ECDSA", hash };
  }
  if (alg.includes("ED25519") || alg === "EDDSA") {
    return { name: "Ed25519" };
  }
  if (alg.includes("HS") || alg.includes("HMAC")) {
    const bits = ((_d2 = alg.match(/\d+/)) == null ? void 0 : _d2[0]) || "256";
    return { name: "HMAC", hash: `SHA-${bits}` };
  }
  return { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" };
}
function extractKeyInfo(key) {
  if (key instanceof KeyObject) {
    return {
      keyData: key._keyData,
      algorithm: key._algorithm,
      type: key._type,
      format: "raw"
    };
  }
  if (typeof key === "object" && "key" in key) {
    return extractKeyInfo(key.key);
  }
  const keyStr = typeof key === "string" ? key : key.toString();
  if (keyStr.includes("-----BEGIN")) {
    const isPrivate = keyStr.includes("PRIVATE");
    const isPublic = keyStr.includes("PUBLIC");
    const base642 = keyStr.replace(/-----BEGIN [^-]+-----/, "").replace(/-----END [^-]+-----/, "").replace(/\s/g, "");
    const keyData2 = BufferPolyfill.from(atob(base642));
    let algorithm;
    if (keyStr.includes("RSA")) algorithm = "RSA-SHA256";
    else if (keyStr.includes("EC")) algorithm = "ES256";
    else if (keyStr.includes("ED25519")) algorithm = "Ed25519";
    return {
      keyData: keyData2,
      algorithm,
      type: isPrivate ? "private" : isPublic ? "public" : "secret",
      format: "pem"
    };
  }
  const keyData = typeof key === "string" ? BufferPolyfill.from(key) : key;
  return {
    keyData,
    type: "secret",
    format: "raw"
  };
}
function concatBuffers(buffers) {
  const totalLength = buffers.reduce((acc, arr) => acc + arr.length, 0);
  const result = new Uint8Array(totalLength);
  let offset2 = 0;
  for (const buf of buffers) {
    result.set(buf, offset2);
    offset2 += buf.length;
  }
  return result;
}
function encodeResult(data2, encoding) {
  if (encoding === "hex") {
    return Array.from(data2).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  if (encoding === "base64") {
    return btoa(String.fromCharCode(...data2));
  }
  return BufferPolyfill.from(data2);
}
function syncHash(data2, algorithm) {
  let size;
  if (algorithm.includes("512")) {
    size = 64;
  } else if (algorithm.includes("384")) {
    size = 48;
  } else if (algorithm.includes("1") || algorithm === "SHA-1") {
    size = 20;
  } else {
    size = 32;
  }
  const result = new Uint8Array(size);
  let h12 = 3735928559;
  let h2 = 1103547991;
  for (let i2 = 0; i2 < data2.length; i2++) {
    h12 = Math.imul(h12 ^ data2[i2], 2654435761);
    h2 = Math.imul(h2 ^ data2[i2], 1597334677);
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h12 ^ h12 >>> 13, 3266489909);
  for (let i2 = 0; i2 < size; i2++) {
    const mix2 = i2 < size / 2 ? h12 : h2;
    result[i2] = mix2 >>> i2 % 4 * 8 & 255;
    h12 = Math.imul(h12, 1103515245) + 12345;
    h2 = Math.imul(h2, 1103515245) + 12345;
  }
  return result;
}
function syncHmac(data2, key, algorithm) {
  const combined = new Uint8Array(key.length + data2.length);
  combined.set(key, 0);
  combined.set(data2, key.length);
  return syncHash(combined, algorithm);
}
async function signAsync(algorithm, data2, keyInfo) {
  const webCryptoAlg = getWebCryptoAlgorithm(algorithm);
  try {
    const cryptoKey = await importKey(keyInfo, webCryptoAlg, ["sign"]);
    const signatureAlg = webCryptoAlg.hash ? { name: webCryptoAlg.name, hash: webCryptoAlg.hash } : { name: webCryptoAlg.name };
    const dataBuffer = new Uint8Array(data2).buffer;
    const signature = await crypto.subtle.sign(signatureAlg, cryptoKey, dataBuffer);
    return BufferPolyfill.from(signature);
  } catch (error) {
    console.warn("WebCrypto sign failed, using fallback:", error);
    return signSync(algorithm, data2, keyInfo);
  }
}
async function verifyAsync(algorithm, data2, keyInfo, signature) {
  const webCryptoAlg = getWebCryptoAlgorithm(algorithm);
  try {
    const cryptoKey = await importKey(keyInfo, webCryptoAlg, ["verify"]);
    const verifyAlg = webCryptoAlg.hash ? { name: webCryptoAlg.name, hash: webCryptoAlg.hash } : { name: webCryptoAlg.name };
    const sigBuffer = new Uint8Array(signature).buffer;
    const dataBuffer = new Uint8Array(data2).buffer;
    return await crypto.subtle.verify(verifyAlg, cryptoKey, sigBuffer, dataBuffer);
  } catch (error) {
    console.warn("WebCrypto verify failed, using fallback:", error);
    return verifySync(algorithm, data2, keyInfo, signature);
  }
}
function signSync(algorithm, data2, keyInfo) {
  const keyData = keyInfo.keyData instanceof Uint8Array ? keyInfo.keyData : new Uint8Array(0);
  const combined = new Uint8Array(keyData.length + data2.length);
  combined.set(keyData, 0);
  combined.set(data2, keyData.length);
  const hash = syncHash(combined, algorithm);
  return BufferPolyfill.from(hash);
}
function verifySync(algorithm, data2, keyInfo, signature) {
  const expectedSig = signSync(algorithm, data2, keyInfo);
  return timingSafeEqual(BufferPolyfill.from(signature), expectedSig);
}
async function importKey(keyInfo, algorithm, usages) {
  if (keyInfo.keyData instanceof CryptoKey) {
    return keyInfo.keyData;
  }
  const keyData = keyInfo.keyData;
  const keyBuffer = new Uint8Array(keyData).buffer;
  if (keyInfo.format === "pem") {
    const format2 = keyInfo.type === "private" ? "pkcs8" : "spki";
    const importAlg = algorithm.name === "ECDSA" ? { name: "ECDSA", namedCurve: "P-256" } : algorithm.name === "Ed25519" ? { name: "Ed25519" } : { name: algorithm.name, hash: algorithm.hash || "SHA-256" };
    return await crypto.subtle.importKey(
      format2,
      keyBuffer,
      importAlg,
      true,
      usages
    );
  }
  if (keyInfo.type === "secret") {
    return await crypto.subtle.importKey(
      "raw",
      keyBuffer,
      { name: algorithm.name, hash: algorithm.hash },
      true,
      usages
    );
  }
  throw new Error(`Unsupported key format: ${keyInfo.format}`);
}
var crypto$1 = {
  randomBytes,
  randomFillSync,
  randomUUID,
  randomInt,
  getRandomValues,
  createHash,
  createHmac,
  createSign,
  createVerify,
  sign,
  verify,
  pbkdf2,
  pbkdf2Sync,
  timingSafeEqual,
  getCiphers: getCiphers$1,
  getHashes,
  constants: constants$5,
  KeyObject,
  createSecretKey,
  createPublicKey,
  createPrivateKey
};
var cryptoShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  KeyObject,
  constants: constants$5,
  createHash,
  createHmac,
  createPrivateKey,
  createPublicKey,
  createSecretKey,
  createSign,
  createVerify,
  default: crypto$1,
  getCiphers: getCiphers$1,
  getHashes,
  getRandomValues,
  pbkdf2,
  pbkdf2Sync,
  randomBytes,
  randomFillSync,
  randomInt,
  randomUUID,
  sign,
  timingSafeEqual,
  verify
});
const _isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
const _BrowserWebSocket = _isBrowser && typeof globalThis.WebSocket === "function" ? globalThis.WebSocket : null;
class IncomingMessage extends Readable {
  constructor(socket) {
    super();
    __publicField(this, "httpVersion", "1.1");
    __publicField(this, "httpVersionMajor", 1);
    __publicField(this, "httpVersionMinor", 1);
    __publicField(this, "complete", false);
    __publicField(this, "headers", {});
    __publicField(this, "rawHeaders", []);
    __publicField(this, "trailers", {});
    __publicField(this, "rawTrailers", []);
    __publicField(this, "method");
    __publicField(this, "url");
    __publicField(this, "statusCode");
    __publicField(this, "statusMessage");
    __publicField(this, "socket");
    __publicField(this, "_body", null);
    this.socket = socket || new Socket$1();
  }
  setTimeout(msecs, callback) {
    if (callback) {
      this.once("timeout", callback);
    }
    return this;
  }
  destroy(error) {
    super.destroy(error);
    return this;
  }
  // Internal: set body data
  _setBody(body) {
    if (body === null) {
      this._body = null;
    } else {
      this._body = typeof body === "string" ? BufferPolyfill.from(body) : body;
    }
    if (this._body) {
      this.push(this._body);
    }
    this.push(null);
    this.complete = true;
  }
  // Internal: initialize from raw request
  static fromRequest(method, url2, headers, body) {
    const msg = new IncomingMessage();
    msg.method = method;
    msg.url = url2;
    msg.headers = { ...headers };
    for (const [key, value2] of Object.entries(headers)) {
      msg.rawHeaders.push(key, value2);
    }
    if (body) {
      msg._setBody(body);
    } else {
      msg.push(null);
      msg.complete = true;
    }
    return msg;
  }
}
class ServerResponse extends Writable {
  constructor(req) {
    super();
    __publicField(this, "statusCode", 200);
    __publicField(this, "statusMessage", "OK");
    __publicField(this, "headersSent", false);
    __publicField(this, "finished", false);
    __publicField(this, "sendDate", true);
    __publicField(this, "socket");
    __publicField(this, "_headers", /* @__PURE__ */ new Map());
    __publicField(this, "_body", []);
    __publicField(this, "_resolve");
    this.socket = req.socket;
  }
  // Internal: set resolver for async response handling
  _setResolver(resolve2) {
    this._resolve = resolve2;
  }
  setHeader(name2, value2) {
    if (this.headersSent) {
      throw new Error("Cannot set headers after they are sent");
    }
    this._headers.set(name2.toLowerCase(), String(value2));
    return this;
  }
  getHeader(name2) {
    return this._headers.get(name2.toLowerCase());
  }
  getHeaders() {
    const headers = {};
    for (const [key, value2] of this._headers) {
      headers[key] = value2;
    }
    return headers;
  }
  getHeaderNames() {
    return [...this._headers.keys()];
  }
  hasHeader(name2) {
    return this._headers.has(name2.toLowerCase());
  }
  removeHeader(name2) {
    if (this.headersSent) {
      throw new Error("Cannot remove headers after they are sent");
    }
    this._headers.delete(name2.toLowerCase());
  }
  writeHead(statusCode, statusMessageOrHeaders, headers) {
    this.statusCode = statusCode;
    if (typeof statusMessageOrHeaders === "string") {
      this.statusMessage = statusMessageOrHeaders;
      if (headers) {
        for (const [key, value2] of Object.entries(headers)) {
          this.setHeader(key, value2);
        }
      }
    } else if (statusMessageOrHeaders) {
      for (const [key, value2] of Object.entries(statusMessageOrHeaders)) {
        this.setHeader(key, value2);
      }
    }
    return this;
  }
  write(chunk, encodingOrCallback, callback) {
    this.headersSent = true;
    const buffer = typeof chunk === "string" ? BufferPolyfill.from(chunk) : chunk;
    this._body.push(buffer);
    const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
    if (cb2) {
      queueMicrotask(() => cb2(null));
    }
    return true;
  }
  end(chunkOrCallback, encodingOrCallback, callback) {
    if (typeof chunkOrCallback === "function") {
      callback = chunkOrCallback;
    } else if (chunkOrCallback !== void 0) {
      this.write(chunkOrCallback);
    }
    if (typeof encodingOrCallback === "function") {
      callback = encodingOrCallback;
    }
    this.headersSent = true;
    this.finished = true;
    if (this._resolve) {
      const headers = {};
      for (const [key, value2] of this._headers) {
        headers[key] = Array.isArray(value2) ? value2.join(", ") : value2;
      }
      this._resolve({
        statusCode: this.statusCode,
        statusMessage: this.statusMessage,
        headers,
        body: BufferPolyfill.concat(this._body)
      });
    }
    queueMicrotask(() => {
      this.emit("finish");
      if (callback) callback();
    });
    return this;
  }
  // Convenience method for simple responses
  send(data2) {
    if (typeof data2 === "object" && !BufferPolyfill.isBuffer(data2)) {
      this.setHeader("Content-Type", "application/json");
      data2 = JSON.stringify(data2);
    }
    if (!this.hasHeader("Content-Type")) {
      this.setHeader("Content-Type", "text/html");
    }
    this.write(typeof data2 === "string" ? data2 : data2);
    return this.end();
  }
  // Express compatibility
  json(data2) {
    this.setHeader("Content-Type", "application/json");
    return this.end(JSON.stringify(data2));
  }
  status(code2) {
    this.statusCode = code2;
    return this;
  }
  redirect(urlOrStatus, url2) {
    if (typeof urlOrStatus === "number") {
      this.statusCode = urlOrStatus;
      this.setHeader("Location", url2);
    } else {
      this.statusCode = 302;
      this.setHeader("Location", urlOrStatus);
    }
    this.end();
  }
  // Get body for testing/debugging
  _getBody() {
    return BufferPolyfill.concat(this._body);
  }
  _getBodyAsString() {
    return this._getBody().toString("utf8");
  }
}
let Server$2 = class Server3 extends EventEmitter {
  constructor(requestListener) {
    super();
    __publicField(this, "_netServer");
    __publicField(this, "_requestListener");
    __publicField(this, "_pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "listening", false);
    __publicField(this, "maxHeadersCount", null);
    __publicField(this, "timeout", 0);
    __publicField(this, "keepAliveTimeout", 5e3);
    __publicField(this, "headersTimeout", 6e4);
    __publicField(this, "requestTimeout", 0);
    this._requestListener = requestListener;
    this._netServer = new Server$3();
    this._netServer.on("listening", () => {
      this.listening = true;
      this.emit("listening");
    });
    this._netServer.on("close", () => {
      this.listening = false;
      this.emit("close");
    });
    this._netServer.on("error", (err2) => {
      this.emit("error", err2);
    });
  }
  listen(portOrOptions, hostOrCallback, callback) {
    let port;
    let host;
    let cb2;
    if (typeof portOrOptions === "number") {
      port = portOrOptions;
      if (typeof hostOrCallback === "string") {
        host = hostOrCallback;
        cb2 = callback;
      } else {
        cb2 = hostOrCallback;
      }
    } else if (portOrOptions) {
      port = portOrOptions.port;
      host = portOrOptions.host;
      cb2 = typeof hostOrCallback === "function" ? hostOrCallback : callback;
    }
    const originalCb = cb2;
    const self = this;
    cb2 = function() {
      const addr = self._netServer.address();
      if (addr) {
        _registerServer(addr.port, self);
      }
      if (originalCb) originalCb();
    };
    this._netServer.listen(port, host, cb2);
    return this;
  }
  close(callback) {
    const addr = this._netServer.address();
    if (addr) {
      _unregisterServer(addr.port);
    }
    this._netServer.close(callback);
    return this;
  }
  address() {
    return this._netServer.address();
  }
  setTimeout(msecs, callback) {
    this.timeout = msecs || 0;
    if (callback) {
      this.on("timeout", callback);
    }
    return this;
  }
  ref() {
    this._netServer.ref();
    return this;
  }
  unref() {
    this._netServer.unref();
    return this;
  }
  /**
   * Handle an incoming request (used by server bridge)
   */
  async handleRequest(method, url2, headers, body) {
    return new Promise((resolve2, reject) => {
      const req = IncomingMessage.fromRequest(method, url2, headers, body);
      const res = new ServerResponse(req);
      res._setResolver(resolve2);
      const timeoutId = this.timeout ? setTimeout(() => {
        reject(new Error("Request timeout"));
      }, this.timeout) : null;
      res.on("finish", () => {
        if (timeoutId) clearTimeout(timeoutId);
      });
      try {
        this.emit("request", req, res);
        if (this._requestListener) {
          this._requestListener(req, res);
        }
      } catch (error) {
        if (timeoutId) clearTimeout(timeoutId);
        reject(error);
      }
    });
  }
};
function createServer$2(requestListener) {
  return new Server$2(requestListener);
}
const STATUS_CODES = {
  100: "Continue",
  101: "Switching Protocols",
  200: "OK",
  201: "Created",
  202: "Accepted",
  204: "No Content",
  301: "Moved Permanently",
  302: "Found",
  304: "Not Modified",
  400: "Bad Request",
  401: "Unauthorized",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  408: "Request Timeout",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable"
};
const METHODS = [
  "GET",
  "POST",
  "PUT",
  "DELETE",
  "PATCH",
  "HEAD",
  "OPTIONS",
  "CONNECT",
  "TRACE"
];
function getCorsProxy() {
  if (typeof localStorage !== "undefined") {
    return localStorage.getItem("__corsProxyUrl") || null;
  }
  return null;
}
class ClientRequest extends Writable {
  constructor(options2, protocol = "http") {
    super();
    __publicField(this, "method");
    __publicField(this, "path");
    __publicField(this, "headers");
    __publicField(this, "_options");
    __publicField(this, "_protocol");
    __publicField(this, "_bodyChunks", []);
    __publicField(this, "_aborted", false);
    __publicField(this, "_timeout", null);
    __publicField(this, "_timeoutId", null);
    __publicField(this, "_requestEnded", false);
    this._options = options2;
    this._protocol = protocol;
    this.method = options2.method || "GET";
    this.path = options2.path || "/";
    this.headers = {};
    if (options2.headers) {
      for (const [key, value2] of Object.entries(options2.headers)) {
        this.headers[key.toLowerCase()] = Array.isArray(value2) ? value2.join(", ") : value2;
      }
    }
  }
  setHeader(name2, value2) {
    this.headers[name2.toLowerCase()] = value2;
  }
  getHeader(name2) {
    return this.headers[name2.toLowerCase()];
  }
  removeHeader(name2) {
    delete this.headers[name2.toLowerCase()];
  }
  write(chunk, encodingOrCallback, callback) {
    const buffer = typeof chunk === "string" ? BufferPolyfill.from(chunk) : chunk;
    this._bodyChunks.push(buffer);
    const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
    if (cb2) {
      queueMicrotask(() => cb2(null));
    }
    return true;
  }
  end(dataOrCallback, encodingOrCallback, callback) {
    if (this._requestEnded) return this;
    this._requestEnded = true;
    let finalCallback = callback;
    if (typeof dataOrCallback === "function") {
      finalCallback = dataOrCallback;
    } else if (dataOrCallback !== void 0) {
      this.write(dataOrCallback);
    }
    if (typeof encodingOrCallback === "function") {
      finalCallback = encodingOrCallback;
    }
    this._performRequest().then(() => {
      if (finalCallback) finalCallback();
    }).catch((error) => {
      this.emit("error", error);
    });
    return this;
  }
  abort() {
    this._aborted = true;
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
    this.emit("abort");
  }
  setTimeout(ms2, callback) {
    this._timeout = ms2;
    if (callback) {
      this.once("timeout", callback);
    }
    return this;
  }
  async _performRequest() {
    var _a3;
    if (this._aborted) return;
    try {
      const protocol = this._protocol === "https" ? "https:" : "http:";
      let hostname2 = this._options.hostname || "";
      let port = this._options.port ? `:${this._options.port}` : "";
      if (!hostname2 && this._options.host) {
        const hostParts = this._options.host.split(":");
        hostname2 = hostParts[0];
        if (!port && hostParts[1]) {
          port = `:${hostParts[1]}`;
        }
      }
      if (!hostname2) hostname2 = "localhost";
      const path2 = this._options.path || "/";
      const url2 = `${protocol}//${hostname2}${port}${path2}`;
      if (((_a3 = this.headers["upgrade"]) == null ? void 0 : _a3.toLowerCase()) === "websocket") {
        this._handleWebSocketUpgrade(url2);
        return;
      }
      const corsProxy = getCorsProxy();
      const fetchUrl = corsProxy ? corsProxy + encodeURIComponent(url2) : url2;
      const fetchOptions = {
        method: this.method,
        headers: this.headers
      };
      if (this._bodyChunks.length > 0 && this.method !== "GET" && this.method !== "HEAD") {
        fetchOptions.body = BufferPolyfill.concat(this._bodyChunks);
      }
      const controller = new AbortController();
      fetchOptions.signal = controller.signal;
      if (this._timeout) {
        this._timeoutId = setTimeout(() => {
          controller.abort();
          this.emit("timeout");
        }, this._timeout);
      }
      const response = await fetch(fetchUrl, fetchOptions);
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
        this._timeoutId = null;
      }
      if (this._aborted) return;
      const incomingMessage = await this._responseToIncomingMessage(response);
      this.emit("response", incomingMessage);
    } catch (error) {
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
      }
      if (this._aborted) return;
      if (error instanceof Error && error.name === "AbortError") {
        return;
      }
      this.emit("error", error);
    }
  }
  async _responseToIncomingMessage(response) {
    const msg = new IncomingMessage();
    msg.statusCode = response.status;
    msg.statusMessage = response.statusText || STATUS_CODES[response.status] || "";
    response.headers.forEach((value2, key) => {
      msg.headers[key.toLowerCase()] = value2;
      msg.rawHeaders.push(key, value2);
    });
    const body = await response.arrayBuffer();
    msg._setBody(BufferPolyfill.from(body));
    return msg;
  }
  /**
   * Bridge a WebSocket upgrade request to the browser's native WebSocket.
   *
   * The bundled ws library (inside the Convex CLI) creates WebSocket connections
   * via http.request() with Upgrade headers. It expects frame-level I/O on the
   * socket from the 'upgrade' event. This method bridges between:
   *   - ws library  frame-level I/O on a mock Socket
   *   - browser native WebSocket  message-level I/O
   */
  _handleWebSocketUpgrade(url2) {
    const wsUrl = url2.replace(/^https:/, "wss:").replace(/^http:/, "ws:");
    const wsKey = this.headers["sec-websocket-key"] || "";
    const NativeWS = _BrowserWebSocket;
    if (!NativeWS) {
      setTimeout(() => {
        this.emit("error", new TypeError("Failed to fetch"));
      }, 0);
      return;
    }
    const GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    const acceptValue = createHash("sha1").update(wsKey + GUID).digest("base64");
    let nativeWs;
    try {
      nativeWs = new NativeWS(wsUrl);
      nativeWs.binaryType = "arraybuffer";
    } catch (e2) {
      setTimeout(() => {
        this.emit("error", e2 instanceof Error ? e2 : new Error(String(e2)));
      }, 0);
      return;
    }
    const socket = new Socket$1();
    if (typeof socket.cork !== "function") socket.cork = () => {
    };
    if (typeof socket.uncork !== "function") socket.uncork = () => {
    };
    socket._readableState = { endEmitted: false };
    socket._writableState = { finished: false, errorEmitted: false };
    let writeBuffer = new Uint8Array(0);
    socket.write = (chunk, encodingOrCallback, callback) => {
      const data2 = typeof chunk === "string" ? BufferPolyfill.from(chunk) : new Uint8Array(chunk);
      const cb2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback;
      const newBuf = new Uint8Array(writeBuffer.length + data2.length);
      newBuf.set(writeBuffer, 0);
      newBuf.set(data2, writeBuffer.length);
      writeBuffer = newBuf;
      while (writeBuffer.length >= 2) {
        const parsed = _parseWsFrame(writeBuffer);
        if (!parsed) break;
        const { opcode, payload, totalLength } = parsed;
        writeBuffer = writeBuffer.slice(totalLength);
        if (nativeWs.readyState !== NativeWS.OPEN) continue;
        if (opcode === 8) {
          nativeWs.close();
        } else if (opcode === 9) {
          nativeWs.send(payload);
        } else if (opcode === 10) ;
        else if (opcode === 1) {
          const text = new TextDecoder().decode(payload);
          nativeWs.send(text);
        } else if (opcode === 2) {
          nativeWs.send(payload);
        }
      }
      if (cb2) queueMicrotask(() => cb2(null));
      return true;
    };
    nativeWs.onopen = () => {
      const response = new IncomingMessage(socket);
      response.statusCode = 101;
      response.statusMessage = "Switching Protocols";
      response.headers = {
        "upgrade": "websocket",
        "connection": "Upgrade",
        "sec-websocket-accept": acceptValue
      };
      response.complete = true;
      response.push(null);
      this.emit("upgrade", response, socket, BufferPolyfill.alloc(0));
    };
    nativeWs.onmessage = (event) => {
      let payload;
      let opcode;
      if (typeof event.data === "string") {
        payload = new TextEncoder().encode(event.data);
        opcode = 1;
      } else if (event.data instanceof ArrayBuffer) {
        payload = new Uint8Array(event.data);
        opcode = 2;
      } else {
        return;
      }
      const frame = _createWsFrame(opcode, payload, false);
      socket._receiveData(BufferPolyfill.from(frame));
    };
    nativeWs.onclose = (event) => {
      const code2 = event.code || 1e3;
      const closePayload = new Uint8Array(2);
      closePayload[0] = code2 >> 8 & 255;
      closePayload[1] = code2 & 255;
      const frame = _createWsFrame(8, closePayload, false);
      socket._receiveData(BufferPolyfill.from(frame));
      setTimeout(() => {
        socket._readableState.endEmitted = true;
        socket._receiveEnd();
        socket.emit("close", false);
      }, 10);
    };
    nativeWs.onerror = () => {
      socket.emit("error", new Error("WebSocket connection error"));
      socket.destroy();
    };
    const origDestroy = socket.destroy.bind(socket);
    socket.destroy = (error) => {
      if (nativeWs.readyState === NativeWS.OPEN || nativeWs.readyState === NativeWS.CONNECTING) {
        nativeWs.close();
      }
      return origDestroy(error);
    };
  }
}
function parseRequestArgs(urlOrOptions, optionsOrCallback, callback) {
  let options2;
  let cb2 = callback;
  if (typeof urlOrOptions === "string" || urlOrOptions instanceof URL) {
    const parsed = new URL(urlOrOptions.toString());
    options2 = {
      hostname: parsed.hostname,
      port: parsed.port ? parseInt(parsed.port) : void 0,
      path: parsed.pathname + parsed.search,
      method: "GET"
    };
    if (typeof optionsOrCallback === "function") {
      cb2 = optionsOrCallback;
    } else if (optionsOrCallback) {
      options2 = { ...options2, ...optionsOrCallback };
    }
  } else {
    options2 = urlOrOptions;
    if (typeof optionsOrCallback === "function") {
      cb2 = optionsOrCallback;
    }
  }
  return { options: options2, callback: cb2 };
}
function request$1(urlOrOptions, optionsOrCallback, callback) {
  const { options: options2, callback: cb2 } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
  const req = new ClientRequest(options2, "http");
  if (cb2) {
    req.once("response", cb2);
  }
  return req;
}
function get$1(urlOrOptions, optionsOrCallback, callback) {
  const { options: options2, callback: cb2 } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
  const req = new ClientRequest({ ...options2, method: "GET" }, "http");
  if (cb2) {
    req.once("response", cb2);
  }
  req.end();
  return req;
}
function _createClientRequest(urlOrOptions, optionsOrCallback, callback, protocol) {
  const { options: options2, callback: cb2 } = parseRequestArgs(urlOrOptions, optionsOrCallback, callback);
  const req = new ClientRequest(options2, protocol);
  if (cb2) {
    req.once("response", cb2);
  }
  return req;
}
const serverRegistry = /* @__PURE__ */ new Map();
let onServerListenCallback = null;
let onServerCloseCallback = null;
function _registerServer(port, server) {
  serverRegistry.set(port, server);
  if (onServerListenCallback) {
    onServerListenCallback(port, server);
  }
}
function _unregisterServer(port) {
  serverRegistry.delete(port);
  if (onServerCloseCallback) {
    onServerCloseCallback(port);
  }
}
function getServer(port) {
  return serverRegistry.get(port);
}
function getAllServers() {
  return new Map(serverRegistry);
}
function setServerListenCallback(callback) {
  onServerListenCallback = callback;
}
function setServerCloseCallback(callback) {
  onServerCloseCallback = callback;
}
class Agent extends EventEmitter {
  constructor(opts) {
    super();
    __publicField(this, "maxSockets");
    __publicField(this, "maxFreeSockets");
    __publicField(this, "maxTotalSockets");
    __publicField(this, "sockets");
    __publicField(this, "freeSockets");
    __publicField(this, "requests");
    __publicField(this, "options");
    this.options = opts || {};
    this.maxSockets = (opts == null ? void 0 : opts.maxSockets) ?? Infinity;
    this.maxFreeSockets = (opts == null ? void 0 : opts.maxFreeSockets) ?? 256;
    this.maxTotalSockets = (opts == null ? void 0 : opts.maxTotalSockets) ?? Infinity;
    this.sockets = {};
    this.freeSockets = {};
    this.requests = {};
  }
  createConnection(_options3, callback) {
    const socket = new Socket$1();
    if (callback) {
      callback(null, socket);
    }
    return socket;
  }
  getName(options2) {
    const host = options2.host || "localhost";
    const port = options2.port || 80;
    return `${host}:${port}:${options2.localAddress || ""}`;
  }
  addRequest(_req, _options3) {
  }
  destroy() {
    this.sockets = {};
    this.freeSockets = {};
    this.requests = {};
  }
}
const globalAgent = new Agent();
function _parseWsFrame(data2) {
  if (data2.length < 2) return null;
  const opcode = data2[0] & 15;
  const masked = (data2[1] & 128) !== 0;
  let payloadLength = data2[1] & 127;
  let offset2 = 2;
  if (payloadLength === 126) {
    if (data2.length < 4) return null;
    payloadLength = data2[2] << 8 | data2[3];
    offset2 = 4;
  } else if (payloadLength === 127) {
    if (data2.length < 10) return null;
    payloadLength = data2[6] << 24 | data2[7] << 16 | data2[8] << 8 | data2[9];
    offset2 = 10;
  }
  if (masked) {
    if (data2.length < offset2 + 4 + payloadLength) return null;
    const maskKey = data2.slice(offset2, offset2 + 4);
    offset2 += 4;
    const payload = new Uint8Array(payloadLength);
    for (let i2 = 0; i2 < payloadLength; i2++) {
      payload[i2] = data2[offset2 + i2] ^ maskKey[i2 % 4];
    }
    return { opcode, payload, totalLength: offset2 + payloadLength };
  } else {
    if (data2.length < offset2 + payloadLength) return null;
    const payload = data2.slice(offset2, offset2 + payloadLength);
    return { opcode, payload, totalLength: offset2 + payloadLength };
  }
}
function _createWsFrame(opcode, payload, masked) {
  const length2 = payload.length;
  let headerSize = 2;
  if (length2 > 125 && length2 <= 65535) {
    headerSize += 2;
  } else if (length2 > 65535) {
    headerSize += 8;
  }
  if (masked) {
    headerSize += 4;
  }
  const frame = new Uint8Array(headerSize + length2);
  frame[0] = 128 | opcode;
  let offset2 = 2;
  if (length2 <= 125) {
    frame[1] = (masked ? 128 : 0) | length2;
  } else if (length2 <= 65535) {
    frame[1] = (masked ? 128 : 0) | 126;
    frame[2] = length2 >> 8 & 255;
    frame[3] = length2 & 255;
    offset2 = 4;
  } else {
    frame[1] = (masked ? 128 : 0) | 127;
    frame[2] = 0;
    frame[3] = 0;
    frame[4] = 0;
    frame[5] = 0;
    frame[6] = length2 >> 24 & 255;
    frame[7] = length2 >> 16 & 255;
    frame[8] = length2 >> 8 & 255;
    frame[9] = length2 & 255;
    offset2 = 10;
  }
  if (masked) {
    const maskKey = new Uint8Array(4);
    if (typeof crypto !== "undefined" && crypto.getRandomValues) {
      crypto.getRandomValues(maskKey);
    } else {
      for (let i2 = 0; i2 < 4; i2++) maskKey[i2] = Math.floor(Math.random() * 256);
    }
    frame.set(maskKey, offset2);
    offset2 += 4;
    for (let i2 = 0; i2 < length2; i2++) {
      frame[offset2 + i2] = payload[i2] ^ maskKey[i2 % 4];
    }
  } else {
    frame.set(payload, offset2);
  }
  return frame;
}
var http = {
  Server: Server$2,
  IncomingMessage,
  ServerResponse,
  ClientRequest,
  createServer: createServer$2,
  request: request$1,
  get: get$1,
  STATUS_CODES,
  METHODS,
  getServer,
  getAllServers,
  setServerListenCallback,
  setServerCloseCallback,
  _createClientRequest,
  Agent,
  globalAgent,
  _parseWsFrame,
  _createWsFrame
};
var httpShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Agent,
  ClientRequest,
  IncomingMessage,
  METHODS,
  STATUS_CODES,
  Server: Server$2,
  ServerResponse,
  _createClientRequest,
  _createWsFrame,
  _parseWsFrame,
  _registerServer,
  _unregisterServer,
  createServer: createServer$2,
  default: http,
  get: get$1,
  getAllServers,
  getServer,
  globalAgent,
  request: request$1,
  setServerCloseCallback,
  setServerListenCallback
});
function request(urlOrOptions, optionsOrCallback, callback) {
  return _createClientRequest(urlOrOptions, optionsOrCallback, callback, "https");
}
function get(urlOrOptions, optionsOrCallback, callback) {
  const req = _createClientRequest(urlOrOptions, optionsOrCallback, callback, "https");
  req.end();
  return req;
}
var https = {
  Server: Server$2,
  IncomingMessage,
  ServerResponse,
  ClientRequest,
  createServer: createServer$2,
  request,
  get,
  STATUS_CODES,
  METHODS,
  getServer,
  getAllServers,
  setServerListenCallback,
  setServerCloseCallback,
  Agent,
  globalAgent
};
var httpsShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Agent,
  ClientRequest,
  IncomingMessage,
  METHODS,
  STATUS_CODES,
  Server: Server$2,
  ServerResponse,
  createServer: createServer$2,
  default: https,
  get,
  getAllServers,
  getServer,
  globalAgent,
  request,
  setServerCloseCallback,
  setServerListenCallback
});
function parse$Q(urlString, parseQueryString = false, slashesDenoteHost = false) {
  var _a3;
  try {
    const url2 = new URL$1(urlString, "http://localhost");
    const result = {
      protocol: url2.protocol,
      slashes: url2.protocol.endsWith(":"),
      auth: url2.username ? `${url2.username}:${url2.password}` : null,
      host: url2.host,
      port: url2.port || null,
      hostname: url2.hostname,
      hash: url2.hash || null,
      search: url2.search || null,
      query: parseQueryString ? Object.fromEntries(url2.searchParams) : ((_a3 = url2.search) == null ? void 0 : _a3.slice(1)) || null,
      pathname: url2.pathname,
      path: url2.pathname + url2.search,
      href: url2.href
    };
    return result;
  } catch {
    return {
      protocol: null,
      slashes: null,
      auth: null,
      host: null,
      port: null,
      hostname: null,
      hash: null,
      search: null,
      query: null,
      pathname: urlString,
      path: urlString,
      href: urlString
    };
  }
}
function format$1(urlObject) {
  if (urlObject.href) {
    return urlObject.href;
  }
  let result = "";
  if (urlObject.protocol) {
    result += urlObject.protocol;
    if (!urlObject.protocol.endsWith(":")) {
      result += ":";
    }
  }
  if (urlObject.slashes || urlObject.protocol === "http:" || urlObject.protocol === "https:") {
    result += "//";
  }
  if (urlObject.auth) {
    result += urlObject.auth + "@";
  }
  if (urlObject.hostname) {
    result += urlObject.hostname;
  } else if (urlObject.host) {
    result += urlObject.host;
  }
  if (urlObject.port) {
    result += ":" + urlObject.port;
  }
  if (urlObject.pathname) {
    result += urlObject.pathname;
  }
  if (urlObject.search) {
    result += urlObject.search;
  } else if (urlObject.query) {
    if (typeof urlObject.query === "string") {
      result += "?" + urlObject.query;
    } else {
      const params = new URLSearchParams();
      for (const [key, value2] of Object.entries(urlObject.query)) {
        if (Array.isArray(value2)) {
          for (const v2 of value2) {
            params.append(key, v2);
          }
        } else {
          params.set(key, value2);
        }
      }
      const search = params.toString();
      if (search) {
        result += "?" + search;
      }
    }
  }
  if (urlObject.hash) {
    result += urlObject.hash;
  }
  return result;
}
function resolve$1(from, to2) {
  try {
    return new URL$1(to2, from).href;
  } catch {
    return to2;
  }
}
const URL$1 = globalThis.URL;
const URLSearchParams = globalThis.URLSearchParams;
function fileURLToPath(url2) {
  const urlObj = typeof url2 === "string" ? new globalThis.URL(url2) : url2;
  if (urlObj.protocol !== "file:") {
    throw new TypeError("The URL must be of scheme file");
  }
  return decodeURIComponent(urlObj.pathname);
}
function pathToFileURL(path2) {
  const encoded = encodeURIComponent(path2).replace(/%2F/g, "/");
  return new globalThis.URL("file://" + encoded);
}
var url$1 = {
  parse: parse$Q,
  format: format$1,
  resolve: resolve$1,
  URL: URL$1,
  URLSearchParams,
  fileURLToPath,
  pathToFileURL
};
var urlShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  URL: URL$1,
  URLSearchParams,
  default: url$1,
  fileURLToPath,
  format: format$1,
  parse: parse$Q,
  pathToFileURL,
  resolve: resolve$1
});
function parse$P(str, sep2 = "&", eq = "=", options2) {
  const result = {};
  if (!str || typeof str !== "string") {
    return result;
  }
  const maxKeys = (options2 == null ? void 0 : options2.maxKeys) || 1e3;
  const pairs = str.split(sep2).slice(0, maxKeys > 0 ? maxKeys : void 0);
  for (const pair of pairs) {
    const idx = pair.indexOf(eq);
    let key;
    let value2;
    if (idx >= 0) {
      key = decodeURIComponent(pair.slice(0, idx).replace(/\+/g, " "));
      value2 = decodeURIComponent(pair.slice(idx + 1).replace(/\+/g, " "));
    } else {
      key = decodeURIComponent(pair.replace(/\+/g, " "));
      value2 = "";
    }
    if (key in result) {
      const existing = result[key];
      if (Array.isArray(existing)) {
        existing.push(value2);
      } else {
        result[key] = [existing, value2];
      }
    } else {
      result[key] = value2;
    }
  }
  return result;
}
function stringify(obj, sep2 = "&", eq = "=") {
  if (!obj || typeof obj !== "object") {
    return "";
  }
  const pairs = [];
  for (const [key, value2] of Object.entries(obj)) {
    if (value2 === void 0) continue;
    const encodedKey = encodeURIComponent(key);
    if (Array.isArray(value2)) {
      for (const v2 of value2) {
        pairs.push(`${encodedKey}${eq}${encodeURIComponent(String(v2))}`);
      }
    } else {
      pairs.push(`${encodedKey}${eq}${encodeURIComponent(String(value2))}`);
    }
  }
  return pairs.join(sep2);
}
function escape$1(str) {
  return encodeURIComponent(str);
}
function unescape$1(str) {
  return decodeURIComponent(str.replace(/\+/g, " "));
}
const encode$2 = stringify;
const decode$2 = parse$P;
var querystring = {
  parse: parse$P,
  stringify,
  escape: escape$1,
  unescape: unescape$1,
  encode: encode$2,
  decode: decode$2
};
var querystringShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  decode: decode$2,
  default: querystring,
  encode: encode$2,
  escape: escape$1,
  parse: parse$P,
  stringify,
  unescape: unescape$1
});
var define_process_env_default$2 = {};
function format(fmt, ...args) {
  if (typeof fmt !== "string") {
    return args.map((arg) => inspect(arg)).join(" ");
  }
  let i2 = 0;
  return fmt.replace(/%[sdjifoO%]/g, (match3) => {
    if (match3 === "%%") return "%";
    if (i2 >= args.length) return match3;
    const arg = args[i2++];
    switch (match3) {
      case "%s":
        return String(arg);
      case "%d":
      case "%i":
        return String(parseInt(String(arg), 10));
      case "%f":
        return String(parseFloat(String(arg)));
      case "%j":
        try {
          return JSON.stringify(arg);
        } catch {
          return "[Circular]";
        }
      case "%o":
      case "%O":
        return inspect(arg);
      default:
        return match3;
    }
  });
}
function inspect(obj, options2) {
  const seen = /* @__PURE__ */ new WeakSet();
  const depth = (options2 == null ? void 0 : options2.depth) ?? 2;
  function inspectValue(value2, currentDepth) {
    if (value2 === null) return "null";
    if (value2 === void 0) return "undefined";
    const type2 = typeof value2;
    if (type2 === "string") {
      return `'${value2}'`;
    }
    if (type2 === "number" || type2 === "boolean" || type2 === "bigint") {
      return String(value2);
    }
    if (type2 === "symbol") {
      return value2.toString();
    }
    if (type2 === "function") {
      const name2 = value2.name || "anonymous";
      return `[Function: ${name2}]`;
    }
    if (type2 !== "object") {
      return String(value2);
    }
    if (seen.has(value2)) {
      return "[Circular]";
    }
    seen.add(value2);
    if (currentDepth > depth) {
      return Array.isArray(value2) ? "[Array]" : "[Object]";
    }
    if (Array.isArray(value2)) {
      if (value2.length === 0) return "[]";
      const items = value2.map((v2) => inspectValue(v2, currentDepth + 1));
      return `[ ${items.join(", ")} ]`;
    }
    if (value2 instanceof Date) {
      return value2.toISOString();
    }
    if (value2 instanceof RegExp) {
      return value2.toString();
    }
    if (value2 instanceof Error) {
      return `${value2.name}: ${value2.message}`;
    }
    if (value2 instanceof Map) {
      const entries2 = [...value2.entries()].map(
        ([k, v2]) => `${inspectValue(k, currentDepth + 1)} => ${inspectValue(v2, currentDepth + 1)}`
      );
      return `Map(${value2.size}) { ${entries2.join(", ")} }`;
    }
    if (value2 instanceof Set) {
      const items = [...value2].map((v2) => inspectValue(v2, currentDepth + 1));
      return `Set(${value2.size}) { ${items.join(", ")} }`;
    }
    const keys = Object.keys(value2);
    if (keys.length === 0) return "{}";
    const entries = keys.map((key) => {
      const val = value2[key];
      return `${key}: ${inspectValue(val, currentDepth + 1)}`;
    });
    return `{ ${entries.join(", ")} }`;
  }
  return inspectValue(obj, 0);
}
function inherits(ctor, superCtor) {
  if (ctor === void 0 || ctor === null) {
    throw new TypeError("inherits: ctor must be a function");
  }
  if (superCtor === void 0 || superCtor === null) {
    return;
  }
  if (superCtor.prototype === void 0) {
    return;
  }
  ctor.super_ = superCtor;
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
function deprecate(fn2, msg, code2) {
  let warned = false;
  const deprecated = function(...args) {
    if (!warned) {
      console.warn(`DeprecationWarning: ${msg}${code2 ? ` (${code2})` : ""}`);
      warned = true;
    }
    return fn2.apply(this, args);
  };
  return deprecated;
}
function promisify(fn2) {
  return (...args) => {
    return new Promise((resolve2, reject) => {
      fn2(...args, (err2, result) => {
        if (err2) {
          reject(err2);
        } else {
          resolve2(result);
        }
      });
    });
  };
}
function callbackify(fn2) {
  return (...args) => {
    const callback = args.pop();
    fn2(...args).then((result) => callback(null, result)).catch((err2) => callback(err2, void 0));
  };
}
function isArray$1(value2) {
  return Array.isArray(value2);
}
function isBoolean(value2) {
  return typeof value2 === "boolean";
}
function isNull(value2) {
  return value2 === null;
}
function isNullOrUndefined(value2) {
  return value2 === null || value2 === void 0;
}
function isNumber(value2) {
  return typeof value2 === "number";
}
function isString(value2) {
  return typeof value2 === "string";
}
function isUndefined(value2) {
  return value2 === void 0;
}
function isRegExp(value2) {
  return value2 instanceof RegExp;
}
function isObject(value2) {
  return typeof value2 === "object" && value2 !== null;
}
function isDate(value2) {
  return value2 instanceof Date;
}
function isError(value2) {
  return value2 instanceof Error;
}
function isFunction(value2) {
  return typeof value2 === "function";
}
function isPrimitive(value2) {
  return value2 === null || typeof value2 !== "object" && typeof value2 !== "function";
}
function isBuffer(value2) {
  return value2 instanceof Uint8Array;
}
function debuglog(section) {
  const nodeDebug = typeof process !== "undefined" && (define_process_env_default$2 == null ? void 0 : define_process_env_default$2.NODE_DEBUG) || "";
  const enabled = nodeDebug.toLowerCase().includes(section.toLowerCase());
  if (enabled) {
    return (...args) => {
      console.error(`${section.toUpperCase()} ${(process == null ? void 0 : process.pid) || 0}:`, ...args);
    };
  }
  return () => {
  };
}
const debug = debuglog;
function stripVTControlCharacters(str) {
  return str.replace(/\x1B\[[0-9;]*[a-zA-Z]|\x1B\].*?(\x07|\x1B\\)|\x1B[()][A-Z0-9]|\x1B[#=]|\x1B./g, "");
}
const types$3 = {
  isArray: isArray$1,
  isBoolean,
  isNull,
  isNullOrUndefined,
  isNumber,
  isString,
  isUndefined,
  isRegExp,
  isObject,
  isDate,
  isError,
  isFunction,
  isPrimitive,
  isBuffer
};
const TextEncoder$1 = globalThis.TextEncoder;
const TextDecoder$1 = globalThis.TextDecoder;
var util$4 = {
  format,
  inspect,
  inherits,
  deprecate,
  promisify,
  callbackify,
  debuglog,
  debug,
  stripVTControlCharacters,
  isArray: isArray$1,
  isBoolean,
  isNull,
  isNullOrUndefined,
  isNumber,
  isString,
  isUndefined,
  isRegExp,
  isObject,
  isDate,
  isError,
  isFunction,
  isPrimitive,
  isBuffer,
  types: types$3,
  TextEncoder: TextEncoder$1,
  TextDecoder: TextDecoder$1
};
var utilShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1,
  callbackify,
  debug,
  debuglog,
  default: util$4,
  deprecate,
  format,
  inherits,
  inspect,
  isArray: isArray$1,
  isBoolean,
  isBuffer,
  isDate,
  isError,
  isFunction,
  isNull,
  isNullOrUndefined,
  isNumber,
  isObject,
  isPrimitive,
  isRegExp,
  isString,
  isUndefined,
  promisify,
  stripVTControlCharacters,
  types: types$3
});
class ReadStream extends Readable {
  constructor() {
    super(...arguments);
    __publicField(this, "isTTY", false);
    __publicField(this, "isRaw", false);
  }
  setRawMode(mode) {
    this.isRaw = mode;
    return this;
  }
}
class WriteStream extends Writable {
  constructor() {
    super(...arguments);
    __publicField(this, "isTTY", false);
    __publicField(this, "columns", 80);
    __publicField(this, "rows", 24);
  }
  clearLine(dir, callback) {
    if (callback) callback();
    return true;
  }
  clearScreenDown(callback) {
    if (callback) callback();
    return true;
  }
  cursorTo(x2, y, callback) {
    if (callback) callback();
    return true;
  }
  moveCursor(dx2, dy2, callback) {
    if (callback) callback();
    return true;
  }
  getColorDepth(env) {
    return 1;
  }
  hasColors(count, env) {
    return false;
  }
  getWindowSize() {
    return [this.columns, this.rows];
  }
}
function isatty(fd2) {
  return false;
}
var tty = {
  ReadStream,
  WriteStream,
  isatty
};
var ttyShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ReadStream,
  WriteStream,
  default: tty,
  isatty
});
function hostname() {
  return "localhost";
}
function platform() {
  return "linux";
}
function arch() {
  return "x64";
}
function type() {
  return "Linux";
}
function release() {
  return "5.10.0";
}
function version$2() {
  return "#1 SMP";
}
function machine() {
  return "x86_64";
}
function tmpdir() {
  return "/tmp";
}
function homedir() {
  return "/home/user";
}
function cpus() {
  const cpu = {
    model: "Virtual CPU",
    speed: 2400,
    times: { user: 0, nice: 0, sys: 0, idle: 0, irq: 0 }
  };
  return [cpu, cpu];
}
function totalmem() {
  return 4 * 1024 * 1024 * 1024;
}
function freemem() {
  return 2 * 1024 * 1024 * 1024;
}
function uptime() {
  return Math.floor(performance.now() / 1e3);
}
function loadavg() {
  return [0.5, 0.5, 0.5];
}
function networkInterfaces() {
  return {
    lo: [
      {
        address: "127.0.0.1",
        netmask: "255.0.0.0",
        family: "IPv4",
        mac: "00:00:00:00:00:00",
        internal: true,
        cidr: "127.0.0.1/8"
      }
    ]
  };
}
function userInfo() {
  return {
    username: "user",
    uid: 1e3,
    gid: 1e3,
    shell: "/bin/bash",
    homedir: "/home/user"
  };
}
function endianness() {
  return "LE";
}
function getPriority(pid) {
  return 0;
}
function setPriority(pid, priority) {
}
const EOL = "\n";
const constants$4 = {
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGBUS: 7,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 10,
    SIGSEGV: 11,
    SIGUSR2: 12,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 17,
    SIGCONT: 18,
    SIGSTOP: 19,
    SIGTSTP: 20,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 23,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 29,
    SIGPWR: 30,
    SIGSYS: 31
  },
  errno: {},
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};
const devNull = "/dev/null";
var os$1 = {
  hostname,
  platform,
  arch,
  type,
  release,
  version: version$2,
  machine,
  tmpdir,
  homedir,
  cpus,
  totalmem,
  freemem,
  uptime,
  loadavg,
  networkInterfaces,
  userInfo,
  endianness,
  getPriority,
  setPriority,
  EOL,
  constants: constants$4,
  devNull
};
var osShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EOL,
  arch,
  constants: constants$4,
  cpus,
  default: os$1,
  devNull,
  endianness,
  freemem,
  getPriority,
  homedir,
  hostname,
  loadavg,
  machine,
  networkInterfaces,
  platform,
  release,
  setPriority,
  tmpdir,
  totalmem,
  type,
  uptime,
  userInfo,
  version: version$2
});
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s2, w) => {
  s2.pending_buf[s2.pending++] = w & 255;
  s2.pending_buf[s2.pending++] = w >>> 8 & 255;
};
const send_bits = (s2, value2, length2) => {
  if (s2.bi_valid > Buf_size - length2) {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    put_short(s2, s2.bi_buf);
    s2.bi_buf = value2 >> Buf_size - s2.bi_valid;
    s2.bi_valid += length2 - Buf_size;
  } else {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    s2.bi_valid += length2;
  }
};
const send_code = (s2, c, tree) => {
  send_bits(
    s2,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code2, len) => {
  let res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
const bi_flush = (s2) => {
  if (s2.bi_valid === 16) {
    put_short(s2, s2.bi_buf);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  } else if (s2.bi_valid >= 8) {
    s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
    s2.bi_buf >>= 8;
    s2.bi_valid -= 8;
  }
};
const gen_bitlen = (s2, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n2, m;
  let bits;
  let xbits;
  let f2;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s2.bl_count[bits] = 0;
  }
  tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
  for (h = s2.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n2 = s2.heap[h];
    bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits;
    if (n2 > max_code) {
      continue;
    }
    s2.bl_count[bits]++;
    xbits = 0;
    if (n2 >= base) {
      xbits = extra[n2 - base];
    }
    f2 = tree[n2 * 2];
    s2.opt_len += f2 * (bits + xbits);
    if (has_stree) {
      s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s2.bl_count[bits] === 0) {
      bits--;
    }
    s2.bl_count[bits]--;
    s2.bl_count[bits + 1] += 2;
    s2.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n2 = s2.bl_count[bits];
    while (n2 !== 0) {
      m = s2.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n2--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code2 = 0;
  let bits;
  let n2;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code2 = code2 + bl_count[bits - 1] << 1;
    next_code[bits] = code2;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    let len = tree[n2 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n2;
  let bits;
  let length2;
  let code2;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length2 = 0;
  for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length2;
    for (n2 = 0; n2 < 1 << extra_lbits[code2]; n2++) {
      _length_code[length2++] = code2;
    }
  }
  _length_code[length2 - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist;
    for (n2 = 0; n2 < 1 << extra_dbits[code2]; n2++) {
      _dist_code[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist << 7;
    for (n2 = 0; n2 < 1 << extra_dbits[code2] - 7; n2++) {
      _dist_code[256 + dist++] = code2;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    static_dtree[n2 * 2 + 1] = 5;
    static_dtree[n2 * 2] = bi_reverse(n2, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s2) => {
  let n2;
  for (n2 = 0; n2 < L_CODES$1; n2++) {
    s2.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    s2.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < BL_CODES$1; n2++) {
    s2.bl_tree[n2 * 2] = 0;
  }
  s2.dyn_ltree[END_BLOCK * 2] = 1;
  s2.opt_len = s2.static_len = 0;
  s2.sym_next = s2.matches = 0;
};
const bi_windup = (s2) => {
  if (s2.bi_valid > 8) {
    put_short(s2, s2.bi_buf);
  } else if (s2.bi_valid > 0) {
    s2.pending_buf[s2.pending++] = s2.bi_buf;
  }
  s2.bi_buf = 0;
  s2.bi_valid = 0;
};
const smaller = (tree, n2, m, depth) => {
  const _n2 = n2 * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
};
const pqdownheap = (s2, tree, k) => {
  const v2 = s2.heap[k];
  let j2 = k << 1;
  while (j2 <= s2.heap_len) {
    if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
      j2++;
    }
    if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
      break;
    }
    s2.heap[k] = s2.heap[j2];
    k = j2;
    j2 <<= 1;
  }
  s2.heap[k] = v2;
};
const compress_block = (s2, ltree, dtree) => {
  let dist;
  let lc2;
  let sx2 = 0;
  let code2;
  let extra;
  if (s2.sym_next !== 0) {
    do {
      dist = s2.pending_buf[s2.sym_buf + sx2++] & 255;
      dist += (s2.pending_buf[s2.sym_buf + sx2++] & 255) << 8;
      lc2 = s2.pending_buf[s2.sym_buf + sx2++];
      if (dist === 0) {
        send_code(s2, lc2, ltree);
      } else {
        code2 = _length_code[lc2];
        send_code(s2, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc2 -= base_length[code2];
          send_bits(s2, lc2, extra);
        }
        dist--;
        code2 = d_code(dist);
        send_code(s2, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist -= base_dist[code2];
          send_bits(s2, dist, extra);
        }
      }
    } while (sx2 < s2.sym_next);
  }
  send_code(s2, END_BLOCK, ltree);
};
const build_tree = (s2, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n2, m;
  let max_code = -1;
  let node2;
  s2.heap_len = 0;
  s2.heap_max = HEAP_SIZE$1;
  for (n2 = 0; n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s2.heap[++s2.heap_len] = max_code = n2;
      s2.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s2.heap_len < 2) {
    node2 = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node2 * 2] = 1;
    s2.depth[node2] = 0;
    s2.opt_len--;
    if (has_stree) {
      s2.static_len -= stree[node2 * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
    pqdownheap(s2, tree, n2);
  }
  node2 = elems;
  do {
    n2 = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[
      1
      /*SMALLEST*/
    ] = s2.heap[s2.heap_len--];
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
    m = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[--s2.heap_max] = n2;
    s2.heap[--s2.heap_max] = m;
    tree[node2 * 2] = tree[n2 * 2] + tree[m * 2];
    s2.depth[node2] = (s2.depth[n2] >= s2.depth[m] ? s2.depth[n2] : s2.depth[m]) + 1;
    tree[n2 * 2 + 1] = tree[m * 2 + 1] = node2;
    s2.heap[
      1
      /*SMALLEST*/
    ] = node2++;
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s2.heap_len >= 2);
  s2.heap[--s2.heap_max] = s2.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s2, desc);
  gen_codes(tree, max_code, s2.bl_count);
};
const scan_tree = (s2, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s2.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s2.bl_tree[curlen * 2]++;
      }
      s2.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s2.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s2.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s2, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s2, curlen, s2.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s2, curlen, s2.bl_tree);
        count--;
      }
      send_code(s2, REP_3_6, s2.bl_tree);
      send_bits(s2, count - 3, 2);
    } else if (count <= 10) {
      send_code(s2, REPZ_3_10, s2.bl_tree);
      send_bits(s2, count - 3, 3);
    } else {
      send_code(s2, REPZ_11_138, s2.bl_tree);
      send_bits(s2, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s2) => {
  let max_blindex;
  scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
  scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
  build_tree(s2, s2.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s2, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s2, lcodes - 257, 5);
  send_bits(s2, dcodes - 1, 5);
  send_bits(s2, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s2, s2.dyn_ltree, lcodes - 1);
  send_tree(s2, s2.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s2) => {
  let block_mask = 4093624447;
  let n2;
  for (n2 = 0; n2 <= 31; n2++, block_mask >>>= 1) {
    if (block_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n2 = 32; n2 < LITERALS$1; n2++) {
    if (s2.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s2) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
  s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
  s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
  s2.bi_buf = 0;
  s2.bi_valid = 0;
  init_block(s2);
};
const _tr_stored_block$1 = (s2, buf, stored_len, last) => {
  send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s2);
  put_short(s2, stored_len);
  put_short(s2, ~stored_len);
  if (stored_len) {
    s2.pending_buf.set(s2.window.subarray(buf, buf + stored_len), s2.pending);
  }
  s2.pending += stored_len;
};
const _tr_align$1 = (s2) => {
  send_bits(s2, STATIC_TREES << 1, 3);
  send_code(s2, END_BLOCK, static_ltree);
  bi_flush(s2);
};
const _tr_flush_block$1 = (s2, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s2.level > 0) {
    if (s2.strm.data_type === Z_UNKNOWN$1) {
      s2.strm.data_type = detect_data_type(s2);
    }
    build_tree(s2, s2.l_desc);
    build_tree(s2, s2.d_desc);
    max_blindex = build_bl_tree(s2);
    opt_lenb = s2.opt_len + 3 + 7 >>> 3;
    static_lenb = s2.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s2, buf, stored_len, last);
  } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s2, static_ltree, static_dtree);
  } else {
    send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
  }
  init_block(s2);
  if (last) {
    bi_windup(s2);
  }
};
const _tr_tally$1 = (s2, dist, lc2) => {
  s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist;
  s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist >> 8;
  s2.pending_buf[s2.sym_buf + s2.sym_next++] = lc2;
  if (dist === 0) {
    s2.dyn_ltree[lc2 * 2]++;
  } else {
    s2.matches++;
    dist--;
    s2.dyn_ltree[(_length_code[lc2] + LITERALS$1 + 1) * 2]++;
    s2.dyn_dtree[d_code(dist) * 2]++;
  }
  return s2.sym_next === s2.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) => {
  let s12 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len !== 0) {
    n2 = len > 2e3 ? 2e3 : len;
    len -= n2;
    do {
      s12 = s12 + buf[pos++] | 0;
      s2 = s2 + s12 | 0;
    } while (--n2);
    s12 %= 65521;
    s2 %= 65521;
  }
  return s12 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c, table = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c = n2;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n2] = c;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t2 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i2 = pos; i2 < end; i2++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2$1 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2$1;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f2) => {
  return f2 * 2 - (f2 > 4 ? 9 : 0);
};
const zero$2 = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
const slide_hash = (s2) => {
  let n2, m;
  let p;
  let wsize = s2.w_size;
  n2 = s2.hash_size;
  p = n2;
  do {
    m = s2.head[--p];
    s2.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n2);
  n2 = wsize;
  p = n2;
  do {
    m = s2.prev[--p];
    s2.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n2);
};
let HASH_ZLIB = (s2, prev, data2) => (prev << s2.hash_shift ^ data2) & s2.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s2 = strm.state;
  let len = s2.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
  strm.next_out += len;
  s2.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s2.pending -= len;
  if (s2.pending === 0) {
    s2.pending_out = 0;
  }
};
const flush_block_only = (s2, last) => {
  _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
  s2.block_start = s2.strstart;
  flush_pending(s2.strm);
};
const put_byte = (s2, b) => {
  s2.pending_buf[s2.pending++] = b;
};
const putShortMSB = (s2, b) => {
  s2.pending_buf[s2.pending++] = b >>> 8 & 255;
  s2.pending_buf[s2.pending++] = b & 255;
};
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s2, cur_match) => {
  let chain_length = s2.max_chain_length;
  let scan = s2.strstart;
  let match3;
  let len;
  let best_len = s2.prev_length;
  let nice_match = s2.nice_match;
  const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s2.window;
  const wmask = s2.w_mask;
  const prev = s2.prev;
  const strend = s2.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s2.prev_length >= s2.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s2.lookahead) {
    nice_match = s2.lookahead;
  }
  do {
    match3 = cur_match;
    if (_win[match3 + best_len] !== scan_end || _win[match3 + best_len - 1] !== scan_end1 || _win[match3] !== _win[scan] || _win[++match3] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match3++;
    do {
    } while (_win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && _win[++scan] === _win[++match3] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s2.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s2.lookahead) {
    return best_len;
  }
  return s2.lookahead;
};
const fill_window = (s2) => {
  const _w_size = s2.w_size;
  let n2, more, str;
  do {
    more = s2.window_size - s2.lookahead - s2.strstart;
    if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s2.match_start -= _w_size;
      s2.strstart -= _w_size;
      s2.block_start -= _w_size;
      if (s2.insert > s2.strstart) {
        s2.insert = s2.strstart;
      }
      slide_hash(s2);
      more += _w_size;
    }
    if (s2.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
    s2.lookahead += n2;
    if (s2.lookahead + s2.insert >= MIN_MATCH) {
      str = s2.strstart - s2.insert;
      s2.ins_h = s2.window[str];
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
      while (s2.insert) {
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
        s2.insert--;
        if (s2.lookahead + s2.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
};
const deflate_stored = (s2, flush) => {
  let min_block = s2.pending_buf_size - 5 > s2.w_size ? s2.w_size : s2.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s2.strm.avail_in;
  do {
    len = 65535;
    have = s2.bi_valid + 42 >> 3;
    if (s2.strm.avail_out < have) {
      break;
    }
    have = s2.strm.avail_out - have;
    left = s2.strstart - s2.block_start;
    if (len > left + s2.strm.avail_in) {
      len = left + s2.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s2.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s2.strm.avail_in ? 1 : 0;
    _tr_stored_block(s2, 0, 0, last);
    s2.pending_buf[s2.pending - 4] = len;
    s2.pending_buf[s2.pending - 3] = len >> 8;
    s2.pending_buf[s2.pending - 2] = ~len;
    s2.pending_buf[s2.pending - 1] = ~len >> 8;
    flush_pending(s2.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s2.strm.output.set(s2.window.subarray(s2.block_start, s2.block_start + left), s2.strm.next_out);
      s2.strm.next_out += left;
      s2.strm.avail_out -= left;
      s2.strm.total_out += left;
      s2.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s2.strm, s2.strm.output, s2.strm.next_out, len);
      s2.strm.next_out += len;
      s2.strm.avail_out -= len;
      s2.strm.total_out += len;
    }
  } while (last === 0);
  used -= s2.strm.avail_in;
  if (used) {
    if (used >= s2.w_size) {
      s2.matches = 2;
      s2.window.set(s2.strm.input.subarray(s2.strm.next_in - s2.w_size, s2.strm.next_in), 0);
      s2.strstart = s2.w_size;
      s2.insert = s2.strstart;
    } else {
      if (s2.window_size - s2.strstart <= used) {
        s2.strstart -= s2.w_size;
        s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
        if (s2.matches < 2) {
          s2.matches++;
        }
        if (s2.insert > s2.strstart) {
          s2.insert = s2.strstart;
        }
      }
      s2.window.set(s2.strm.input.subarray(s2.strm.next_in - used, s2.strm.next_in), s2.strstart);
      s2.strstart += used;
      s2.insert += used > s2.w_size - s2.insert ? s2.w_size - s2.insert : used;
    }
    s2.block_start = s2.strstart;
  }
  if (s2.high_water < s2.strstart) {
    s2.high_water = s2.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s2.strm.avail_in === 0 && s2.strstart === s2.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s2.window_size - s2.strstart;
  if (s2.strm.avail_in > have && s2.block_start >= s2.w_size) {
    s2.block_start -= s2.w_size;
    s2.strstart -= s2.w_size;
    s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
    if (s2.matches < 2) {
      s2.matches++;
    }
    have += s2.w_size;
    if (s2.insert > s2.strstart) {
      s2.insert = s2.strstart;
    }
  }
  if (have > s2.strm.avail_in) {
    have = s2.strm.avail_in;
  }
  if (have) {
    read_buf(s2.strm, s2.window, s2.strstart, have);
    s2.strstart += have;
    s2.insert += have > s2.w_size - s2.insert ? s2.w_size - s2.insert : have;
  }
  if (s2.high_water < s2.strstart) {
    s2.high_water = s2.strstart;
  }
  have = s2.bi_valid + 42 >> 3;
  have = s2.pending_buf_size - have > 65535 ? 65535 : s2.pending_buf_size - have;
  min_block = have > s2.w_size ? s2.w_size : have;
  left = s2.strstart - s2.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s2.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s2.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s2, s2.block_start, len, last);
    s2.block_start += len;
    flush_pending(s2.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s2, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
        s2.match_length--;
        do {
          s2.strstart++;
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        } while (--s2.match_length !== 0);
        s2.strstart++;
      } else {
        s2.strstart += s2.match_length;
        s2.match_length = 0;
        s2.ins_h = s2.window[s2.strstart];
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s2, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    s2.prev_length = s2.match_length;
    s2.prev_match = s2.match_start;
    s2.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
      if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
        s2.match_length = MIN_MATCH - 1;
      }
    }
    if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
      max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
      bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
      s2.lookahead -= s2.prev_length - 1;
      s2.prev_length -= 2;
      do {
        if (++s2.strstart <= max_insert) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
      } while (--s2.prev_length !== 0);
      s2.match_available = 0;
      s2.match_length = MIN_MATCH - 1;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s2.match_available) {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      if (bflush) {
        flush_block_only(s2, false);
      }
      s2.strstart++;
      s2.lookahead--;
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s2.match_available = 1;
      s2.strstart++;
      s2.lookahead--;
    }
  }
  if (s2.match_available) {
    bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
    s2.match_available = 0;
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s2, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s2.window;
  for (; ; ) {
    if (s2.lookahead <= MAX_MATCH) {
      fill_window(s2);
      if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.match_length = 0;
    if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
      scan = s2.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s2.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s2.match_length = MAX_MATCH - (strend - scan);
        if (s2.match_length > s2.lookahead) {
          s2.match_length = s2.lookahead;
        }
      }
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      s2.strstart += s2.match_length;
      s2.match_length = 0;
    } else {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s2, flush) => {
  let bflush;
  for (; ; ) {
    if (s2.lookahead === 0) {
      fill_window(s2);
      if (s2.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s2.match_length = 0;
    bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
    s2.lookahead--;
    s2.strstart++;
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.sym_next) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s2) => {
  s2.window_size = 2 * s2.w_size;
  zero$2(s2.head);
  s2.max_lazy_match = configuration_table[s2.level].max_lazy;
  s2.good_match = configuration_table[s2.level].good_length;
  s2.nice_match = configuration_table[s2.level].nice_length;
  s2.max_chain_length = configuration_table[s2.level].max_chain;
  s2.strstart = 0;
  s2.block_start = 0;
  s2.lookahead = 0;
  s2.insert = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  s2.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero$2(this.dyn_ltree);
  zero$2(this.dyn_dtree);
  zero$2(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero$2(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero$2(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s2 = strm.state;
  if (!s2 || s2.strm !== strm || s2.status !== INIT_STATE && //#ifdef GZIP
  s2.status !== GZIP_STATE && //#endif
  s2.status !== EXTRA_STATE && s2.status !== NAME_STATE && s2.status !== COMMENT_STATE && s2.status !== HCRC_STATE && s2.status !== BUSY_STATE && s2.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s2 = strm.state;
  s2.pending = 0;
  s2.pending_out = 0;
  if (s2.wrap < 0) {
    s2.wrap = -s2.wrap;
  }
  s2.status = //#ifdef GZIP
  s2.wrap === 2 ? GZIP_STATE : (
    //#endif
    s2.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s2.wrap === 2 ? 0 : 1;
  s2.last_flush = -2;
  _tr_init(s2);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap2 !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s2 = new DeflateState();
  strm.state = s2;
  s2.strm = strm;
  s2.status = INIT_STATE;
  s2.wrap = wrap2;
  s2.gzhead = null;
  s2.w_bits = windowBits;
  s2.w_size = 1 << s2.w_bits;
  s2.w_mask = s2.w_size - 1;
  s2.hash_bits = memLevel + 7;
  s2.hash_size = 1 << s2.hash_bits;
  s2.hash_mask = s2.hash_size - 1;
  s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s2.window = new Uint8Array(s2.w_size * 2);
  s2.head = new Uint16Array(s2.hash_size);
  s2.prev = new Uint16Array(s2.w_size);
  s2.lit_bufsize = 1 << memLevel + 6;
  s2.pending_buf_size = s2.lit_bufsize * 4;
  s2.pending_buf = new Uint8Array(s2.pending_buf_size);
  s2.sym_buf = s2.lit_bufsize;
  s2.sym_end = (s2.lit_bufsize - 1) * 3;
  s2.level = level;
  s2.strategy = strategy;
  s2.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s2 = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s2.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s2.last_flush;
  s2.last_flush = flush;
  if (s2.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === INIT_STATE && s2.wrap === 0) {
    s2.status = BUSY_STATE;
  }
  if (s2.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
      level_flags = 0;
    } else if (s2.level < 6) {
      level_flags = 1;
    } else if (s2.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s2.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s2, header);
    if (s2.strstart !== 0) {
      putShortMSB(s2, strm.adler >>> 16);
      putShortMSB(s2, strm.adler & 65535);
    }
    strm.adler = 1;
    s2.status = BUSY_STATE;
    flush_pending(strm);
    if (s2.pending !== 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s2.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s2, 31);
    put_byte(s2, 139);
    put_byte(s2, 8);
    if (!s2.gzhead) {
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, 0);
      put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
      put_byte(s2, OS_CODE);
      s2.status = BUSY_STATE;
      flush_pending(strm);
      if (s2.pending !== 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s2,
        (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
      );
      put_byte(s2, s2.gzhead.time & 255);
      put_byte(s2, s2.gzhead.time >> 8 & 255);
      put_byte(s2, s2.gzhead.time >> 16 & 255);
      put_byte(s2, s2.gzhead.time >> 24 & 255);
      put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
      put_byte(s2, s2.gzhead.os & 255);
      if (s2.gzhead.extra && s2.gzhead.extra.length) {
        put_byte(s2, s2.gzhead.extra.length & 255);
        put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
      }
      if (s2.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
      }
      s2.gzindex = 0;
      s2.status = EXTRA_STATE;
    }
  }
  if (s2.status === EXTRA_STATE) {
    if (s2.gzhead.extra) {
      let beg = s2.pending;
      let left = (s2.gzhead.extra.length & 65535) - s2.gzindex;
      while (s2.pending + left > s2.pending_buf_size) {
        let copy = s2.pending_buf_size - s2.pending;
        s2.pending_buf.set(s2.gzhead.extra.subarray(s2.gzindex, s2.gzindex + copy), s2.pending);
        s2.pending = s2.pending_buf_size;
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        s2.gzindex += copy;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s2.gzhead.extra);
      s2.pending_buf.set(gzhead_extra.subarray(s2.gzindex, s2.gzindex + left), s2.pending);
      s2.pending += left;
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      s2.gzindex = 0;
    }
    s2.status = NAME_STATE;
  }
  if (s2.status === NAME_STATE) {
    if (s2.gzhead.name) {
      let beg = s2.pending;
      let val;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s2.gzindex < s2.gzhead.name.length) {
          val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      s2.gzindex = 0;
    }
    s2.status = COMMENT_STATE;
  }
  if (s2.status === COMMENT_STATE) {
    if (s2.gzhead.comment) {
      let beg = s2.pending;
      let val;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s2.gzindex < s2.gzhead.comment.length) {
          val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
    }
    s2.status = HCRC_STATE;
  }
  if (s2.status === HCRC_STATE) {
    if (s2.gzhead.hcrc) {
      if (s2.pending + 2 > s2.pending_buf_size) {
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s2, strm.adler & 255);
      put_byte(s2, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s2.status = BUSY_STATE;
    flush_pending(strm);
    if (s2.pending !== 0) {
      s2.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
    let bstate = s2.level === 0 ? deflate_stored(s2, flush) : s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s2.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s2);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s2, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero$2(s2.head);
          if (s2.lookahead === 0) {
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s2.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s2.wrap === 2) {
    put_byte(s2, strm.adler & 255);
    put_byte(s2, strm.adler >> 8 & 255);
    put_byte(s2, strm.adler >> 16 & 255);
    put_byte(s2, strm.adler >> 24 & 255);
    put_byte(s2, strm.total_in & 255);
    put_byte(s2, strm.total_in >> 8 & 255);
    put_byte(s2, strm.total_in >> 16 & 255);
    put_byte(s2, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s2, strm.adler >>> 16);
    putShortMSB(s2, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s2.wrap > 0) {
    s2.wrap = -s2.wrap;
  }
  return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s2 = strm.state;
  const wrap2 = s2.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s2.status !== INIT_STATE || s2.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s2.wrap = 0;
  if (dictLength >= s2.w_size) {
    if (wrap2 === 0) {
      zero$2(s2.head);
      s2.strstart = 0;
      s2.block_start = 0;
      s2.insert = 0;
    }
    let tmpDict = new Uint8Array(s2.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s2.w_size;
  }
  const avail = strm.avail_in;
  const next2 = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s2);
  while (s2.lookahead >= MIN_MATCH) {
    let str = s2.strstart;
    let n2 = s2.lookahead - (MIN_MATCH - 1);
    do {
      s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
      s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = str;
      str++;
    } while (--n2);
    s2.strstart = str;
    s2.lookahead = MIN_MATCH - 1;
    fill_window(s2);
  }
  s2.strstart += s2.lookahead;
  s2.block_start = s2.strstart;
  s2.insert = s2.lookahead;
  s2.lookahead = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  strm.next_in = next2;
  strm.input = input;
  strm.avail_in = avail;
  s2.wrap = wrap2;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l = chunks.length; i2 < l; i2++) {
    len += chunks[i2].length;
  }
  const result = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l = chunks.length; i2 < l; i2++) {
    let chunk = chunks[i2];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i2++] = c;
    } else if (c < 2048) {
      buf[i2++] = 192 | c >>> 6;
      buf[i2++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i2++] = 224 | c >>> 12;
      buf[i2++] = 128 | c >>> 6 & 63;
      buf[i2++] = 128 | c & 63;
    } else {
      buf[i2++] = 240 | c >>> 18;
      buf[i2++] = 128 | c >>> 12 & 63;
      buf[i2++] = 128 | c >>> 6 & 63;
      buf[i2++] = 128 | c & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i2 = 0; i2 < len; i2++) {
    result += String.fromCharCode(buf[i2]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    let c = buf[i2++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c = c << 6 | buf[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2$1;
function Deflate$1(options2) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options2 || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data2 === "string") {
    strm.input = strings.string2buf(data2);
  } else if (toString$1.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options2) {
  const deflator = new Deflate$1(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$1(input, options2);
}
function gzip$1(input, options2) {
  options2 = options2 || {};
  options2.gzip = true;
  return deflate$1(input, options2);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1
};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op2;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op2 = here >>> 24;
          hold >>>= op2;
          bits -= op2;
          op2 = here >>> 16 & 255;
          if (op2 === 0) {
            output[_out++] = here & 65535;
          } else if (op2 & 16) {
            len = here & 65535;
            op2 &= 15;
            if (op2) {
              if (bits < op2) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op2) - 1;
              hold >>>= op2;
              bits -= op2;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op2 = here >>> 24;
                hold >>>= op2;
                bits -= op2;
                op2 = here >>> 16 & 255;
                if (op2 & 16) {
                  dist = here & 65535;
                  op2 &= 15;
                  if (bits < op2) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op2) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op2) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op2;
                  bits -= op2;
                  op2 = _out - beg;
                  if (dist > op2) {
                    op2 = dist - op2;
                    if (op2 > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op2;
                      if (op2 < len) {
                        len -= op2;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op2);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op2) {
                      from += wsize + wnext - op2;
                      op2 -= wnext;
                      if (op2 < len) {
                        len -= op2;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op2);
                        from = 0;
                        if (wnext < len) {
                          op2 = wnext;
                          len -= op2;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op2);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op2;
                      if (op2 < len) {
                        len -= op2;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op2);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op2 & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op2) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op2 & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op2) - 1)];
            continue dolen;
          } else if (op2 & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root2 = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next2;
  let base = null;
  let match3;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root2 > max) {
    root2 = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root2 < min) {
    root2 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base = extra = work;
    match3 = 20;
  } else if (type2 === LENS$1) {
    base = lbase;
    extra = lext;
    match3 = 257;
  } else {
    base = dbase;
    extra = dext;
    match3 = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next2 = table_index;
  curr = root2;
  drop = 0;
  low = -1;
  used = 1 << root2;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match3) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match3) {
      here_op = extra[work[sym] - match3];
      here_val = base[work[sym] - match3];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root2;
      }
      next2 += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root2 << 24 | curr << 16 | next2 - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2$1;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS$1 = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH$1 = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap2;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next2;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n2;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next2 = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS$1;
        case OS$1:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next2,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next2 + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next2);
              }
              have -= copy;
              next2 += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next2, next2 + copy), put);
            have -= copy;
            next2 += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next2 = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH$1;
        case MATCH$1:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next2++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next2;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString$2 = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2$1;
function Inflate$1(options2) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options2 || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data2, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString$2.call(data2) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data2);
  } else {
    strm.input = data2;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data2[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options2) {
  const inflator = new Inflate$1(options2);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$1(input, options2);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1
};
const { Deflate, deflate: deflate$3, deflateRaw: deflateRaw$2, gzip: gzip$2 } = deflate_1$1;
const { Inflate, inflate: inflate$3, inflateRaw: inflateRaw$2, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate$3;
var deflateRaw_1 = deflateRaw$2;
var gzip_1 = gzip$2;
var Inflate_1 = Inflate;
var inflate_1 = inflate$3;
var inflateRaw_1 = inflateRaw$2;
var ungzip_1 = ungzip;
var constants_1 = constants$2$1;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};
let brotliModule = null;
let brotliLoadPromise = null;
async function loadBrotli() {
  if (brotliModule) return brotliModule;
  if (!brotliLoadPromise) {
    brotliLoadPromise = (async () => {
      try {
        const brotliWasmModule = await Promise.resolve().then(function() {
          return index_web$1;
        });
        brotliModule = await brotliWasmModule.default;
        console.log("[zlib] brotli-wasm loaded successfully");
        return brotliModule;
      } catch (error) {
        console.error("[zlib] Failed to load brotli-wasm:", error);
        return null;
      }
    })();
  }
  return brotliLoadPromise;
}
function gzip(buffer, callback) {
  try {
    const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
    const result = pako.gzip(input);
    callback(null, BufferPolyfill.from(result));
  } catch (error) {
    callback(error, BufferPolyfill.alloc(0));
  }
}
function gunzip(buffer, callback) {
  try {
    const result = pako.ungzip(buffer);
    callback(null, BufferPolyfill.from(result));
  } catch (error) {
    callback(error, BufferPolyfill.alloc(0));
  }
}
function deflate(buffer, callback) {
  try {
    const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
    const result = pako.deflate(input);
    callback(null, BufferPolyfill.from(result));
  } catch (error) {
    callback(error, BufferPolyfill.alloc(0));
  }
}
function inflate(buffer, callback) {
  try {
    const result = pako.inflate(buffer);
    callback(null, BufferPolyfill.from(result));
  } catch (error) {
    callback(error, BufferPolyfill.alloc(0));
  }
}
function deflateRaw(buffer, callback) {
  try {
    const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
    const result = pako.deflateRaw(input);
    callback(null, BufferPolyfill.from(result));
  } catch (error) {
    callback(error, BufferPolyfill.alloc(0));
  }
}
function inflateRaw(buffer, callback) {
  try {
    const result = pako.inflateRaw(buffer);
    callback(null, BufferPolyfill.from(result));
  } catch (error) {
    callback(error, BufferPolyfill.alloc(0));
  }
}
function brotliCompress(buffer, options2, callback) {
  if (typeof options2 === "function") {
    callback = options2;
  }
  loadBrotli().then((brotli) => {
    if (!brotli) {
      callback(new Error("Brotli WASM failed to load"), BufferPolyfill.alloc(0));
      return;
    }
    try {
      const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
      const result = brotli.compress(new Uint8Array(input));
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }).catch((error) => {
    callback(error, BufferPolyfill.alloc(0));
  });
}
function brotliDecompress(buffer, options2, callback) {
  if (typeof options2 === "function") {
    callback = options2;
  }
  loadBrotli().then((brotli) => {
    if (!brotli) {
      callback(new Error("Brotli WASM failed to load"), BufferPolyfill.alloc(0));
      return;
    }
    try {
      const result = brotli.decompress(new Uint8Array(buffer));
      callback(null, BufferPolyfill.from(result));
    } catch (error) {
      callback(error, BufferPolyfill.alloc(0));
    }
  }).catch((error) => {
    callback(error, BufferPolyfill.alloc(0));
  });
}
function brotliCompressSync(buffer, _options3) {
  if (!brotliModule) {
    throw new Error("Brotli WASM not loaded. Call brotliCompress first to initialize.");
  }
  const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
  return BufferPolyfill.from(brotliModule.compress(new Uint8Array(input)));
}
function brotliDecompressSync(buffer, _options3) {
  if (!brotliModule) {
    throw new Error("Brotli WASM not loaded. Call brotliDecompress first to initialize.");
  }
  return BufferPolyfill.from(brotliModule.decompress(new Uint8Array(buffer)));
}
function gzipSync(buffer) {
  const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
  return BufferPolyfill.from(pako.gzip(input));
}
function gunzipSync(buffer) {
  return BufferPolyfill.from(pako.ungzip(buffer));
}
function deflateSync(buffer) {
  const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
  return BufferPolyfill.from(pako.deflate(input));
}
function inflateSync(buffer) {
  return BufferPolyfill.from(pako.inflate(buffer));
}
function deflateRawSync(buffer) {
  const input = typeof buffer === "string" ? BufferPolyfill.from(buffer) : buffer;
  return BufferPolyfill.from(pako.deflateRaw(input));
}
function inflateRawSync(buffer) {
  return BufferPolyfill.from(pako.inflateRaw(buffer));
}
const constants$3 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_VERSION_ERROR: -6,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  ZLIB_VERNUM: 4784,
  Z_MIN_WINDOWBITS: 8,
  Z_MAX_WINDOWBITS: 15,
  Z_DEFAULT_WINDOWBITS: 15,
  Z_MIN_CHUNK: 64,
  Z_MAX_CHUNK: Infinity,
  Z_DEFAULT_CHUNK: 16384,
  Z_MIN_MEMLEVEL: 1,
  Z_MAX_MEMLEVEL: 9,
  Z_DEFAULT_MEMLEVEL: 8,
  Z_MIN_LEVEL: -1,
  Z_MAX_LEVEL: 9,
  Z_DEFAULT_LEVEL: -1,
  // Brotli constants
  BROTLI_DECODE: 0,
  BROTLI_ENCODE: 1,
  BROTLI_OPERATION_PROCESS: 0,
  BROTLI_OPERATION_FLUSH: 1,
  BROTLI_OPERATION_FINISH: 2,
  BROTLI_OPERATION_EMIT_METADATA: 3,
  BROTLI_PARAM_MODE: 0,
  BROTLI_MODE_GENERIC: 0,
  BROTLI_MODE_TEXT: 1,
  BROTLI_MODE_FONT: 2,
  BROTLI_PARAM_QUALITY: 1,
  BROTLI_MIN_QUALITY: 0,
  BROTLI_MAX_QUALITY: 11,
  BROTLI_DEFAULT_QUALITY: 11,
  BROTLI_PARAM_LGWIN: 2,
  BROTLI_MIN_WINDOW_BITS: 10,
  BROTLI_MAX_WINDOW_BITS: 24,
  BROTLI_DEFAULT_WINDOW: 22,
  BROTLI_PARAM_LGBLOCK: 3,
  BROTLI_MIN_INPUT_BLOCK_BITS: 16,
  BROTLI_MAX_INPUT_BLOCK_BITS: 24
};
var zlib = {
  gzip,
  gunzip,
  deflate,
  inflate,
  deflateRaw,
  inflateRaw,
  gzipSync,
  gunzipSync,
  deflateSync,
  inflateSync,
  deflateRawSync,
  inflateRawSync,
  brotliCompress,
  brotliDecompress,
  brotliCompressSync,
  brotliDecompressSync,
  constants: constants$3
};
var zlibShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  brotliCompress,
  brotliCompressSync,
  brotliDecompress,
  brotliDecompressSync,
  constants: constants$3,
  default: zlib,
  deflate,
  deflateRaw,
  deflateRawSync,
  deflateSync,
  gunzip,
  gunzipSync,
  gzip,
  gzipSync,
  inflate,
  inflateRaw,
  inflateRawSync,
  inflateSync
});
function lookup(hostname2, optionsOrCallback, callback) {
  const cb2 = typeof optionsOrCallback === "function" ? optionsOrCallback : callback;
  const options2 = typeof optionsOrCallback === "object" ? optionsOrCallback : {};
  setImmediate(() => {
    if (hostname2 === "localhost" || hostname2 === "127.0.0.1") {
      if (options2.all) {
        cb2(null, [{ address: "127.0.0.1", family: 4 }]);
      } else {
        cb2(null, "127.0.0.1", 4);
      }
    } else {
      if (options2.all) {
        cb2(null, [{ address: "0.0.0.0", family: 4 }]);
      } else {
        cb2(null, "0.0.0.0", 4);
      }
    }
  });
}
function resolve(hostname2, callback) {
  setImmediate(() => {
    callback(null, ["0.0.0.0"]);
  });
}
function resolve4(hostname2, callback) {
  resolve(hostname2, callback);
}
function resolve6(hostname2, callback) {
  setImmediate(() => {
    callback(null, ["::1"]);
  });
}
function reverse(ip2, callback) {
  setImmediate(() => {
    callback(null, ["localhost"]);
  });
}
function setServers(_servers) {
}
function getServers() {
  return [];
}
function setDefaultResultOrder(_order) {
}
function getDefaultResultOrder() {
  return "verbatim";
}
const promises$1 = {
  lookup: (hostname2, options2) => {
    return new Promise((resolve2, reject) => {
      if (options2 == null ? void 0 : options2.all) {
        lookup(hostname2, options2, (err2, addresses) => {
          if (err2) reject(err2);
          else resolve2(addresses || []);
        });
        return;
      }
      lookup(hostname2, options2 || {}, (err2, address, family) => {
        if (err2) reject(err2);
        else resolve2({ address, family });
      });
    });
  },
  resolve: (hostname2) => {
    return new Promise((promiseResolve, promiseReject) => {
      resolve(hostname2, (err2, addresses) => {
        if (err2) promiseReject(err2);
        else promiseResolve(addresses || []);
      });
    });
  },
  resolve4: (hostname2) => promises$1.resolve(hostname2),
  resolve6: (hostname2) => {
    return new Promise((resolve2) => {
      resolve2(["::1"]);
    });
  },
  reverse: (ip2) => {
    return new Promise((resolve2) => {
      resolve2(["localhost"]);
    });
  },
  setServers: (_servers) => {
  },
  getServers: () => []
};
const ADDRCONFIG = 0;
const V4MAPPED = 0;
const ALL = 0;
var dns = {
  lookup,
  resolve,
  resolve4,
  resolve6,
  reverse,
  setServers,
  getServers,
  setDefaultResultOrder,
  getDefaultResultOrder,
  promises: promises$1,
  ADDRCONFIG,
  V4MAPPED,
  ALL
};
var dnsShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ADDRCONFIG,
  ALL,
  V4MAPPED,
  default: dns,
  getDefaultResultOrder,
  getServers,
  lookup,
  promises: promises$1,
  resolve,
  resolve4,
  resolve6,
  reverse,
  setDefaultResultOrder,
  setServers
});
const Buffer$1 = BufferPolyfill;
const SlowBuffer = BufferPolyfill;
const kMaxLength = 2147483647;
const INSPECT_MAX_BYTES = 50;
const constants$2 = {
  MAX_LENGTH: kMaxLength,
  MAX_STRING_LENGTH: 536870888
};
function transcode(source, _fromEnc, _toEnc) {
  return Buffer$1.from(source);
}
function resolveObjectURL(id2) {
  return void 0;
}
function atob$1(data2) {
  return globalThis.atob(data2);
}
function btoa$1(data2) {
  return globalThis.btoa(data2);
}
const bufferModule = {
  Buffer: Buffer$1,
  SlowBuffer,
  kMaxLength,
  INSPECT_MAX_BYTES,
  constants: constants$2,
  transcode,
  resolveObjectURL,
  atob: atob$1,
  btoa: btoa$1
};
Object.defineProperty(bufferModule, "hasOwnProperty", {
  value: Object.prototype.hasOwnProperty,
  enumerable: false,
  configurable: true,
  writable: true
});
var sprintf = {};
(function(exports$1) {
  !function() {
    var re2 = {
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf2(key) {
      return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf2.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, arg, output = "", i2, k, ph2, pad, pad_character, pad_length, is_positive, sign2;
      for (i2 = 0; i2 < tree_length; i2++) {
        if (typeof parse_tree[i2] === "string") {
          output += parse_tree[i2];
        } else if (typeof parse_tree[i2] === "object") {
          ph2 = parse_tree[i2];
          if (ph2.keys) {
            arg = argv[cursor];
            for (k = 0; k < ph2.keys.length; k++) {
              if (arg == void 0) {
                throw new Error(sprintf2('[sprintf] Cannot access property "%s" of undefined value "%s"', ph2.keys[k], ph2.keys[k - 1]));
              }
              arg = arg[ph2.keys[k]];
            }
          } else if (ph2.param_no) {
            arg = argv[ph2.param_no];
          } else {
            arg = argv[cursor++];
          }
          if (re2.not_type.test(ph2.type) && re2.not_primitive.test(ph2.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re2.numeric_arg.test(ph2.type) && (typeof arg !== "number" && isNaN(arg))) {
            throw new TypeError(sprintf2("[sprintf] expecting number but found %T", arg));
          }
          if (re2.number.test(ph2.type)) {
            is_positive = arg >= 0;
          }
          switch (ph2.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph2.width ? parseInt(ph2.width) : 0);
              break;
            case "e":
              arg = ph2.precision ? parseFloat(arg).toExponential(ph2.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph2.precision ? parseFloat(arg).toFixed(ph2.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph2.precision ? String(Number(arg.toPrecision(ph2.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph2.precision ? arg.substring(0, ph2.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re2.json.test(ph2.type)) {
            output += arg;
          } else {
            if (re2.number.test(ph2.type) && (!is_positive || ph2.sign)) {
              sign2 = is_positive ? "+" : "-";
              arg = arg.toString().replace(re2.sign, "");
            } else {
              sign2 = "";
            }
            pad_character = ph2.pad_char ? ph2.pad_char === "0" ? "0" : ph2.pad_char.charAt(1) : " ";
            pad_length = ph2.width - (sign2 + arg).length;
            pad = ph2.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
            output += ph2.align ? sign2 + arg + pad : pad_character === "0" ? sign2 + pad + arg : pad + sign2 + arg;
          }
        }
      }
      return output;
    }
    var sprintf_cache = /* @__PURE__ */ Object.create(null);
    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }
      var _fmt = fmt, match3, parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match3 = re2.text.exec(_fmt)) !== null) {
          parse_tree.push(match3[0]);
        } else if ((match3 = re2.modulo.exec(_fmt)) !== null) {
          parse_tree.push("%");
        } else if ((match3 = re2.placeholder.exec(_fmt)) !== null) {
          if (match3[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match3[2], field_match = [];
            if ((field_match = re2.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                if ((field_match = re2.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re2.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match3[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parse_tree.push(
            {
              placeholder: match3[0],
              param_no: match3[1],
              keys: match3[2],
              sign: match3[3],
              pad_char: match3[4],
              align: match3[5],
              width: match3[6],
              precision: match3[7],
              type: match3[8]
            }
          );
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        _fmt = _fmt.substring(match3[0].length);
      }
      return sprintf_cache[fmt] = parse_tree;
    }
    {
      exports$1["sprintf"] = sprintf2;
      exports$1["vsprintf"] = vsprintf;
    }
    if (typeof window !== "undefined") {
      window["sprintf"] = sprintf2;
      window["vsprintf"] = vsprintf;
    }
  }();
})(sprintf);
const balanced = (a, b, str) => {
  const ma2 = a instanceof RegExp ? maybeMatch(a, str) : a;
  const mb2 = b instanceof RegExp ? maybeMatch(b, str) : b;
  const r2 = ma2 !== null && mb2 != null && range(ma2, mb2, str);
  return r2 && {
    start: r2[0],
    end: r2[1],
    pre: str.slice(0, r2[0]),
    body: str.slice(r2[0] + ma2.length, r2[1]),
    post: str.slice(r2[1] + mb2.length)
  };
};
const maybeMatch = (reg, str) => {
  const m = str.match(reg);
  return m ? m[0] : null;
};
const range = (a, b, str) => {
  let begs, beg, left, right = void 0, result;
  let ai2 = str.indexOf(a);
  let bi2 = str.indexOf(b, ai2 + 1);
  let i2 = ai2;
  if (ai2 >= 0 && bi2 > 0) {
    if (a === b) {
      return [ai2, bi2];
    }
    begs = [];
    left = str.length;
    while (i2 >= 0 && !result) {
      if (i2 === ai2) {
        begs.push(i2);
        ai2 = str.indexOf(a, i2 + 1);
      } else if (begs.length === 1) {
        const r2 = begs.pop();
        if (r2 !== void 0)
          result = [r2, bi2];
      } else {
        beg = begs.pop();
        if (beg !== void 0 && beg < left) {
          left = beg;
          right = bi2;
        }
        bi2 = str.indexOf(b, i2 + 1);
      }
      i2 = ai2 < bi2 && ai2 >= 0 ? ai2 : bi2;
    }
    if (begs.length && right !== void 0) {
      result = [left, right];
    }
  }
  return result;
};
const escSlash = "\0SLASH" + Math.random() + "\0";
const escOpen = "\0OPEN" + Math.random() + "\0";
const escClose = "\0CLOSE" + Math.random() + "\0";
const escComma = "\0COMMA" + Math.random() + "\0";
const escPeriod = "\0PERIOD" + Math.random() + "\0";
const escSlashPattern = new RegExp(escSlash, "g");
const escOpenPattern = new RegExp(escOpen, "g");
const escClosePattern = new RegExp(escClose, "g");
const escCommaPattern = new RegExp(escComma, "g");
const escPeriodPattern = new RegExp(escPeriod, "g");
const slashPattern = /\\\\/g;
const openPattern = /\\{/g;
const closePattern = /\\}/g;
const commaPattern = /\\,/g;
const periodPattern = /\\./g;
function numeric(str) {
  return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
}
function unescapeBraces(str) {
  return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
}
function parseCommaParts(str) {
  if (!str) {
    return [""];
  }
  const parts = [];
  const m = balanced("{", "}", str);
  if (!m) {
    return str.split(",");
  }
  const { pre, body, post } = m;
  const p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  const postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expand(str) {
  if (!str) {
    return [];
  }
  if (str.slice(0, 2) === "{}") {
    str = "\\{\\}" + str.slice(2);
  }
  return expand_(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
  return "{" + str + "}";
}
function isPadded(el2) {
  return /^-?0\d/.test(el2);
}
function lte(i2, y) {
  return i2 <= y;
}
function gte(i2, y) {
  return i2 >= y;
}
function expand_(str, isTop) {
  const expansions = [];
  const m = balanced("{", "}", str);
  if (!m)
    return [str];
  const pre = m.pre;
  const post = m.post.length ? expand_(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (let k = 0; k < post.length; k++) {
      const expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    const isSequence = isNumericSequence || isAlphaSequence;
    const isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand_(str);
      }
      return [str];
    }
    let n2;
    if (isSequence) {
      n2 = m.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m.body);
      if (n2.length === 1 && n2[0] !== void 0) {
        n2 = expand_(n2[0], false).map(embrace);
        if (n2.length === 1) {
          return post.map((p) => m.pre + n2[0] + p);
        }
      }
    }
    let N2;
    if (isSequence && n2[0] !== void 0 && n2[1] !== void 0) {
      const x2 = numeric(n2[0]);
      const y = numeric(n2[1]);
      const width = Math.max(n2[0].length, n2[1].length);
      let incr = n2.length === 3 && n2[2] !== void 0 ? Math.abs(numeric(n2[2])) : 1;
      let test = lte;
      const reverse2 = y < x2;
      if (reverse2) {
        incr *= -1;
        test = gte;
      }
      const pad = n2.some(isPadded);
      N2 = [];
      for (let i2 = x2; test(i2, y); i2 += incr) {
        let c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i2);
          if (c === "\\") {
            c = "";
          }
        } else {
          c = String(i2);
          if (pad) {
            const need = width - c.length;
            if (need > 0) {
              const z2 = new Array(need + 1).join("0");
              if (i2 < 0) {
                c = "-" + z2 + c.slice(1);
              } else {
                c = z2 + c;
              }
            }
          }
        }
        N2.push(c);
      }
    } else {
      N2 = [];
      for (let j2 = 0; j2 < n2.length; j2++) {
        N2.push.apply(N2, expand_(n2[j2], false));
      }
    }
    for (let j2 = 0; j2 < N2.length; j2++) {
      for (let k = 0; k < post.length; k++) {
        const expansion = pre + N2[j2] + post[k];
        if (!isTop || isSequence || expansion) {
          expansions.push(expansion);
        }
      }
    }
  }
  return expansions;
}
const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
  if (typeof pattern !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};
const posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
  "[:alpha:]": ["\\p{L}\\p{Nl}", true],
  "[:ascii:]": ["\\x00-\\x7f", false],
  "[:blank:]": ["\\p{Zs}\\t", true],
  "[:cntrl:]": ["\\p{Cc}", true],
  "[:digit:]": ["\\p{Nd}", true],
  "[:graph:]": ["\\p{Z}\\p{C}", true, true],
  "[:lower:]": ["\\p{Ll}", true],
  "[:print:]": ["\\p{C}", true],
  "[:punct:]": ["\\p{P}", true],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
  "[:upper:]": ["\\p{Lu}", true],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
  "[:xdigit:]": ["A-Fa-f0-9", false]
};
const braceEscape = (s2) => s2.replace(/[[\]\\-]/g, "\\$&");
const regexpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
const rangesToString = (ranges) => ranges.join("");
const parseClass = (glob, position) => {
  const pos = position;
  if (glob.charAt(pos) !== "[") {
    throw new Error("not in a brace expression");
  }
  const ranges = [];
  const negs = [];
  let i2 = pos + 1;
  let sawStart = false;
  let uflag = false;
  let escaping = false;
  let negate = false;
  let endPos = pos;
  let rangeStart = "";
  WHILE: while (i2 < glob.length) {
    const c = glob.charAt(i2);
    if ((c === "!" || c === "^") && i2 === pos + 1) {
      negate = true;
      i2++;
      continue;
    }
    if (c === "]" && sawStart && !escaping) {
      endPos = i2 + 1;
      break;
    }
    sawStart = true;
    if (c === "\\") {
      if (!escaping) {
        escaping = true;
        i2++;
        continue;
      }
    }
    if (c === "[" && !escaping) {
      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
        if (glob.startsWith(cls, i2)) {
          if (rangeStart) {
            return ["$.", false, glob.length - pos, true];
          }
          i2 += cls.length;
          if (neg)
            negs.push(unip);
          else
            ranges.push(unip);
          uflag = uflag || u;
          continue WHILE;
        }
      }
    }
    escaping = false;
    if (rangeStart) {
      if (c > rangeStart) {
        ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
      } else if (c === rangeStart) {
        ranges.push(braceEscape(c));
      }
      rangeStart = "";
      i2++;
      continue;
    }
    if (glob.startsWith("-]", i2 + 1)) {
      ranges.push(braceEscape(c + "-"));
      i2 += 2;
      continue;
    }
    if (glob.startsWith("-", i2 + 1)) {
      rangeStart = c;
      i2 += 2;
      continue;
    }
    ranges.push(braceEscape(c));
    i2++;
  }
  if (endPos < i2) {
    return ["", false, 0, false];
  }
  if (!ranges.length && !negs.length) {
    return ["$.", false, glob.length - pos, true];
  }
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    const r2 = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r2), false, endPos - pos, false];
  }
  const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
  const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
  return [comb, uflag, endPos - pos, true];
};
const unescape = (s2, { windowsPathsNoEscape = false, magicalBraces = true } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s2.replace(/\[([^\/\\])\]/g, "$1") : s2.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  }
  return windowsPathsNoEscape ? s2.replace(/\[([^\/\\{}])\]/g, "$1") : s2.replace(/((?!\\).|^)\[([^\/\\{}])\]/g, "$1$2").replace(/\\([^\/{}])/g, "$1");
};
const types$2 = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
const isExtglobType = (c) => types$2.has(c);
const startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
const startNoDot = "(?!\\.)";
const addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
const justDots = /* @__PURE__ */ new Set(["..", "."]);
const reSpecials = new Set("().*{}+?[]^$\\!");
const regExpEscape$1 = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
const qmark$1 = "[^/]";
const star$1 = qmark$1 + "*?";
const starNoEmpty = qmark$1 + "+?";
const _AST = class _AST {
  constructor(type2, parent, options2 = {}) {
    __privateAdd(this, _AST_instances);
    __publicField(this, "type");
    __privateAdd(this, _root);
    __privateAdd(this, _hasMagic);
    __privateAdd(this, _uflag, false);
    __privateAdd(this, _parts, []);
    __privateAdd(this, _parent);
    __privateAdd(this, _parentIndex);
    __privateAdd(this, _negs);
    __privateAdd(this, _filledNegs, false);
    __privateAdd(this, _options2);
    __privateAdd(this, _toString);
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    __privateAdd(this, _emptyExt, false);
    this.type = type2;
    if (type2)
      __privateSet(this, _hasMagic, true);
    __privateSet(this, _parent, parent);
    __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
    __privateSet(this, _options2, __privateGet(this, _root) === this ? options2 : __privateGet(__privateGet(this, _root), _options2));
    __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
    if (type2 === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
      __privateGet(this, _negs).push(this);
    __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
  }
  get hasMagic() {
    if (__privateGet(this, _hasMagic) !== void 0)
      return __privateGet(this, _hasMagic);
    for (const p of __privateGet(this, _parts)) {
      if (typeof p === "string")
        continue;
      if (p.type || p.hasMagic)
        return __privateSet(this, _hasMagic, true);
    }
    return __privateGet(this, _hasMagic);
  }
  // reconstructs the pattern
  toString() {
    if (__privateGet(this, _toString) !== void 0)
      return __privateGet(this, _toString);
    if (!this.type) {
      return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
    } else {
      return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
    }
  }
  push(...parts) {
    for (const p of parts) {
      if (p === "")
        continue;
      if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
        throw new Error("invalid part: " + p);
      }
      __privateGet(this, _parts).push(p);
    }
  }
  toJSON() {
    var _a3;
    const ret = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
    if (this.isStart() && !this.type)
      ret.unshift([]);
    if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && ((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.type) === "!")) {
      ret.push({});
    }
    return ret;
  }
  isStart() {
    var _a3;
    if (__privateGet(this, _root) === this)
      return true;
    if (!((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.isStart()))
      return false;
    if (__privateGet(this, _parentIndex) === 0)
      return true;
    const p = __privateGet(this, _parent);
    for (let i2 = 0; i2 < __privateGet(this, _parentIndex); i2++) {
      const pp2 = __privateGet(p, _parts)[i2];
      if (!(pp2 instanceof _AST && pp2.type === "!")) {
        return false;
      }
    }
    return true;
  }
  isEnd() {
    var _a3, _b3, _c2;
    if (__privateGet(this, _root) === this)
      return true;
    if (((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.type) === "!")
      return true;
    if (!((_b3 = __privateGet(this, _parent)) == null ? void 0 : _b3.isEnd()))
      return false;
    if (!this.type)
      return (_c2 = __privateGet(this, _parent)) == null ? void 0 : _c2.isEnd();
    const pl2 = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
    return __privateGet(this, _parentIndex) === pl2 - 1;
  }
  copyIn(part) {
    if (typeof part === "string")
      this.push(part);
    else
      this.push(part.clone(this));
  }
  clone(parent) {
    const c = new _AST(this.type, parent);
    for (const p of __privateGet(this, _parts)) {
      c.copyIn(p);
    }
    return c;
  }
  static fromGlob(pattern, options2 = {}) {
    var _a3;
    const ast = new _AST(null, void 0, options2);
    __privateMethod(_a3 = _AST, _AST_static, parseAST_fn).call(_a3, pattern, ast, 0, options2);
    return ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== __privateGet(this, _root))
      return __privateGet(this, _root).toMMPattern();
    const glob = this.toString();
    const [re2, body, hasMagic, uflag] = this.toRegExpSource();
    const anyMagic = hasMagic || __privateGet(this, _hasMagic) || __privateGet(this, _options2).nocase && !__privateGet(this, _options2).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
    if (!anyMagic) {
      return body;
    }
    const flags = (__privateGet(this, _options2).nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re2}$`, flags), {
      _src: re2,
      _glob: glob
    });
  }
  get options() {
    return __privateGet(this, _options2);
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    var _a3;
    const dot = allowDot ?? !!__privateGet(this, _options2).dot;
    if (__privateGet(this, _root) === this)
      __privateMethod(this, _AST_instances, fillNegs_fn).call(this);
    if (!this.type) {
      const noEmpty = this.isStart() && this.isEnd() && !__privateGet(this, _parts).some((s2) => typeof s2 !== "string");
      const src = __privateGet(this, _parts).map((p) => {
        var _a4;
        const [re2, _2, hasMagic, uflag] = typeof p === "string" ? __privateMethod(_a4 = _AST, _AST_static, parseGlob_fn).call(_a4, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
        __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic);
        __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
        return re2;
      }).join("");
      let start2 = "";
      if (this.isStart()) {
        if (typeof __privateGet(this, _parts)[0] === "string") {
          const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
          if (!dotTravAllowed) {
            const aps = addPatternStart;
            const needNoTrav = (
              // dots are allowed, and the pattern starts with [ or .
              dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
              src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
              src.startsWith("\\.\\.") && aps.has(src.charAt(4))
            );
            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
            start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
          }
        }
      }
      let end = "";
      if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && ((_a3 = __privateGet(this, _parent)) == null ? void 0 : _a3.type) === "!") {
        end = "(?:$|\\/)";
      }
      const final2 = start2 + src + end;
      return [
        final2,
        unescape(src),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
    const repeated = this.type === "*" || this.type === "+";
    const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
    let body = __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      const s2 = this.toString();
      __privateSet(this, _parts, [s2]);
      this.type = null;
      __privateSet(this, _hasMagic, void 0);
      return [s2, unescape(this.toString()), false, false];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _AST_instances, partsToRegExp_fn).call(this, true);
    if (bodyDotAllowed === body) {
      bodyDotAllowed = "";
    }
    if (bodyDotAllowed) {
      body = `(?:${body})(?:${bodyDotAllowed})*?`;
    }
    let final = "";
    if (this.type === "!" && __privateGet(this, _emptyExt)) {
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    } else {
      const close2 = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star$1 + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
      final = start + body + close2;
    }
    return [
      final,
      unescape(body),
      __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
      __privateGet(this, _uflag)
    ];
  }
};
_root = new WeakMap();
_hasMagic = new WeakMap();
_uflag = new WeakMap();
_parts = new WeakMap();
_parent = new WeakMap();
_parentIndex = new WeakMap();
_negs = new WeakMap();
_filledNegs = new WeakMap();
_options2 = new WeakMap();
_toString = new WeakMap();
_emptyExt = new WeakMap();
_AST_instances = new WeakSet();
fillNegs_fn = function() {
  if (this !== __privateGet(this, _root))
    throw new Error("should only call on root");
  if (__privateGet(this, _filledNegs))
    return this;
  this.toString();
  __privateSet(this, _filledNegs, true);
  let n2;
  while (n2 = __privateGet(this, _negs).pop()) {
    if (n2.type !== "!")
      continue;
    let p = n2;
    let pp2 = __privateGet(p, _parent);
    while (pp2) {
      for (let i2 = __privateGet(p, _parentIndex) + 1; !pp2.type && i2 < __privateGet(pp2, _parts).length; i2++) {
        for (const part of __privateGet(n2, _parts)) {
          if (typeof part === "string") {
            throw new Error("string part in extglob AST??");
          }
          part.copyIn(__privateGet(pp2, _parts)[i2]);
        }
      }
      p = pp2;
      pp2 = __privateGet(p, _parent);
    }
  }
  return this;
};
_AST_static = new WeakSet();
parseAST_fn = function(str, ast, pos, opt) {
  var _a3, _b3;
  let escaping = false;
  let inBrace = false;
  let braceStart = -1;
  let braceNeg = false;
  if (ast.type === null) {
    let i3 = pos;
    let acc2 = "";
    while (i3 < str.length) {
      const c = str.charAt(i3++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc2 += c;
        continue;
      }
      if (inBrace) {
        if (i3 === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i3 === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc2 += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i3;
        braceNeg = false;
        acc2 += c;
        continue;
      }
      if (!opt.noext && isExtglobType(c) && str.charAt(i3) === "(") {
        ast.push(acc2);
        acc2 = "";
        const ext2 = new _AST(c, ast);
        i3 = __privateMethod(_a3 = _AST, _AST_static, parseAST_fn).call(_a3, str, ext2, i3, opt);
        ast.push(ext2);
        continue;
      }
      acc2 += c;
    }
    ast.push(acc2);
    return i3;
  }
  let i2 = pos + 1;
  let part = new _AST(null, ast);
  const parts = [];
  let acc = "";
  while (i2 < str.length) {
    const c = str.charAt(i2++);
    if (escaping || c === "\\") {
      escaping = !escaping;
      acc += c;
      continue;
    }
    if (inBrace) {
      if (i2 === braceStart + 1) {
        if (c === "^" || c === "!") {
          braceNeg = true;
        }
      } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
        inBrace = false;
      }
      acc += c;
      continue;
    } else if (c === "[") {
      inBrace = true;
      braceStart = i2;
      braceNeg = false;
      acc += c;
      continue;
    }
    if (isExtglobType(c) && str.charAt(i2) === "(") {
      part.push(acc);
      acc = "";
      const ext2 = new _AST(c, part);
      part.push(ext2);
      i2 = __privateMethod(_b3 = _AST, _AST_static, parseAST_fn).call(_b3, str, ext2, i2, opt);
      continue;
    }
    if (c === "|") {
      part.push(acc);
      acc = "";
      parts.push(part);
      part = new _AST(null, ast);
      continue;
    }
    if (c === ")") {
      if (acc === "" && __privateGet(ast, _parts).length === 0) {
        __privateSet(ast, _emptyExt, true);
      }
      part.push(acc);
      acc = "";
      ast.push(...parts, part);
      return i2;
    }
    acc += c;
  }
  ast.type = null;
  __privateSet(ast, _hasMagic, void 0);
  __privateSet(ast, _parts, [str.substring(pos - 1)]);
  return i2;
};
partsToRegExp_fn = function(dot) {
  return __privateGet(this, _parts).map((p) => {
    if (typeof p === "string") {
      throw new Error("string type in extglob ast??");
    }
    const [re2, _2, _hasMagic2, uflag] = p.toRegExpSource(dot);
    __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
    return re2;
  }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
};
parseGlob_fn = function(glob, hasMagic, noEmpty = false) {
  let escaping = false;
  let re2 = "";
  let uflag = false;
  for (let i2 = 0; i2 < glob.length; i2++) {
    const c = glob.charAt(i2);
    if (escaping) {
      escaping = false;
      re2 += (reSpecials.has(c) ? "\\" : "") + c;
      continue;
    }
    if (c === "\\") {
      if (i2 === glob.length - 1) {
        re2 += "\\\\";
      } else {
        escaping = true;
      }
      continue;
    }
    if (c === "[") {
      const [src, needUflag, consumed, magic] = parseClass(glob, i2);
      if (consumed) {
        re2 += src;
        uflag = uflag || needUflag;
        i2 += consumed - 1;
        hasMagic = hasMagic || magic;
        continue;
      }
    }
    if (c === "*") {
      re2 += noEmpty && glob === "*" ? starNoEmpty : star$1;
      hasMagic = true;
      continue;
    }
    if (c === "?") {
      re2 += qmark$1;
      hasMagic = true;
      continue;
    }
    re2 += regExpEscape$1(c);
  }
  return [re2, unescape(glob), !!hasMagic, uflag];
};
__privateAdd(_AST, _AST_static);
let AST = _AST;
const escape = (s2, { windowsPathsNoEscape = false, magicalBraces = false } = {}) => {
  if (magicalBraces) {
    return windowsPathsNoEscape ? s2.replace(/[?*()[\]{}]/g, "[$&]") : s2.replace(/[?*()[\]\\{}]/g, "\\$&");
  }
  return windowsPathsNoEscape ? s2.replace(/[?*()[\]]/g, "[$&]") : s2.replace(/[?*()[\]\\]/g, "\\$&");
};
var define_process_env_default$1 = {};
const minimatch = (p, pattern, options2 = {}) => {
  assertValidPattern(pattern);
  if (!options2.nocomment && pattern.charAt(0) === "#") {
    return false;
  }
  return new Minimatch(pattern, options2).match(p);
};
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext2) => (f2) => !f2.startsWith(".") && f2.endsWith(ext2);
const starDotExtTestDot = (ext2) => (f2) => f2.endsWith(ext2);
const starDotExtTestNocase = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f2) => !f2.startsWith(".") && f2.toLowerCase().endsWith(ext2);
};
const starDotExtTestNocaseDot = (ext2) => {
  ext2 = ext2.toLowerCase();
  return (f2) => f2.toLowerCase().endsWith(ext2);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f2) => !f2.startsWith(".") && f2.includes(".");
const starDotStarTestDot = (f2) => f2 !== "." && f2 !== ".." && f2.includes(".");
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f2) => f2 !== "." && f2 !== ".." && f2.startsWith(".");
const starRE = /^\*+$/;
const starTest = (f2) => f2.length !== 0 && !f2.startsWith(".");
const starTestDot = (f2) => f2.length !== 0 && f2 !== "." && f2 !== "..";
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$02, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$02]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
const qmarksTestNocaseDot = ([$02, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$02]);
  if (!ext2)
    return noext;
  ext2 = ext2.toLowerCase();
  return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
};
const qmarksTestDot = ([$02, ext2 = ""]) => {
  const noext = qmarksTestNoExtDot([$02]);
  return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
const qmarksTest = ([$02, ext2 = ""]) => {
  const noext = qmarksTestNoExt([$02]);
  return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
};
const qmarksTestNoExt = ([$02]) => {
  const len = $02.length;
  return (f2) => f2.length === len && !f2.startsWith(".");
};
const qmarksTestNoExtDot = ([$02]) => {
  const len = $02.length;
  return (f2) => f2.length === len && f2 !== "." && f2 !== "..";
};
const defaultPlatform = typeof process === "object" && process ? typeof define_process_env_default$1 === "object" && define_process_env_default$1 && define_process_env_default$1.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
const path = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
};
const sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
const GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
const qmark = "[^/]";
const star = qmark + "*?";
const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
const filter = (pattern, options2 = {}) => (p) => minimatch(p, pattern, options2);
minimatch.filter = filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch;
  }
  const orig = minimatch;
  const m = (p, pattern, options2 = {}) => orig(p, pattern, ext(def, options2));
  return Object.assign(m, {
    Minimatch: class Minimatch extends orig.Minimatch {
      constructor(pattern, options2 = {}) {
        super(pattern, ext(def, options2));
      }
      static defaults(options2) {
        return orig.defaults(ext(def, options2)).Minimatch;
      }
    },
    AST: class AST extends orig.AST {
      /* c8 ignore start */
      constructor(type2, parent, options2 = {}) {
        super(type2, parent, ext(def, options2));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options2 = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options2));
      }
    },
    unescape: (s2, options2 = {}) => orig.unescape(s2, ext(def, options2)),
    escape: (s2, options2 = {}) => orig.escape(s2, ext(def, options2)),
    filter: (pattern, options2 = {}) => orig.filter(pattern, ext(def, options2)),
    defaults: (options2) => orig.defaults(ext(def, options2)),
    makeRe: (pattern, options2 = {}) => orig.makeRe(pattern, ext(def, options2)),
    braceExpand: (pattern, options2 = {}) => orig.braceExpand(pattern, ext(def, options2)),
    match: (list2, pattern, options2 = {}) => orig.match(list2, pattern, ext(def, options2)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
const braceExpand = (pattern, options2 = {}) => {
  assertValidPattern(pattern);
  if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    return [pattern];
  }
  return expand(pattern);
};
minimatch.braceExpand = braceExpand;
const makeRe = (pattern, options2 = {}) => new Minimatch(pattern, options2).makeRe();
minimatch.makeRe = makeRe;
const match = (list2, pattern, options2 = {}) => {
  const mm2 = new Minimatch(pattern, options2);
  list2 = list2.filter((f2) => mm2.match(f2));
  if (mm2.options.nonull && !list2.length) {
    list2.push(pattern);
  }
  return list2;
};
minimatch.match = match;
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
class Minimatch {
  constructor(pattern, options2 = {}) {
    __publicField(this, "options");
    __publicField(this, "set");
    __publicField(this, "pattern");
    __publicField(this, "windowsPathsNoEscape");
    __publicField(this, "nonegate");
    __publicField(this, "negate");
    __publicField(this, "comment");
    __publicField(this, "empty");
    __publicField(this, "preserveMultipleSlashes");
    __publicField(this, "partial");
    __publicField(this, "globSet");
    __publicField(this, "globParts");
    __publicField(this, "nocase");
    __publicField(this, "isWindows");
    __publicField(this, "platform");
    __publicField(this, "windowsNoMagicRoot");
    __publicField(this, "regexp");
    assertValidPattern(pattern);
    options2 = options2 || {};
    this.options = options2;
    this.pattern = pattern;
    this.platform = options2.platform || defaultPlatform;
    this.isWindows = this.platform === "win32";
    this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.preserveMultipleSlashes = !!options2.preserveMultipleSlashes;
    this.regexp = null;
    this.negate = false;
    this.nonegate = !!options2.nonegate;
    this.comment = false;
    this.empty = false;
    this.partial = !!options2.partial;
    this.nocase = !!this.options.nocase;
    this.windowsNoMagicRoot = options2.windowsNoMagicRoot !== void 0 ? options2.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
    this.globSet = [];
    this.globParts = [];
    this.set = [];
    this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1) {
      return true;
    }
    for (const pattern of this.set) {
      for (const part of pattern) {
        if (typeof part !== "string")
          return true;
      }
    }
    return false;
  }
  debug(..._2) {
  }
  make() {
    const pattern = this.pattern;
    const options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    this.globSet = [...new Set(this.braceExpand())];
    if (options2.debug) {
      this.debug = (...args) => console.error(...args);
    }
    this.debug(this.pattern, this.globSet);
    const rawGlobParts = this.globSet.map((s2) => this.slashSplit(s2));
    this.globParts = this.preprocess(rawGlobParts);
    this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s2, _2, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        const isUNC = s2[0] === "" && s2[1] === "" && (s2[2] === "?" || !globMagic.test(s2[2])) && !globMagic.test(s2[3]);
        const isDrive = /^[a-z]:/i.test(s2[0]);
        if (isUNC) {
          return [...s2.slice(0, 4), ...s2.slice(4).map((ss2) => this.parse(ss2))];
        } else if (isDrive) {
          return [s2[0], ...s2.slice(1).map((ss2) => this.parse(ss2))];
        }
      }
      return s2.map((ss2) => this.parse(ss2));
    });
    this.debug(this.pattern, set);
    this.set = set.filter((s2) => s2.indexOf(false) === -1);
    if (this.isWindows) {
      for (let i2 = 0; i2 < this.set.length; i2++) {
        const p = this.set[i2];
        if (p[0] === "" && p[1] === "" && this.globParts[i2][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
          p[2] = "?";
        }
      }
    }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar) {
      for (let i2 = 0; i2 < globParts.length; i2++) {
        for (let j2 = 0; j2 < globParts[i2].length; j2++) {
          if (globParts[i2][j2] === "**") {
            globParts[i2][j2] = "*";
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      globParts = this.firstPhasePreProcess(globParts);
      globParts = this.secondPhasePreProcess(globParts);
    } else if (optimizationLevel >= 1) {
      globParts = this.levelOneOptimize(globParts);
    } else {
      globParts = this.adjascentGlobstarOptimize(globParts);
    }
    return globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs2 = -1;
      while (-1 !== (gs2 = parts.indexOf("**", gs2 + 1))) {
        let i2 = gs2;
        while (parts[i2 + 1] === "**") {
          i2++;
        }
        if (i2 !== gs2) {
          parts.splice(gs2, i2 - gs2);
        }
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => {
      parts = parts.reduce((set, part) => {
        const prev = set[set.length - 1];
        if (part === "**" && prev === "**") {
          return set;
        }
        if (part === "..") {
          if (prev && prev !== ".." && prev !== "." && prev !== "**") {
            set.pop();
            return set;
          }
        }
        set.push(part);
        return set;
      }, []);
      return parts.length === 0 ? [""] : parts;
    });
  }
  levelTwoFileOptimize(parts) {
    if (!Array.isArray(parts)) {
      parts = this.slashSplit(parts);
    }
    let didSomething = false;
    do {
      didSomething = false;
      if (!this.preserveMultipleSlashes) {
        for (let i2 = 1; i2 < parts.length - 1; i2++) {
          const p = parts[i2];
          if (i2 === 1 && p === "" && parts[0] === "")
            continue;
          if (p === "." || p === "") {
            didSomething = true;
            parts.splice(i2, 1);
            i2--;
          }
        }
        if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
          didSomething = true;
          parts.pop();
        }
      }
      let dd2 = 0;
      while (-1 !== (dd2 = parts.indexOf("..", dd2 + 1))) {
        const p = parts[dd2 - 1];
        if (p && p !== "." && p !== ".." && p !== "**") {
          didSomething = true;
          parts.splice(dd2 - 1, 2);
          dd2 -= 2;
        }
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = false;
    do {
      didSomething = false;
      for (let parts of globParts) {
        let gs2 = -1;
        while (-1 !== (gs2 = parts.indexOf("**", gs2 + 1))) {
          let gss = gs2;
          while (parts[gss + 1] === "**") {
            gss++;
          }
          if (gss > gs2) {
            parts.splice(gs2 + 1, gss - gs2);
          }
          let next2 = parts[gs2 + 1];
          const p = parts[gs2 + 2];
          const p2 = parts[gs2 + 3];
          if (next2 !== "..")
            continue;
          if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
            continue;
          }
          didSomething = true;
          parts.splice(gs2, 1);
          const other = parts.slice(0);
          other[gs2] = "**";
          globParts.push(other);
          gs2--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i2 = 1; i2 < parts.length - 1; i2++) {
            const p = parts[i2];
            if (i2 === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i2, 1);
              i2--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd2 = 0;
        while (-1 !== (dd2 = parts.indexOf("..", dd2 + 1))) {
          const p = parts[dd2 - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            const needDot = dd2 === 1 && parts[dd2 + 1] === "**";
            const splin = needDot ? ["."] : [];
            parts.splice(dd2 - 1, 2, ...splin);
            if (parts.length === 0)
              parts.push("");
            dd2 -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i2 = 0; i2 < globParts.length - 1; i2++) {
      for (let j2 = i2 + 1; j2 < globParts.length; j2++) {
        const matched = this.partsMatch(globParts[i2], globParts[j2], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i2] = [];
          globParts[j2] = matched;
          break;
        }
      }
    }
    return globParts.filter((gs2) => gs2.length);
  }
  partsMatch(a, b, emptyGSMatch = false) {
    let ai2 = 0;
    let bi2 = 0;
    let result = [];
    let which = "";
    while (ai2 < a.length && bi2 < b.length) {
      if (a[ai2] === b[bi2]) {
        result.push(which === "b" ? b[bi2] : a[ai2]);
        ai2++;
        bi2++;
      } else if (emptyGSMatch && a[ai2] === "**" && b[bi2] === a[ai2 + 1]) {
        result.push(a[ai2]);
        ai2++;
      } else if (emptyGSMatch && b[bi2] === "**" && a[ai2] === b[bi2 + 1]) {
        result.push(b[bi2]);
        bi2++;
      } else if (a[ai2] === "*" && b[bi2] && (this.options.dot || !b[bi2].startsWith(".")) && b[bi2] !== "**") {
        if (which === "b")
          return false;
        which = "a";
        result.push(a[ai2]);
        ai2++;
        bi2++;
      } else if (b[bi2] === "*" && a[ai2] && (this.options.dot || !a[ai2].startsWith(".")) && a[ai2] !== "**") {
        if (which === "a")
          return false;
        which = "b";
        result.push(b[bi2]);
        ai2++;
        bi2++;
      } else {
        return false;
      }
    }
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    const pattern = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.slice(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = false) {
    const options2 = this.options;
    if (this.isWindows) {
      const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
      const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
      const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
      const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
      const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
      const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi === "number" && typeof pdi === "number") {
        const [fd2, pd2] = [file[fdi], pattern[pdi]];
        if (fd2.toLowerCase() === pd2.toLowerCase()) {
          pattern[pdi] = fd2;
          if (pdi > fdi) {
            pattern = pattern.slice(pdi);
          } else if (fdi > pdi) {
            file = file.slice(fdi);
          }
        }
      }
    }
    const { optimizationLevel = 1 } = this.options;
    if (optimizationLevel >= 2) {
      file = this.levelTwoFileOptimize(file);
    }
    this.debug("matchOne", this, { file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi2 = 0, pi2 = 0, fl2 = file.length, pl2 = pattern.length; fi2 < fl2 && pi2 < pl2; fi2++, pi2++) {
      this.debug("matchOne loop");
      var p = pattern[pi2];
      var f2 = file[fi2];
      this.debug(pattern, p, f2);
      if (p === false) {
        return false;
      }
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f2]);
        var fr2 = fi2;
        var pr2 = pi2 + 1;
        if (pr2 === pl2) {
          this.debug("** at the end");
          for (; fi2 < fl2; fi2++) {
            if (file[fi2] === "." || file[fi2] === ".." || !options2.dot && file[fi2].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr2 < fl2) {
          var swallowee = file[fr2];
          this.debug("\nglobstar while", file, fr2, pattern, pr2, swallowee);
          if (this.matchOne(file.slice(fr2), pattern.slice(pr2), partial)) {
            this.debug("globstar found match!", fr2, fl2, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr2, pattern, pr2);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr2++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr2, pattern, pr2);
          if (fr2 === fl2) {
            return true;
          }
        }
        return false;
      }
      let hit;
      if (typeof p === "string") {
        hit = f2 === p;
        this.debug("string match", p, f2, hit);
      } else {
        hit = p.test(f2);
        this.debug("pattern match", p, f2, hit);
      }
      if (!hit)
        return false;
    }
    if (fi2 === fl2 && pi2 === pl2) {
      return true;
    } else if (fi2 === fl2) {
      return partial;
    } else if (pi2 === pl2) {
      return fi2 === fl2 - 1 && file[fi2] === "";
    } else {
      throw new Error("wtf?");
    }
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    const options2 = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m;
    let fastTest = null;
    if (m = pattern.match(starRE)) {
      fastTest = options2.dot ? starTestDot : starTest;
    } else if (m = pattern.match(starDotExtRE)) {
      fastTest = (options2.nocase ? options2.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options2.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
    } else if (m = pattern.match(qmarksRE)) {
      fastTest = (options2.nocase ? options2.dot ? qmarksTestNocaseDot : qmarksTestNocase : options2.dot ? qmarksTestDot : qmarksTest)(m);
    } else if (m = pattern.match(starDotStarRE)) {
      fastTest = options2.dot ? starDotStarTestDot : starDotStarTest;
    } else if (m = pattern.match(dotStarRE)) {
      fastTest = dotStarTest;
    }
    const re2 = AST.fromGlob(pattern, this.options).toMMPattern();
    if (fastTest && typeof re2 === "object") {
      Reflect.defineProperty(re2, "test", { value: fastTest });
    }
    return re2;
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options2 = this.options;
    const twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
    const flags = new Set(options2.nocase ? ["i"] : []);
    let re2 = set.map((pattern) => {
      const pp2 = pattern.map((p) => {
        if (p instanceof RegExp) {
          for (const f2 of p.flags.split(""))
            flags.add(f2);
        }
        return typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      pp2.forEach((p, i2) => {
        const next2 = pp2[i2 + 1];
        const prev = pp2[i2 - 1];
        if (p !== GLOBSTAR || prev === GLOBSTAR) {
          return;
        }
        if (prev === void 0) {
          if (next2 !== void 0 && next2 !== GLOBSTAR) {
            pp2[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + next2;
          } else {
            pp2[i2] = twoStar;
          }
        } else if (next2 === void 0) {
          pp2[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + ")?";
        } else if (next2 !== GLOBSTAR) {
          pp2[i2 - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next2;
          pp2[i2 + 1] = GLOBSTAR;
        }
      });
      const filtered = pp2.filter((p) => p !== GLOBSTAR);
      if (this.partial && filtered.length >= 1) {
        const prefixes = [];
        for (let i2 = 1; i2 <= filtered.length; i2++) {
          prefixes.push(filtered.slice(0, i2).join("/"));
        }
        return "(?:" + prefixes.join("|") + ")";
      }
      return filtered.join("/");
    }).join("|");
    const [open2, close2] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re2 = "^" + open2 + re2 + close2 + "$";
    if (this.partial) {
      re2 = "^(?:\\/|" + open2 + re2.slice(1, -1) + close2 + ")$";
    }
    if (this.negate)
      re2 = "^(?!" + re2 + ").+$";
    try {
      this.regexp = new RegExp(re2, [...flags].join(""));
    } catch (ex2) {
      this.regexp = false;
    }
    return this.regexp;
  }
  slashSplit(p) {
    if (this.preserveMultipleSlashes) {
      return p.split("/");
    } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
      return ["", ...p.split(/\/+/)];
    } else {
      return p.split(/\/+/);
    }
  }
  match(f2, partial = this.partial) {
    this.debug("match", f2, this.pattern);
    if (this.comment) {
      return false;
    }
    if (this.empty) {
      return f2 === "";
    }
    if (f2 === "/" && partial) {
      return true;
    }
    const options2 = this.options;
    if (this.isWindows) {
      f2 = f2.split("\\").join("/");
    }
    const ff2 = this.slashSplit(f2);
    this.debug(this.pattern, "split", ff2);
    const set = this.set;
    this.debug(this.pattern, "set", set);
    let filename2 = ff2[ff2.length - 1];
    if (!filename2) {
      for (let i2 = ff2.length - 2; !filename2 && i2 >= 0; i2--) {
        filename2 = ff2[i2];
      }
    }
    for (let i2 = 0; i2 < set.length; i2++) {
      const pattern = set[i2];
      let file = ff2;
      if (options2.matchBase && pattern.length === 1) {
        file = [filename2];
      }
      const hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options2.flipNegate) {
          return true;
        }
        return !this.negate;
      }
    }
    if (options2.flipNegate) {
      return false;
    }
    return this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
}
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;
class Diff {
  diff(oldStr, newStr, options2 = {}) {
    let callback;
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    } else if ("callback" in options2) {
      callback = options2.callback;
    }
    const oldString = this.castInput(oldStr, options2);
    const newString = this.castInput(newStr, options2);
    const oldTokens = this.removeEmpty(this.tokenize(oldString, options2));
    const newTokens = this.removeEmpty(this.tokenize(newString, options2));
    return this.diffWithOptionsObj(oldTokens, newTokens, options2, callback);
  }
  diffWithOptionsObj(oldTokens, newTokens, options2, callback) {
    var _a3;
    const done = (value2) => {
      value2 = this.postProcess(value2, options2);
      if (callback) {
        setTimeout(function() {
          callback(value2);
        }, 0);
        return void 0;
      } else {
        return value2;
      }
    };
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let editLength = 1;
    let maxEditLength = newLen + oldLen;
    if (options2.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options2.maxEditLength);
    }
    const maxExecutionTime = (_a3 = options2.timeout) !== null && _a3 !== void 0 ? _a3 : Infinity;
    const abortAfterTimestamp = Date.now() + maxExecutionTime;
    const bestPath = [{ oldPos: -1, lastComponent: void 0 }];
    let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options2);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));
    }
    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    const execEditLength = () => {
      for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        let basePath;
        const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        let canAdd = false;
        if (addPath) {
          const addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        const canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = this.addToPath(addPath, true, false, 0, options2);
        } else {
          basePath = this.addToPath(removePath, false, true, 1, options2);
        }
        newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options2);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    };
    if (callback) {
      (function exec2() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback(void 0);
          }
          if (!execEditLength()) {
            exec2();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        const ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }
  addToPath(path2, added, removed, oldPosInc, options2) {
    const last = path2.lastComponent;
    if (last && !options2.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path2.oldPos + oldPosInc,
        lastComponent: { count: last.count + 1, added, removed, previousComponent: last.previousComponent }
      };
    } else {
      return {
        oldPos: path2.oldPos + oldPosInc,
        lastComponent: { count: 1, added, removed, previousComponent: last }
      };
    }
  }
  extractCommon(basePath, newTokens, oldTokens, diagonalPath, options2) {
    const newLen = newTokens.length, oldLen = oldTokens.length;
    let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options2)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options2.oneChangePerToken) {
        basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };
      }
    }
    if (commonCount && !options2.oneChangePerToken) {
      basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }
  equals(left, right, options2) {
    if (options2.comparator) {
      return options2.comparator(left, right);
    } else {
      return left === right || !!options2.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }
  removeEmpty(array) {
    const ret = [];
    for (let i2 = 0; i2 < array.length; i2++) {
      if (array[i2]) {
        ret.push(array[i2]);
      }
    }
    return ret;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  castInput(value2, options2) {
    return value2;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  tokenize(value2, options2) {
    return Array.from(value2);
  }
  join(chars) {
    return chars.join("");
  }
  postProcess(changeObjects, options2) {
    return changeObjects;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(lastComponent, newTokens, oldTokens) {
    const components = [];
    let nextComponent;
    while (lastComponent) {
      components.push(lastComponent);
      nextComponent = lastComponent.previousComponent;
      delete lastComponent.previousComponent;
      lastComponent = nextComponent;
    }
    components.reverse();
    const componentLen = components.length;
    let componentPos = 0, newPos = 0, oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      const component = components[componentPos];
      if (!component.removed) {
        if (!component.added && this.useLongestToken) {
          let value2 = newTokens.slice(newPos, newPos + component.count);
          value2 = value2.map(function(value3, i2) {
            const oldValue = oldTokens[oldPos + i2];
            return oldValue.length > value3.length ? oldValue : value3;
          });
          component.value = this.join(value2);
        } else {
          component.value = this.join(newTokens.slice(newPos, newPos + component.count));
        }
        newPos += component.count;
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));
        oldPos += component.count;
      }
    }
    return components;
  }
}
class LineDiff extends Diff {
  constructor() {
    super(...arguments);
    this.tokenize = tokenize$2;
  }
  equals(left, right, options2) {
    if (options2.ignoreWhitespace) {
      if (!options2.newlineIsToken || !left.includes("\n")) {
        left = left.trim();
      }
      if (!options2.newlineIsToken || !right.includes("\n")) {
        right = right.trim();
      }
    } else if (options2.ignoreNewlineAtEof && !options2.newlineIsToken) {
      if (left.endsWith("\n")) {
        left = left.slice(0, -1);
      }
      if (right.endsWith("\n")) {
        right = right.slice(0, -1);
      }
    }
    return super.equals(left, right, options2);
  }
}
const lineDiff = new LineDiff();
function diffLines(oldStr, newStr, options2) {
  return lineDiff.diff(oldStr, newStr, options2);
}
function tokenize$2(value2, options2) {
  if (options2.stripTrailingCr) {
    value2 = value2.replace(/\r\n/g, "\n");
  }
  const retLines = [], linesAndNewlines = value2.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (let i2 = 0; i2 < linesAndNewlines.length; i2++) {
    const line = linesAndNewlines[i2];
    if (i2 % 2 && !options2.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
}
const INCLUDE_HEADERS = {
  includeIndex: true,
  includeUnderline: true,
  includeFileHeaders: true
};
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2) {
  let optionsObj;
  if (!options2) {
    optionsObj = {};
  } else if (typeof options2 === "function") {
    optionsObj = { callback: options2 };
  } else {
    optionsObj = options2;
  }
  if (typeof optionsObj.context === "undefined") {
    optionsObj.context = 4;
  }
  const context2 = optionsObj.context;
  if (optionsObj.newlineIsToken) {
    throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  }
  if (!optionsObj.callback) {
    return diffLinesResultToPatch(diffLines(oldStr, newStr, optionsObj));
  } else {
    const { callback } = optionsObj;
    diffLines(oldStr, newStr, Object.assign(Object.assign({}, optionsObj), { callback: (diff) => {
      const patch = diffLinesResultToPatch(diff);
      callback(patch);
    } }));
  }
  function diffLinesResultToPatch(diff) {
    if (!diff) {
      return;
    }
    diff.push({ value: "", lines: [] });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    const hunks = [];
    let oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    for (let i2 = 0; i2 < diff.length; i2++) {
      const current2 = diff[i2], lines = current2.lines || splitLines(current2.value);
      current2.lines = lines;
      if (current2.added || current2.removed) {
        if (!oldRangeStart) {
          const prev = diff[i2 - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;
          if (prev) {
            curRange = context2 > 0 ? contextLines(prev.lines.slice(-context2)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }
        for (const line of lines) {
          curRange.push((current2.added ? "+" : "-") + line);
        }
        if (current2.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        if (oldRangeStart) {
          if (lines.length <= context2 * 2 && i2 < diff.length - 2) {
            for (const line of contextLines(lines)) {
              curRange.push(line);
            }
          } else {
            const contextSize = Math.min(lines.length, context2);
            for (const line of contextLines(lines.slice(0, contextSize))) {
              curRange.push(line);
            }
            const hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    }
    for (const hunk of hunks) {
      for (let i2 = 0; i2 < hunk.lines.length; i2++) {
        if (hunk.lines[i2].endsWith("\n")) {
          hunk.lines[i2] = hunk.lines[i2].slice(0, -1);
        } else {
          hunk.lines.splice(i2 + 1, 0, "\\ No newline at end of file");
          i2++;
        }
      }
    }
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
}
function formatPatch(patch, headerOptions) {
  if (!headerOptions) {
    headerOptions = INCLUDE_HEADERS;
  }
  if (Array.isArray(patch)) {
    if (patch.length > 1 && !headerOptions.includeFileHeaders) {
      throw new Error("Cannot omit file headers on a multi-file patch. (The result would be unparseable; how would a tool trying to apply the patch know which changes are to which file?)");
    }
    return patch.map((p) => formatPatch(p, headerOptions)).join("\n");
  }
  const ret = [];
  if (headerOptions.includeIndex && patch.oldFileName == patch.newFileName) {
    ret.push("Index: " + patch.oldFileName);
  }
  if (headerOptions.includeUnderline) {
    ret.push("===================================================================");
  }
  if (headerOptions.includeFileHeaders) {
    ret.push("--- " + patch.oldFileName + (typeof patch.oldHeader === "undefined" ? "" : "	" + patch.oldHeader));
    ret.push("+++ " + patch.newFileName + (typeof patch.newHeader === "undefined" ? "" : "	" + patch.newHeader));
  }
  for (let i2 = 0; i2 < patch.hunks.length; i2++) {
    const hunk = patch.hunks[i2];
    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }
    ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    for (const line of hunk.lines) {
      ret.push(line);
    }
  }
  return ret.join("\n") + "\n";
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2) {
  if (typeof options2 === "function") {
    options2 = { callback: options2 };
  }
  if (!(options2 === null || options2 === void 0 ? void 0 : options2.callback)) {
    const patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2);
    if (!patchObj) {
      return;
    }
    return formatPatch(patchObj, options2 === null || options2 === void 0 ? void 0 : options2.headerOptions);
  } else {
    const { callback } = options2;
    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, Object.assign(Object.assign({}, options2), { callback: (patchObj) => {
      if (!patchObj) {
        callback(void 0);
      } else {
        callback(formatPatch(patchObj, options2.headerOptions));
      }
    } }));
  }
}
function splitLines(text) {
  const hasTrailingNl = text.endsWith("\n");
  const result = text.split("\n").map((line) => line + "\n");
  if (hasTrailingNl) {
    result.pop();
  } else {
    result.push(result.pop().slice(0, -1));
  }
  return result;
}
function extend(destination) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (source.hasOwnProperty(key)) destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n") indexEnd--;
  return string.substring(0, indexEnd);
}
function trimNewlines(string) {
  return trimTrailingNewlines(trimLeadingNewlines(string));
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node2) {
  return is$1(node2, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node2) {
  return is$1(node2, voidElements);
}
function hasVoid(node2) {
  return has$1(node2, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node2) {
  return is$1(node2, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node2) {
  return has$1(node2, meaningfulWhenBlankElements);
}
function is$1(node2, tagNames) {
  return tagNames.indexOf(node2.nodeName) >= 0;
}
function has$1(node2, tagNames) {
  return node2.getElementsByTagName && tagNames.some(function(tagName) {
    return node2.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node2, options2) {
    return options2.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node2, options2) {
    var hLevel = Number(node2.nodeName.charAt(1));
    if (options2.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = trimNewlines(content).replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node2) {
    var parent = node2.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node2) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node2, options2) {
    var prefix = options2.bulletListMarker + "   ";
    var parent = node2.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index2 = Array.prototype.indexOf.call(parent.children, node2);
      prefix = (start ? Number(start) + index2 : index2 + 1) + ".  ";
    }
    var isParagraph = /\n$/.test(content);
    content = trimNewlines(content) + (isParagraph ? "\n" : "");
    content = content.replace(/\n/gm, "\n" + " ".repeat(prefix.length));
    return prefix + content + (node2.nextSibling ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node2, options2) {
    return options2.codeBlockStyle === "indented" && node2.nodeName === "PRE" && node2.firstChild && node2.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node2, options2) {
    return "\n\n    " + node2.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node2, options2) {
    return options2.codeBlockStyle === "fenced" && node2.nodeName === "PRE" && node2.firstChild && node2.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node2, options2) {
    var className = node2.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code2 = node2.firstChild.textContent;
    var fenceChar = options2.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match3;
    while (match3 = fenceInCodeRegex.exec(code2)) {
      if (match3[0].length >= fenceSize) {
        fenceSize = match3[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code2.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node2, options2) {
    return "\n\n" + options2.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node2, options2) {
    return options2.linkStyle === "inlined" && node2.nodeName === "A" && node2.getAttribute("href");
  },
  replacement: function(content, node2) {
    var href = node2.getAttribute("href");
    if (href) href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node2.getAttribute("title"));
    if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node2, options2) {
    return options2.linkStyle === "referenced" && node2.nodeName === "A" && node2.getAttribute("href");
  },
  replacement: function(content, node2, options2) {
    var href = node2.getAttribute("href");
    var title = cleanAttribute(node2.getAttribute("title"));
    if (title) title = ' "' + title + '"';
    var replacement;
    var reference;
    switch (options2.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference = "[" + content + "]: " + href + title;
        break;
      default:
        var id2 = this.references.length + 1;
        replacement = "[" + content + "][" + id2 + "]";
        reference = "[" + id2 + "]: " + href + title;
    }
    this.references.push(reference);
    return replacement;
  },
  references: [],
  append: function(options2) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node2, options2) {
    if (!content.trim()) return "";
    return options2.emDelimiter + content + options2.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node2, options2) {
    if (!content.trim()) return "";
    return options2.strongDelimiter + content + options2.strongDelimiter;
  }
};
rules.code = {
  filter: function(node2) {
    var hasSiblings = node2.previousSibling || node2.nextSibling;
    var isCodeBlock = node2.parentNode.nodeName === "PRE" && !hasSiblings;
    return node2.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content) return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter2 = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter2) !== -1) delimiter2 = delimiter2 + "`";
    return delimiter2 + extraSpace + content + extraSpace + delimiter2;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node2) {
    var alt = cleanAttribute(node2.getAttribute("alt"));
    var src = node2.getAttribute("src") || "";
    var title = cleanAttribute(node2.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options2) {
  this.options = options2;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options2.blankReplacement
  };
  this.keepReplacement = options2.keepReplacement;
  this.defaultRule = {
    replacement: options2.defaultReplacement
  };
  this.array = [];
  for (var key in options2.rules) this.array.push(options2.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter2) {
    this._keep.unshift({
      filter: filter2,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter2) {
    this._remove.unshift({
      filter: filter2,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node2) {
    if (node2.isBlank) return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node2, this.options)) return rule;
    if (rule = findRule(this._keep, node2, this.options)) return rule;
    if (rule = findRule(this._remove, node2, this.options)) return rule;
    return this.defaultRule;
  },
  forEach: function(fn2) {
    for (var i2 = 0; i2 < this.array.length; i2++) fn2(this.array[i2], i2);
  }
};
function findRule(rules2, node2, options2) {
  for (var i2 = 0; i2 < rules2.length; i2++) {
    var rule = rules2[i2];
    if (filterValue(rule, node2, options2)) return rule;
  }
  return void 0;
}
function filterValue(rule, node2, options2) {
  var filter2 = rule.filter;
  if (typeof filter2 === "string") {
    if (filter2 === node2.nodeName.toLowerCase()) return true;
  } else if (Array.isArray(filter2)) {
    if (filter2.indexOf(node2.nodeName.toLowerCase()) > -1) return true;
  } else if (typeof filter2 === "function") {
    if (filter2.call(rule, node2, options2)) return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options2) {
  var element = options2.element;
  var isBlock2 = options2.isBlock;
  var isVoid2 = options2.isVoid;
  var isPre = options2.isPre || function(node3) {
    return node3.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element)) return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node2 = next(prev, element, isPre);
  while (node2 !== element) {
    if (node2.nodeType === 3 || node2.nodeType === 4) {
      var text = node2.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node2 = remove(node2);
        continue;
      }
      node2.data = text;
      prevText = node2;
    } else if (node2.nodeType === 1) {
      if (isBlock2(node2) || node2.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node2) || isPre(node2)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node2 = remove(node2);
      continue;
    }
    var nextNode = next(prev, node2, isPre);
    prev = node2;
    node2 = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node2) {
  var next2 = node2.nextSibling || node2.parentNode;
  node2.parentNode.removeChild(node2);
  return next2;
}
function next(prev, current2, isPre) {
  if (prev && prev.parentNode === current2 || isPre(current2)) {
    return current2.nextSibling || current2.parentNode;
  }
  return current2.firstChild || current2.nextSibling || current2.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser3 = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser3().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e2) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser3 = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser3.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser3.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser3;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e2) {
    if (root.ActiveXObject) useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options2) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options2.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node2) {
  return node2.nodeName === "PRE" || node2.nodeName === "CODE";
}
function Node$1(node2, options2) {
  node2.isBlock = isBlock(node2);
  node2.isCode = node2.nodeName === "CODE" || node2.parentNode.isCode;
  node2.isBlank = isBlank(node2);
  node2.flankingWhitespace = flankingWhitespace(node2, options2);
  return node2;
}
function isBlank(node2) {
  return !isVoid(node2) && !isMeaningfulWhenBlank(node2) && /^\s*$/i.test(node2.textContent) && !hasVoid(node2) && !hasMeaningfulWhenBlank(node2);
}
function flankingWhitespace(node2, options2) {
  if (node2.isBlock || options2.preformattedCode && node2.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node2.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node2, options2)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node2, options2)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node2, options2) {
  var sibling2;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling2 = node2.previousSibling;
    regExp = / $/;
  } else {
    sibling2 = node2.nextSibling;
    regExp = /^ /;
  }
  if (sibling2) {
    if (sibling2.nodeType === 3) {
      isFlanked = regExp.test(sibling2.nodeValue);
    } else if (options2.preformattedCode && sibling2.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling2.nodeType === 1 && !isBlock(sibling2)) {
      isFlanked = regExp.test(sibling2.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options2) {
  if (!(this instanceof TurndownService)) return new TurndownService(options2);
  var defaults2 = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node2) {
      return node2.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node2) {
      return node2.isBlock ? "\n\n" + node2.outerHTML + "\n\n" : node2.outerHTML;
    },
    defaultReplacement: function(content, node2) {
      return node2.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults2, options2);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "") return "";
    var output = process$1.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i2 = 0; i2 < plugin.length; i2++) this.use(plugin[i2]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter2) {
    this.rules.keep(filter2);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter2) {
    this.rules.remove(filter2);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape2) {
      return accumulator.replace(escape2[0], escape2[1]);
    }, string);
  }
};
function process$1(parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function(output, node2) {
    node2 = new Node$1(node2, self.options);
    var replacement = "";
    if (node2.nodeType === 3) {
      replacement = node2.isCode ? node2.nodeValue : self.escape(node2.nodeValue);
    } else if (node2.nodeType === 1) {
      replacement = replacementForNode.call(self, node2);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node2) {
  var rule = this.rules.forNode(node2);
  var content = process$1.call(this, node2);
  var whitespace = node2.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing) content = content.trim();
  return whitespace.leading + rule.replacement(content, node2, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s12 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s12.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s12 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var define_process_env_default = {};
var qy = Object.create;
var Wi = Object.defineProperty;
var Gy = Object.getOwnPropertyDescriptor;
var Zy = Object.getOwnPropertyNames;
var Qy = Object.getPrototypeOf, Ky = Object.prototype.hasOwnProperty;
var v = (e2, t2) => () => (e2 && (t2 = e2(e2 = 0)), t2);
var Kr = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports), V = (e2, t2) => {
  for (var n2 in t2) Wi(e2, n2, { get: t2[n2], enumerable: true });
}, Xy = (e2, t2, n2, r2) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function") for (let s2 of Zy(t2)) !Ky.call(e2, s2) && s2 !== n2 && Wi(e2, s2, { get: () => t2[s2], enumerable: !(r2 = Gy(t2, s2)) || r2.enumerable });
  return e2;
};
var Kl = (e2, t2, n2) => (n2 = e2 != null ? qy(Qy(e2)) : {}, Xy(Wi(n2, "default", { value: e2, enumerable: true }), e2));
var Xl = {};
V(Xl, { echoCommand: () => Yy });
function Jy(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) if (e2[n2] === "\\") {
    if (n2 + 1 >= e2.length) {
      t2 += "\\";
      break;
    }
    let r2 = e2[n2 + 1];
    switch (r2) {
      case "\\":
        t2 += "\\", n2 += 2;
        break;
      case "n":
        t2 += `
`, n2 += 2;
        break;
      case "t":
        t2 += "	", n2 += 2;
        break;
      case "r":
        t2 += "\r", n2 += 2;
        break;
      case "a":
        t2 += "\x07", n2 += 2;
        break;
      case "b":
        t2 += "\b", n2 += 2;
        break;
      case "f":
        t2 += "\f", n2 += 2;
        break;
      case "v":
        t2 += "\v", n2 += 2;
        break;
      case "e":
      case "E":
        t2 += "\x1B", n2 += 2;
        break;
      case "c":
        return { output: t2, stop: true };
      case "0": {
        let s2 = "", i2 = n2 + 2;
        for (; i2 < e2.length && i2 < n2 + 5 && /[0-7]/.test(e2[i2]); ) s2 += e2[i2], i2++;
        if (s2.length === 0) t2 += "\0";
        else {
          let o2 = parseInt(s2, 8) % 256;
          t2 += String.fromCharCode(o2);
        }
        n2 = i2;
        break;
      }
      case "x": {
        let s2 = "", i2 = n2 + 2;
        for (; i2 < e2.length && i2 < n2 + 4 && /[0-9a-fA-F]/.test(e2[i2]); ) s2 += e2[i2], i2++;
        if (s2.length === 0) t2 += "\\x", n2 += 2;
        else {
          let o2 = parseInt(s2, 16);
          t2 += String.fromCharCode(o2), n2 = i2;
        }
        break;
      }
      case "u": {
        let s2 = "", i2 = n2 + 2;
        for (; i2 < e2.length && i2 < n2 + 6 && /[0-9a-fA-F]/.test(e2[i2]); ) s2 += e2[i2], i2++;
        if (s2.length === 0) t2 += "\\u", n2 += 2;
        else {
          let o2 = parseInt(s2, 16);
          t2 += String.fromCodePoint(o2), n2 = i2;
        }
        break;
      }
      case "U": {
        let s2 = "", i2 = n2 + 2;
        for (; i2 < e2.length && i2 < n2 + 10 && /[0-9a-fA-F]/.test(e2[i2]); ) s2 += e2[i2], i2++;
        if (s2.length === 0) t2 += "\\U", n2 += 2;
        else {
          let o2 = parseInt(s2, 16);
          try {
            t2 += String.fromCodePoint(o2);
          } catch {
            t2 += `\\U${s2}`;
          }
          n2 = i2;
        }
        break;
      }
      default:
        t2 += `\\${r2}`, n2 += 2;
    }
  } else t2 += e2[n2], n2++;
  return { output: t2, stop: false };
}
var Yy, Jl = v(() => {
  Yy = { name: "echo", async execute(e2, t2) {
    let n2 = false, r2 = t2.xpgEcho ?? false, s2 = 0;
    for (; s2 < e2.length; ) {
      let o2 = e2[s2];
      if (o2 === "-n") n2 = true, s2++;
      else if (o2 === "-e") r2 = true, s2++;
      else if (o2 === "-E") r2 = false, s2++;
      else if (o2 === "-ne" || o2 === "-en") n2 = true, r2 = true, s2++;
      else break;
    }
    let i2 = e2.slice(s2).join(" ");
    if (r2) {
      let o2 = Jy(i2);
      if (i2 = o2.output, o2.stop) return { stdout: i2, stderr: "", exitCode: 0 };
    }
    return n2 || (i2 += `
`), { stdout: i2, stderr: "", exitCode: 0 };
  } };
});
function F$3(e2) {
  let t2 = `${e2.name} - ${e2.summary}

`;
  if (t2 += `Usage: ${e2.usage}
`, e2.description) {
    if (t2 += `
Description:
`, typeof e2.description == "string") for (let n2 of e2.description.split(`
`)) t2 += n2 ? `  ${n2}
` : `
`;
    else if (e2.description.length > 0) for (let n2 of e2.description) t2 += n2 ? `  ${n2}
` : `
`;
  }
  if (e2.options && e2.options.length > 0) {
    t2 += `
Options:
`;
    for (let n2 of e2.options) t2 += `  ${n2}
`;
  }
  if (e2.examples && e2.examples.length > 0) {
    t2 += `
Examples:
`;
    for (let n2 of e2.examples) t2 += `  ${n2}
`;
  }
  if (e2.notes && e2.notes.length > 0) {
    t2 += `
Notes:
`;
    for (let n2 of e2.notes) t2 += `  ${n2}
`;
  }
  return { stdout: t2, stderr: "", exitCode: 0 };
}
function _(e2) {
  return e2.includes("--help");
}
function G(e2, t2) {
  return { stdout: "", stderr: t2.startsWith("--") ? `${e2}: unrecognized option '${t2}'
` : `${e2}: invalid option -- '${t2.replace(/^-/, "")}'
`, exitCode: 1 };
}
var X = v(() => {
});
function fe(e2, t2, n2) {
  let r2 = /* @__PURE__ */ new Map(), s2 = /* @__PURE__ */ new Map();
  for (let [l, c] of Object.entries(n2)) {
    let u = { name: l, type: c.type };
    c.short && r2.set(c.short, u), c.long && s2.set(c.long, u);
  }
  let i2 = {};
  for (let [l, c] of Object.entries(n2)) c.default !== void 0 ? i2[l] = c.default : c.type === "boolean" && (i2[l] = false);
  let o2 = [], a = false;
  for (let l = 0; l < t2.length; l++) {
    let c = t2[l];
    if (a || !c.startsWith("-") || c === "-") {
      o2.push(c);
      continue;
    }
    if (c === "--") {
      a = true;
      continue;
    }
    if (c.startsWith("--")) {
      let u = c.indexOf("="), f2, p;
      u !== -1 ? (f2 = c.slice(2, u), p = c.slice(u + 1)) : f2 = c.slice(2);
      let d = s2.get(f2);
      if (!d) return { ok: false, error: G(e2, c) };
      let { name: m, type: h } = d;
      if (h === "boolean") i2[m] = true;
      else {
        if (p === void 0) {
          if (l + 1 >= t2.length) return { ok: false, error: { stdout: "", stderr: `${e2}: option '--${f2}' requires an argument
`, exitCode: 1 } };
          p = t2[++l];
        }
        i2[m] = h === "number" ? parseInt(p, 10) : p;
      }
    } else {
      let u = c.slice(1);
      for (let f2 = 0; f2 < u.length; f2++) {
        let p = u[f2], d = r2.get(p);
        if (!d) return { ok: false, error: G(e2, `-${p}`) };
        let { name: m, type: h } = d;
        if (h === "boolean") i2[m] = true;
        else {
          let g;
          if (f2 + 1 < u.length) g = u.slice(f2 + 1);
          else if (l + 1 < t2.length) g = t2[++l];
          else return { ok: false, error: { stdout: "", stderr: `${e2}: option requires an argument -- '${p}'
`, exitCode: 1 } };
          i2[m] = h === "number" ? parseInt(g, 10) : g;
          break;
        }
      }
    }
  }
  return { ok: true, result: { flags: i2, positional: o2 } };
}
var Oe = v(() => {
  X();
});
var Pn = v(() => {
});
async function fn(e2, t2, n2) {
  let { cmdName: r2, allowStdinMarker: s2 = true, stopOnError: i2 = false, batchSize: o2 = 100 } = n2;
  if (t2.length === 0) return { files: [{ filename: "", content: e2.stdin }], stderr: "", exitCode: 0 };
  let a = [], l = "", c = 0;
  for (let u = 0; u < t2.length; u += o2) {
    let f2 = t2.slice(u, u + o2), p = await Promise.all(f2.map(async (d) => {
      if (s2 && d === "-") return { filename: "-", content: e2.stdin, error: null };
      try {
        let m = e2.fs.resolvePath(e2.cwd, d), h = await e2.fs.readFile(m, "binary");
        return { filename: d, content: h, error: null };
      } catch {
        return { filename: d, content: "", error: `${r2}: ${d}: No such file or directory
` };
      }
    }));
    for (let d of p) if (d.error) {
      if (l += d.error, c = 1, i2) return { files: a, stderr: l, exitCode: c };
    } else a.push({ filename: d.filename, content: d.content });
  }
  return { files: a, stderr: l, exitCode: c };
}
async function Tn(e2, t2, n2) {
  let r2 = await fn(e2, t2, { ...n2, stopOnError: true });
  return r2.exitCode !== 0 ? { ok: false, error: { stdout: "", stderr: r2.stderr, exitCode: r2.exitCode } } : { ok: true, content: r2.files.map((i2) => i2.content).join("") };
}
var pn = v(() => {
  Pn();
});
var Yl = {};
V(Yl, { catCommand: () => nb });
function rb(e2, t2) {
  let n2 = e2.split(`
`), r2 = e2.endsWith(`
`), s2 = r2 ? n2.slice(0, -1) : n2;
  return { content: s2.map((o2, a) => `${String(t2 + a).padStart(6, " ")}	${o2}`).join(`
`) + (r2 ? `
` : ""), nextLineNumber: t2 + s2.length };
}
var eb, tb, nb, ec = v(() => {
  Oe();
  pn();
  X();
  eb = { name: "cat", summary: "concatenate files and print on the standard output", usage: "cat [OPTION]... [FILE]...", options: ["-n, --number           number all output lines", "    --help             display this help and exit"] }, tb = { number: { short: "n", long: "number", type: "boolean" } }, nb = { name: "cat", async execute(e2, t2) {
    if (_(e2)) return F$3(eb);
    let n2 = fe("cat", e2, tb);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.number, s2 = n2.result.positional, i2 = await fn(t2, s2, { cmdName: "cat", allowStdinMarker: true, stopOnError: false }), o2 = "", a = 1;
    for (let { content: l } of i2.files) if (r2) {
      let c = rb(l, a);
      o2 += c.content, a = c.nextLineNumber;
    } else o2 += l;
    return { stdout: o2, stderr: i2.stderr, exitCode: i2.exitCode };
  } };
});
function Ne(e2) {
  return e2 instanceof Error ? e2.message : String(e2);
}
var wt = v(() => {
});
function Xr(e2, t2, n2) {
  let r2 = e2;
  n2 >= 0 && r2.length > n2 && (r2 = r2.slice(0, n2));
  let s2 = Math.abs(t2);
  return s2 > r2.length && (t2 < 0 ? r2 = r2.padEnd(s2, " ") : r2 = r2.padStart(s2, " ")), r2;
}
function tc(e2, t2) {
  let n2 = t2, r2 = 0, s2 = -1, i2 = false;
  for (n2 < e2.length && e2[n2] === "-" && (i2 = true, n2++); n2 < e2.length && /\d/.test(e2[n2]); ) r2 = r2 * 10 + parseInt(e2[n2], 10), n2++;
  if (n2 < e2.length && e2[n2] === ".") for (n2++, s2 = 0; n2 < e2.length && /\d/.test(e2[n2]); ) s2 = s2 * 10 + parseInt(e2[n2], 10), n2++;
  return i2 && r2 > 0 && (r2 = -r2), [r2, s2, n2 - t2];
}
function Jr(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) if (e2[n2] === "\\" && n2 + 1 < e2.length) switch (e2[n2 + 1]) {
    case "n":
      t2 += `
`, n2 += 2;
      break;
    case "t":
      t2 += "	", n2 += 2;
      break;
    case "r":
      t2 += "\r", n2 += 2;
      break;
    case "\\":
      t2 += "\\", n2 += 2;
      break;
    case "a":
      t2 += "\x07", n2 += 2;
      break;
    case "b":
      t2 += "\b", n2 += 2;
      break;
    case "f":
      t2 += "\f", n2 += 2;
      break;
    case "v":
      t2 += "\v", n2 += 2;
      break;
    case "e":
    case "E":
      t2 += "\x1B", n2 += 2;
      break;
    case "0":
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7": {
      let s2 = "", i2 = n2 + 1;
      for (; i2 < e2.length && i2 < n2 + 4 && /[0-7]/.test(e2[i2]); ) s2 += e2[i2], i2++;
      t2 += String.fromCharCode(parseInt(s2, 8)), n2 = i2;
      break;
    }
    case "x": {
      let s2 = [], i2 = n2;
      for (; i2 + 3 < e2.length && e2[i2] === "\\" && e2[i2 + 1] === "x" && /[0-9a-fA-F]{2}/.test(e2.slice(i2 + 2, i2 + 4)); ) s2.push(parseInt(e2.slice(i2 + 2, i2 + 4), 16)), i2 += 4;
      if (s2.length > 0) {
        try {
          let o2 = new TextDecoder("utf-8", { fatal: true });
          t2 += o2.decode(new Uint8Array(s2));
        } catch {
          for (let o2 of s2) t2 += String.fromCharCode(o2);
        }
        n2 = i2;
      } else t2 += e2[n2], n2++;
      break;
    }
    case "u": {
      let s2 = "", i2 = n2 + 2;
      for (; i2 < e2.length && i2 < n2 + 6 && /[0-9a-fA-F]/.test(e2[i2]); ) s2 += e2[i2], i2++;
      s2 ? (t2 += String.fromCodePoint(parseInt(s2, 16)), n2 = i2) : (t2 += "\\u", n2 += 2);
      break;
    }
    case "U": {
      let s2 = "", i2 = n2 + 2;
      for (; i2 < e2.length && i2 < n2 + 10 && /[0-9a-fA-F]/.test(e2[i2]); ) s2 += e2[i2], i2++;
      s2 ? (t2 += String.fromCodePoint(parseInt(s2, 16)), n2 = i2) : (t2 += "\\U", n2 += 2);
      break;
    }
    default:
      t2 += e2[n2], n2++;
  }
  else t2 += e2[n2], n2++;
  return t2;
}
var Bi = v(() => {
});
function sc(e2, t2, n2) {
  let r2 = new Date(t2 * 1e3), s2 = "", i2 = 0;
  for (; i2 < e2.length; ) if (e2[i2] === "%" && i2 + 1 < e2.length) {
    let o2 = e2[i2 + 1], a = ib(r2, o2, n2);
    a !== null ? (s2 += a, i2 += 2) : (s2 += e2[i2], i2++);
  } else s2 += e2[i2], i2++;
  return s2;
}
function sb(e2, t2) {
  let n2 = { year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", weekday: "short", hour12: false, timeZone: t2 };
  try {
    let s2 = new Intl.DateTimeFormat("en-US", n2).formatToParts(e2), i2 = (l) => {
      var _a3;
      return ((_a3 = s2.find((c) => c.type === l)) == null ? void 0 : _a3.value) ?? "";
    }, o2 = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 }, a = i2("weekday");
    return { year: Number.parseInt(i2("year"), 10) || e2.getFullYear(), month: Number.parseInt(i2("month"), 10) || e2.getMonth() + 1, day: Number.parseInt(i2("day"), 10) || e2.getDate(), hour: Number.parseInt(i2("hour"), 10) || e2.getHours(), minute: Number.parseInt(i2("minute"), 10) || e2.getMinutes(), second: Number.parseInt(i2("second"), 10) || e2.getSeconds(), weekday: o2[a] ?? e2.getDay() };
  } catch {
    return { year: e2.getFullYear(), month: e2.getMonth() + 1, day: e2.getDate(), hour: e2.getHours(), minute: e2.getMinutes(), second: e2.getSeconds(), weekday: e2.getDay() };
  }
}
function ib(e2, t2, n2) {
  let r2 = sb(e2, n2), s2 = (l, c = 2) => String(l).padStart(c, "0"), i2 = ic(r2.year, r2.month, r2.day), o2 = nc(r2.year, r2.month, r2.day, r2.weekday, 0), a = nc(r2.year, r2.month, r2.day, r2.weekday, 1);
  switch (t2) {
    case "a":
      return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][r2.weekday];
    case "A":
      return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][r2.weekday];
    case "b":
    case "h":
      return ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][r2.month - 1];
    case "B":
      return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][r2.month - 1];
    case "c":
      return `${["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][r2.weekday]} ${["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][r2.month - 1]} ${String(r2.day).padStart(2, " ")} ${s2(r2.hour)}:${s2(r2.minute)}:${s2(r2.second)} ${r2.year}`;
    case "C":
      return s2(Math.floor(r2.year / 100));
    case "d":
      return s2(r2.day);
    case "D":
      return `${s2(r2.month)}/${s2(r2.day)}/${s2(r2.year % 100)}`;
    case "e":
      return String(r2.day).padStart(2, " ");
    case "F":
      return `${r2.year}-${s2(r2.month)}-${s2(r2.day)}`;
    case "g":
      return s2(rc(r2.year, r2.month, r2.day) % 100);
    case "G":
      return String(rc(r2.year, r2.month, r2.day));
    case "H":
      return s2(r2.hour);
    case "I":
      return s2(r2.hour % 12 || 12);
    case "j":
      return String(i2).padStart(3, "0");
    case "k":
      return String(r2.hour).padStart(2, " ");
    case "l":
      return String(r2.hour % 12 || 12).padStart(2, " ");
    case "m":
      return s2(r2.month);
    case "M":
      return s2(r2.minute);
    case "n":
      return `
`;
    case "N":
      return "000000000";
    case "p":
      return r2.hour < 12 ? "AM" : "PM";
    case "P":
      return r2.hour < 12 ? "am" : "pm";
    case "r":
      return `${s2(r2.hour % 12 || 12)}:${s2(r2.minute)}:${s2(r2.second)} ${r2.hour < 12 ? "AM" : "PM"}`;
    case "R":
      return `${s2(r2.hour)}:${s2(r2.minute)}`;
    case "s":
      return String(Math.floor(e2.getTime() / 1e3));
    case "S":
      return s2(r2.second);
    case "t":
      return "	";
    case "T":
      return `${s2(r2.hour)}:${s2(r2.minute)}:${s2(r2.second)}`;
    case "u":
      return String(r2.weekday === 0 ? 7 : r2.weekday);
    case "U":
      return s2(o2);
    case "V":
      return s2(lb(r2.year, r2.month, r2.day));
    case "w":
      return String(r2.weekday);
    case "W":
      return s2(a);
    case "x":
      return `${s2(r2.month)}/${s2(r2.day)}/${s2(r2.year % 100)}`;
    case "X":
      return `${s2(r2.hour)}:${s2(r2.minute)}:${s2(r2.second)}`;
    case "y":
      return s2(r2.year % 100);
    case "Y":
      return String(r2.year);
    case "z":
      return ob(e2, n2);
    case "Z":
      return ab(e2, n2);
    case "%":
      return "%";
    default:
      return null;
  }
}
function ob(e2, t2) {
  if (!t2) {
    let o2 = -e2.getTimezoneOffset(), a = o2 >= 0 ? "+" : "-", l = Math.floor(Math.abs(o2) / 60), c = Math.abs(o2) % 60;
    return `${a}${String(l).padStart(2, "0")}${String(c).padStart(2, "0")}`;
  }
  try {
    let l = new Intl.DateTimeFormat("en-US", { timeZone: t2, timeZoneName: "longOffset" }).formatToParts(e2).find((c) => c.type === "timeZoneName");
    if (l) {
      let c = l.value.match(/GMT([+-])(\d{2}):(\d{2})/);
      if (c) return `${c[1]}${c[2]}${c[3]}`;
      if (l.value === "GMT" || l.value === "UTC") return "+0000";
    }
  } catch {
  }
  let n2 = -e2.getTimezoneOffset(), r2 = n2 >= 0 ? "+" : "-", s2 = Math.floor(Math.abs(n2) / 60), i2 = Math.abs(n2) % 60;
  return `${r2}${String(s2).padStart(2, "0")}${String(i2).padStart(2, "0")}`;
}
function ab(e2, t2) {
  var _a3;
  try {
    return ((_a3 = new Intl.DateTimeFormat("en-US", { timeZone: t2, timeZoneName: "short" }).formatToParts(e2).find((i2) => i2.type === "timeZoneName")) == null ? void 0 : _a3.value) ?? "UTC";
  } catch {
    return "UTC";
  }
}
function ic(e2, t2, n2) {
  let r2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  (e2 % 4 === 0 && e2 % 100 !== 0 || e2 % 400 === 0) && (r2[1] = 29);
  let i2 = n2;
  for (let o2 = 0; o2 < t2 - 1; o2++) i2 += r2[o2];
  return i2;
}
function nc(e2, t2, n2, r2, s2) {
  let i2 = ic(e2, t2, n2), l = (new Date(e2, 0, 1).getDay() - s2 + 7) % 7, c = (r2 - s2 + 7) % 7, u = i2 - 1 + l;
  return Math.floor((u - c + 7) / 7);
}
function lb(e2, t2, n2) {
  let r2 = new Date(e2, t2 - 1, n2, 12, 0, 0);
  r2.setDate(r2.getDate() + 3 - (r2.getDay() + 6) % 7);
  let s2 = new Date(r2.getFullYear(), 0, 4);
  s2.setDate(s2.getDate() + 3 - (s2.getDay() + 6) % 7);
  let i2 = r2.getTime() - s2.getTime();
  return 1 + Math.round(i2 / (10080 * 60 * 1e3));
}
function rc(e2, t2, n2) {
  let r2 = new Date(e2, t2 - 1, n2, 12, 0, 0);
  return r2.setDate(r2.getDate() + 3 - (r2.getDay() + 6) % 7), r2.getFullYear();
}
var oc = v(() => {
});
var lc = {};
V(lc, { printfCommand: () => fb });
function cb(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) {
    let r2 = e2[n2];
    if (r2 < 128) {
      t2 += String.fromCharCode(r2), n2++;
      continue;
    }
    if ((r2 & 224) === 192) {
      if (n2 + 1 < e2.length && (e2[n2 + 1] & 192) === 128 && r2 >= 194) {
        let s2 = (r2 & 31) << 6 | e2[n2 + 1] & 63;
        t2 += String.fromCharCode(s2), n2 += 2;
        continue;
      }
      t2 += String.fromCharCode(r2), n2++;
      continue;
    }
    if ((r2 & 240) === 224) {
      if (n2 + 2 < e2.length && (e2[n2 + 1] & 192) === 128 && (e2[n2 + 2] & 192) === 128) {
        if (r2 === 224 && e2[n2 + 1] < 160) {
          t2 += String.fromCharCode(r2), n2++;
          continue;
        }
        let s2 = (r2 & 15) << 12 | (e2[n2 + 1] & 63) << 6 | e2[n2 + 2] & 63;
        if (s2 >= 55296 && s2 <= 57343) {
          t2 += String.fromCharCode(r2), n2++;
          continue;
        }
        t2 += String.fromCharCode(s2), n2 += 3;
        continue;
      }
      t2 += String.fromCharCode(r2), n2++;
      continue;
    }
    if ((r2 & 248) === 240 && r2 <= 244) {
      if (n2 + 3 < e2.length && (e2[n2 + 1] & 192) === 128 && (e2[n2 + 2] & 192) === 128 && (e2[n2 + 3] & 192) === 128) {
        if (r2 === 240 && e2[n2 + 1] < 144) {
          t2 += String.fromCharCode(r2), n2++;
          continue;
        }
        let s2 = (r2 & 7) << 18 | (e2[n2 + 1] & 63) << 12 | (e2[n2 + 2] & 63) << 6 | e2[n2 + 3] & 63;
        if (s2 > 1114111) {
          t2 += String.fromCharCode(r2), n2++;
          continue;
        }
        t2 += String.fromCodePoint(s2), n2 += 4;
        continue;
      }
      t2 += String.fromCharCode(r2), n2++;
      continue;
    }
    t2 += String.fromCharCode(r2), n2++;
  }
  return t2;
}
function pb(e2, t2, n2, r2) {
  let s2 = "", i2 = 0, o2 = 0, a = false, l = "";
  for (; i2 < e2.length; ) if (e2[i2] === "%" && i2 + 1 < e2.length) {
    let c = i2;
    if (i2++, e2[i2] === "%") {
      s2 += "%", i2++;
      continue;
    }
    let u = e2.slice(c).match(/^%(-?\d*)(?:\.(\d+))?\(([^)]*)\)T/);
    if (u) {
      let C = u[1] ? parseInt(u[1], 10) : 0, A = u[2] ? parseInt(u[2], 10) : -1, I = u[3], O = u[0], L = t2[n2 + o2] || "";
      o2++;
      let D;
      L === "" || L === "-1" || L === "-2" ? D = Math.floor(Date.now() / 1e3) : D = parseInt(L, 10) || 0;
      let $ = sc(I, D, r2);
      if (A >= 0 && $.length > A && ($ = $.slice(0, A)), C !== 0) {
        let N2 = Math.abs(C);
        $.length < N2 && (C < 0 ? $ = $.padEnd(N2, " ") : $ = $.padStart(N2, " "));
      }
      s2 += $, i2 = c + O.length;
      continue;
    }
    for (; i2 < e2.length && "+-0 #'".includes(e2[i2]); ) i2++;
    let f2 = false;
    if (e2[i2] === "*") f2 = true, i2++;
    else for (; i2 < e2.length && /\d/.test(e2[i2]); ) i2++;
    let p = false;
    if (e2[i2] === ".") if (i2++, e2[i2] === "*") p = true, i2++;
    else for (; i2 < e2.length && /\d/.test(e2[i2]); ) i2++;
    i2 < e2.length && "hlL".includes(e2[i2]) && i2++;
    let d = e2[i2] || "";
    i2++;
    let h = e2.slice(c, i2);
    if (f2) {
      let C = parseInt(t2[n2 + o2] || "0", 10);
      o2++, h = h.replace("*", String(C));
    }
    if (p) {
      let C = parseInt(t2[n2 + o2] || "0", 10);
      o2++, h = h.replace(".*", `.${C}`);
    }
    let g = t2[n2 + o2] || "";
    o2++;
    let { value: b, parseError: y, parseErrMsg: w, stopped: E } = db(h, d, g);
    if (s2 += b, y && (a = true, w && (l = w)), E) return { result: s2, argsConsumed: o2, error: a, errMsg: l, stopped: true };
  } else s2 += e2[i2], i2++;
  return { result: s2, argsConsumed: o2, error: a, errMsg: l, stopped: false };
}
function db(e2, t2, n2) {
  let r2 = false, s2 = "";
  switch (t2) {
    case "d":
    case "i": {
      let i2 = Yr(n2);
      return r2 = It, r2 && (s2 = `printf: ${n2}: invalid number
`), { value: ac(e2, i2), parseError: r2, parseErrMsg: s2 };
    }
    case "o": {
      let i2 = Yr(n2);
      return r2 = It, r2 && (s2 = `printf: ${n2}: invalid number
`), { value: hb(e2, i2), parseError: r2, parseErrMsg: s2 };
    }
    case "u": {
      let i2 = Yr(n2);
      r2 = It, r2 && (s2 = `printf: ${n2}: invalid number
`);
      let o2 = i2 < 0 ? i2 >>> 0 : i2;
      return { value: ac(e2.replace("u", "d"), o2), parseError: r2, parseErrMsg: s2 };
    }
    case "x":
    case "X": {
      let i2 = Yr(n2);
      return r2 = It, r2 && (s2 = `printf: ${n2}: invalid number
`), { value: mb(e2, i2), parseError: r2, parseErrMsg: s2 };
    }
    case "e":
    case "E":
    case "f":
    case "F":
    case "g":
    case "G": {
      let i2 = parseFloat(n2) || 0;
      return { value: wb(e2, t2, i2), parseError: false, parseErrMsg: "" };
    }
    case "c": {
      if (n2 === "") return { value: "", parseError: false, parseErrMsg: "" };
      let a = new TextEncoder().encode(n2)[0];
      return { value: String.fromCharCode(a), parseError: false, parseErrMsg: "" };
    }
    case "s":
      return { value: yb(e2, n2), parseError: false, parseErrMsg: "" };
    case "q":
      return { value: bb(e2, n2), parseError: false, parseErrMsg: "" };
    case "b": {
      let i2 = xb(n2);
      return { value: i2.value, parseError: false, parseErrMsg: "", stopped: i2.stopped };
    }
    default:
      try {
        return { value: sprintf.sprintf(e2, n2), parseError: false, parseErrMsg: "" };
      } catch {
        return { value: "", parseError: true, parseErrMsg: `printf: [sprintf] unexpected placeholder
` };
      }
  }
}
function Yr(e2) {
  It = false;
  let t2 = e2.trimStart(), n2 = t2 !== t2.trimEnd();
  if (e2 = t2.trimEnd(), e2.startsWith("'") && e2.length >= 2 || e2.startsWith('"') && e2.length >= 2) return e2.charCodeAt(1);
  if (e2.startsWith("\\'") && e2.length >= 3 || e2.startsWith('\\"') && e2.length >= 3) return e2.charCodeAt(2);
  if (e2.startsWith("+") && (e2 = e2.slice(1)), e2.startsWith("0x") || e2.startsWith("0X")) {
    let r2 = parseInt(e2, 16);
    return Number.isNaN(r2) ? (It = true, 0) : (n2 && (It = true), r2);
  }
  if (e2.startsWith("0") && e2.length > 1 && /^-?0[0-7]+$/.test(e2)) return n2 && (It = true), parseInt(e2, 8) || 0;
  if (/^\d+#/.test(e2)) {
    It = true;
    let r2 = e2.match(/^(\d+)#/);
    return r2 ? parseInt(r2[1], 10) : 0;
  }
  if (e2 !== "" && !/^-?\d+$/.test(e2)) {
    It = true;
    let r2 = parseInt(e2, 10);
    return Number.isNaN(r2) ? 0 : r2;
  }
  return n2 && (It = true), parseInt(e2, 10) || 0;
}
function ac(e2, t2) {
  let n2 = e2.match(/^%([- +#0']*)(\d*)(\.(\d*))?[diu]$/);
  if (!n2) return sprintf.sprintf(e2.replace(/\.\d*/, ""), t2);
  let r2 = n2[1] || "", s2 = n2[2] ? parseInt(n2[2], 10) : 0, i2 = n2[3] !== void 0 ? n2[4] ? parseInt(n2[4], 10) : 0 : -1, o2 = t2 < 0, a = Math.abs(t2), l = String(a);
  i2 >= 0 && (l = l.padStart(i2, "0"));
  let c = "";
  o2 ? c = "-" : r2.includes("+") ? c = "+" : r2.includes(" ") && (c = " ");
  let u = c + l;
  return s2 > u.length && (r2.includes("-") ? u = u.padEnd(s2, " ") : r2.includes("0") && i2 < 0 ? u = c + l.padStart(s2 - c.length, "0") : u = u.padStart(s2, " ")), u;
}
function hb(e2, t2) {
  let n2 = e2.match(/^%([- +#0']*)(\d*)(\.(\d*))?o$/);
  if (!n2) return sprintf.sprintf(e2, t2);
  let r2 = n2[1] || "", s2 = n2[2] ? parseInt(n2[2], 10) : 0, i2 = n2[3] !== void 0 ? n2[4] ? parseInt(n2[4], 10) : 0 : -1, o2 = Math.abs(t2).toString(8);
  i2 >= 0 && (o2 = o2.padStart(i2, "0")), r2.includes("#") && !o2.startsWith("0") && (o2 = `0${o2}`);
  let a = o2;
  return s2 > a.length && (r2.includes("-") ? a = a.padEnd(s2, " ") : r2.includes("0") && i2 < 0 ? a = a.padStart(s2, "0") : a = a.padStart(s2, " ")), a;
}
function mb(e2, t2) {
  let n2 = e2.includes("X"), r2 = e2.match(/^%([- +#0']*)(\d*)(\.(\d*))?[xX]$/);
  if (!r2) return sprintf.sprintf(e2, t2);
  let s2 = r2[1] || "", i2 = r2[2] ? parseInt(r2[2], 10) : 0, o2 = r2[3] !== void 0 ? r2[4] ? parseInt(r2[4], 10) : 0 : -1, a = Math.abs(t2).toString(16);
  n2 && (a = a.toUpperCase()), o2 >= 0 && (a = a.padStart(o2, "0"));
  let l = "";
  s2.includes("#") && t2 !== 0 && (l = n2 ? "0X" : "0x");
  let c = l + a;
  return i2 > c.length && (s2.includes("-") ? c = c.padEnd(i2, " ") : s2.includes("0") && o2 < 0 ? c = l + a.padStart(i2 - l.length, "0") : c = c.padStart(i2, " ")), c;
}
function gb(e2) {
  if (e2 === "") return "''";
  if (/^[a-zA-Z0-9_./-]+$/.test(e2)) return e2;
  if (/[\x00-\x1f\x7f-\xff]/.test(e2)) {
    let r2 = "$'";
    for (let s2 of e2) {
      let i2 = s2.charCodeAt(0);
      s2 === "'" ? r2 += "\\'" : s2 === "\\" ? r2 += "\\\\" : s2 === `
` ? r2 += "\\n" : s2 === "	" ? r2 += "\\t" : s2 === "\r" ? r2 += "\\r" : s2 === "\x07" ? r2 += "\\a" : s2 === "\b" ? r2 += "\\b" : s2 === "\f" ? r2 += "\\f" : s2 === "\v" ? r2 += "\\v" : s2 === "\x1B" ? r2 += "\\E" : i2 < 32 || i2 >= 127 && i2 <= 255 ? r2 += `\\${i2.toString(8).padStart(3, "0")}` : s2 === '"' ? r2 += '\\"' : r2 += s2;
    }
    return r2 += "'", r2;
  }
  let n2 = "";
  for (let r2 of e2) " 	|&;<>()$`\\\"'*?[#~=%!{}".includes(r2) ? n2 += `\\${r2}` : n2 += r2;
  return n2;
}
function yb(e2, t2) {
  let n2 = e2.match(/^%(-?)(\d*)(\.(\d*))?s$/);
  if (!n2) return sprintf.sprintf(e2.replace(/0+(?=\d)/, ""), t2);
  let r2 = n2[1] === "-", s2 = n2[2] ? parseInt(n2[2], 10) : 0, i2 = n2[3] !== void 0 ? n2[4] ? parseInt(n2[4], 10) : 0 : -1, o2 = r2 ? -s2 : s2;
  return Xr(t2, o2, i2);
}
function bb(e2, t2) {
  let n2 = gb(t2), r2 = e2.match(/^%(-?)(\d*)q$/);
  if (!r2) return n2;
  let s2 = r2[1] === "-", i2 = r2[2] ? parseInt(r2[2], 10) : 0, o2 = n2;
  return i2 > o2.length && (s2 ? o2 = o2.padEnd(i2, " ") : o2 = o2.padStart(i2, " ")), o2;
}
function wb(e2, t2, n2) {
  var _a3;
  let r2 = e2.match(/^%([- +#0']*)(\d*)(\.(\d*))?[eEfFgG]$/);
  if (!r2) return sprintf.sprintf(e2, n2);
  let s2 = r2[1] || "", i2 = r2[2] ? parseInt(r2[2], 10) : 0, o2 = r2[3] !== void 0 ? r2[4] ? parseInt(r2[4], 10) : 0 : 6, a, l = t2.toLowerCase();
  if (l === "e" ? (a = n2.toExponential(o2), a = a.replace(/e([+-])(\d)$/, "e$10$2"), t2 === "E" && (a = a.toUpperCase())) : l === "f" ? (a = n2.toFixed(o2), s2.includes("#") && o2 === 0 && !a.includes(".") && (a += ".")) : l === "g" ? (a = n2.toPrecision(o2 || 1), s2.includes("#") || (a = a.replace(/\.?0+$/, ""), a = a.replace(/\.?0+e/, "e")), a = a.replace(/e([+-])(\d)$/, "e$10$2"), t2 === "G" && (a = a.toUpperCase())) : a = n2.toString(), n2 >= 0 && (s2.includes("+") ? a = `+${a}` : s2.includes(" ") && (a = ` ${a}`)), i2 > a.length) if (s2.includes("-")) a = a.padEnd(i2, " ");
  else if (s2.includes("0")) {
    let c = ((_a3 = a.match(/^[+ -]/)) == null ? void 0 : _a3[0]) || "", u = c ? a.slice(1) : a;
    a = c + u.padStart(i2 - c.length, "0");
  } else a = a.padStart(i2, " ");
  return a;
}
function xb(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) if (e2[n2] === "\\" && n2 + 1 < e2.length) switch (e2[n2 + 1]) {
    case "n":
      t2 += `
`, n2 += 2;
      break;
    case "t":
      t2 += "	", n2 += 2;
      break;
    case "r":
      t2 += "\r", n2 += 2;
      break;
    case "\\":
      t2 += "\\", n2 += 2;
      break;
    case "a":
      t2 += "\x07", n2 += 2;
      break;
    case "b":
      t2 += "\b", n2 += 2;
      break;
    case "f":
      t2 += "\f", n2 += 2;
      break;
    case "v":
      t2 += "\v", n2 += 2;
      break;
    case "c":
      return { value: t2, stopped: true };
    case "x": {
      let s2 = [], i2 = n2;
      for (; i2 + 1 < e2.length && e2[i2] === "\\" && e2[i2 + 1] === "x"; ) {
        let o2 = "", a = i2 + 2;
        for (; a < e2.length && a < i2 + 4 && /[0-9a-fA-F]/.test(e2[a]); ) o2 += e2[a], a++;
        if (o2) s2.push(parseInt(o2, 16)), i2 = a;
        else break;
      }
      s2.length > 0 ? (t2 += cb(s2), n2 = i2) : (t2 += "\\x", n2 += 2);
      break;
    }
    case "u": {
      let s2 = "", i2 = n2 + 2;
      for (; i2 < e2.length && i2 < n2 + 6 && /[0-9a-fA-F]/.test(e2[i2]); ) s2 += e2[i2], i2++;
      s2 ? (t2 += String.fromCodePoint(parseInt(s2, 16)), n2 = i2) : (t2 += "\\u", n2 += 2);
      break;
    }
    case "0": {
      let s2 = "", i2 = n2 + 2;
      for (; i2 < e2.length && i2 < n2 + 5 && /[0-7]/.test(e2[i2]); ) s2 += e2[i2], i2++;
      s2 ? t2 += String.fromCharCode(parseInt(s2, 8)) : t2 += "\0", n2 = i2;
      break;
    }
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7": {
      let s2 = "", i2 = n2 + 1;
      for (; i2 < e2.length && i2 < n2 + 4 && /[0-7]/.test(e2[i2]); ) s2 += e2[i2], i2++;
      t2 += String.fromCharCode(parseInt(s2, 8)), n2 = i2;
      break;
    }
    default:
      t2 += e2[n2], n2++;
  }
  else t2 += e2[n2], n2++;
  return { value: t2, stopped: false };
}
var ub, fb, It, cc = v(() => {
  wt();
  X();
  Bi();
  oc();
  ub = { name: "printf", summary: "format and print data", usage: "printf [-v var] FORMAT [ARGUMENT...]", options: ["    -v var     assign the output to shell variable VAR rather than display it", "    --help     display this help and exit"], notes: ["FORMAT controls the output like in C printf.", "Escape sequences: \\n (newline), \\t (tab), \\\\ (backslash)", "Format specifiers: %s (string), %d (integer), %f (float), %x (hex), %o (octal), %% (literal %)", "Width and precision: %10s (width 10), %.2f (2 decimal places), %010d (zero-padded)", "Flags: %- (left-justify), %+ (show sign), %0 (zero-pad)"] }, fb = { name: "printf", async execute(e2, t2) {
    if (_(e2)) return F$3(ub);
    if (e2.length === 0) return { stdout: "", stderr: `printf: usage: printf format [arguments]
`, exitCode: 2 };
    let n2 = null, r2 = 0;
    for (; r2 < e2.length; ) {
      let o2 = e2[r2];
      if (o2 === "--") {
        r2++;
        break;
      }
      if (o2 === "-v") {
        if (r2 + 1 >= e2.length) return { stdout: "", stderr: `printf: -v: option requires an argument
`, exitCode: 1 };
        if (n2 = e2[r2 + 1], !/^[a-zA-Z_][a-zA-Z0-9_]*(\[[^\]]+\])?$/.test(n2)) return { stdout: "", stderr: `printf: \`${n2}': not a valid identifier
`, exitCode: 2 };
        r2 += 2;
      } else {
        if (o2.startsWith("-") && o2 !== "-") break;
        break;
      }
    }
    if (r2 >= e2.length) return { stdout: "", stderr: `printf: usage: printf format [arguments]
`, exitCode: 1 };
    let s2 = e2[r2], i2 = e2.slice(r2 + 1);
    try {
      let o2 = Jr(s2), a = "", l = 0, c = false, u = "", f2 = t2.env.TZ;
      do {
        let { result: p, argsConsumed: d, error: m, errMsg: h, stopped: g } = pb(o2, i2, l, f2);
        if (a += p, l += d, m && (c = true, h && (u = h)), g) break;
      } while (l < i2.length && l > 0);
      if (l === 0 && i2.length > 0, n2) {
        let p = n2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(['"]?)(.+?)\2\]$/);
        if (p) {
          let d = p[1], m = p[3];
          m = m.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (h, g) => t2.env[g] ?? ""), t2.env[`${d}_${m}`] = a;
        } else t2.env[n2] = a;
        return { stdout: "", stderr: u, exitCode: c ? 1 : 0 };
      }
      return { stdout: a, stderr: u, exitCode: c ? 1 : 0 };
    } catch (o2) {
      return { stdout: "", stderr: `printf: ${Ne(o2)}
`, exitCode: 1 };
    }
  } };
  It = false;
});
var pc = {};
V(pc, { lsCommand: () => Ab });
function es(e2) {
  if (e2 < 1024) return String(e2);
  if (e2 < 1024 * 1024) {
    let n2 = e2 / 1024;
    return n2 < 10 ? `${n2.toFixed(1)}K` : `${Math.round(n2)}K`;
  }
  if (e2 < 1024 * 1024 * 1024) {
    let n2 = e2 / 1048576;
    return n2 < 10 ? `${n2.toFixed(1)}M` : `${Math.round(n2)}M`;
  }
  let t2 = e2 / (1024 * 1024 * 1024);
  return t2 < 10 ? `${t2.toFixed(1)}G` : `${Math.round(t2)}G`;
}
function ts(e2) {
  let n2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][e2.getMonth()], r2 = String(e2.getDate()).padStart(2, " "), s2 = /* @__PURE__ */ new Date(), i2 = new Date(s2.getTime() - 4320 * 60 * 60 * 1e3);
  if (e2 > i2) {
    let a = String(e2.getHours()).padStart(2, "0"), l = String(e2.getMinutes()).padStart(2, "0");
    return `${n2} ${r2} ${a}:${l}`;
  }
  let o2 = e2.getFullYear();
  return `${n2} ${r2}  ${o2}`;
}
async function Cb(e2, t2, n2, r2, s2, i2 = false, o2 = false, a = false) {
  let l = n2 || r2, c = t2.fs.getAllPaths(), u = t2.fs.resolvePath(t2.cwd, "."), f2 = [];
  for (let p of c) {
    let d = p.startsWith(u) && p.slice(u.length + 1) || p;
    if (minimatch(d, e2) || minimatch(p, e2)) {
      let m = d.split("/").pop() || d;
      if (!l && m.startsWith(".")) continue;
      f2.push(d || p);
    }
  }
  if (f2.length === 0) return { stdout: "", stderr: `ls: ${e2}: No such file or directory
`, exitCode: 2 };
  if (a) {
    let p = [];
    for (let d of f2) {
      let m = t2.fs.resolvePath(t2.cwd, d);
      try {
        let h = await t2.fs.stat(m);
        p.push({ path: d, size: h.size ?? 0 });
      } catch {
        p.push({ path: d, size: 0 });
      }
    }
    p.sort((d, m) => m.size - d.size), f2.length = 0, f2.push(...p.map((d) => d.path));
  } else f2.sort();
  if (i2 && f2.reverse(), s2) {
    let p = [];
    for (let d of f2) {
      let m = t2.fs.resolvePath(t2.cwd, d);
      try {
        let h = await t2.fs.stat(m), g = h.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", b = h.isDirectory ? "/" : "", y = h.size ?? 0, w = o2 ? es(y).padStart(5) : String(y).padStart(5), E = h.mtime ?? /* @__PURE__ */ new Date(0), C = ts(E);
        p.push(`${g} 1 user user ${w} ${C} ${d}${b}`);
      } catch {
        p.push(`-rw-r--r-- 1 user user     0 Jan  1 00:00 ${d}`);
      }
    }
    return { stdout: `${p.join(`
`)}
`, stderr: "", exitCode: 0 };
  }
  return { stdout: `${f2.join(`
`)}
`, stderr: "", exitCode: 0 };
}
async function fc(e2, t2, n2, r2, s2, i2, o2, a = false, l = false, c = false, u = false) {
  let f2 = n2 || r2, p = t2.fs.resolvePath(t2.cwd, e2);
  try {
    let d = await t2.fs.stat(p);
    if (!d.isDirectory) {
      if (s2) {
        let g = d.size ?? 0, b = l ? es(g).padStart(5) : String(g).padStart(5), y = d.mtime ?? /* @__PURE__ */ new Date(0), w = ts(y);
        return { stdout: `-rw-r--r-- 1 user user ${b} ${w} ${e2}
`, stderr: "", exitCode: 0 };
      }
      return { stdout: `${e2}
`, stderr: "", exitCode: 0 };
    }
    let m = await t2.fs.readdir(p);
    if (f2 || (m = m.filter((g) => !g.startsWith("."))), c) {
      let g = [];
      for (let b of m) {
        let y = p === "/" ? `/${b}` : `${p}/${b}`;
        try {
          let w = await t2.fs.stat(y);
          g.push({ name: b, size: w.size ?? 0 });
        } catch {
          g.push({ name: b, size: 0 });
        }
      }
      g.sort((b, y) => y.size - b.size), m = g.map((b) => b.name);
    } else m.sort();
    n2 && (m = [".", "..", ...m]), a && m.reverse();
    let h = "";
    if ((i2 || o2) && (h += `${e2}:
`), s2) {
      h += `total ${m.length}
`;
      let g = m.filter((E) => E === "." || E === ".."), b = m.filter((E) => E !== "." && E !== "..");
      for (let E of g) h += `drwxr-xr-x 1 user user     0 Jan  1 00:00 ${E}
`;
      let y = [];
      for (let E = 0; E < b.length; E += 100) {
        let C = b.slice(E, E + 100), A = await Promise.all(C.map(async (I) => {
          let O = p === "/" ? `/${I}` : `${p}/${I}`;
          try {
            let L = await t2.fs.stat(O), D = L.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", $ = L.isDirectory ? "/" : "", N2 = L.size ?? 0, P = l ? es(N2).padStart(5) : String(N2).padStart(5), k = L.mtime ?? /* @__PURE__ */ new Date(0), R2 = ts(k);
            return { name: I, line: `${D} 1 user user ${P} ${R2} ${I}${$}
` };
          } catch {
            return { name: I, line: `-rw-r--r-- 1 user user     0 Jan  1 00:00 ${I}
` };
          }
        }));
        y.push(...A);
      }
      let w = new Map(b.map((E, C) => [E, C]));
      y.sort((E, C) => (w.get(E.name) ?? 0) - (w.get(C.name) ?? 0));
      for (let { line: E } of y) h += E;
    } else h += m.join(`
`) + (m.length ? `
` : "");
    if (i2) {
      let g = m.filter((w) => w !== "." && w !== ".."), b = [];
      if (t2.fs.readdirWithFileTypes) b = (await t2.fs.readdirWithFileTypes(p)).filter((E) => E.isDirectory && g.includes(E.name)).map((E) => ({ name: E.name, isDirectory: true }));
      else for (let w = 0; w < g.length; w += 100) {
        let E = g.slice(w, w + 100), C = await Promise.all(E.map(async (A) => {
          let I = p === "/" ? `/${A}` : `${p}/${A}`;
          try {
            let O = await t2.fs.stat(I);
            return { name: A, isDirectory: O.isDirectory };
          } catch {
            return { name: A, isDirectory: false };
          }
        }));
        b.push(...C.filter((A) => A.isDirectory));
      }
      b.sort((w, E) => w.name.localeCompare(E.name)), a && b.reverse();
      let y = [];
      for (let w = 0; w < b.length; w += 100) {
        let E = b.slice(w, w + 100), C = await Promise.all(E.map(async (A) => {
          let I = e2 === "." ? `./${A.name}` : `${e2}/${A.name}`, O = await fc(I, t2, n2, r2, s2, i2, false, a, l, c, true);
          return { name: A.name, result: O };
        }));
        y.push(...C);
      }
      y.sort((w, E) => w.name.localeCompare(E.name)), a && y.reverse();
      for (let { result: w } of y) h += `
`, h += w.stdout;
    }
    return { stdout: h, stderr: "", exitCode: 0 };
  } catch {
    return { stdout: "", stderr: `ls: ${e2}: No such file or directory
`, exitCode: 2 };
  }
}
var Eb, Sb, Ab, dc = v(() => {
  Oe();
  Pn();
  X();
  Eb = { name: "ls", summary: "list directory contents", usage: "ls [OPTION]... [FILE]...", options: ["-a, --all            do not ignore entries starting with .", "-A, --almost-all     do not list . and ..", "-d, --directory      list directories themselves, not their contents", "-h, --human-readable with -l, print sizes like 1K 234M 2G etc.", "-l                   use a long listing format", "-r, --reverse        reverse order while sorting", "-R, --recursive      list subdirectories recursively", "-S                   sort by file size, largest first", "-t                   sort by time, newest first", "-1                   list one file per line", "    --help           display this help and exit"] }, Sb = { showAll: { short: "a", long: "all", type: "boolean" }, showAlmostAll: { short: "A", long: "almost-all", type: "boolean" }, longFormat: { short: "l", type: "boolean" }, humanReadable: { short: "h", long: "human-readable", type: "boolean" }, recursive: { short: "R", long: "recursive", type: "boolean" }, reverse: { short: "r", long: "reverse", type: "boolean" }, sortBySize: { short: "S", type: "boolean" }, directoryOnly: { short: "d", long: "directory", type: "boolean" }, sortByTime: { short: "t", type: "boolean" }, onePerLine: { short: "1", type: "boolean" } }, Ab = { name: "ls", async execute(e2, t2) {
    if (_(e2)) return F$3(Eb);
    let n2 = fe("ls", e2, Sb);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.showAll, s2 = n2.result.flags.showAlmostAll, i2 = n2.result.flags.longFormat, o2 = n2.result.flags.humanReadable, a = n2.result.flags.recursive, l = n2.result.flags.reverse, c = n2.result.flags.sortBySize, u = n2.result.flags.directoryOnly;
    n2.result.flags.sortByTime;
    n2.result.flags.onePerLine;
    let p = n2.result.positional;
    p.length === 0 && p.push(".");
    let d = "", m = "", h = 0;
    for (let g = 0; g < p.length; g++) {
      let b = p[g];
      if (g > 0 && d && !d.endsWith(`

`) && (d += `
`), u) {
        let y = t2.fs.resolvePath(t2.cwd, b);
        try {
          let w = await t2.fs.stat(y);
          if (i2) {
            let E = w.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", C = w.isDirectory ? "/" : "", A = w.size ?? 0, I = o2 ? es(A).padStart(5) : String(A).padStart(5), O = w.mtime ?? /* @__PURE__ */ new Date(0), L = ts(O);
            d += `${E} 1 user user ${I} ${L} ${b}${C}
`;
          } else d += `${b}
`;
        } catch {
          m += `ls: cannot access '${b}': No such file or directory
`, h = 2;
        }
        continue;
      }
      if (b.includes("*") || b.includes("?") || b.includes("[")) {
        let y = await Cb(b, t2, r2, s2, i2, l, o2, c);
        d += y.stdout, m += y.stderr, y.exitCode !== 0 && (h = y.exitCode);
      } else {
        let y = await fc(b, t2, r2, s2, i2, a, p.length > 1, l, o2, c);
        d += y.stdout, m += y.stderr, y.exitCode !== 0 && (h = y.exitCode);
      }
    }
    return { stdout: d, stderr: m, exitCode: h };
  } };
});
var hc = {};
V(hc, { mkdirCommand: () => kb });
var Nb, kb, mc = v(() => {
  wt();
  Oe();
  Nb = { recursive: { short: "p", long: "parents", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, kb = { name: "mkdir", async execute(e2, t2) {
    let n2 = fe("mkdir", e2, Nb);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.recursive, s2 = n2.result.flags.verbose, i2 = n2.result.positional;
    if (i2.length === 0) return { stdout: "", stderr: `mkdir: missing operand
`, exitCode: 1 };
    let o2 = "", a = "", l = 0;
    for (let c of i2) try {
      let u = t2.fs.resolvePath(t2.cwd, c);
      await t2.fs.mkdir(u, { recursive: r2 }), s2 && (o2 += `mkdir: created directory '${c}'
`);
    } catch (u) {
      let f2 = Ne(u);
      f2.includes("ENOENT") || f2.includes("no such file") ? a += `mkdir: cannot create directory '${c}': No such file or directory
` : f2.includes("EEXIST") || f2.includes("already exists") ? a += `mkdir: cannot create directory '${c}': File exists
` : a += `mkdir: cannot create directory '${c}': ${f2}
`, l = 1;
    }
    return { stdout: o2, stderr: a, exitCode: l };
  } };
});
var bc = {};
V(bc, { rmdirCommand: () => Ib });
async function Rb(e2, t2, n2, r2) {
  let s2 = "", i2 = "", a = e2.fs.resolvePath(e2.cwd, t2), l = await gc(e2, a, t2, r2);
  if (s2 += l.stdout, i2 += l.stderr, l.exitCode !== 0) return { stdout: s2, stderr: i2, exitCode: l.exitCode };
  if (n2) {
    let c = a, u = t2;
    for (; ; ) {
      let f2 = yc(c), p = yc(u);
      if (f2 === c || f2 === "/" || f2 === "." || p === "." || p === "") break;
      let d = await gc(e2, f2, p, r2);
      if (s2 += d.stdout, d.exitCode !== 0) break;
      c = f2, u = p;
    }
  }
  return { stdout: s2, stderr: i2, exitCode: 0 };
}
async function gc(e2, t2, n2, r2) {
  try {
    if (!await e2.fs.exists(t2)) return { stdout: "", stderr: `rmdir: failed to remove '${n2}': No such file or directory
`, exitCode: 1 };
    if (!(await e2.fs.stat(t2)).isDirectory) return { stdout: "", stderr: `rmdir: failed to remove '${n2}': Not a directory
`, exitCode: 1 };
    if ((await e2.fs.readdir(t2)).length > 0) return { stdout: "", stderr: `rmdir: failed to remove '${n2}': Directory not empty
`, exitCode: 1 };
    await e2.fs.rm(t2, { recursive: false, force: false });
    let a = "";
    return r2 && (a = `rmdir: removing directory, '${n2}'
`), { stdout: a, stderr: "", exitCode: 0 };
  } catch (s2) {
    let i2 = Ne(s2);
    return { stdout: "", stderr: `rmdir: failed to remove '${n2}': ${i2}
`, exitCode: 1 };
  }
}
function yc(e2) {
  let t2 = e2.replace(/\/+$/, ""), n2 = t2.lastIndexOf("/");
  return n2 === -1 ? "." : n2 === 0 ? "/" : t2.substring(0, n2);
}
var vb, $b, Ib, wc = v(() => {
  wt();
  Oe();
  vb = `Usage: rmdir [-pv] DIRECTORY...
Remove empty directories.

Options:
  -p, --parents   Remove DIRECTORY and its ancestors
  -v, --verbose   Output a diagnostic for every directory processed`, $b = { parents: { short: "p", long: "parents", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" }, help: { long: "help", type: "boolean" } }, Ib = { name: "rmdir", async execute(e2, t2) {
    let n2 = fe("rmdir", e2, $b);
    if (!n2.ok) return n2.error;
    if (n2.result.flags.help) return { stdout: `${vb}
`, stderr: "", exitCode: 0 };
    let r2 = n2.result.flags.parents, s2 = n2.result.flags.verbose, i2 = n2.result.positional;
    if (i2.length === 0) return { stdout: "", stderr: `rmdir: missing operand
`, exitCode: 1 };
    let o2 = "", a = "", l = 0;
    for (let c of i2) {
      let u = await Rb(t2, c, r2, s2);
      o2 += u.stdout, a += u.stderr, u.exitCode !== 0 && (l = u.exitCode);
    }
    return { stdout: o2, stderr: a, exitCode: l };
  } };
});
var xc = {};
V(xc, { touchCommand: () => Tb });
function Pb(e2) {
  let t2 = e2.replace(/\//g, "-"), n2 = new Date(t2);
  if (!Number.isNaN(n2.getTime())) return n2;
  let r2 = t2.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (r2) {
    let [, i2, o2, a] = r2;
    if (n2 = new Date(Number.parseInt(i2, 10), Number.parseInt(o2, 10) - 1, Number.parseInt(a, 10)), !Number.isNaN(n2.getTime())) return n2;
  }
  let s2 = t2.match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})$/);
  if (s2) {
    let [, i2, o2, a, l, c, u] = s2;
    if (n2 = new Date(Number.parseInt(i2, 10), Number.parseInt(o2, 10) - 1, Number.parseInt(a, 10), Number.parseInt(l, 10), Number.parseInt(c, 10), Number.parseInt(u, 10)), !Number.isNaN(n2.getTime())) return n2;
  }
  return null;
}
var Tb, Ec = v(() => {
  wt();
  X();
  Tb = { name: "touch", async execute(e2, t2) {
    let n2 = [], r2 = null, s2 = false;
    for (let l = 0; l < e2.length; l++) {
      let c = e2[l];
      if (c === "--") {
        n2.push(...e2.slice(l + 1));
        break;
      } else if (c === "-d" || c === "--date") {
        if (l + 1 >= e2.length) return { stdout: "", stderr: `touch: option requires an argument -- 'd'
`, exitCode: 1 };
        r2 = e2[++l];
      } else if (c.startsWith("--date=")) r2 = c.slice(7);
      else if (c === "-c" || c === "--no-create") s2 = true;
      else if (c === "-a" || c === "-m" || c === "-r" || c === "-t") (c === "-r" || c === "-t") && l++;
      else {
        if (c.startsWith("--")) return G("touch", c);
        if (c.startsWith("-") && c.length > 1) {
          let u = false;
          for (let f2 of c.slice(1)) if (f2 === "c") s2 = true;
          else if (!(f2 === "a" || f2 === "m")) if (f2 === "d") {
            if (l + 1 >= e2.length) return { stdout: "", stderr: `touch: option requires an argument -- 'd'
`, exitCode: 1 };
            r2 = e2[++l], u = true;
            break;
          } else if (f2 === "r" || f2 === "t") {
            l++, u = true;
            break;
          } else return G("touch", `-${f2}`);
          if (u) continue;
        } else n2.push(c);
      }
    }
    if (n2.length === 0) return { stdout: "", stderr: `touch: missing file operand
`, exitCode: 1 };
    let i2 = null;
    if (r2 !== null && (i2 = Pb(r2), i2 === null)) return { stdout: "", stderr: `touch: invalid date format '${r2}'
`, exitCode: 1 };
    let o2 = "", a = 0;
    for (let l of n2) try {
      let c = t2.fs.resolvePath(t2.cwd, l);
      if (!await t2.fs.exists(c)) {
        if (s2) continue;
        await t2.fs.writeFile(c, "");
      }
      let f2 = i2 ?? /* @__PURE__ */ new Date();
      await t2.fs.utimes(c, f2, f2);
    } catch (c) {
      o2 += `touch: cannot touch '${l}': ${Ne(c)}
`, a = 1;
    }
    return { stdout: "", stderr: o2, exitCode: a };
  } };
});
var Sc = {};
V(Sc, { rmCommand: () => Db });
var Ob, Db, Ac = v(() => {
  wt();
  Oe();
  Ob = { recursive: { short: "r", long: "recursive", type: "boolean" }, recursiveUpper: { short: "R", type: "boolean" }, force: { short: "f", long: "force", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, Db = { name: "rm", async execute(e2, t2) {
    let n2 = fe("rm", e2, Ob);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.recursive || n2.result.flags.recursiveUpper, s2 = n2.result.flags.force, i2 = n2.result.flags.verbose, o2 = n2.result.positional;
    if (o2.length === 0) return s2 ? { stdout: "", stderr: "", exitCode: 0 } : { stdout: "", stderr: `rm: missing operand
`, exitCode: 1 };
    let a = "", l = "", c = 0;
    for (let u of o2) try {
      let f2 = t2.fs.resolvePath(t2.cwd, u);
      if ((await t2.fs.stat(f2)).isDirectory && !r2) {
        l += `rm: cannot remove '${u}': Is a directory
`, c = 1;
        continue;
      }
      await t2.fs.rm(f2, { recursive: r2, force: s2 }), i2 && (a += `removed '${u}'
`);
    } catch (f2) {
      if (!s2) {
        let p = Ne(f2);
        p.includes("ENOENT") || p.includes("no such file") ? l += `rm: cannot remove '${u}': No such file or directory
` : p.includes("ENOTEMPTY") || p.includes("not empty") ? l += `rm: cannot remove '${u}': Directory not empty
` : l += `rm: cannot remove '${u}': ${p}
`, c = 1;
      }
    }
    return { stdout: a, stderr: l, exitCode: c };
  } };
});
var Cc = {};
V(Cc, { cpCommand: () => Lb });
var Fb, _b, Lb, Nc = v(() => {
  wt();
  Oe();
  X();
  Fb = { name: "cp", summary: "copy files and directories", usage: "cp [OPTION]... SOURCE... DEST", options: ["-r, -R, --recursive  copy directories recursively", "-n, --no-clobber     do not overwrite an existing file", "-p, --preserve       preserve file attributes", "-v, --verbose        explain what is being done", "    --help           display this help and exit"] }, _b = { recursive: { short: "r", long: "recursive", type: "boolean" }, recursiveUpper: { short: "R", type: "boolean" }, noClobber: { short: "n", long: "no-clobber", type: "boolean" }, preserve: { short: "p", long: "preserve", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, Lb = { name: "cp", async execute(e2, t2) {
    if (_(e2)) return F$3(Fb);
    let n2 = fe("cp", e2, _b);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.recursive || n2.result.flags.recursiveUpper, s2 = n2.result.flags.noClobber;
    n2.result.flags.preserve;
    let o2 = n2.result.flags.verbose, a = n2.result.positional;
    if (a.length < 2) return { stdout: "", stderr: `cp: missing destination file operand
`, exitCode: 1 };
    let l = a.pop() ?? "", c = a, u = t2.fs.resolvePath(t2.cwd, l), f2 = "", p = "", d = 0, m = false;
    try {
      m = (await t2.fs.stat(u)).isDirectory;
    } catch {
    }
    if (c.length > 1 && !m) return { stdout: "", stderr: `cp: target '${l}' is not a directory
`, exitCode: 1 };
    for (let h of c) try {
      let g = t2.fs.resolvePath(t2.cwd, h), b = await t2.fs.stat(g), y = u;
      if (m) {
        let w = h.split("/").pop() || h;
        y = u === "/" ? `/${w}` : `${u}/${w}`;
      }
      if (b.isDirectory && !r2) {
        p += `cp: -r not specified; omitting directory '${h}'
`, d = 1;
        continue;
      }
      if (s2) try {
        await t2.fs.stat(y);
        continue;
      } catch {
      }
      await t2.fs.cp(g, y, { recursive: r2 }), o2 && (f2 += `'${h}' -> '${y}'
`);
    } catch (g) {
      let b = Ne(g);
      b.includes("ENOENT") || b.includes("no such file") ? p += `cp: cannot stat '${h}': No such file or directory
` : p += `cp: cannot copy '${h}': ${b}
`, d = 1;
    }
    return { stdout: f2, stderr: p, exitCode: d };
  } };
});
var kc = {};
V(kc, { mvCommand: () => Bb });
var Mb, Wb, Bb, vc = v(() => {
  wt();
  Oe();
  X();
  Mb = { name: "mv", summary: "move (rename) files", usage: "mv [OPTION]... SOURCE... DEST", options: ["-f, --force       do not prompt before overwriting", "-n, --no-clobber  do not overwrite an existing file", "-v, --verbose     explain what is being done", "    --help        display this help and exit"] }, Wb = { force: { short: "f", long: "force", type: "boolean" }, noClobber: { short: "n", long: "no-clobber", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, Bb = { name: "mv", async execute(e2, t2) {
    if (_(e2)) return F$3(Mb);
    let n2 = fe("mv", e2, Wb);
    if (!n2.ok) return n2.error;
    n2.result.flags.force;
    let s2 = n2.result.flags.noClobber, i2 = n2.result.flags.verbose, o2 = n2.result.positional;
    if (o2.length < 2) return { stdout: "", stderr: `mv: missing destination file operand
`, exitCode: 1 };
    let a = o2.pop() ?? "", l = o2, c = t2.fs.resolvePath(t2.cwd, a), u = "", f2 = "", p = 0, d = false;
    try {
      d = (await t2.fs.stat(c)).isDirectory;
    } catch {
    }
    if (l.length > 1 && !d) return { stdout: "", stderr: `mv: target '${a}' is not a directory
`, exitCode: 1 };
    for (let m of l) try {
      let h = t2.fs.resolvePath(t2.cwd, m), g = c;
      if (d) {
        let b = m.split("/").pop() || m;
        g = c === "/" ? `/${b}` : `${c}/${b}`;
      }
      if (s2) try {
        await t2.fs.stat(g);
        continue;
      } catch {
      }
      if (await t2.fs.mv(h, g), i2) {
        let b = d ? `${a}/${m.split("/").pop() || m}` : a;
        u += `renamed '${m}' -> '${b}'
`;
      }
    } catch (h) {
      let g = Ne(h);
      g.includes("ENOENT") || g.includes("no such file") ? f2 += `mv: cannot stat '${m}': No such file or directory
` : f2 += `mv: cannot move '${m}': ${g}
`, p = 1;
    }
    return { stdout: u, stderr: f2, exitCode: p };
  } };
});
var $c = {};
V($c, { lnCommand: () => zb });
var Ub, zb, Ic = v(() => {
  X();
  Ub = { name: "ln", summary: "make links between files", usage: "ln [OPTIONS] TARGET LINK_NAME", options: ["-s      create a symbolic link instead of a hard link", "-f      remove existing destination files", "-n      treat LINK_NAME as a normal file if it is a symbolic link to a directory", "-v      print name of each linked file", "    --help display this help and exit"] }, zb = { name: "ln", async execute(e2, t2) {
    if (_(e2)) return F$3(Ub);
    let n2 = false, r2 = false, s2 = false, i2 = 0;
    for (; i2 < e2.length && e2[i2].startsWith("-"); ) {
      let f2 = e2[i2];
      if (f2 === "-s" || f2 === "--symbolic") n2 = true, i2++;
      else if (f2 === "-f" || f2 === "--force") r2 = true, i2++;
      else if (f2 === "-v" || f2 === "--verbose") s2 = true, i2++;
      else if (f2 === "-n" || f2 === "--no-dereference") i2++;
      else if (/^-[sfvn]+$/.test(f2)) f2.includes("s") && (n2 = true), f2.includes("f") && (r2 = true), f2.includes("v") && (s2 = true), i2++;
      else if (f2 === "--") {
        i2++;
        break;
      } else return { stdout: "", stderr: `ln: invalid option -- '${f2.slice(1)}'
`, exitCode: 1 };
    }
    let o2 = e2.slice(i2);
    if (o2.length < 2) return { stdout: "", stderr: `ln: missing file operand
`, exitCode: 1 };
    let a = o2[0], l = o2[1], c = t2.fs.resolvePath(t2.cwd, l);
    if (await t2.fs.exists(c)) if (r2) try {
      await t2.fs.rm(c, { force: true });
    } catch {
      return { stdout: "", stderr: `ln: cannot remove '${l}': Permission denied
`, exitCode: 1 };
    }
    else return { stdout: "", stderr: `ln: failed to create ${n2 ? "symbolic " : ""}link '${l}': File exists
`, exitCode: 1 };
    try {
      if (n2) await t2.fs.symlink(a, c);
      else {
        let f2 = t2.fs.resolvePath(t2.cwd, a);
        if (!await t2.fs.exists(f2)) return { stdout: "", stderr: `ln: failed to access '${a}': No such file or directory
`, exitCode: 1 };
        await t2.fs.link(f2, c);
      }
    } catch (f2) {
      let p = f2;
      return p.message.includes("EPERM") ? { stdout: "", stderr: `ln: '${a}': hard link not allowed for directory
`, exitCode: 1 } : { stdout: "", stderr: `ln: ${p.message}
`, exitCode: 1 };
    }
    let u = "";
    return s2 && (u = `'${l}' -> '${a}'
`), { stdout: u, stderr: "", exitCode: 0 };
  } };
});
var Pc = {};
V(Pc, { chmodCommand: () => Hb });
async function Rc(e2, t2, n2, r2, s2) {
  let i2 = "", o2 = await e2.fs.readdir(t2);
  for (let a of o2) {
    let l = t2 === "/" ? `/${a}` : `${t2}/${a}`, c;
    if (n2 !== void 0) c = n2;
    else if (r2 !== void 0) {
      let f2 = await e2.fs.stat(l);
      c = Ui(r2, f2.mode);
    } else c = 420;
    await e2.fs.chmod(l, c), s2 && (i2 += `mode of '${l}' changed to ${c.toString(8).padStart(4, "0")}
`), (await e2.fs.stat(l)).isDirectory && (i2 += await Rc(e2, l, n2, r2, s2));
  }
  return i2;
}
function Ui(e2, t2 = 420) {
  if (/^[0-7]+$/.test(e2)) return parseInt(e2, 8);
  let n2 = t2 & 4095, r2 = e2.split(",");
  for (let s2 of r2) {
    let i2 = s2.match(/^([ugoa]*)([+\-=])([rwxXst]*)$/);
    if (!i2) throw new Error(`Invalid mode: ${e2}`);
    let o2 = i2[1] || "a", a = i2[2], l = i2[3];
    (o2 === "a" || o2 === "") && (o2 = "ugo");
    let c = 0;
    l.includes("r") && (c |= 4), l.includes("w") && (c |= 2), (l.includes("x") || l.includes("X")) && (c |= 1);
    let u = 0;
    l.includes("s") && (o2.includes("u") && (u |= 2048), o2.includes("g") && (u |= 1024)), l.includes("t") && (u |= 512);
    for (let f2 of o2) {
      let p = 0;
      f2 === "u" ? p = 6 : f2 === "g" ? p = 3 : f2 === "o" && (p = 0);
      let d = c << p;
      a === "+" ? n2 |= d : a === "-" ? n2 &= ~d : a === "=" && (n2 &= ~(7 << p), n2 |= d);
    }
    a === "+" ? n2 |= u : a === "-" ? n2 &= ~u : a === "=" && (l.includes("s") && (o2.includes("u") && (n2 &= -2049, n2 |= u & 2048), o2.includes("g") && (n2 &= -1025, n2 |= u & 1024)), l.includes("t") && (n2 &= -513, n2 |= u & 512));
  }
  return n2;
}
var jb, Hb, Tc = v(() => {
  X();
  jb = { name: "chmod", summary: "change file mode bits", usage: "chmod [OPTIONS] MODE FILE...", options: ["-R      change files recursively", "-v      output a diagnostic for every file processed", "    --help display this help and exit"] }, Hb = { name: "chmod", async execute(e2, t2) {
    if (_(e2)) return F$3(jb);
    if (e2.length < 2) return { stdout: "", stderr: `chmod: missing operand
`, exitCode: 1 };
    let n2 = false, r2 = false, s2 = 0;
    for (; s2 < e2.length && e2[s2].startsWith("-"); ) {
      let p = e2[s2];
      if (p === "-R" || p === "--recursive") n2 = true, s2++;
      else if (p === "-v" || p === "--verbose") r2 = true, s2++;
      else if (p === "--") {
        s2++;
        break;
      } else {
        if (/^[+-]?[rwxugo]+/.test(p) || /^\d+$/.test(p)) break;
        if (/^-[Rv]+$/.test(p)) {
          p.includes("R") && (n2 = true), p.includes("v") && (r2 = true), s2++;
          continue;
        }
        return { stdout: "", stderr: `chmod: invalid option -- '${p.slice(1)}'
`, exitCode: 1 };
      }
    }
    if (e2.length - s2 < 2) return { stdout: "", stderr: `chmod: missing operand
`, exitCode: 1 };
    let i2 = e2[s2], o2 = e2.slice(s2 + 1), a = /^[0-7]+$/.test(i2), l;
    if (a) l = parseInt(i2, 8);
    else try {
      Ui(i2, 420);
    } catch {
      return { stdout: "", stderr: `chmod: invalid mode: '${i2}'
`, exitCode: 1 };
    }
    let c = "", u = "", f2 = false;
    for (let p of o2) {
      let d = t2.fs.resolvePath(t2.cwd, p);
      try {
        let m;
        if (a && l !== void 0) m = l;
        else {
          let h = await t2.fs.stat(d);
          m = Ui(i2, h.mode);
        }
        if (await t2.fs.chmod(d, m), r2 && (c += `mode of '${p}' changed to ${m.toString(8).padStart(4, "0")}
`), n2 && (await t2.fs.stat(d)).isDirectory) {
          let g = await Rc(t2, d, a ? l : void 0, a ? void 0 : i2, r2);
          c += g;
        }
      } catch {
        u += `chmod: cannot access '${p}': No such file or directory
`, f2 = true;
      }
    }
    return { stdout: c, stderr: u, exitCode: f2 ? 1 : 0 };
  } };
});
var Oc = {};
V(Oc, { pwdCommand: () => Vb });
var Vb, Dc = v(() => {
  Vb = { name: "pwd", async execute(e2, t2) {
    let n2 = false;
    for (let s2 of e2) if (s2 === "-P") n2 = true;
    else if (s2 === "-L") n2 = false;
    else {
      if (s2 === "--") break;
      s2.startsWith("-");
    }
    let r2 = t2.cwd;
    if (n2) try {
      r2 = await t2.fs.realpath(t2.cwd);
    } catch {
    }
    return { stdout: `${r2}
`, stderr: "", exitCode: 0 };
  } };
});
var Fc = {};
V(Fc, { readlinkCommand: () => Gb });
var qb, Gb, _c = v(() => {
  X();
  qb = { name: "readlink", summary: "print resolved symbolic links or canonical file names", usage: "readlink [OPTIONS] FILE...", options: ["-f      canonicalize by following every symlink in every component of the given name recursively", "    --help display this help and exit"] }, Gb = { name: "readlink", async execute(e2, t2) {
    if (_(e2)) return F$3(qb);
    let n2 = false, r2 = 0;
    for (; r2 < e2.length && e2[r2].startsWith("-"); ) {
      let a = e2[r2];
      if (a === "-f" || a === "--canonicalize") n2 = true, r2++;
      else if (a === "--") {
        r2++;
        break;
      } else return { stdout: "", stderr: `readlink: invalid option -- '${a.slice(1)}'
`, exitCode: 1 };
    }
    let s2 = e2.slice(r2);
    if (s2.length === 0) return { stdout: "", stderr: `readlink: missing operand
`, exitCode: 1 };
    let i2 = "", o2 = false;
    for (let a of s2) {
      let l = t2.fs.resolvePath(t2.cwd, a);
      try {
        if (n2) {
          let c = l, u = /* @__PURE__ */ new Set();
          for (; !u.has(c); ) {
            u.add(c);
            try {
              let f2 = await t2.fs.readlink(c);
              if (f2.startsWith("/")) c = f2;
              else {
                let p = c.substring(0, c.lastIndexOf("/")) || "/";
                c = t2.fs.resolvePath(p, f2);
              }
            } catch {
              break;
            }
          }
          i2 += `${c}
`;
        } else {
          let c = await t2.fs.readlink(l);
          i2 += `${c}
`;
        }
      } catch {
        n2 ? i2 += `${l}
` : o2 = true;
      }
    }
    return { stdout: i2, stderr: "", exitCode: o2 ? 1 : 0 };
  } };
});
function ns(e2, t2) {
  let n2 = 10, r2 = null, s2 = false, i2 = false, o2 = false, a = [];
  for (let l = 0; l < e2.length; l++) {
    let c = e2[l];
    if (c === "-n" && l + 1 < e2.length) {
      let u = e2[++l];
      t2 === "tail" && u.startsWith("+") ? (o2 = true, n2 = parseInt(u.slice(1), 10)) : n2 = parseInt(u, 10);
    } else if (t2 === "tail" && c.startsWith("-n+")) o2 = true, n2 = parseInt(c.slice(3), 10);
    else if (c.startsWith("-n")) n2 = parseInt(c.slice(2), 10);
    else if (c === "-c" && l + 1 < e2.length) r2 = parseInt(e2[++l], 10);
    else if (c.startsWith("-c")) r2 = parseInt(c.slice(2), 10);
    else if (c.startsWith("--bytes=")) r2 = parseInt(c.slice(8), 10);
    else if (c.startsWith("--lines=")) n2 = parseInt(c.slice(8), 10);
    else if (c === "-q" || c === "--quiet" || c === "--silent") s2 = true;
    else if (c === "-v" || c === "--verbose") i2 = true;
    else if (c.match(/^-\d+$/)) n2 = parseInt(c.slice(1), 10);
    else {
      if (c.startsWith("--")) return { ok: false, error: G(t2, c) };
      if (c.startsWith("-") && c !== "-") return { ok: false, error: G(t2, c) };
      a.push(c);
    }
  }
  return r2 !== null && (Number.isNaN(r2) || r2 < 0) ? { ok: false, error: { stdout: "", stderr: `${t2}: invalid number of bytes
`, exitCode: 1 } } : Number.isNaN(n2) || n2 < 0 ? { ok: false, error: { stdout: "", stderr: `${t2}: invalid number of lines
`, exitCode: 1 } } : { ok: true, options: { lines: n2, bytes: r2, quiet: s2, verbose: i2, files: a, fromLine: o2 } };
}
async function rs(e2, t2, n2, r2) {
  let { quiet: s2, verbose: i2, files: o2 } = t2;
  if (o2.length === 0) return { stdout: r2(e2.stdin), stderr: "", exitCode: 0 };
  let a = "", l = "", c = 0, u = i2 || !s2 && o2.length > 1, f2 = 0;
  for (let p = 0; p < o2.length; p++) {
    let d = o2[p];
    try {
      let m = e2.fs.resolvePath(e2.cwd, d), h = await e2.fs.readFile(m);
      u && (f2 > 0 && (a += `
`), a += `==> ${d} <==
`), a += r2(h), f2++;
    } catch {
      l += `${n2}: ${d}: No such file or directory
`, c = 1;
    }
  }
  return { stdout: a, stderr: l, exitCode: c };
}
function Lc(e2, t2, n2) {
  if (n2 !== null) return e2.slice(0, n2);
  if (t2 === 0) return "";
  let r2 = 0, s2 = 0, i2 = e2.length;
  for (; r2 < i2 && s2 < t2; ) {
    let o2 = e2.indexOf(`
`, r2);
    if (o2 === -1) return `${e2}
`;
    s2++, r2 = o2 + 1;
  }
  return r2 > 0 ? e2.slice(0, r2) : "";
}
function Mc(e2, t2, n2, r2) {
  if (n2 !== null) return e2.slice(-n2);
  let s2 = e2.length;
  if (s2 === 0) return "";
  if (r2) {
    let l = 0, c = 1;
    for (; l < s2 && c < t2; ) {
      let f2 = e2.indexOf(`
`, l);
      if (f2 === -1) break;
      c++, l = f2 + 1;
    }
    let u = e2.slice(l);
    return u.endsWith(`
`) ? u : `${u}
`;
  }
  if (t2 === 0) return "";
  let i2 = s2 - 1;
  e2[i2] === `
` && i2--;
  let o2 = 0;
  for (; i2 >= 0 && o2 < t2; ) {
    if (e2[i2] === `
` && (o2++, o2 === t2)) {
      i2++;
      break;
    }
    i2--;
  }
  i2 < 0 && (i2 = 0);
  let a = e2.slice(i2);
  return e2[s2 - 1] === `
` ? a : `${a}
`;
}
var zi = v(() => {
  X();
});
var Wc = {};
V(Wc, { headCommand: () => Qb });
var Zb, Qb, Bc = v(() => {
  X();
  zi();
  Zb = { name: "head", summary: "output the first part of files", usage: "head [OPTION]... [FILE]...", options: ["-c, --bytes=NUM    print the first NUM bytes", "-n, --lines=NUM    print the first NUM lines (default 10)", "-q, --quiet        never print headers giving file names", "-v, --verbose      always print headers giving file names", "    --help         display this help and exit"] }, Qb = { name: "head", async execute(e2, t2) {
    if (_(e2)) return F$3(Zb);
    let n2 = ns(e2, "head");
    if (!n2.ok) return n2.error;
    let { lines: r2, bytes: s2 } = n2.options;
    return rs(t2, n2.options, "head", (i2) => Lc(i2, r2, s2));
  } };
});
var Uc = {};
V(Uc, { tailCommand: () => Xb });
var Kb, Xb, zc = v(() => {
  zi();
  X();
  Kb = { name: "tail", summary: "output the last part of files", usage: "tail [OPTION]... [FILE]...", options: ["-c, --bytes=NUM    print the last NUM bytes", "-n, --lines=NUM    print the last NUM lines (default 10)", "-n +NUM            print starting from line NUM", "-q, --quiet        never print headers giving file names", "-v, --verbose      always print headers giving file names", "    --help         display this help and exit"] }, Xb = { name: "tail", async execute(e2, t2) {
    if (_(e2)) return F$3(Kb);
    let n2 = ns(e2, "tail");
    if (!n2.ok) return n2.error;
    let { lines: r2, bytes: s2, fromLine: i2 } = n2.options;
    return rs(t2, n2.options, "tail", (o2) => Mc(o2, r2, s2, i2 ?? false));
  } };
});
var Hc = {};
V(Hc, { wcCommand: () => ew });
function jc(e2) {
  let t2 = e2.length, n2 = 0, r2 = 0, s2 = false;
  for (let i2 = 0; i2 < t2; i2++) {
    let o2 = e2[i2];
    o2 === `
` ? (n2++, s2 && (r2++, s2 = false)) : o2 === " " || o2 === "	" || o2 === "\r" ? s2 && (r2++, s2 = false) : s2 = true;
  }
  return s2 && r2++, { lines: n2, words: r2, chars: t2 };
}
function ji(e2, t2, n2, r2, s2, i2) {
  let o2 = [];
  t2 && o2.push(String(e2.lines).padStart(i2)), n2 && o2.push(String(e2.words).padStart(i2)), r2 && o2.push(String(e2.chars).padStart(i2));
  let a = o2.join(" ");
  return s2 && (a += ` ${s2}`), a;
}
var Jb, Yb, ew, Vc = v(() => {
  Oe();
  pn();
  X();
  Jb = { name: "wc", summary: "print newline, word, and byte counts for each file", usage: "wc [OPTION]... [FILE]...", options: ["-c, --bytes      print the byte counts", "-m, --chars      print the character counts", "-l, --lines      print the newline counts", "-w, --words      print the word counts", "    --help       display this help and exit"] }, Yb = { lines: { short: "l", long: "lines", type: "boolean" }, words: { short: "w", long: "words", type: "boolean" }, bytes: { short: "c", long: "bytes", type: "boolean" }, chars: { short: "m", long: "chars", type: "boolean" } }, ew = { name: "wc", async execute(e2, t2) {
    if (_(e2)) return F$3(Jb);
    let n2 = fe("wc", e2, Yb);
    if (!n2.ok) return n2.error;
    let { lines: r2, words: s2 } = n2.result.flags, i2 = n2.result.flags.bytes || n2.result.flags.chars, o2 = n2.result.positional;
    !r2 && !s2 && !i2 && (r2 = s2 = i2 = true);
    let a = await fn(t2, o2, { cmdName: "wc", stopOnError: false });
    if (o2.length === 0) {
      let b = jc(a.files[0].content);
      return { stdout: `${ji(b, r2, s2, i2, "", 0)}
`, stderr: "", exitCode: 0 };
    }
    let l = [], c = 0, u = 0, f2 = 0;
    for (let { filename: b, content: y } of a.files) {
      let w = jc(y);
      c += w.lines, u += w.words, f2 += w.chars, l.push({ filename: b, stats: w });
    }
    let p = o2.length > 1 ? c : Math.max(...l.map((b) => b.stats.lines)), d = o2.length > 1 ? u : Math.max(...l.map((b) => b.stats.words)), m = o2.length > 1 ? f2 : Math.max(...l.map((b) => b.stats.chars)), h = o2.length > 1 ? 3 : 0;
    r2 && (h = Math.max(h, String(p).length)), s2 && (h = Math.max(h, String(d).length)), i2 && (h = Math.max(h, String(m).length));
    let g = "";
    for (let { filename: b, stats: y } of l) g += `${ji(y, r2, s2, i2, b, h)}
`;
    return o2.length > 1 && (g += `${ji({ lines: c, words: u, chars: f2 }, r2, s2, i2, "total", h)}
`), { stdout: g, stderr: a.stderr, exitCode: a.exitCode };
  } };
});
var Gc = {};
V(Gc, { statCommand: () => rw });
function qc(e2, t2) {
  let n2 = t2 ? "d" : "-", r2 = [e2 & 256 ? "r" : "-", e2 & 128 ? "w" : "-", e2 & 64 ? "x" : "-", e2 & 32 ? "r" : "-", e2 & 16 ? "w" : "-", e2 & 8 ? "x" : "-", e2 & 4 ? "r" : "-", e2 & 2 ? "w" : "-", e2 & 1 ? "x" : "-"];
  return n2 + r2.join("");
}
var tw, nw, rw, Zc = v(() => {
  Oe();
  X();
  tw = { name: "stat", summary: "display file or file system status", usage: "stat [OPTION]... FILE...", options: ["-c FORMAT   use the specified FORMAT instead of the default", "    --help  display this help and exit"] }, nw = { format: { short: "c", type: "string" } }, rw = { name: "stat", async execute(e2, t2) {
    if (_(e2)) return F$3(tw);
    let n2 = fe("stat", e2, nw);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.format ?? null, s2 = n2.result.positional;
    if (s2.length === 0) return { stdout: "", stderr: `stat: missing operand
`, exitCode: 1 };
    let i2 = "", o2 = "", a = false;
    for (let l of s2) {
      let c = t2.fs.resolvePath(t2.cwd, l);
      try {
        let u = await t2.fs.stat(c);
        if (r2) {
          let f2 = r2, p = u.mode.toString(8), d = qc(u.mode, u.isDirectory);
          f2 = f2.replace(/%n/g, l), f2 = f2.replace(/%N/g, `'${l}'`), f2 = f2.replace(/%s/g, String(u.size)), f2 = f2.replace(/%F/g, u.isDirectory ? "directory" : "regular file"), f2 = f2.replace(/%a/g, p), f2 = f2.replace(/%A/g, d), f2 = f2.replace(/%u/g, "1000"), f2 = f2.replace(/%U/g, "user"), f2 = f2.replace(/%g/g, "1000"), f2 = f2.replace(/%G/g, "group"), i2 += `${f2}
`;
        } else {
          let f2 = u.mode.toString(8).padStart(4, "0"), p = qc(u.mode, u.isDirectory);
          i2 += `  File: ${l}
`, i2 += `  Size: ${u.size}		Blocks: ${Math.ceil(u.size / 512)}
`, i2 += `Access: (${f2}/${p})
`, i2 += `Modify: ${u.mtime.toISOString()}
`;
        }
      } catch {
        o2 += `stat: cannot stat '${l}': No such file or directory
`, a = true;
      }
    }
    return { stdout: i2, stderr: o2, exitCode: a ? 1 : 0 };
  } };
});
function Ye(e2, t2, n2) {
  let r2 = typeof n2 == "boolean" ? { ignoreCase: n2 } : n2 ?? {}, s2 = t2;
  r2.stripQuotes && (s2.startsWith('"') && s2.endsWith('"') || s2.startsWith("'") && s2.endsWith("'")) && (s2 = s2.slice(1, -1));
  let i2 = r2.ignoreCase ? `i:${s2}` : s2, o2 = Qc.get(i2);
  return o2 || (o2 = sw(s2, r2.ignoreCase), Qc.set(i2, o2)), o2.test(e2);
}
function sw(e2, t2) {
  let n2 = "^";
  for (let r2 = 0; r2 < e2.length; r2++) {
    let s2 = e2[r2];
    if (s2 === "*") n2 += ".*";
    else if (s2 === "?") n2 += ".";
    else if (s2 === "[") {
      let i2 = r2 + 1;
      for (; i2 < e2.length && e2[i2] !== "]"; ) i2++;
      n2 += e2.slice(r2, i2 + 1), r2 = i2;
    } else s2 === "." || s2 === "+" || s2 === "^" || s2 === "$" || s2 === "{" || s2 === "}" || s2 === "(" || s2 === ")" || s2 === "|" || s2 === "\\" ? n2 += `\\${s2}` : n2 += s2;
  }
  return n2 += "$", new RegExp(n2, t2 ? "i" : "");
}
var Qc, Hi = v(() => {
  Qc = /* @__PURE__ */ new Map();
});
function Kc(e2, t2) {
  return e2.replace(/\$(&|\d+|<([^>]+)>)/g, (n2, r2, s2) => {
    var _a3;
    if (r2 === "&") return t2[0];
    if (s2 !== void 0) return ((_a3 = t2.groups) == null ? void 0 : _a3[s2]) ?? "";
    let i2 = parseInt(r2, 10);
    return t2[i2] ?? "";
  });
}
function Dn(e2, t2, n2 = {}) {
  let { invertMatch: r2 = false, showLineNumbers: s2 = false, countOnly: i2 = false, countMatches: o2 = false, filename: a = "", onlyMatching: l = false, beforeContext: c = 0, afterContext: u = 0, maxCount: f2 = 0, contextSeparator: p = "--", showColumn: d = false, vimgrep: m = false, showByteOffset: h = false, replace: g = null, passthru: b = false, multiline: y = false, kResetGroup: w } = n2;
  if (y) return iw(e2, t2, { invertMatch: r2, showLineNumbers: s2, countOnly: i2, countMatches: o2, filename: a, onlyMatching: l, beforeContext: c, afterContext: u, maxCount: f2, contextSeparator: p, showColumn: d, showByteOffset: h, replace: g, kResetGroup: w });
  let E = e2.split(`
`), C = E.length, A = C > 0 && E[C - 1] === "" ? C - 1 : C;
  if (i2 || o2) {
    let N2 = 0, P = (o2 || l) && !r2;
    for (let R2 = 0; R2 < A; R2++) if (t2.lastIndex = 0, P) for (let T = t2.exec(E[R2]); T !== null; T = t2.exec(E[R2])) N2++, T[0].length === 0 && t2.lastIndex++;
    else t2.test(E[R2]) !== r2 && N2++;
    return { output: `${a ? `${a}:${N2}` : String(N2)}
`, matched: N2 > 0, matchCount: N2 };
  }
  if (c === 0 && u === 0 && !b) {
    let N2 = [], P = false, k = 0, R2 = 0;
    for (let T = 0; T < A && !(f2 > 0 && k >= f2); T++) {
      let Y = E[T];
      if (t2.lastIndex = 0, t2.test(Y) !== r2) if (P = true, k++, l) {
        t2.lastIndex = 0;
        for (let K = t2.exec(Y); K !== null; K = t2.exec(Y)) {
          let B = w !== void 0 ? K[w] ?? "" : K[0], q = g !== null ? Kc(g, K) : B, be = a ? `${a}:` : "";
          h && (be += `${R2 + K.index}:`), s2 && (be += `${T + 1}:`), d && (be += `${K.index + 1}:`), N2.push(be + q), K[0].length === 0 && t2.lastIndex++;
        }
      } else if (m) {
        t2.lastIndex = 0;
        for (let K = t2.exec(Y); K !== null; K = t2.exec(Y)) {
          let B = a ? `${a}:` : "";
          h && (B += `${R2 + K.index}:`), s2 && (B += `${T + 1}:`), d && (B += `${K.index + 1}:`), N2.push(B + Y), K[0].length === 0 && t2.lastIndex++;
        }
      } else {
        t2.lastIndex = 0;
        let K = t2.exec(Y), B = K ? K.index + 1 : 1, q = Y;
        g !== null && (t2.lastIndex = 0, q = Y.replace(t2, (...ee) => {
          if (ee[0].length === 0) return "";
          let U2 = ee, ye = ee[ee.length - 1];
          return typeof ye == "object" && ye !== null ? (U2.groups = ye, U2.input = ee[ee.length - 2], U2.index = ee[ee.length - 3]) : (U2.input = ee[ee.length - 1], U2.index = ee[ee.length - 2]), Kc(g, U2);
        }));
        let be = a ? `${a}:` : "";
        h && (be += `${R2 + (K ? K.index : 0)}:`), s2 && (be += `${T + 1}:`), d && (be += `${B}:`), N2.push(be + q);
      }
      R2 += Y.length + 1;
    }
    return { output: N2.length > 0 ? `${N2.join(`
`)}
` : "", matched: P, matchCount: k };
  }
  if (b) {
    let N2 = [], P = false, k = 0;
    for (let R2 = 0; R2 < A; R2++) {
      let T = E[R2];
      t2.lastIndex = 0;
      let ie = t2.test(T) !== r2;
      ie && (P = true, k++);
      let K = ie ? ":" : "-", B = a ? `${a}${K}` : "";
      s2 && (B += `${R2 + 1}${K}`), N2.push(B + T);
    }
    return { output: N2.length > 0 ? `${N2.join(`
`)}
` : "", matched: P, matchCount: k };
  }
  let I = [], O = 0, L = /* @__PURE__ */ new Set(), D = -1, $ = [];
  for (let N2 = 0; N2 < A && !(f2 > 0 && O >= f2); N2++) t2.lastIndex = 0, t2.test(E[N2]) !== r2 && ($.push(N2), O++);
  for (let N2 of $) {
    let P = Math.max(0, N2 - c);
    D >= 0 && P > D + 1 && I.push(p);
    for (let R2 = P; R2 < N2; R2++) if (!L.has(R2)) {
      L.add(R2), D = R2;
      let T = E[R2];
      s2 && (T = `${R2 + 1}-${T}`), a && (T = `${a}-${T}`), I.push(T);
    }
    if (!L.has(N2)) {
      L.add(N2), D = N2;
      let R2 = E[N2];
      if (l) {
        t2.lastIndex = 0;
        for (let T = t2.exec(R2); T !== null; T = t2.exec(R2)) {
          let Y = w !== void 0 ? T[w] ?? "" : T[0], ie = g !== null ? g : Y, K = a ? `${a}:` : "";
          s2 && (K += `${N2 + 1}:`), d && (K += `${T.index + 1}:`), I.push(K + ie), T[0].length === 0 && t2.lastIndex++;
        }
      } else {
        let T = R2;
        s2 && (T = `${N2 + 1}:${T}`), a && (T = `${a}:${T}`), I.push(T);
      }
    }
    let k = Math.min(A - 1, N2 + u);
    for (let R2 = N2 + 1; R2 <= k; R2++) if (!L.has(R2)) {
      L.add(R2), D = R2;
      let T = E[R2];
      s2 && (T = `${R2 + 1}-${T}`), a && (T = `${a}-${T}`), I.push(T);
    }
  }
  return { output: I.length > 0 ? `${I.join(`
`)}
` : "", matched: O > 0, matchCount: O };
}
function iw(e2, t2, n2) {
  let { invertMatch: r2, showLineNumbers: s2, countOnly: i2, countMatches: o2, filename: a, onlyMatching: l, beforeContext: c, afterContext: u, maxCount: f2, contextSeparator: p, showColumn: d, showByteOffset: m, replace: h, kResetGroup: g } = n2, b = e2.split(`
`), y = b.length, w = y > 0 && b[y - 1] === "" ? y - 1 : y, E = [0];
  for (let $ = 0; $ < e2.length; $++) e2[$] === `
` && E.push($ + 1);
  let C = ($) => {
    let N2 = 0;
    for (let P = 0; P < E.length && !(E[P] > $); P++) N2 = P;
    return N2;
  }, A = ($) => {
    let N2 = C($);
    return $ - E[N2] + 1;
  }, I = [];
  t2.lastIndex = 0;
  for (let $ = t2.exec(e2); $ !== null && !(f2 > 0 && I.length >= f2); $ = t2.exec(e2)) {
    let N2 = C($.index), P = C($.index + Math.max(0, $[0].length - 1)), k = g !== void 0 ? $[g] ?? "" : $[0];
    I.push({ startLine: N2, endLine: P, byteOffset: $.index, column: A($.index), matchText: k }), $[0].length === 0 && t2.lastIndex++;
  }
  if (i2 || o2) {
    let $;
    if (o2) $ = r2 ? 0 : I.length;
    else {
      let P = /* @__PURE__ */ new Set();
      for (let k of I) for (let R2 = k.startLine; R2 <= k.endLine; R2++) P.add(R2);
      $ = r2 ? w - P.size : P.size;
    }
    return { output: `${a ? `${a}:${$}` : String($)}
`, matched: $ > 0, matchCount: $ };
  }
  if (r2) {
    let $ = /* @__PURE__ */ new Set();
    for (let P of I) for (let k = P.startLine; k <= P.endLine; k++) $.add(k);
    let N2 = [];
    for (let P = 0; P < w; P++) if (!$.has(P)) {
      let k = b[P];
      s2 && (k = `${P + 1}:${k}`), a && (k = `${a}:${k}`), N2.push(k);
    }
    return { output: N2.length > 0 ? `${N2.join(`
`)}
` : "", matched: N2.length > 0, matchCount: N2.length };
  }
  if (I.length === 0) return { output: "", matched: false, matchCount: 0 };
  let O = /* @__PURE__ */ new Set(), L = -1, D = [];
  for (let $ of I) {
    let N2 = Math.max(0, $.startLine - c), P = Math.min(w - 1, $.endLine + u);
    L >= 0 && N2 > L + 1 && D.push(p);
    for (let k = N2; k < $.startLine; k++) if (!O.has(k)) {
      O.add(k), L = k;
      let R2 = b[k];
      s2 && (R2 = `${k + 1}-${R2}`), a && (R2 = `${a}-${R2}`), D.push(R2);
    }
    if (l) {
      let k = h !== null ? h : $.matchText, R2 = a ? `${a}:` : "";
      m && (R2 += `${$.byteOffset}:`), s2 && (R2 += `${$.startLine + 1}:`), d && (R2 += `${$.column}:`), D.push(R2 + k);
      for (let T = $.startLine; T <= $.endLine; T++) O.add(T), L = T;
    } else for (let k = $.startLine; k <= $.endLine && k < w; k++) if (!O.has(k)) {
      O.add(k), L = k;
      let R2 = b[k];
      h !== null && k === $.startLine && (t2.lastIndex = 0, R2 = R2.replace(t2, h));
      let T = a ? `${a}:` : "";
      m && k === $.startLine && (T += `${$.byteOffset}:`), s2 && (T += `${k + 1}:`), d && k === $.startLine && (T += `${$.column}:`), D.push(T + R2);
    }
    for (let k = $.endLine + 1; k <= P; k++) if (!O.has(k)) {
      O.add(k), L = k;
      let R2 = b[k];
      s2 && (R2 = `${k + 1}-${R2}`), a && (R2 = `${a}-${R2}`), D.push(R2);
    }
  }
  return { output: D.length > 0 ? `${D.join(`
`)}
` : "", matched: true, matchCount: I.length };
}
var Xc = v(() => {
});
function Jc(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) {
    if (e2.slice(n2, n2 + 7) === "[[:<:]]") {
      t2 += "(?<![\\w])", n2 += 7;
      continue;
    }
    if (e2.slice(n2, n2 + 7) === "[[:>:]]") {
      t2 += "(?![\\w])", n2 += 7;
      continue;
    }
    if (e2[n2] === "[") {
      let r2 = "[";
      for (n2++, n2 < e2.length && (e2[n2] === "^" || e2[n2] === "!") && (r2 += "^", n2++), n2 < e2.length && e2[n2] === "]" && (r2 += "\\]", n2++); n2 < e2.length && e2[n2] !== "]"; ) {
        if (e2[n2] === "[" && n2 + 1 < e2.length && e2[n2 + 1] === ":") {
          let s2 = e2.indexOf(":]", n2 + 2);
          if (s2 !== -1) {
            let i2 = e2.slice(n2 + 2, s2), o2 = ow[i2];
            if (o2) {
              r2 += o2, n2 = s2 + 2;
              continue;
            }
          }
        }
        if (e2[n2] === "\\" && n2 + 1 < e2.length) {
          r2 += e2[n2] + e2[n2 + 1], n2 += 2;
          continue;
        }
        r2 += e2[n2], n2++;
      }
      n2 < e2.length && e2[n2] === "]" && (r2 += "]", n2++), t2 += r2;
      continue;
    }
    if (e2[n2] === "\\" && n2 + 1 < e2.length) {
      t2 += e2[n2] + e2[n2 + 1], n2 += 2;
      continue;
    }
    t2 += e2[n2], n2++;
  }
  return t2;
}
function hr(e2, t2) {
  let n2, r2;
  switch (t2.mode) {
    case "fixed":
      n2 = e2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      break;
    case "extended":
    case "perl": {
      if (n2 = Jc(e2), n2 = n2.replace(/\(\?P<([^>]+)>/g, "(?<$1>"), t2.mode === "perl") {
        n2 = aw(n2), n2 = lw(n2), n2 = cw(n2);
        let o2 = dw(n2);
        n2 = o2.pattern, r2 = o2.kResetGroup;
      }
      break;
    }
    default:
      n2 = Jc(e2), n2 = gw(n2);
      break;
  }
  t2.wholeWord && (n2 = `(?<![\\w])(?:${n2})(?![\\w])`), t2.lineRegexp && (n2 = `^${n2}$`);
  let s2 = /\\u\{[0-9A-Fa-f]+\}/.test(n2), i2 = "g" + (t2.ignoreCase ? "i" : "") + (t2.multiline ? "m" : "") + (t2.multilineDotall ? "s" : "") + (s2 ? "u" : "");
  return { regex: new RegExp(n2, i2), kResetGroup: r2 };
}
function aw(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) if (e2[n2] === "\\" && n2 + 1 < e2.length && e2[n2 + 1] === "Q") {
    n2 += 2;
    let r2 = "";
    for (; n2 < e2.length; ) {
      if (e2[n2] === "\\" && n2 + 1 < e2.length && e2[n2 + 1] === "E") {
        n2 += 2;
        break;
      }
      r2 += e2[n2], n2++;
    }
    t2 += r2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  } else t2 += e2[n2], n2++;
  return t2;
}
function lw(e2) {
  return e2.replace(/\\x\{([0-9A-Fa-f]+)\}/g, "\\u{$1}");
}
function cw(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) {
    if (e2[n2] === "(" && n2 + 1 < e2.length && e2[n2 + 1] === "?") {
      let r2 = e2.slice(n2).match(/^\(\?([imsx]*)(-[imsx]*)?(:|$|\))/);
      if (r2) {
        let s2 = r2[1] || "";
        r2[2] || "";
        let o2 = r2[3];
        if (o2 === ":") {
          let a = n2 + r2[0].length - 1, l = uw(e2, n2);
          if (l !== -1) {
            let c = e2.slice(a + 1, l), u = fw(c, s2);
            t2 += `(?:${u})`, n2 = l + 1;
            continue;
          }
        } else if (o2 === ")" || o2 === "") {
          n2 += r2[0].length;
          continue;
        }
      }
    }
    t2 += e2[n2], n2++;
  }
  return t2;
}
function uw(e2, t2) {
  let n2 = 0, r2 = t2;
  for (; r2 < e2.length; ) {
    if (e2[r2] === "\\") {
      r2 += 2;
      continue;
    }
    if (e2[r2] === "[") {
      for (r2++; r2 < e2.length && e2[r2] !== "]"; ) e2[r2] === "\\" && r2++, r2++;
      r2++;
      continue;
    }
    if (e2[r2] === "(") n2++;
    else if (e2[r2] === ")" && (n2--, n2 === 0)) return r2;
    r2++;
  }
  return -1;
}
function fw(e2, t2, n2) {
  let r2 = e2;
  return t2.includes("i") && (r2 = pw(r2)), r2;
}
function pw(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) {
    let r2 = e2[n2];
    if (r2 === "\\") {
      n2 + 1 < e2.length ? (t2 += r2 + e2[n2 + 1], n2 += 2) : (t2 += r2, n2++);
      continue;
    }
    if (r2 === "[") {
      t2 += r2, n2++, n2 < e2.length && e2[n2] === "^" && (t2 += e2[n2], n2++);
      let s2 = [];
      for (; n2 < e2.length && e2[n2] !== "]"; ) if (e2[n2] === "\\") s2.push(e2[n2]), n2++, n2 < e2.length && (s2.push(e2[n2]), n2++);
      else if (e2[n2] === "-" && s2.length > 0 && n2 + 1 < e2.length && e2[n2 + 1] !== "]") {
        let i2 = s2[s2.length - 1], o2 = e2[n2 + 1];
        s2.push("-"), s2.push(o2), /[a-z]/.test(i2) && /[a-z]/.test(o2) ? (s2.push(i2.toUpperCase()), s2.push("-"), s2.push(o2.toUpperCase())) : /[A-Z]/.test(i2) && /[A-Z]/.test(o2) && (s2.push(i2.toLowerCase()), s2.push("-"), s2.push(o2.toLowerCase())), n2 += 2;
      } else {
        let i2 = e2[n2];
        if (s2.push(i2), /[a-zA-Z]/.test(i2)) {
          let o2 = i2 === i2.toLowerCase() ? i2.toUpperCase() : i2.toLowerCase();
          s2.includes(o2) || s2.push(o2);
        }
        n2++;
      }
      t2 += s2.join(""), n2 < e2.length && (t2 += e2[n2], n2++);
      continue;
    }
    if (/[a-zA-Z]/.test(r2)) {
      let s2 = r2.toLowerCase(), i2 = r2.toUpperCase();
      t2 += `[${i2}${s2}]`;
    } else t2 += r2;
    n2++;
  }
  return t2;
}
function dw(e2) {
  let t2 = hw(e2);
  if (t2 === -1) return { pattern: e2 };
  let n2 = e2.slice(0, t2), r2 = e2.slice(t2 + 2), s2 = mw(n2);
  return { pattern: `(?:${n2})(${r2})`, kResetGroup: s2 + 1 };
}
function hw(e2) {
  let t2 = 0;
  for (; t2 < e2.length - 1; ) if (e2[t2] === "\\") {
    if (e2[t2 + 1] === "K") {
      let n2 = 0, r2 = t2 - 1;
      for (; r2 >= 0 && e2[r2] === "\\"; ) n2++, r2--;
      if (n2 % 2 === 0) return t2;
    }
    t2 += 2;
  } else t2++;
  return -1;
}
function mw(e2) {
  let t2 = 0, n2 = 0;
  for (; n2 < e2.length; ) {
    if (e2[n2] === "\\") {
      n2 += 2;
      continue;
    }
    if (e2[n2] === "[") {
      for (n2++; n2 < e2.length && e2[n2] !== "]"; ) e2[n2] === "\\" && n2++, n2++;
      n2++;
      continue;
    }
    if (e2[n2] === "(") if (n2 + 1 < e2.length && e2[n2 + 1] === "?") {
      if (n2 + 2 < e2.length) {
        let r2 = e2[n2 + 2];
        if (r2 === ":" || r2 === "=" || r2 === "!") {
          n2++;
          continue;
        }
        if (r2 === "<" && n2 + 3 < e2.length) {
          let s2 = e2[n2 + 3];
          if (s2 === "=" || s2 === "!") {
            n2++;
            continue;
          }
          t2++, n2++;
          continue;
        }
      }
    } else t2++;
    n2++;
  }
  return t2;
}
function Vi(e2) {
  let t2 = e2.replace(/\$\{0\}|\$0(?![0-9])/g, "$$&");
  return t2 = t2.replace(/\$\{([^0-9}][^}]*)\}/g, "$$<$1>"), t2 = t2.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)(?![>0-9])/g, "$$<$1>"), t2;
}
function gw(e2) {
  let t2 = "", n2 = 0, r2 = true;
  for (; n2 < e2.length; ) {
    let i2 = e2[n2];
    if (i2 === "[") {
      for (t2 += i2, n2++, n2 < e2.length && (e2[n2] === "^" || e2[n2] === "!") && (t2 += e2[n2], n2++), n2 < e2.length && e2[n2] === "]" && (t2 += e2[n2], n2++); n2 < e2.length && e2[n2] !== "]"; ) e2[n2] === "\\" && n2 + 1 < e2.length ? (t2 += e2[n2] + e2[n2 + 1], n2 += 2) : (t2 += e2[n2], n2++);
      n2 < e2.length && e2[n2] === "]" && (t2 += e2[n2], n2++), r2 = false;
      continue;
    }
    if (i2 === "\\" && n2 + 1 < e2.length) {
      let o2 = e2[n2 + 1];
      if (o2 === "|") {
        t2 += "|", n2 += 2, r2 = true;
        continue;
      }
      if (o2 === "(") {
        t2 += "(", n2 += 2, r2 = true;
        continue;
      }
      if (o2 === ")") {
        t2 += ")", n2 += 2, r2 = false;
        continue;
      }
      if (o2 === "{") {
        let l = e2.slice(n2).match(/^\\{(\d+)(,(\d*)?)?\\}/);
        if (l) {
          let c = l[1], u = l[2] !== void 0, f2 = l[3] || "";
          u ? t2 += `{${c},${f2}}` : t2 += `{${c}}`, n2 += l[0].length, r2 = false;
          continue;
        }
        t2 += "\\{", n2 += 2, r2 = false;
        continue;
      }
      if (o2 === "}") {
        t2 += "\\}", n2 += 2, r2 = false;
        continue;
      }
      t2 += i2 + o2, n2 += 2, r2 = false;
      continue;
    }
    if (i2 === "*" && r2) {
      t2 += "\\*", n2++;
      continue;
    }
    if (i2 === "^") {
      if (r2) {
        t2 += "^", n2++;
        continue;
      }
      t2 += "\\^", n2++;
      continue;
    }
    if (i2 === "$") {
      let o2 = n2 === e2.length - 1, a = n2 + 2 < e2.length && e2[n2 + 1] === "\\" && e2[n2 + 2] === ")";
      o2 || a ? t2 += "$" : t2 += "\\$", n2++, r2 = false;
      continue;
    }
    i2 === "+" || i2 === "?" || i2 === "|" || i2 === "(" || i2 === ")" || i2 === "{" || i2 === "}" ? t2 += `\\${i2}` : t2 += i2, n2++, r2 = false;
  }
  return t2;
}
var ow, Yc = v(() => {
  ow = { alpha: "a-zA-Z", digit: "0-9", alnum: "a-zA-Z0-9", lower: "a-z", upper: "A-Z", xdigit: "0-9A-Fa-f", space: " \\t\\n\\r\\f\\v", blank: " \\t", punct: "!-/:-@\\[-`{-~", graph: "!-~", print: " -~", cntrl: "\\x00-\\x1F\\x7F", ascii: "\\x00-\\x7F", word: "a-zA-Z0-9_" };
});
var qi = v(() => {
  Xc();
  Yc();
});
var is = {};
V(is, { egrepCommand: () => xw, fgrepCommand: () => ww, grepCommand: () => Gi });
async function eu(e2, t2, n2, r2) {
  let s2 = n2.fs.resolvePath(n2.cwd, e2);
  try {
    if (!(await n2.fs.stat(s2)).isDirectory) {
      let a = e2.split("/").pop() || "";
      if (t2) {
        let l = t2.replace(/^\//, "");
        Ye(a, l, { stripQuotes: true }) && r2.push(e2);
      }
      return;
    }
    let o2 = await n2.fs.readdir(s2);
    for (let a of o2) {
      let l = e2 === "." ? a : `${e2}/${a}`, c = n2.fs.resolvePath(n2.cwd, l);
      if ((await n2.fs.stat(c)).isDirectory) await eu(l, t2, n2, r2);
      else if (t2) {
        let f2 = t2.replace(/^\//, "");
        Ye(a, f2, { stripQuotes: true }) && r2.push(l);
      }
    }
  } catch {
  }
}
async function bw(e2, t2) {
  let n2 = [], r2 = e2.lastIndexOf("/"), s2, i2;
  if (r2 === -1 ? (s2 = t2.cwd, i2 = e2) : (s2 = e2.slice(0, r2) || "/", i2 = e2.slice(r2 + 1)), e2.includes("**")) {
    let a = [], l = e2.split("**"), c = l[0].replace(/\/$/, "") || ".", u = l[1] || "";
    return await eu(c, u, t2, a), a.map((f2) => ({ path: f2 }));
  }
  let o2 = t2.fs.resolvePath(t2.cwd, s2);
  try {
    if (t2.fs.readdirWithFileTypes) {
      let a = await t2.fs.readdirWithFileTypes(o2);
      for (let l of a) if (Ye(l.name, i2, { stripQuotes: true })) {
        let c = r2 === -1 ? l.name : `${s2}/${l.name}`;
        n2.push({ path: c, isFile: l.isFile });
      }
    } else {
      let a = await t2.fs.readdir(o2);
      for (let l of a) if (Ye(l, i2, { stripQuotes: true })) {
        let c = r2 === -1 ? l : `${s2}/${l}`;
        n2.push({ path: c });
      }
    }
  } catch {
  }
  return n2.sort((a, l) => a.path.localeCompare(l.path));
}
async function ss(e2, t2, n2 = [], r2 = [], s2 = [], i2) {
  let o2 = t2.fs.resolvePath(t2.cwd, e2), a = [];
  try {
    let l, c;
    if (i2 !== void 0) l = i2, c = !i2;
    else {
      let f2 = await t2.fs.stat(o2);
      l = f2.isFile, c = f2.isDirectory;
    }
    if (l) {
      let f2 = e2.split("/").pop() || e2;
      return r2.length > 0 && r2.some((p) => Ye(f2, p, { stripQuotes: true })) ? [] : n2.length > 0 && !n2.some((p) => Ye(f2, p, { stripQuotes: true })) ? [] : [{ path: e2, isFile: true }];
    }
    if (!c) return [];
    let u = e2.split("/").pop() || e2;
    if (s2.length > 0 && s2.some((f2) => Ye(u, f2, { stripQuotes: true }))) return [];
    if (t2.fs.readdirWithFileTypes) {
      let f2 = await t2.fs.readdirWithFileTypes(o2);
      for (let p of f2) {
        if (p.name.startsWith(".")) continue;
        let d = e2 === "." ? p.name : `${e2}/${p.name}`, m = await ss(d, t2, n2, r2, s2, p.isFile);
        a.push(...m);
      }
    } else {
      let f2 = await t2.fs.readdir(o2);
      for (let p of f2) {
        if (p.startsWith(".")) continue;
        let d = e2 === "." ? p : `${e2}/${p}`, m = await ss(d, t2, n2, r2, s2);
        a.push(...m);
      }
    }
  } catch {
  }
  return a;
}
var yw, Gi, ww, xw, os = v(() => {
  Hi();
  X();
  qi();
  yw = { name: "grep", summary: "print lines that match patterns", usage: "grep [OPTION]... PATTERN [FILE]...", options: ["-E, --extended-regexp    PATTERN is an extended regular expression", "-P, --perl-regexp        PATTERN is a Perl regular expression", "-F, --fixed-strings      PATTERN is a set of newline-separated strings", "-i, --ignore-case        ignore case distinctions", "-v, --invert-match       select non-matching lines", "-w, --word-regexp        match only whole words", "-x, --line-regexp        match only whole lines", "-c, --count              print only a count of matching lines", "-l, --files-with-matches print only names of files with matches", "-L, --files-without-match print names of files with no matches", "-m NUM, --max-count=NUM  stop after NUM matches", "-n, --line-number        print line number with output lines", "-h, --no-filename        suppress the file name prefix on output", "-o, --only-matching      show only nonempty parts of lines that match", "-q, --quiet, --silent    suppress all normal output", "-r, -R, --recursive      search directories recursively", "-A NUM                   print NUM lines of trailing context", "-B NUM                   print NUM lines of leading context", "-C NUM                   print NUM lines of context", "-e PATTERN               use PATTERN for matching", "    --include=GLOB       search only files matching GLOB", "    --exclude=GLOB       skip files matching GLOB", "    --exclude-dir=DIR    skip directories matching DIR", "    --help               display this help and exit"] }, Gi = { name: "grep", async execute(e2, t2) {
    if (_(e2)) return F$3(yw);
    let n2 = false, r2 = false, s2 = false, i2 = false, o2 = false, a = false, l = false, c = false, u = false, f2 = false, p = false, d = false, m = false, h = false, g = false, b = 0, y = 0, w = 0, E = [], C = [], A = [], I = null, O = [];
    for (let B = 0; B < e2.length; B++) {
      let q = e2[B];
      if (q.startsWith("-") && q !== "-") {
        if (q === "-e" && B + 1 < e2.length) {
          I = e2[++B];
          continue;
        }
        if (q.startsWith("--include=")) {
          E.push(q.slice(10));
          continue;
        }
        if (q.startsWith("--exclude=")) {
          C.push(q.slice(10));
          continue;
        }
        if (q.startsWith("--exclude-dir=")) {
          A.push(q.slice(14));
          continue;
        }
        if (q.startsWith("--max-count=")) {
          b = parseInt(q.slice(12), 10);
          continue;
        }
        let be = q.match(/^-m(\d+)$/);
        if (be) {
          b = parseInt(be[1], 10);
          continue;
        }
        if (q === "-m" && B + 1 < e2.length) {
          b = parseInt(e2[++B], 10);
          continue;
        }
        let ee = q.match(/^-([ABC])(\d+)$/);
        if (ee) {
          let U2 = parseInt(ee[2], 10);
          ee[1] === "A" ? w = U2 : ee[1] === "B" ? y = U2 : ee[1] === "C" && (y = U2, w = U2);
          continue;
        }
        if ((q === "-A" || q === "-B" || q === "-C") && B + 1 < e2.length) {
          let U2 = parseInt(e2[++B], 10);
          q === "-A" ? w = U2 : q === "-B" ? y = U2 : (y = U2, w = U2);
          continue;
        }
        let ge = q.startsWith("--") ? [q] : q.slice(1).split("");
        for (let U2 of ge) if (U2 === "i" || U2 === "--ignore-case") n2 = true;
        else if (U2 === "n" || U2 === "--line-number") r2 = true;
        else if (U2 === "v" || U2 === "--invert-match") s2 = true;
        else if (U2 === "c" || U2 === "--count") i2 = true;
        else if (U2 === "l" || U2 === "--files-with-matches") o2 = true;
        else if (U2 === "L" || U2 === "--files-without-match") a = true;
        else if (U2 === "r" || U2 === "R" || U2 === "--recursive") l = true;
        else if (U2 === "w" || U2 === "--word-regexp") c = true;
        else if (U2 === "x" || U2 === "--line-regexp") u = true;
        else if (U2 === "E" || U2 === "--extended-regexp") f2 = true;
        else if (U2 === "P" || U2 === "--perl-regexp") p = true;
        else if (U2 === "F" || U2 === "--fixed-strings") d = true;
        else if (U2 === "o" || U2 === "--only-matching") m = true;
        else if (U2 === "h" || U2 === "--no-filename") h = true;
        else if (U2 === "q" || U2 === "--quiet" || U2 === "--silent") g = true;
        else {
          if (U2.startsWith("--")) return G("grep", U2);
          if (U2.length === 1) return G("grep", `-${U2}`);
        }
      } else I === null ? I = q : O.push(q);
    }
    if (I === null) return { stdout: "", stderr: `grep: missing pattern
`, exitCode: 2 };
    let L = d ? "fixed" : f2 ? "extended" : p ? "perl" : "basic", D, $;
    try {
      let B = hr(I, { mode: L, ignoreCase: n2, wholeWord: c, lineRegexp: u });
      D = B.regex, $ = B.kResetGroup;
    } catch {
      return { stdout: "", stderr: `grep: invalid regular expression: ${I}
`, exitCode: 2 };
    }
    if (O.length === 0 && t2.stdin !== void 0) {
      let B = Dn(t2.stdin, D, { invertMatch: s2, showLineNumbers: r2, countOnly: i2, filename: "", onlyMatching: m, beforeContext: y, afterContext: w, maxCount: b, kResetGroup: $ });
      return g ? { stdout: "", stderr: "", exitCode: B.matched ? 0 : 1 } : { stdout: B.output, stderr: "", exitCode: B.matched ? 0 : 1 };
    }
    if (O.length === 0) return { stdout: "", stderr: `grep: no input files
`, exitCode: 2 };
    let N2 = "", P = "", k = false, R2 = false, T = [];
    for (let B of O) if (B.includes("*") || B.includes("?") || B.includes("[")) {
      let q = await bw(B, t2);
      if (l) for (let be of q) {
        let ee = await ss(be.path, t2, E, C, A, be.isFile);
        T.push(...ee);
      }
      else T.push(...q);
    } else if (l) {
      let q = await ss(B, t2, E, C, A);
      T.push(...q);
    } else T.push({ path: B });
    let Y = (T.length > 1 || l) && !h, ie = 50;
    for (let B = 0; B < T.length; B += ie) {
      let q = T.slice(B, B + ie), be = await Promise.all(q.map(async (ee) => {
        let ge = ee.path, U2 = ge.split("/").pop() || ge;
        if (C.length > 0 && !l && C.some((ye) => Ye(U2, ye, { stripQuotes: true })) || E.length > 0 && !l && !E.some((ye) => Ye(U2, ye, { stripQuotes: true }))) return null;
        try {
          let ye = t2.fs.resolvePath(t2.cwd, ge), Ce = false;
          if (ee.isFile === void 0 ? Ce = (await t2.fs.stat(ye)).isDirectory : Ce = !ee.isFile, Ce) return l ? null : { error: `grep: ${ge}: Is a directory
` };
          let Re = await t2.fs.readFile(ye), Me = Dn(Re, D, { invertMatch: s2, showLineNumbers: r2, countOnly: i2, filename: Y ? ge : "", onlyMatching: m, beforeContext: y, afterContext: w, maxCount: b, kResetGroup: $ });
          return { file: ge, result: Me };
        } catch {
          return { error: `grep: ${ge}: No such file or directory
` };
        }
      }));
      for (let ee of be) {
        if (ee === null) continue;
        if ("error" in ee && ee.error) {
          P += ee.error, ee.error.includes("Is a directory") || (R2 = true);
          continue;
        }
        if (!("file" in ee) || !ee.result) continue;
        let { file: ge, result: U2 } = ee;
        if (U2.matched) {
          if (k = true, g) return { stdout: "", stderr: "", exitCode: 0 };
          o2 ? N2 += `${ge}
` : a || (N2 += U2.output);
        } else a ? N2 += `${ge}
` : i2 && !o2 && (N2 += U2.output);
      }
    }
    let K;
    return R2 ? K = 2 : a ? K = N2.length > 0 ? 0 : 1 : K = k ? 0 : 1, g ? { stdout: "", stderr: "", exitCode: K } : { stdout: N2, stderr: P, exitCode: K };
  } };
  ww = { name: "fgrep", async execute(e2, t2) {
    return Gi.execute(["-F", ...e2], t2);
  } }, xw = { name: "egrep", async execute(e2, t2) {
    return Gi.execute(["-E", ...e2], t2);
  } };
});
function nu() {
  let e2 = [];
  for (let [t2, n2] of Object.entries(tu).sort()) {
    let r2 = [];
    for (let s2 of n2.extensions) r2.push(`*${s2}`);
    for (let s2 of n2.globs) r2.push(s2);
    e2.push(`${t2}: ${r2.join(", ")}`);
  }
  return `${e2.join(`
`)}
`;
}
var tu, mr, Zi = v(() => {
  tu = { js: { extensions: [".js", ".mjs", ".cjs", ".jsx"], globs: [] }, ts: { extensions: [".ts", ".tsx", ".mts", ".cts"], globs: [] }, html: { extensions: [".html", ".htm", ".xhtml"], globs: [] }, css: { extensions: [".css", ".scss", ".sass", ".less"], globs: [] }, json: { extensions: [".json", ".jsonc", ".json5"], globs: [] }, xml: { extensions: [".xml", ".xsl", ".xslt"], globs: [] }, c: { extensions: [".c", ".h"], globs: [] }, cpp: { extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx", ".h"], globs: [] }, rust: { extensions: [".rs"], globs: [] }, go: { extensions: [".go"], globs: [] }, zig: { extensions: [".zig"], globs: [] }, java: { extensions: [".java"], globs: [] }, kotlin: { extensions: [".kt", ".kts"], globs: [] }, scala: { extensions: [".scala", ".sc"], globs: [] }, clojure: { extensions: [".clj", ".cljc", ".cljs", ".edn"], globs: [] }, py: { extensions: [".py", ".pyi", ".pyw"], globs: [] }, rb: { extensions: [".rb", ".rake", ".gemspec"], globs: ["Rakefile", "Gemfile"] }, php: { extensions: [".php", ".phtml", ".php3", ".php4", ".php5"], globs: [] }, perl: { extensions: [".pl", ".pm", ".pod", ".t"], globs: [] }, lua: { extensions: [".lua"], globs: [] }, sh: { extensions: [".sh", ".bash", ".zsh", ".fish"], globs: [".bashrc", ".zshrc", ".profile"] }, bat: { extensions: [".bat", ".cmd"], globs: [] }, ps: { extensions: [".ps1", ".psm1", ".psd1"], globs: [] }, yaml: { extensions: [".yaml", ".yml"], globs: [] }, toml: { extensions: [".toml"], globs: ["Cargo.toml", "pyproject.toml"] }, ini: { extensions: [".ini", ".cfg", ".conf"], globs: [] }, csv: { extensions: [".csv", ".tsv"], globs: [] }, md: { extensions: [".md", ".mdx", ".markdown", ".mdown", ".mkd"], globs: [] }, markdown: { extensions: [".md", ".mdx", ".markdown", ".mdown", ".mkd"], globs: [] }, rst: { extensions: [".rst"], globs: [] }, txt: { extensions: [".txt", ".text"], globs: [] }, tex: { extensions: [".tex", ".ltx", ".sty", ".cls"], globs: [] }, sql: { extensions: [".sql"], globs: [] }, graphql: { extensions: [".graphql", ".gql"], globs: [] }, proto: { extensions: [".proto"], globs: [] }, make: { extensions: [".mk", ".mak"], globs: ["Makefile", "GNUmakefile", "makefile"] }, docker: { extensions: [], globs: ["Dockerfile", "Dockerfile.*", "*.dockerfile"] }, tf: { extensions: [".tf", ".tfvars"], globs: [] } }, mr = class {
    constructor() {
      __publicField(this, "types");
      this.types = new Map(Object.entries(tu).map(([t2, n2]) => [t2, { extensions: [...n2.extensions], globs: [...n2.globs] }]));
    }
    addType(t2) {
      let n2 = t2.indexOf(":");
      if (n2 === -1) return;
      let r2 = t2.slice(0, n2), s2 = t2.slice(n2 + 1);
      if (s2.startsWith("include:")) {
        let i2 = s2.slice(8), o2 = this.types.get(i2);
        if (o2) {
          let a = this.types.get(r2) || { extensions: [], globs: [] };
          a.extensions.push(...o2.extensions), a.globs.push(...o2.globs), this.types.set(r2, a);
        }
      } else {
        let i2 = this.types.get(r2) || { extensions: [], globs: [] };
        if (s2.startsWith("*.") && !s2.slice(2).includes("*")) {
          let o2 = s2.slice(1);
          i2.extensions.includes(o2) || i2.extensions.push(o2);
        } else i2.globs.includes(s2) || i2.globs.push(s2);
        this.types.set(r2, i2);
      }
    }
    clearType(t2) {
      let n2 = this.types.get(t2);
      n2 && (n2.extensions = [], n2.globs = []);
    }
    getType(t2) {
      return this.types.get(t2);
    }
    getAllTypes() {
      return this.types;
    }
    matchesType(t2, n2) {
      let r2 = t2.toLowerCase();
      for (let s2 of n2) {
        if (s2 === "all") {
          if (this.matchesAnyType(t2)) return true;
          continue;
        }
        let i2 = this.types.get(s2);
        if (i2) {
          for (let o2 of i2.extensions) if (r2.endsWith(o2)) return true;
          for (let o2 of i2.globs) if (o2.includes("*")) {
            let a = o2.replace(/\./g, "\\.").replace(/\*/g, ".*");
            if (new RegExp(`^${a}$`, "i").test(t2)) return true;
          } else if (r2 === o2.toLowerCase()) return true;
        }
      }
      return false;
    }
    matchesAnyType(t2) {
      let n2 = t2.toLowerCase();
      for (let r2 of this.types.values()) {
        for (let s2 of r2.extensions) if (n2.endsWith(s2)) return true;
        for (let s2 of r2.globs) if (s2.includes("*")) {
          let i2 = s2.replace(/\./g, "\\.").replace(/\*/g, ".*");
          if (new RegExp(`^${i2}$`, "i").test(t2)) return true;
        } else if (n2 === s2.toLowerCase()) return true;
      }
      return false;
    }
  };
});
function ru() {
  return { ignoreCase: false, caseSensitive: false, smartCase: true, fixedStrings: false, wordRegexp: false, lineRegexp: false, invertMatch: false, multiline: false, multilineDotall: false, patterns: [], patternFiles: [], count: false, countMatches: false, files: false, filesWithMatches: false, filesWithoutMatch: false, stats: false, onlyMatching: false, maxCount: 0, lineNumber: true, noFilename: false, withFilename: false, nullSeparator: false, byteOffset: false, column: false, vimgrep: false, replace: null, afterContext: 0, beforeContext: 0, contextSeparator: "--", quiet: false, heading: false, passthru: false, includeZero: false, sort: "path", json: false, globs: [], iglobs: [], globCaseInsensitive: false, types: [], typesNot: [], typeAdd: [], typeClear: [], hidden: false, noIgnore: false, noIgnoreDot: false, noIgnoreVcs: false, ignoreFiles: [], maxDepth: 1 / 0, maxFilesize: 0, followSymlinks: false, searchZip: false, searchBinary: false, preprocessor: null, preprocessorGlobs: [] };
}
var su = v(() => {
});
function Ew(e2) {
  let t2 = e2.match(/^(\d+)([KMG])?$/i);
  if (!t2) return 0;
  let n2 = parseInt(t2[1], 10);
  switch ((t2[2] || "").toUpperCase()) {
    case "K":
      return n2 * 1024;
    case "M":
      return n2 * 1024 * 1024;
    case "G":
      return n2 * 1024 * 1024 * 1024;
    default:
      return n2;
  }
}
function Sw(e2) {
  return /^\d+[KMG]?$/i.test(e2) ? null : { stdout: "", stderr: `rg: invalid --max-filesize value: ${e2}
`, exitCode: 1 };
}
function iu(e2) {
  return null;
}
function Nw(e2) {
  e2.hidden ? e2.searchBinary = true : e2.noIgnore ? e2.hidden = true : e2.noIgnore = true;
}
function kw$1(e2, t2, n2) {
  let r2 = e2[t2];
  for (let s2 of ou) {
    if (r2.startsWith(`--${s2.long}=`)) {
      let i2 = r2.slice(`--${s2.long}=`.length), o2 = as(n2, s2, i2);
      return o2 ? { newIndex: t2, error: o2 } : { newIndex: t2 };
    }
    if (s2.short && r2.startsWith(`-${s2.short}`) && r2.length > 2) {
      let i2 = r2.slice(2), o2 = as(n2, s2, i2);
      return o2 ? { newIndex: t2, error: o2 } : { newIndex: t2 };
    }
    if (s2.short && r2 === `-${s2.short}` || r2 === `--${s2.long}`) {
      if (t2 + 1 >= e2.length) return null;
      let i2 = e2[t2 + 1], o2 = as(n2, s2, i2);
      return o2 ? { newIndex: t2 + 1, error: o2 } : { newIndex: t2 + 1 };
    }
  }
  return null;
}
function vw(e2) {
  return ou.find((t2) => t2.short === e2);
}
function as(e2, t2, n2) {
  if (t2.validate) {
    let s2 = t2.validate(n2);
    if (s2) return s2;
  }
  let r2 = t2.parse ? t2.parse(n2) : n2;
  t2.multi ? e2[t2.target].push(r2) : e2[t2.target] = r2;
}
function $w(e2, t2) {
  let n2 = e2[t2];
  if (n2 === "--sort" && t2 + 1 < e2.length) {
    let r2 = e2[t2 + 1];
    if (r2 === "path" || r2 === "none") return { value: r2, newIndex: t2 + 1 };
  }
  if (n2.startsWith("--sort=")) {
    let r2 = n2.slice(7);
    if (r2 === "path" || r2 === "none") return { value: r2, newIndex: t2 };
  }
  return null;
}
function Iw(e2, t2) {
  let n2 = e2[t2], r2 = n2.match(/^-([ABC])(\d+)$/);
  return r2 ? { flag: r2[1], value: parseInt(r2[2], 10), newIndex: t2 } : (n2 === "-A" || n2 === "-B" || n2 === "-C") && t2 + 1 < e2.length ? { flag: n2[1], value: parseInt(e2[t2 + 1], 10), newIndex: t2 + 1 } : null;
}
function Rw(e2) {
  let t2 = e2.match(/^-m(\d+)$/);
  return t2 ? parseInt(t2[1], 10) : null;
}
function au(e2) {
  let t2 = ru(), n2 = null, r2 = [], s2 = -1, i2 = -1, o2 = -1, a = false;
  for (let l = 0; l < e2.length; l++) {
    let c = e2[l];
    if (c.startsWith("-") && c !== "-") {
      let u = Iw(e2, l);
      if (u) {
        let { flag: g, value: b, newIndex: y } = u;
        g === "A" ? s2 = Math.max(s2, b) : g === "B" ? i2 = Math.max(i2, b) : o2 = b, l = y;
        continue;
      }
      let f2 = Rw(c);
      if (f2 !== null) {
        t2.maxCount = f2;
        continue;
      }
      let p = kw$1(e2, l, t2);
      if (p) {
        if (p.error) return { success: false, error: p.error };
        l = p.newIndex;
        continue;
      }
      let d = $w(e2, l);
      if (d) {
        t2.sort = d.value, l = d.newIndex;
        continue;
      }
      let m = c.startsWith("--") ? [c] : c.slice(1).split("");
      for (let g of m) {
        if (Cw.has(g)) {
          t2.lineNumber = true, a = true;
          continue;
        }
        if (g === "u" || g === "--unrestricted") {
          Nw(t2);
          continue;
        }
        if (g === "P" || g === "--pcre2") return { success: false, error: { stdout: "", stderr: `rg: PCRE2 is not supported. Use standard regex syntax instead.
`, exitCode: 1 } };
        if (g.length === 1) {
          let y = vw(g);
          if (y) {
            if (l + 1 >= e2.length) return { success: false, error: G("rg", `-${g}`) };
            let w = as(t2, y, e2[l + 1]);
            if (w) return { success: false, error: w };
            l++;
            continue;
          }
        }
        let b = Aw[g];
        if (b) {
          b(t2);
          continue;
        }
        if (g.startsWith("--")) return { success: false, error: G("rg", g) };
        if (g.length === 1) return { success: false, error: G("rg", `-${g}`) };
      }
    } else n2 === null && t2.patterns.length === 0 && t2.patternFiles.length === 0 ? n2 = c : r2.push(c);
  }
  return (s2 >= 0 || o2 >= 0) && (t2.afterContext = Math.max(s2 >= 0 ? s2 : 0, o2 >= 0 ? o2 : 0)), (i2 >= 0 || o2 >= 0) && (t2.beforeContext = Math.max(i2 >= 0 ? i2 : 0, o2 >= 0 ? o2 : 0)), n2 !== null && t2.patterns.push(n2), (t2.column || t2.vimgrep) && (a = true), { success: true, options: t2, paths: r2, explicitLineNumbers: a };
}
var ou, Aw, Cw, lu = v(() => {
  X();
  su();
  ou = [{ short: "g", long: "glob", target: "globs", multi: true }, { long: "iglob", target: "iglobs", multi: true }, { short: "t", long: "type", target: "types", multi: true, validate: iu }, { short: "T", long: "type-not", target: "typesNot", multi: true, validate: iu }, { long: "type-add", target: "typeAdd", multi: true }, { long: "type-clear", target: "typeClear", multi: true }, { short: "m", long: "max-count", target: "maxCount", parse: parseInt }, { short: "e", long: "regexp", target: "patterns", multi: true }, { short: "f", long: "file", target: "patternFiles", multi: true }, { short: "r", long: "replace", target: "replace" }, { short: "d", long: "max-depth", target: "maxDepth", parse: parseInt }, { long: "max-filesize", target: "maxFilesize", parse: Ew, validate: Sw }, { long: "context-separator", target: "contextSeparator" }, { short: "j", long: "threads", target: "maxDepth", parse: () => 1 / 0 }, { long: "ignore-file", target: "ignoreFiles", multi: true }, { long: "pre", target: "preprocessor" }, { long: "pre-glob", target: "preprocessorGlobs", multi: true }], Aw = { i: (e2) => {
    e2.ignoreCase = true, e2.caseSensitive = false, e2.smartCase = false;
  }, "--ignore-case": (e2) => {
    e2.ignoreCase = true, e2.caseSensitive = false, e2.smartCase = false;
  }, s: (e2) => {
    e2.caseSensitive = true, e2.ignoreCase = false, e2.smartCase = false;
  }, "--case-sensitive": (e2) => {
    e2.caseSensitive = true, e2.ignoreCase = false, e2.smartCase = false;
  }, S: (e2) => {
    e2.smartCase = true, e2.ignoreCase = false, e2.caseSensitive = false;
  }, "--smart-case": (e2) => {
    e2.smartCase = true, e2.ignoreCase = false, e2.caseSensitive = false;
  }, F: (e2) => {
    e2.fixedStrings = true;
  }, "--fixed-strings": (e2) => {
    e2.fixedStrings = true;
  }, w: (e2) => {
    e2.wordRegexp = true;
  }, "--word-regexp": (e2) => {
    e2.wordRegexp = true;
  }, x: (e2) => {
    e2.lineRegexp = true;
  }, "--line-regexp": (e2) => {
    e2.lineRegexp = true;
  }, v: (e2) => {
    e2.invertMatch = true;
  }, "--invert-match": (e2) => {
    e2.invertMatch = true;
  }, U: (e2) => {
    e2.multiline = true;
  }, "--multiline": (e2) => {
    e2.multiline = true;
  }, "--multiline-dotall": (e2) => {
    e2.multilineDotall = true, e2.multiline = true;
  }, c: (e2) => {
    e2.count = true;
  }, "--count": (e2) => {
    e2.count = true;
  }, "--count-matches": (e2) => {
    e2.countMatches = true;
  }, l: (e2) => {
    e2.filesWithMatches = true;
  }, "--files": (e2) => {
    e2.files = true;
  }, "--files-with-matches": (e2) => {
    e2.filesWithMatches = true;
  }, "--files-without-match": (e2) => {
    e2.filesWithoutMatch = true;
  }, "--stats": (e2) => {
    e2.stats = true;
  }, o: (e2) => {
    e2.onlyMatching = true;
  }, "--only-matching": (e2) => {
    e2.onlyMatching = true;
  }, q: (e2) => {
    e2.quiet = true;
  }, "--quiet": (e2) => {
    e2.quiet = true;
  }, N: (e2) => {
    e2.lineNumber = false;
  }, "--no-line-number": (e2) => {
    e2.lineNumber = false;
  }, H: (e2) => {
    e2.withFilename = true;
  }, "--with-filename": (e2) => {
    e2.withFilename = true;
  }, I: (e2) => {
    e2.noFilename = true;
  }, "--no-filename": (e2) => {
    e2.noFilename = true;
  }, 0: (e2) => {
    e2.nullSeparator = true;
  }, "--null": (e2) => {
    e2.nullSeparator = true;
  }, b: (e2) => {
    e2.byteOffset = true;
  }, "--byte-offset": (e2) => {
    e2.byteOffset = true;
  }, "--column": (e2) => {
    e2.column = true, e2.lineNumber = true;
  }, "--no-column": (e2) => {
    e2.column = false;
  }, "--vimgrep": (e2) => {
    e2.vimgrep = true, e2.column = true, e2.lineNumber = true;
  }, "--json": (e2) => {
    e2.json = true;
  }, "--hidden": (e2) => {
    e2.hidden = true;
  }, "--no-ignore": (e2) => {
    e2.noIgnore = true;
  }, "--no-ignore-dot": (e2) => {
    e2.noIgnoreDot = true;
  }, "--no-ignore-vcs": (e2) => {
    e2.noIgnoreVcs = true;
  }, L: (e2) => {
    e2.followSymlinks = true;
  }, "--follow": (e2) => {
    e2.followSymlinks = true;
  }, z: (e2) => {
    e2.searchZip = true;
  }, "--search-zip": (e2) => {
    e2.searchZip = true;
  }, a: (e2) => {
    e2.searchBinary = true;
  }, "--text": (e2) => {
    e2.searchBinary = true;
  }, "--heading": (e2) => {
    e2.heading = true;
  }, "--passthru": (e2) => {
    e2.passthru = true;
  }, "--include-zero": (e2) => {
    e2.includeZero = true;
  }, "--glob-case-insensitive": (e2) => {
    e2.globCaseInsensitive = true;
  } }, Cw = /* @__PURE__ */ new Set(["n", "--line-number"]);
});
async function Qi(e2, t2, n2 = false, r2 = false, s2 = []) {
  let i2 = new yr(e2, t2, n2, r2);
  await i2.load(t2);
  for (let o2 of s2) try {
    let a = e2.resolvePath(t2, o2), l = await e2.readFile(a);
    i2.addPatternsFromContent(l, t2);
  } catch {
  }
  return i2;
}
var gr, yr, cu = v(() => {
  gr = class {
    constructor(t2 = "/") {
      __publicField(this, "patterns", []);
      __publicField(this, "basePath");
      this.basePath = t2;
    }
    parse(t2) {
      let n2 = t2.split(`
`);
      for (let r2 of n2) {
        let s2 = r2.replace(/\s+$/, "");
        if (!s2 || s2.startsWith("#")) continue;
        let i2 = false;
        s2.startsWith("!") && (i2 = true, s2 = s2.slice(1));
        let o2 = false;
        s2.endsWith("/") && (o2 = true, s2 = s2.slice(0, -1));
        let a = false;
        s2.startsWith("/") ? (a = true, s2 = s2.slice(1)) : s2.includes("/") && !s2.startsWith("**/") && (a = true);
        let l = this.patternToRegex(s2, a);
        this.patterns.push({ pattern: r2, regex: l, negated: i2, directoryOnly: o2, rooted: a });
      }
    }
    patternToRegex(t2, n2) {
      let r2 = "";
      n2 ? r2 = "^" : r2 = "(?:^|/)";
      let s2 = 0;
      for (; s2 < t2.length; ) {
        let i2 = t2[s2];
        if (i2 === "*") t2[s2 + 1] === "*" ? t2[s2 + 2] === "/" ? (r2 += "(?:.*/)?", s2 += 3) : (s2 + 2 >= t2.length, r2 += ".*", s2 += 2) : (r2 += "[^/]*", s2++);
        else if (i2 === "?") r2 += "[^/]", s2++;
        else if (i2 === "[") {
          let o2 = s2 + 1;
          for (o2 < t2.length && t2[o2] === "!" && o2++, o2 < t2.length && t2[o2] === "]" && o2++; o2 < t2.length && t2[o2] !== "]"; ) o2++;
          if (o2 < t2.length) {
            let a = t2.slice(s2, o2 + 1);
            a.startsWith("[!") && (a = `[^${a.slice(2)}`), r2 += a, s2 = o2 + 1;
          } else r2 += "\\[", s2++;
        } else i2 === "/" ? (r2 += "/", s2++) : (r2 += i2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), s2++);
      }
      return r2 += "(?:/.*)?$", new RegExp(r2);
    }
    matches(t2, n2) {
      let r2 = t2.replace(/^\.\//, "");
      r2 = r2.replace(/^\//, "");
      let s2 = false;
      for (let i2 of this.patterns) i2.directoryOnly && !n2 || i2.regex.test(r2) && (s2 = !i2.negated);
      return s2;
    }
    isWhitelisted(t2, n2) {
      let r2 = t2.replace(/^\.\//, "");
      r2 = r2.replace(/^\//, "");
      for (let s2 of this.patterns) if (!(s2.directoryOnly && !n2) && s2.negated && s2.regex.test(r2)) return true;
      return false;
    }
    getBasePath() {
      return this.basePath;
    }
  }, yr = class {
    constructor(t2, n2, r2 = false, s2 = false) {
      __publicField(this, "parsers", []);
      __publicField(this, "fs");
      __publicField(this, "skipDotIgnore");
      __publicField(this, "skipVcsIgnore");
      __publicField(this, "loadedDirs", /* @__PURE__ */ new Set());
      this.fs = t2, this.skipDotIgnore = r2, this.skipVcsIgnore = s2;
    }
    async load(t2) {
      let n2 = [], r2 = t2;
      for (; ; ) {
        n2.unshift(r2);
        let i2 = this.fs.resolvePath(r2, "..");
        if (i2 === r2) break;
        r2 = i2;
      }
      let s2 = [];
      this.skipVcsIgnore || s2.push(".gitignore"), this.skipDotIgnore || s2.push(".rgignore", ".ignore");
      for (let i2 of n2) {
        this.loadedDirs.add(i2);
        for (let o2 of s2) {
          let a = this.fs.resolvePath(i2, o2);
          try {
            let l = await this.fs.readFile(a), c = new gr(i2);
            c.parse(l), this.parsers.push(c);
          } catch {
          }
        }
      }
    }
    async loadForDirectory(t2) {
      if (this.loadedDirs.has(t2)) return;
      this.loadedDirs.add(t2);
      let n2 = [];
      this.skipVcsIgnore || n2.push(".gitignore"), this.skipDotIgnore || n2.push(".rgignore", ".ignore");
      for (let r2 of n2) {
        let s2 = this.fs.resolvePath(t2, r2);
        try {
          let i2 = await this.fs.readFile(s2), o2 = new gr(t2);
          o2.parse(i2), this.parsers.push(o2);
        } catch {
        }
      }
    }
    addPatternsFromContent(t2, n2) {
      let r2 = new gr(n2);
      r2.parse(t2), this.parsers.push(r2);
    }
    matches(t2, n2) {
      for (let r2 of this.parsers) {
        let s2 = r2.getBasePath();
        if (!t2.startsWith(s2)) continue;
        let i2 = t2.slice(s2.length).replace(/^\//, "");
        if (r2.matches(i2, n2)) return true;
      }
      return false;
    }
    isWhitelisted(t2, n2) {
      for (let r2 of this.parsers) {
        let s2 = r2.getBasePath();
        if (!t2.startsWith(s2)) continue;
        let i2 = t2.slice(s2.length).replace(/^\//, "");
        if (r2.isWhitelisted(i2, n2)) return true;
      }
      return false;
    }
    static isCommonIgnored(t2) {
      return (/* @__PURE__ */ new Set(["node_modules", ".git", ".svn", ".hg", "__pycache__", ".pytest_cache", ".mypy_cache", "venv", ".venv", ".next", ".nuxt", ".cargo"])).has(t2);
    }
  };
});
function Tw(e2) {
  return e2.length >= 2 && e2[0] === 31 && e2[1] === 139;
}
function Ow(e2) {
  let t2 = false;
  for (let n2 = 0; n2 < e2.length; n2++) {
    let r2 = e2[n2];
    r2 === "[" && !t2 ? t2 = true : r2 === "]" && t2 && (t2 = false);
  }
  return t2 ? `rg: glob '${e2}' has an unclosed character class` : null;
}
async function uu(e2) {
  let { ctx: t2, options: n2, paths: r2, explicitLineNumbers: s2 } = e2;
  for (let g of n2.globs) {
    let b = g.startsWith("!") ? g.slice(1) : g, y = Ow(b);
    if (y) return { stdout: "", stderr: `${y}
`, exitCode: 1 };
  }
  if (n2.files) {
    let g = [...n2.patterns, ...r2];
    return _w(t2, g, n2);
  }
  let i2 = [...n2.patterns];
  for (let g of n2.patternFiles) try {
    let b;
    if (g === "-") b = t2.stdin;
    else {
      let w = t2.fs.resolvePath(t2.cwd, g);
      b = await t2.fs.readFile(w);
    }
    let y = b.split(`
`).filter((w) => w.length > 0);
    i2.push(...y);
  } catch {
    return { stdout: "", stderr: `rg: ${g}: No such file or directory
`, exitCode: 2 };
  }
  if (i2.length === 0) return n2.patternFiles.length > 0 ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `rg: no pattern given
`, exitCode: 2 };
  let o2 = r2.length === 0 ? ["."] : r2, a = Dw(n2, i2), l, c;
  try {
    let g = Fw(i2, n2, a);
    l = g.regex, c = g.kResetGroup;
  } catch {
    return { stdout: "", stderr: `rg: invalid regex: ${i2.join(", ")}
`, exitCode: 2 };
  }
  let u = null;
  n2.noIgnore || (u = await Qi(t2.fs, t2.cwd, n2.noIgnoreDot, n2.noIgnoreVcs, n2.ignoreFiles));
  let f2 = new mr();
  for (let g of n2.typeClear) f2.clearType(g);
  for (let g of n2.typeAdd) f2.addType(g);
  let { files: p, singleExplicitFile: d } = await fu(t2, o2, n2, u, f2);
  if (p.length === 0) return { stdout: "", stderr: "", exitCode: 1 };
  let m = !n2.noFilename && (n2.withFilename || !d || p.length > 1), h = n2.lineNumber;
  return s2 || (d && p.length === 1 && (h = false), n2.onlyMatching && (h = false)), Ww(t2, p, l, n2, m, h, c);
}
function Dw(e2, t2) {
  return e2.caseSensitive ? false : e2.ignoreCase ? true : e2.smartCase ? !t2.some((n2) => /[A-Z]/.test(n2)) : false;
}
function Fw(e2, t2, n2) {
  let r2;
  return e2.length === 1 ? r2 = e2[0] : r2 = e2.map((s2) => t2.fixedStrings ? s2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") : `(?:${s2})`).join("|"), hr(r2, { mode: t2.fixedStrings && e2.length === 1 ? "fixed" : "perl", ignoreCase: n2, wholeWord: t2.wordRegexp, lineRegexp: t2.lineRegexp, multiline: t2.multiline, multilineDotall: t2.multilineDotall });
}
async function fu(e2, t2, n2, r2, s2) {
  let i2 = [], o2 = 0, a = 0;
  for (let c of t2) {
    let u = e2.fs.resolvePath(e2.cwd, c);
    try {
      let f2 = await e2.fs.stat(u);
      if (f2.isFile) {
        if (o2++, n2.maxFilesize > 0 && f2.size > n2.maxFilesize) continue;
        du(c, n2, r2, u, s2) && i2.push(c);
      } else f2.isDirectory && (a++, await pu(e2, c, u, 0, n2, r2, s2, i2));
    } catch {
    }
  }
  return { files: n2.sort === "path" ? i2.sort() : i2, singleExplicitFile: o2 === 1 && a === 0 };
}
async function pu(e2, t2, n2, r2, s2, i2, o2, a) {
  if (!(r2 >= s2.maxDepth)) {
    i2 && await i2.loadForDirectory(n2);
    try {
      let l = e2.fs.readdirWithFileTypes ? await e2.fs.readdirWithFileTypes(n2) : (await e2.fs.readdir(n2)).map((c) => ({ name: c, isFile: void 0 }));
      for (let c of l) {
        let u = c.name;
        if (!s2.noIgnore && yr.isCommonIgnored(u)) continue;
        let f2 = u.startsWith("."), p = t2 === "." ? u : t2 === "./" ? `./${u}` : t2.endsWith("/") ? `${t2}${u}` : `${t2}/${u}`, d = e2.fs.resolvePath(n2, u), m, h, g = false;
        if (c.isFile !== void 0 && "isDirectory" in c) {
          let w = c;
          if (g = w.isSymbolicLink === true, g && !s2.followSymlinks) continue;
          if (g && s2.followSymlinks) try {
            let E = await e2.fs.stat(d);
            m = E.isFile, h = E.isDirectory;
          } catch {
            continue;
          }
          else m = w.isFile, h = w.isDirectory;
        } else try {
          let w = e2.fs.lstat ? await e2.fs.lstat(d) : await e2.fs.stat(d);
          if (g = w.isSymbolicLink === true, g && !s2.followSymlinks) continue;
          let E = g && s2.followSymlinks ? await e2.fs.stat(d) : w;
          m = E.isFile, h = E.isDirectory;
        } catch {
          continue;
        }
        if (!(i2 == null ? void 0 : i2.matches(d, h)) && !(f2 && !s2.hidden && !(i2 == null ? void 0 : i2.isWhitelisted(d, h)))) {
          if (h) await pu(e2, p, d, r2 + 1, s2, i2, o2, a);
          else if (m) {
            if (s2.maxFilesize > 0) try {
              if ((await e2.fs.stat(d)).size > s2.maxFilesize) continue;
            } catch {
              continue;
            }
            du(p, s2, i2, d, o2) && a.push(p);
          }
        }
      }
    } catch {
    }
  }
}
function du(e2, t2, n2, r2, s2) {
  let i2 = e2.split("/").pop() || e2;
  if ((n2 == null ? void 0 : n2.matches(r2, false)) || t2.types.length > 0 && !s2.matchesType(i2, t2.types) || t2.typesNot.length > 0 && s2.matchesType(i2, t2.typesNot)) return false;
  if (t2.globs.length > 0) {
    let o2 = t2.globCaseInsensitive, a = t2.globs.filter((c) => !c.startsWith("!")), l = t2.globs.filter((c) => c.startsWith("!")).map((c) => c.slice(1));
    if (a.length > 0) {
      let c = false;
      for (let u of a) if (Rt(i2, u, o2) || Rt(e2, u, o2)) {
        c = true;
        break;
      }
      if (!c) return false;
    }
    for (let c of l) if (c.startsWith("/")) {
      let u = c.slice(1);
      if (Rt(e2, u, o2)) return false;
    } else if (Rt(i2, c, o2) || Rt(e2, c, o2)) return false;
  }
  if (t2.iglobs.length > 0) {
    let o2 = t2.iglobs.filter((l) => !l.startsWith("!")), a = t2.iglobs.filter((l) => l.startsWith("!")).map((l) => l.slice(1));
    if (o2.length > 0) {
      let l = false;
      for (let c of o2) if (Rt(i2, c, true) || Rt(e2, c, true)) {
        l = true;
        break;
      }
      if (!l) return false;
    }
    for (let l of a) if (l.startsWith("/")) {
      let c = l.slice(1);
      if (Rt(e2, c, true)) return false;
    } else if (Rt(i2, l, true) || Rt(e2, l, true)) return false;
  }
  return true;
}
function Rt(e2, t2, n2 = false) {
  let r2 = "^";
  for (let s2 = 0; s2 < t2.length; s2++) {
    let i2 = t2[s2];
    if (i2 === "*") t2[s2 + 1] === "*" ? (r2 += ".*", s2++) : r2 += "[^/]*";
    else if (i2 === "?") r2 += "[^/]";
    else if (i2 === "[") {
      let o2 = s2 + 1;
      for (o2 < t2.length && t2[o2] === "!" && o2++, o2 < t2.length && t2[o2] === "]" && o2++; o2 < t2.length && t2[o2] !== "]"; ) o2++;
      if (o2 < t2.length) {
        let a = t2.slice(s2, o2 + 1);
        a.startsWith("[!") && (a = `[^${a.slice(2)}`), r2 += a, s2 = o2;
      } else r2 += "\\[";
    } else r2 += i2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  return r2 += "$", new RegExp(r2, n2 ? "i" : "").test(e2);
}
async function _w(e2, t2, n2) {
  let r2 = null;
  n2.noIgnore || (r2 = await Qi(e2.fs, e2.cwd, n2.noIgnoreDot, n2.noIgnoreVcs, n2.ignoreFiles));
  let s2 = new mr();
  for (let c of n2.typeClear) s2.clearType(c);
  for (let c of n2.typeAdd) s2.addType(c);
  let i2 = t2.length === 0 ? ["."] : t2, { files: o2 } = await fu(e2, i2, n2, r2, s2);
  if (o2.length === 0) return { stdout: "", stderr: "", exitCode: 1 };
  if (n2.quiet) return { stdout: "", stderr: "", exitCode: 0 };
  let a = n2.nullSeparator ? "\0" : `
`;
  return { stdout: o2.map((c) => c + a).join(""), stderr: "", exitCode: 0 };
}
function Lw(e2, t2) {
  if (t2.length === 0) return true;
  for (let n2 of t2) if (Rt(e2, n2, false)) return true;
  return false;
}
async function Mw(e2, t2, n2, r2) {
  try {
    if (r2.preprocessor && e2.exec) {
      let o2 = n2.split("/").pop() || n2;
      if (Lw(o2, r2.preprocessorGlobs)) {
        let a = await e2.exec(`${r2.preprocessor} "${t2}"`, { cwd: e2.cwd });
        if (a.exitCode === 0 && a.stdout) {
          let l = a.stdout.slice(0, 8192);
          return { content: a.stdout, isBinary: l.includes("\0") };
        }
      }
    }
    if (r2.searchZip && n2.endsWith(".gz")) {
      let o2 = await e2.fs.readFileBuffer(t2);
      if (Tw(o2)) try {
        let a = gunzipSync(o2), l = new TextDecoder().decode(a), c = l.slice(0, 8192);
        return { content: l, isBinary: c.includes("\0") };
      } catch {
        return null;
      }
    }
    let s2 = await e2.fs.readFile(t2), i2 = s2.slice(0, 8192);
    return { content: s2, isBinary: i2.includes("\0") };
  } catch {
    return null;
  }
}
async function Ww(e2, t2, n2, r2, s2, i2, o2) {
  let a = "", l = false, c = [], u = 0, f2 = 0, p = 0, d = 50;
  e: for (let g = 0; g < t2.length; g += d) {
    let b = t2.slice(g, g + d), y = await Promise.all(b.map(async (w) => {
      let E = e2.fs.resolvePath(e2.cwd, w), C = await Mw(e2, E, w, r2);
      if (!C) return null;
      let { content: A, isBinary: I } = C;
      if (p += A.length, I && !r2.searchBinary) return null;
      let O = s2 && !r2.heading ? w : "", L = Dn(A, n2, { invertMatch: r2.invertMatch, showLineNumbers: i2, countOnly: r2.count, countMatches: r2.countMatches, filename: O, onlyMatching: r2.onlyMatching, beforeContext: r2.beforeContext, afterContext: r2.afterContext, maxCount: r2.maxCount, contextSeparator: r2.contextSeparator, showColumn: r2.column, vimgrep: r2.vimgrep, showByteOffset: r2.byteOffset, replace: r2.replace !== null ? Vi(r2.replace) : null, passthru: r2.passthru, multiline: r2.multiline, kResetGroup: o2 });
      return r2.json && L.matched ? { file: w, result: L, content: A, isBinary: false } : { file: w, result: L };
    }));
    for (let w of y) {
      if (!w) continue;
      let { file: E, result: C } = w;
      if (C.matched) {
        if (l = true, f2++, u += C.matchCount, r2.quiet && !r2.json) break e;
        if (r2.json && !r2.quiet) {
          let A = w.content || "";
          c.push(JSON.stringify({ type: "begin", data: { path: { text: E } } }));
          let I = A.split(`
`);
          n2.lastIndex = 0;
          let O = 0;
          for (let L = 0; L < I.length; L++) {
            let D = I[L];
            n2.lastIndex = 0;
            let $ = [];
            for (let N2 = n2.exec(D); N2 !== null; N2 = n2.exec(D)) {
              let P = { match: { text: N2[0] }, start: N2.index, end: N2.index + N2[0].length };
              r2.replace !== null && (P.replacement = { text: r2.replace }), $.push(P), N2[0].length === 0 && n2.lastIndex++;
            }
            if ($.length > 0) {
              let N2 = { type: "match", data: { path: { text: E }, lines: { text: `${D}
` }, line_number: L + 1, absolute_offset: O, submatches: $ } };
              c.push(JSON.stringify(N2));
            }
            O += D.length + 1;
          }
          c.push(JSON.stringify({ type: "end", data: { path: { text: E }, binary_offset: null, stats: { elapsed: { secs: 0, nanos: 0, human: "0s" }, searches: 1, searches_with_match: 1, bytes_searched: A.length, bytes_printed: 0, matched_lines: C.matchCount, matches: C.matchCount } } }));
        } else if (r2.filesWithMatches) {
          let A = r2.nullSeparator ? "\0" : `
`;
          a += `${E}${A}`;
        } else r2.filesWithoutMatch || (r2.heading && !r2.noFilename && (a += `${E}
`), a += C.output);
      } else if (r2.filesWithoutMatch) {
        let A = r2.nullSeparator ? "\0" : `
`;
        a += `${E}${A}`;
      } else r2.includeZero && (r2.count || r2.countMatches) && (a += C.output);
    }
  }
  r2.json && (c.push(JSON.stringify({ type: "summary", data: { elapsed_total: { secs: 0, nanos: 0, human: "0s" }, stats: { elapsed: { secs: 0, nanos: 0, human: "0s" }, searches: t2.length, searches_with_match: f2, bytes_searched: p, bytes_printed: 0, matched_lines: u, matches: u } } })), a = `${c.join(`
`)}
`);
  let m = r2.quiet && !r2.json ? "" : a;
  if (r2.stats && !r2.json) {
    let g = ["", `${u} matches`, `${u} matched lines`, `${f2} files contained matches`, `${t2.length} files searched`, `${p} bytes searched`].join(`
`);
    m += `${g}
`;
  }
  let h;
  return r2.filesWithoutMatch ? h = a.length > 0 ? 0 : 1 : h = l ? 0 : 1, { stdout: m, stderr: "", exitCode: h };
}
var hu = v(() => {
  qi();
  Zi();
  cu();
});
var mu = {};
V(mu, { rgCommand: () => Uw });
var Bw, Uw, gu = v(() => {
  X();
  Zi();
  lu();
  hu();
  Bw = { name: "rg", summary: "recursively search for a pattern", usage: "rg [OPTIONS] PATTERN [PATH ...]", description: `rg (ripgrep) recursively searches directories for a regex pattern.
Unlike grep, rg is recursive by default and respects .gitignore files.

EXAMPLES:
  rg foo                    Search for 'foo' in current directory
  rg foo src/               Search in src/ directory
  rg -i foo                 Case-insensitive search
  rg -w foo                 Match whole words only
  rg -t js foo              Search only JavaScript files
  rg -g '*.ts' foo          Search files matching glob
  rg --hidden foo           Include hidden files
  rg -l foo                 List files with matches only`, options: ["-e, --regexp PATTERN    search for PATTERN (can be used multiple times)", "-f, --file FILE         read patterns from FILE, one per line", "-i, --ignore-case       case-insensitive search", "-s, --case-sensitive    case-sensitive search (overrides smart-case)", "-S, --smart-case        smart case (default: case-insensitive unless pattern has uppercase)", "-F, --fixed-strings     treat pattern as literal string", "-w, --word-regexp       match whole words only", "-x, --line-regexp       match whole lines only", "-v, --invert-match      select non-matching lines", "-r, --replace TEXT      replace matches with TEXT", "-c, --count             print count of matching lines per file", "    --count-matches     print count of individual matches per file", "-l, --files-with-matches print only file names with matches", "    --files-without-match print file names without matches", "    --files             list files that would be searched", "-o, --only-matching     print only matching parts", "-m, --max-count NUM     stop after NUM matches per file", "-q, --quiet             suppress output, exit 0 on match", "    --stats             print search statistics", "-n, --line-number       print line numbers (default: on)", "-N, --no-line-number    do not print line numbers", "-I, --no-filename       suppress the prefixing of file names", "-0, --null              use NUL as filename separator", "-b, --byte-offset       show byte offset of each match", "    --column            show column number of first match", "    --vimgrep           show results in vimgrep format", "    --json              show results in JSON Lines format", "-A NUM                  print NUM lines after each match", "-B NUM                  print NUM lines before each match", "-C NUM                  print NUM lines before and after each match", "    --context-separator SEP  separator for context groups (default: --)", "-U, --multiline         match patterns across lines", "-z, --search-zip        search in compressed files (gzip only)", "-g, --glob GLOB         include files matching GLOB", "-t, --type TYPE         only search files of TYPE (e.g., js, py, ts)", "-T, --type-not TYPE     exclude files of TYPE", "-L, --follow            follow symbolic links", "-u, --unrestricted      reduce filtering (-u: no ignore, -uu: +hidden, -uuu: +binary)", "-a, --text              search binary files as text", "    --hidden            search hidden files and directories", "    --no-ignore         don't respect .gitignore/.ignore files", "-d, --max-depth NUM     maximum search depth", "    --sort TYPE         sort files (path, none)", "    --heading           show file path above matches", "    --passthru          print all lines (non-matches use - separator)", "    --include-zero      include files with 0 matches in count output", "    --type-list         list all available file types", "    --help              display this help and exit"] }, Uw = { name: "rg", async execute(e2, t2) {
    if (_(e2)) return F$3(Bw);
    if (e2.includes("--type-list")) return { stdout: nu(), stderr: "", exitCode: 0 };
    let n2 = au(e2);
    return n2.success ? uu({ ctx: t2, options: n2.options, paths: n2.paths, explicitLineNumbers: n2.explicitLineNumbers }) : n2.error;
  } };
});
function ls(e2) {
  return e2 instanceof Qe || e2 instanceof Ke || e2 instanceof Ve;
}
var et, Qe, Ke, Ve, lt, tt, ae, Ee, nt, _t, Fn, ne, Lt, xt, de = v(() => {
  var _a3;
  et = class extends Error {
    constructor(t2, n2 = "", r2 = "") {
      super(t2);
      __publicField(this, "stdout");
      __publicField(this, "stderr");
      this.stdout = n2, this.stderr = r2;
    }
    prependOutput(t2, n2) {
      this.stdout = t2 + this.stdout, this.stderr = n2 + this.stderr;
    }
  }, Qe = class extends et {
    constructor(t2 = 1, n2 = "", r2 = "") {
      super("break", n2, r2);
      __publicField(this, "levels");
      __publicField(this, "name", "BreakError");
      this.levels = t2;
    }
  }, Ke = class extends et {
    constructor(t2 = 1, n2 = "", r2 = "") {
      super("continue", n2, r2);
      __publicField(this, "levels");
      __publicField(this, "name", "ContinueError");
      this.levels = t2;
    }
  }, Ve = class extends et {
    constructor(t2 = 0, n2 = "", r2 = "") {
      super("return", n2, r2);
      __publicField(this, "exitCode");
      __publicField(this, "name", "ReturnError");
      this.exitCode = t2;
    }
  }, lt = class extends et {
    constructor(t2, n2 = "", r2 = "") {
      super(`errexit: command exited with status ${t2}`, n2, r2);
      __publicField(this, "exitCode");
      __publicField(this, "name", "ErrexitError");
      this.exitCode = t2;
    }
  }, tt = class extends et {
    constructor(t2, n2 = "") {
      super(`${t2}: unbound variable`, n2, `bash: ${t2}: unbound variable
`);
      __publicField(this, "varName");
      __publicField(this, "name", "NounsetError");
      this.varName = t2;
    }
  }, ae = class extends et {
    constructor(t2, n2 = "", r2 = "") {
      super("exit", n2, r2);
      __publicField(this, "exitCode");
      __publicField(this, "name", "ExitError");
      this.exitCode = t2;
    }
  }, Ee = class extends et {
    constructor(t2, n2 = "", r2 = "", s2 = false) {
      super(t2, n2, r2);
      __publicField(this, "name", "ArithmeticError");
      __publicField(this, "fatal");
      this.stderr = r2 || `bash: ${t2}
`, this.fatal = s2;
    }
  }, nt = class extends et {
    constructor(t2, n2 = "", r2 = "") {
      super(t2, n2, r2);
      __publicField(this, "name", "BadSubstitutionError");
      this.stderr = r2 || `bash: ${t2}: bad substitution
`;
    }
  }, _t = class extends et {
    constructor(t2, n2 = "", r2 = "") {
      super(`no match: ${t2}`, n2, r2);
      __publicField(this, "name", "GlobError");
      this.stderr = r2 || `bash: no match: ${t2}
`;
    }
  }, Fn = class extends et {
    constructor(t2, n2 = "", r2 = "") {
      super(t2, n2, r2);
      __publicField(this, "name", "BraceExpansionError");
      this.stderr = r2 || `bash: ${t2}
`;
    }
  }, ne = (_a3 = class extends et {
    constructor(t2, n2, r2 = "", s2 = "") {
      super(t2, r2, s2);
      __publicField(this, "limitType");
      __publicField(this, "name", "ExecutionLimitError");
      this.limitType = n2, this.stderr = s2 || `bash: ${t2}
`;
    }
  }, __publicField(_a3, "EXIT_CODE", 126), _a3), Lt = class extends et {
    constructor(t2 = "", n2 = "") {
      super("subshell exit", t2, n2);
      __publicField(this, "name", "SubshellExitError");
    }
  };
  xt = class extends et {
    constructor(t2, n2 = "", r2 = "") {
      super("posix fatal error", n2, r2);
      __publicField(this, "exitCode");
      __publicField(this, "name", "PosixFatalError");
      this.exitCode = t2;
    }
  };
});
function Xi(e2) {
  let t2 = "", n2 = 0, r2 = false;
  for (; n2 < e2.length; ) {
    if (e2[n2] === "[" && !r2) {
      if (e2[n2 + 1] === "[" && e2[n2 + 2] === ":") {
        let s2 = e2.indexOf(":]]", n2 + 3);
        if (s2 !== -1) {
          let i2 = e2.slice(n2 + 3, s2), o2 = Ki[i2];
          if (o2) {
            t2 += `[${o2}]`, n2 = s2 + 3;
            continue;
          }
        }
      }
      if (e2[n2 + 1] === "^" && e2[n2 + 2] === "[" && e2[n2 + 3] === ":") {
        let s2 = e2.indexOf(":]]", n2 + 4);
        if (s2 !== -1) {
          let i2 = e2.slice(n2 + 4, s2), o2 = Ki[i2];
          if (o2) {
            t2 += `[^${o2}]`, n2 = s2 + 3;
            continue;
          }
        }
      }
      t2 += "[", n2++, r2 = true, n2 < e2.length && e2[n2] === "^" && (t2 += "^", n2++), n2 < e2.length && e2[n2] === "]" && (t2 += "\\]", n2++);
      continue;
    }
    if (r2) {
      if (e2[n2] === "]") {
        t2 += "]", n2++, r2 = false;
        continue;
      }
      if (e2[n2] === "[" && e2[n2 + 1] === ":") {
        let s2 = e2.indexOf(":]", n2 + 2);
        if (s2 !== -1) {
          let i2 = e2.slice(n2 + 2, s2), o2 = Ki[i2];
          if (o2) {
            t2 += o2, n2 = s2 + 2;
            continue;
          }
        }
      }
      if (e2[n2] === "\\" && n2 + 1 < e2.length) {
        t2 += e2[n2] + e2[n2 + 1], n2 += 2;
        continue;
      }
      t2 += e2[n2], n2++;
      continue;
    }
    if (e2[n2] === "\\" && n2 + 1 < e2.length) {
      let s2 = e2[n2 + 1];
      if (s2 === "+" || s2 === "?" || s2 === "|") {
        t2 += s2, n2 += 2;
        continue;
      }
      if (s2 === "(" || s2 === ")") {
        t2 += s2, n2 += 2;
        continue;
      }
      if (s2 === "{" || s2 === "}") {
        t2 += s2, n2 += 2;
        continue;
      }
      if (s2 === "t") {
        t2 += "	", n2 += 2;
        continue;
      }
      if (s2 === "n") {
        t2 += `
`, n2 += 2;
        continue;
      }
      if (s2 === "r") {
        t2 += "\r", n2 += 2;
        continue;
      }
      t2 += e2[n2] + s2, n2 += 2;
      continue;
    }
    if (e2[n2] === "+" || e2[n2] === "?" || e2[n2] === "|" || e2[n2] === "(" || e2[n2] === ")") {
      t2 += `\\${e2[n2]}`, n2++;
      continue;
    }
    if (e2[n2] === "^" && !(t2 === "" || t2.endsWith("("))) {
      t2 += "\\^", n2++;
      continue;
    }
    if (e2[n2] === "$") {
      let s2 = n2 === e2.length - 1, i2 = n2 + 2 < e2.length && e2[n2 + 1] === "\\" && e2[n2 + 2] === ")";
      if (!s2 && !i2) {
        t2 += "\\$", n2++;
        continue;
      }
    }
    t2 += e2[n2], n2++;
  }
  return t2;
}
function Ji(e2) {
  let t2 = "", n2 = false;
  for (let r2 = 0; r2 < e2.length; r2++) e2[r2] === "[" && !n2 ? (n2 = true, t2 += "[", r2++, r2 < e2.length && e2[r2] === "^" && (t2 += "^", r2++), r2 < e2.length && e2[r2] === "]" && (t2 += "]", r2++), r2--) : e2[r2] === "]" && n2 ? (n2 = false, t2 += "]") : !n2 && e2[r2] === "{" && e2[r2 + 1] === "," ? (t2 += "{0,", r2++) : t2 += e2[r2];
  return t2;
}
function yu(e2) {
  let t2 = "";
  for (let n2 = 0; n2 < e2.length; n2++) {
    let r2 = e2[n2], s2 = r2.charCodeAt(0);
    r2 === "\\" ? t2 += "\\\\" : r2 === "	" ? t2 += "\\t" : r2 === `
` ? t2 += `$
` : r2 === "\r" ? t2 += "\\r" : r2 === "\x07" ? t2 += "\\a" : r2 === "\b" ? t2 += "\\b" : r2 === "\f" ? t2 += "\\f" : r2 === "\v" ? t2 += "\\v" : s2 < 32 || s2 >= 127 ? t2 += `\\${s2.toString(8).padStart(3, "0")}` : t2 += r2;
  }
  return `${t2}$`;
}
var Ki, bu = v(() => {
  Ki = { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "!-~", lower: "a-z", print: " -~", punct: "!-/:-@\\[-`{-~", space: " \\t\\n\\r\\f\\v", upper: "A-Z", word: "a-zA-Z0-9_", xdigit: "0-9A-Fa-f" };
});
function wu(e2, t2, n2) {
  return { patternSpace: "", holdSpace: "", lineNumber: 0, totalLines: e2, deleted: false, printed: false, quit: false, quitSilent: false, exitCode: void 0, errorMessage: void 0, appendBuffer: [], substitutionMade: false, lineNumberOutput: [], nCommandOutput: [], restartCycle: false, inDRestartedCycle: false, currentFilename: t2, pendingFileReads: [], pendingFileWrites: [], pendingExecute: void 0, rangeStates: n2 || /* @__PURE__ */ new Map(), linesConsumedInCycle: 0 };
}
function jw(e2) {
  return typeof e2 == "object" && "first" in e2 && "step" in e2;
}
function Hw(e2) {
  return typeof e2 == "object" && "offset" in e2;
}
function _n(e2, t2, n2, r2, s2) {
  if (e2 === "$") return t2 === n2;
  if (typeof e2 == "number") return t2 === e2;
  if (jw(e2)) {
    let { first: i2, step: o2 } = e2;
    return o2 === 0 ? t2 === i2 : (t2 - i2) % o2 === 0 && t2 >= i2;
  }
  if (typeof e2 == "object" && "pattern" in e2) try {
    let i2 = e2.pattern;
    i2 === "" && (s2 == null ? void 0 : s2.lastPattern) ? i2 = s2.lastPattern : i2 !== "" && s2 && (s2.lastPattern = i2);
    let o2 = Ji(Xi(i2));
    return new RegExp(o2).test(r2);
  } catch {
    return false;
  }
  return false;
}
function Yi(e2) {
  let t2 = (n2) => n2 === void 0 ? "undefined" : n2 === "$" ? "$" : typeof n2 == "number" ? String(n2) : "pattern" in n2 ? `/${n2.pattern}/` : "first" in n2 ? `${n2.first}~${n2.step}` : "unknown";
  return `${t2(e2.start)},${t2(e2.end)}`;
}
function Vw(e2, t2, n2, r2, s2, i2) {
  if (!e2 || !e2.start && !e2.end) return true;
  let o2 = e2.start, a = e2.end;
  if (o2 !== void 0 && a === void 0) return _n(o2, t2, n2, r2, i2);
  if (o2 !== void 0 && a !== void 0) {
    let l = typeof o2 == "object" && "pattern" in o2, c = typeof a == "object" && "pattern" in a, u = Hw(a);
    if (u && s2) {
      let p = Yi(e2), d = s2.get(p);
      if (d || (d = { active: false }, s2.set(p, d)), d.active) {
        let m = d.startLine || t2;
        return t2 >= m + a.offset && (d.active = false, s2.set(p, d)), true;
      } else return _n(o2, t2, n2, r2, i2) ? (d.active = true, d.startLine = t2, s2.set(p, d), a.offset === 0 && (d.active = false, s2.set(p, d)), true) : false;
    }
    if (!l && !c && !u) {
      let p = typeof o2 == "number" ? o2 : o2 === "$" ? n2 : 1, d = typeof a == "number" ? a : n2;
      if (p <= d) return t2 >= p && t2 <= d;
      if (s2) {
        let m = Yi(e2), h = s2.get(m);
        return h || (h = { active: false }, s2.set(m, h)), !h.completed && t2 >= p ? (h.completed = true, s2.set(m, h), true) : false;
      }
      return false;
    }
    if (s2) {
      let p = Yi(e2), d = s2.get(p);
      if (d || (d = { active: false }, s2.set(p, d)), d.active) return _n(a, t2, n2, r2, i2) && (d.active = false, typeof o2 == "number" && (d.completed = true), s2.set(p, d)), true;
      {
        if (d.completed) return false;
        let m = false;
        return typeof o2 == "number" ? m = t2 >= o2 : m = _n(o2, t2, n2, r2, i2), m ? (d.active = true, d.startLine = t2, s2.set(p, d), _n(a, t2, n2, r2, i2) && (d.active = false, typeof o2 == "number" && (d.completed = true), s2.set(p, d)), true) : false;
      }
    }
    return _n(o2, t2, n2, r2, i2);
  }
  return true;
}
function dn(e2, t2, n2, r2, s2, i2) {
  let o2 = Vw(e2, t2, n2, r2, s2, i2);
  return (e2 == null ? void 0 : e2.negated) ? !o2 : o2;
}
function qw(e2, t2, n2, r2) {
  let s2 = "", i2 = 0, o2 = false;
  for (; i2 <= e2.length; ) {
    t2.lastIndex = i2;
    let a = t2.exec(e2);
    if (!a) {
      s2 += e2.slice(i2);
      break;
    }
    if (a.index !== i2) {
      s2 += e2.slice(i2, a.index), i2 = a.index, o2 = false;
      continue;
    }
    let l = a[0], c = a.slice(1);
    if (o2 && l.length === 0) {
      if (i2 < e2.length) s2 += e2[i2], i2++;
      else break;
      o2 = false;
      continue;
    }
    if (s2 += r2(l, c), o2 = false, l.length === 0) if (i2 < e2.length) s2 += e2[i2], i2++;
    else break;
    else i2 += l.length, o2 = true;
  }
  return s2;
}
function eo(e2, t2, n2) {
  let r2 = "", s2 = 0;
  for (; s2 < e2.length; ) {
    if (e2[s2] === "\\" && s2 + 1 < e2.length) {
      let i2 = e2[s2 + 1];
      if (i2 === "&") {
        r2 += "&", s2 += 2;
        continue;
      }
      if (i2 === "n") {
        r2 += `
`, s2 += 2;
        continue;
      }
      if (i2 === "t") {
        r2 += "	", s2 += 2;
        continue;
      }
      if (i2 === "r") {
        r2 += "\r", s2 += 2;
        continue;
      }
      let o2 = parseInt(i2, 10);
      if (o2 === 0) {
        r2 += t2, s2 += 2;
        continue;
      }
      if (o2 >= 1 && o2 <= 9) {
        r2 += n2[o2 - 1] || "", s2 += 2;
        continue;
      }
      r2 += i2, s2 += 2;
      continue;
    }
    if (e2[s2] === "&") {
      r2 += t2, s2++;
      continue;
    }
    r2 += e2[s2], s2++;
  }
  return r2;
}
function Gw(e2, t2) {
  let { lineNumber: n2, totalLines: r2, patternSpace: s2 } = t2;
  if (e2.type !== "label" && dn(e2.address, n2, r2, s2, t2.rangeStates, t2)) switch (e2.type) {
    case "substitute": {
      let i2 = e2, o2 = "";
      i2.global && (o2 += "g"), i2.ignoreCase && (o2 += "i");
      let a = i2.pattern;
      a === "" && t2.lastPattern ? a = t2.lastPattern : a !== "" && (t2.lastPattern = a);
      let l = Ji(i2.extendedRegex ? a : Xi(a));
      try {
        let c = new RegExp(l, o2), u = c.test(t2.patternSpace);
        if (c.lastIndex = 0, u) {
          if (t2.substitutionMade = true, i2.nthOccurrence && i2.nthOccurrence > 0 && !i2.global) {
            let f2 = 0, p = i2.nthOccurrence;
            t2.patternSpace = t2.patternSpace.replace(new RegExp(l, `g${i2.ignoreCase ? "i" : ""}`), (d, ...m) => {
              if (f2++, f2 === p) {
                let h = m.slice(0, -2);
                return eo(i2.replacement, d, h);
              }
              return d;
            });
          } else i2.global ? t2.patternSpace = qw(t2.patternSpace, new RegExp(l, `g${i2.ignoreCase ? "i" : ""}`), i2.replacement, (f2, p) => eo(i2.replacement, f2, p)) : t2.patternSpace = t2.patternSpace.replace(c, (f2, ...p) => {
            let d = p.slice(0, -2);
            return eo(i2.replacement, f2, d);
          });
          i2.printOnMatch && t2.lineNumberOutput.push(t2.patternSpace);
        }
      } catch {
      }
      break;
    }
    case "print":
      t2.lineNumberOutput.push(t2.patternSpace);
      break;
    case "printFirstLine": {
      let i2 = t2.patternSpace.indexOf(`
`);
      i2 !== -1 ? t2.lineNumberOutput.push(t2.patternSpace.slice(0, i2)) : t2.lineNumberOutput.push(t2.patternSpace);
      break;
    }
    case "delete":
      t2.deleted = true;
      break;
    case "deleteFirstLine": {
      let i2 = t2.patternSpace.indexOf(`
`);
      i2 !== -1 ? (t2.patternSpace = t2.patternSpace.slice(i2 + 1), t2.restartCycle = true, t2.inDRestartedCycle = true) : t2.deleted = true;
      break;
    }
    case "zap":
      t2.patternSpace = "";
      break;
    case "append":
      t2.appendBuffer.push(e2.text);
      break;
    case "insert":
      t2.appendBuffer.unshift(`__INSERT__${e2.text}`);
      break;
    case "change":
      t2.deleted = true, t2.changedText = e2.text;
      break;
    case "hold":
      t2.holdSpace = t2.patternSpace;
      break;
    case "holdAppend":
      t2.holdSpace ? t2.holdSpace += `
${t2.patternSpace}` : t2.holdSpace = t2.patternSpace;
      break;
    case "get":
      t2.patternSpace = t2.holdSpace;
      break;
    case "getAppend":
      t2.patternSpace += `
${t2.holdSpace}`;
      break;
    case "exchange": {
      let i2 = t2.patternSpace;
      t2.patternSpace = t2.holdSpace, t2.holdSpace = i2;
      break;
    }
    case "next":
      t2.printed = true;
      break;
    case "quit":
      t2.quit = true, e2.exitCode !== void 0 && (t2.exitCode = e2.exitCode);
      break;
    case "quitSilent":
      t2.quit = true, t2.quitSilent = true, e2.exitCode !== void 0 && (t2.exitCode = e2.exitCode);
      break;
    case "list": {
      let i2 = yu(t2.patternSpace);
      t2.lineNumberOutput.push(i2);
      break;
    }
    case "printFilename":
      t2.currentFilename && t2.lineNumberOutput.push(t2.currentFilename);
      break;
    case "version": {
      let i2 = [4, 8, 0];
      if (e2.minVersion) {
        let o2 = e2.minVersion.split("."), a = [], l = false;
        for (let c of o2) {
          let u = parseInt(c, 10);
          if (Number.isNaN(u) || u < 0) {
            t2.quit = true, t2.exitCode = 1, t2.errorMessage = `sed: invalid version string: ${e2.minVersion}`, l = true;
            break;
          }
          a.push(u);
        }
        if (!l) {
          for (; a.length < 3; ) a.push(0);
          for (let c = 0; c < 3; c++) {
            if (a[c] > i2[c]) {
              t2.quit = true, t2.exitCode = 1, t2.errorMessage = `sed: this is not GNU sed version ${e2.minVersion}`;
              break;
            }
            if (a[c] < i2[c]) break;
          }
        }
      }
      break;
    }
    case "readFile":
      t2.pendingFileReads.push({ filename: e2.filename, wholeFile: true });
      break;
    case "readFileLine":
      t2.pendingFileReads.push({ filename: e2.filename, wholeFile: false });
      break;
    case "writeFile":
      t2.pendingFileWrites.push({ filename: e2.filename, content: `${t2.patternSpace}
` });
      break;
    case "writeFirstLine": {
      let i2 = t2.patternSpace.indexOf(`
`), o2 = i2 !== -1 ? t2.patternSpace.slice(0, i2) : t2.patternSpace;
      t2.pendingFileWrites.push({ filename: e2.filename, content: `${o2}
` });
      break;
    }
    case "execute":
      e2.command ? t2.pendingExecute = { command: e2.command, replacePattern: false } : t2.pendingExecute = { command: t2.patternSpace, replacePattern: true };
      break;
    case "transliterate":
      t2.patternSpace = Zw(t2.patternSpace, e2);
      break;
    case "lineNumber":
      t2.lineNumberOutput.push(String(t2.lineNumber));
      break;
  }
}
function Zw(e2, t2) {
  let n2 = "";
  for (let r2 of e2) {
    let s2 = t2.source.indexOf(r2);
    s2 !== -1 ? n2 += t2.dest[s2] : n2 += r2;
  }
  return n2;
}
function to(e2, t2, n2, r2) {
  let s2 = /* @__PURE__ */ new Map();
  for (let l = 0; l < e2.length; l++) {
    let c = e2[l];
    c.type === "label" && s2.set(c.name, l);
  }
  let i2 = (r2 == null ? void 0 : r2.maxIterations) ?? zw, o2 = 0, a = 0;
  for (; a < e2.length; ) {
    if (o2++, o2 > i2) throw new ne(`sed: command execution exceeded maximum iterations (${i2})`, "iterations");
    if (t2.deleted || t2.quit || t2.quitSilent || t2.restartCycle) break;
    let l = e2[a];
    if (l.type === "next") {
      if (dn(l.address, t2.lineNumber, t2.totalLines, t2.patternSpace, t2.rangeStates, t2)) if (t2.nCommandOutput.push(t2.patternSpace), n2 && n2.currentLineIndex + t2.linesConsumedInCycle + 1 < n2.lines.length) {
        t2.linesConsumedInCycle++;
        let c = n2.lines[n2.currentLineIndex + t2.linesConsumedInCycle];
        t2.patternSpace = c, t2.lineNumber = n2.currentLineIndex + t2.linesConsumedInCycle + 1, t2.substitutionMade = false;
      } else {
        t2.quit = true, t2.deleted = true;
        break;
      }
      a++;
      continue;
    }
    if (l.type === "nextAppend") {
      if (dn(l.address, t2.lineNumber, t2.totalLines, t2.patternSpace, t2.rangeStates, t2)) if (n2 && n2.currentLineIndex + t2.linesConsumedInCycle + 1 < n2.lines.length) {
        t2.linesConsumedInCycle++;
        let c = n2.lines[n2.currentLineIndex + t2.linesConsumedInCycle];
        t2.patternSpace += `
${c}`, t2.lineNumber = n2.currentLineIndex + t2.linesConsumedInCycle + 1;
      } else {
        t2.quit = true;
        break;
      }
      a++;
      continue;
    }
    if (l.type === "branch") {
      let c = l;
      if (dn(c.address, t2.lineNumber, t2.totalLines, t2.patternSpace, t2.rangeStates, t2)) {
        if (c.label) {
          let u = s2.get(c.label);
          if (u !== void 0) {
            a = u;
            continue;
          }
          t2.branchRequest = c.label;
          break;
        }
        break;
      }
      a++;
      continue;
    }
    if (l.type === "branchOnSubst") {
      let c = l;
      if (dn(c.address, t2.lineNumber, t2.totalLines, t2.patternSpace, t2.rangeStates, t2) && t2.substitutionMade) {
        if (t2.substitutionMade = false, c.label) {
          let u = s2.get(c.label);
          if (u !== void 0) {
            a = u;
            continue;
          }
          t2.branchRequest = c.label;
          break;
        }
        break;
      }
      a++;
      continue;
    }
    if (l.type === "branchOnNoSubst") {
      let c = l;
      if (dn(c.address, t2.lineNumber, t2.totalLines, t2.patternSpace, t2.rangeStates, t2) && !t2.substitutionMade) {
        if (c.label) {
          let u = s2.get(c.label);
          if (u !== void 0) {
            a = u;
            continue;
          }
          t2.branchRequest = c.label;
          break;
        }
        break;
      }
      a++;
      continue;
    }
    if (l.type === "group") {
      let c = l;
      if (dn(c.address, t2.lineNumber, t2.totalLines, t2.patternSpace, t2.rangeStates, t2) && (to(c.commands, t2, n2, r2), t2.branchRequest)) {
        let u = s2.get(t2.branchRequest);
        if (u !== void 0) {
          t2.branchRequest = void 0, a = u;
          continue;
        }
        break;
      }
      a++;
      continue;
    }
    Gw(l, t2), a++;
  }
  return t2.linesConsumedInCycle;
}
var zw, xu = v(() => {
  de();
  bu();
  zw = 1e4;
});
var Z, cs, Eu = v(() => {
  (function(e2) {
    e2.NUMBER = "NUMBER", e2.DOLLAR = "DOLLAR", e2.PATTERN = "PATTERN", e2.STEP = "STEP", e2.RELATIVE_OFFSET = "RELATIVE_OFFSET", e2.LBRACE = "LBRACE", e2.RBRACE = "RBRACE", e2.SEMICOLON = "SEMICOLON", e2.NEWLINE = "NEWLINE", e2.COMMA = "COMMA", e2.NEGATION = "NEGATION", e2.COMMAND = "COMMAND", e2.SUBSTITUTE = "SUBSTITUTE", e2.TRANSLITERATE = "TRANSLITERATE", e2.LABEL_DEF = "LABEL_DEF", e2.BRANCH = "BRANCH", e2.BRANCH_ON_SUBST = "BRANCH_ON_SUBST", e2.BRANCH_ON_NO_SUBST = "BRANCH_ON_NO_SUBST", e2.TEXT_CMD = "TEXT_CMD", e2.FILE_READ = "FILE_READ", e2.FILE_READ_LINE = "FILE_READ_LINE", e2.FILE_WRITE = "FILE_WRITE", e2.FILE_WRITE_LINE = "FILE_WRITE_LINE", e2.EXECUTE = "EXECUTE", e2.VERSION = "VERSION", e2.EOF = "EOF", e2.ERROR = "ERROR";
  })(Z || (Z = {}));
  cs = class {
    constructor(t2) {
      __publicField(this, "input");
      __publicField(this, "pos", 0);
      __publicField(this, "line", 1);
      __publicField(this, "column", 1);
      this.input = t2;
    }
    tokenize() {
      let t2 = [];
      for (; this.pos < this.input.length; ) {
        let n2 = this.nextToken();
        n2 && t2.push(n2);
      }
      return t2.push(this.makeToken(Z.EOF, "")), t2;
    }
    makeToken(t2, n2, r2) {
      return { type: t2, value: n2, line: this.line, column: this.column, ...r2 };
    }
    peek(t2 = 0) {
      return this.input[this.pos + t2] || "";
    }
    advance() {
      let t2 = this.input[this.pos++] || "";
      return t2 === `
` ? (this.line++, this.column = 1) : this.column++, t2;
    }
    readEscapedString(t2) {
      let n2 = "";
      for (; this.pos < this.input.length && this.peek() !== t2; ) if (this.peek() === "\\") {
        this.advance();
        let r2 = this.advance();
        r2 === "n" ? n2 += `
` : r2 === "t" ? n2 += "	" : n2 += r2;
      } else {
        if (this.peek() === `
`) return null;
        n2 += this.advance();
      }
      return n2;
    }
    skipWhitespace() {
      for (; this.pos < this.input.length; ) {
        let t2 = this.peek();
        if (t2 === " " || t2 === "	" || t2 === "\r") this.advance();
        else if (t2 === "#") for (; this.pos < this.input.length && this.peek() !== `
`; ) this.advance();
        else break;
      }
    }
    nextToken() {
      if (this.skipWhitespace(), this.pos >= this.input.length) return null;
      let t2 = this.line, n2 = this.column, r2 = this.peek();
      return r2 === `
` ? (this.advance(), { type: Z.NEWLINE, value: `
`, line: t2, column: n2 }) : r2 === ";" ? (this.advance(), { type: Z.SEMICOLON, value: ";", line: t2, column: n2 }) : r2 === "{" ? (this.advance(), { type: Z.LBRACE, value: "{", line: t2, column: n2 }) : r2 === "}" ? (this.advance(), { type: Z.RBRACE, value: "}", line: t2, column: n2 }) : r2 === "," ? (this.advance(), { type: Z.COMMA, value: ",", line: t2, column: n2 }) : r2 === "!" ? (this.advance(), { type: Z.NEGATION, value: "!", line: t2, column: n2 }) : r2 === "$" ? (this.advance(), { type: Z.DOLLAR, value: "$", line: t2, column: n2 }) : this.isDigit(r2) ? this.readNumber() : r2 === "+" && this.isDigit(this.input[this.pos + 1] || "") ? this.readRelativeOffset() : r2 === "/" ? this.readPattern() : r2 === ":" ? this.readLabelDef() : this.readCommand();
    }
    readNumber() {
      let t2 = this.line, n2 = this.column, r2 = "";
      for (; this.isDigit(this.peek()); ) r2 += this.advance();
      if (this.peek() === "~") {
        this.advance();
        let s2 = "";
        for (; this.isDigit(this.peek()); ) s2 += this.advance();
        let i2 = parseInt(r2, 10), o2 = parseInt(s2, 10) || 0;
        return { type: Z.STEP, value: `${i2}~${o2}`, first: i2, step: o2, line: t2, column: n2 };
      }
      return { type: Z.NUMBER, value: parseInt(r2, 10), line: t2, column: n2 };
    }
    readRelativeOffset() {
      let t2 = this.line, n2 = this.column;
      this.advance();
      let r2 = "";
      for (; this.isDigit(this.peek()); ) r2 += this.advance();
      let s2 = parseInt(r2, 10) || 0;
      return { type: Z.RELATIVE_OFFSET, value: `+${s2}`, offset: s2, line: t2, column: n2 };
    }
    readPattern() {
      let t2 = this.line, n2 = this.column;
      this.advance();
      let r2 = "", s2 = false;
      for (; this.pos < this.input.length; ) {
        let i2 = this.peek();
        if (i2 === "/" && !s2) break;
        if (i2 === "\\") r2 += this.advance(), this.pos < this.input.length && this.peek() !== `
` && (r2 += this.advance());
        else {
          if (i2 === `
`) break;
          i2 === "[" && !s2 ? (s2 = true, r2 += this.advance(), this.peek() === "^" && (r2 += this.advance()), this.peek() === "]" && (r2 += this.advance())) : i2 === "]" && s2 ? (s2 = false, r2 += this.advance()) : r2 += this.advance();
        }
      }
      return this.peek() === "/" && this.advance(), { type: Z.PATTERN, value: r2, pattern: r2, line: t2, column: n2 };
    }
    readLabelDef() {
      let t2 = this.line, n2 = this.column;
      for (this.advance(); this.peek() === " " || this.peek() === "	"; ) this.advance();
      let r2 = "";
      for (; this.pos < this.input.length; ) {
        let s2 = this.peek();
        if (s2 === " " || s2 === "	" || s2 === `
` || s2 === ";" || s2 === "}" || s2 === "{") break;
        r2 += this.advance();
      }
      return { type: Z.LABEL_DEF, value: r2, label: r2, line: t2, column: n2 };
    }
    readCommand() {
      let t2 = this.line, n2 = this.column, r2 = this.advance();
      switch (r2) {
        case "s":
          return this.readSubstitute(t2, n2);
        case "y":
          return this.readTransliterate(t2, n2);
        case "a":
        case "i":
        case "c":
          return this.readTextCommand(r2, t2, n2);
        case "b":
          return this.readBranch(Z.BRANCH, "b", t2, n2);
        case "t":
          return this.readBranch(Z.BRANCH_ON_SUBST, "t", t2, n2);
        case "T":
          return this.readBranch(Z.BRANCH_ON_NO_SUBST, "T", t2, n2);
        case "r":
          return this.readFileCommand(Z.FILE_READ, "r", t2, n2);
        case "R":
          return this.readFileCommand(Z.FILE_READ_LINE, "R", t2, n2);
        case "w":
          return this.readFileCommand(Z.FILE_WRITE, "w", t2, n2);
        case "W":
          return this.readFileCommand(Z.FILE_WRITE_LINE, "W", t2, n2);
        case "e":
          return this.readExecute(t2, n2);
        case "p":
        case "P":
        case "d":
        case "D":
        case "h":
        case "H":
        case "g":
        case "G":
        case "x":
        case "n":
        case "N":
        case "q":
        case "Q":
        case "z":
        case "=":
        case "l":
        case "F":
          return { type: Z.COMMAND, value: r2, line: t2, column: n2 };
        case "v":
          return this.readVersion(t2, n2);
        default:
          return { type: Z.ERROR, value: r2, line: t2, column: n2 };
      }
    }
    readSubstitute(t2, n2) {
      let r2 = this.advance();
      if (!r2 || r2 === `
`) return { type: Z.ERROR, value: "s", line: t2, column: n2 };
      let s2 = "", i2 = false;
      for (; this.pos < this.input.length; ) {
        let l = this.peek();
        if (l === r2 && !i2) break;
        if (l === "\\") this.advance(), this.pos < this.input.length && this.peek() !== `
` ? this.peek() === r2 && !i2 ? s2 += this.advance() : (s2 += "\\", s2 += this.advance()) : s2 += "\\";
        else {
          if (l === `
`) break;
          l === "[" && !i2 ? (i2 = true, s2 += this.advance(), this.peek() === "^" && (s2 += this.advance()), this.peek() === "]" && (s2 += this.advance())) : l === "]" && i2 ? (i2 = false, s2 += this.advance()) : s2 += this.advance();
        }
      }
      if (this.peek() !== r2) return { type: Z.ERROR, value: "unterminated substitution pattern", line: t2, column: n2 };
      this.advance();
      let o2 = "";
      for (; this.pos < this.input.length && this.peek() !== r2; ) if (this.peek() === "\\") if (this.advance(), this.pos < this.input.length) {
        let l = this.peek();
        l === "\\" ? (this.advance(), this.pos < this.input.length && this.peek() === `
` ? (o2 += `
`, this.advance()) : o2 += "\\") : l === `
` ? (o2 += `
`, this.advance()) : o2 += `\\${this.advance()}`;
      } else o2 += "\\";
      else {
        if (this.peek() === `
`) break;
        o2 += this.advance();
      }
      this.peek() === r2 && this.advance();
      let a = "";
      for (; this.pos < this.input.length; ) {
        let l = this.peek();
        if (l === "g" || l === "i" || l === "p" || l === "I" || this.isDigit(l)) a += this.advance();
        else break;
      }
      return { type: Z.SUBSTITUTE, value: `s${r2}${s2}${r2}${o2}${r2}${a}`, pattern: s2, replacement: o2, flags: a, line: t2, column: n2 };
    }
    readTransliterate(t2, n2) {
      let r2 = this.advance();
      if (!r2 || r2 === `
`) return { type: Z.ERROR, value: "y", line: t2, column: n2 };
      let s2 = this.readEscapedString(r2);
      if (s2 === null || this.peek() !== r2) return { type: Z.ERROR, value: "unterminated transliteration source", line: t2, column: n2 };
      this.advance();
      let i2 = this.readEscapedString(r2);
      if (i2 === null || this.peek() !== r2) return { type: Z.ERROR, value: "unterminated transliteration dest", line: t2, column: n2 };
      this.advance();
      let o2 = this.peek();
      for (; o2 === " " || o2 === "	"; ) this.advance(), o2 = this.peek();
      return o2 !== "" && o2 !== ";" && o2 !== `
` && o2 !== "}" ? { type: Z.ERROR, value: "extra text at the end of a transform command", line: t2, column: n2 } : { type: Z.TRANSLITERATE, value: `y${r2}${s2}${r2}${i2}${r2}`, source: s2, dest: i2, line: t2, column: n2 };
    }
    readTextCommand(t2, n2, r2) {
      let s2 = false;
      this.peek() === "\\" && this.pos + 1 < this.input.length && (this.input[this.pos + 1] === `
` || this.input[this.pos + 1] === " " || this.input[this.pos + 1] === "	") && (s2 = true, this.advance()), (this.peek() === " " || this.peek() === "	") && this.advance(), this.peek() === "\\" && this.pos + 1 < this.input.length && (this.input[this.pos + 1] === " " || this.input[this.pos + 1] === "	") && this.advance(), s2 && this.peek() === `
` && this.advance();
      let i2 = "";
      for (; this.pos < this.input.length; ) {
        let o2 = this.peek();
        if (o2 === `
`) {
          if (i2.endsWith("\\")) {
            i2 = `${i2.slice(0, -1)}
`, this.advance();
            continue;
          }
          break;
        }
        if (o2 === "\\" && this.pos + 1 < this.input.length) {
          let a = this.input[this.pos + 1];
          if (a === "n") {
            i2 += `
`, this.advance(), this.advance();
            continue;
          }
          if (a === "t") {
            i2 += "	", this.advance(), this.advance();
            continue;
          }
          if (a === "r") {
            i2 += "\r", this.advance(), this.advance();
            continue;
          }
        }
        i2 += this.advance();
      }
      return { type: Z.TEXT_CMD, value: t2, text: i2, line: n2, column: r2 };
    }
    readBranch(t2, n2, r2, s2) {
      for (; this.peek() === " " || this.peek() === "	"; ) this.advance();
      let i2 = "";
      for (; this.pos < this.input.length; ) {
        let o2 = this.peek();
        if (o2 === " " || o2 === "	" || o2 === `
` || o2 === ";" || o2 === "}" || o2 === "{") break;
        i2 += this.advance();
      }
      return { type: t2, value: n2, label: i2 || void 0, line: r2, column: s2 };
    }
    readVersion(t2, n2) {
      for (; this.peek() === " " || this.peek() === "	"; ) this.advance();
      let r2 = "";
      for (; this.pos < this.input.length; ) {
        let s2 = this.peek();
        if (s2 === " " || s2 === "	" || s2 === `
` || s2 === ";" || s2 === "}" || s2 === "{") break;
        r2 += this.advance();
      }
      return { type: Z.VERSION, value: "v", label: r2 || void 0, line: t2, column: n2 };
    }
    readFileCommand(t2, n2, r2, s2) {
      for (; this.peek() === " " || this.peek() === "	"; ) this.advance();
      let i2 = "";
      for (; this.pos < this.input.length; ) {
        let o2 = this.peek();
        if (o2 === `
` || o2 === ";") break;
        i2 += this.advance();
      }
      return { type: t2, value: n2, filename: i2.trim(), line: r2, column: s2 };
    }
    readExecute(t2, n2) {
      for (; this.peek() === " " || this.peek() === "	"; ) this.advance();
      let r2 = "";
      for (; this.pos < this.input.length; ) {
        let s2 = this.peek();
        if (s2 === `
` || s2 === ";") break;
        r2 += this.advance();
      }
      return { type: Z.EXECUTE, value: "e", command: r2.trim() || void 0, line: t2, column: n2 };
    }
    isDigit(t2) {
      return t2 >= "0" && t2 <= "9";
    }
  };
});
function Su(e2, t2 = false) {
  let n2 = false, r2 = false, s2 = [];
  for (let l = 0; l < e2.length; l++) {
    let c = e2[l];
    if (s2.length === 0 && l === 0) {
      let u = c.match(/^#([nr]+)\s*(?:\n|$)/i);
      if (u) {
        let f2 = u[1].toLowerCase();
        f2.includes("n") && (n2 = true), f2.includes("r") && (r2 = true), c = c.slice(u[0].length);
      }
    }
    if (s2.length > 0 && s2[s2.length - 1].endsWith("\\")) {
      let u = s2[s2.length - 1];
      s2[s2.length - 1] = `${u}
${c}`;
    } else s2.push(c);
  }
  let i2 = s2.join(`
`), a = new no([i2], t2 || r2).parse();
  if (!a.error && a.commands.length > 0) {
    let l = Qw(a.commands);
    if (l) return { commands: [], error: l, silentMode: n2, extendedRegexMode: r2 };
  }
  return { ...a, silentMode: n2, extendedRegexMode: r2 };
}
function Qw(e2) {
  let t2 = /* @__PURE__ */ new Set();
  Au(e2, t2);
  let n2 = Cu(e2, t2);
  if (n2) return `undefined label '${n2}'`;
}
function Au(e2, t2) {
  for (let n2 of e2) n2.type === "label" ? t2.add(n2.name) : n2.type === "group" && Au(n2.commands, t2);
}
function Cu(e2, t2) {
  for (let n2 of e2) {
    if ((n2.type === "branch" || n2.type === "branchOnSubst" || n2.type === "branchOnNoSubst") && n2.label && !t2.has(n2.label)) return n2.label;
    if (n2.type === "group") {
      let r2 = Cu(n2.commands, t2);
      if (r2) return r2;
    }
  }
}
var no, Nu = v(() => {
  Eu();
  no = class {
    constructor(t2, n2 = false) {
      __publicField(this, "scripts");
      __publicField(this, "tokens", []);
      __publicField(this, "pos", 0);
      __publicField(this, "extendedRegex", false);
      this.scripts = t2, this.extendedRegex = n2;
    }
    parse() {
      let t2 = [];
      for (let n2 of this.scripts) {
        let r2 = new cs(n2);
        for (this.tokens = r2.tokenize(), this.pos = 0; !this.isAtEnd(); ) {
          if (this.check(Z.NEWLINE) || this.check(Z.SEMICOLON)) {
            this.advance();
            continue;
          }
          let s2 = this.parseCommand();
          if (s2.error) return { commands: [], error: s2.error };
          s2.command && t2.push(s2.command);
        }
      }
      return { commands: t2 };
    }
    parseCommand() {
      let t2 = this.parseAddressRange();
      if (t2 == null ? void 0 : t2.error) return { command: null, error: t2.error };
      let n2 = t2 == null ? void 0 : t2.address;
      for (this.check(Z.NEGATION) && (this.advance(), n2 && (n2.negated = true)); this.check(Z.NEWLINE) || this.check(Z.SEMICOLON); ) this.advance();
      if (this.isAtEnd()) return n2 && (n2.start !== void 0 || n2.end !== void 0) ? { command: null, error: "command expected" } : { command: null };
      let r2 = this.peek();
      switch (r2.type) {
        case Z.COMMAND:
          return this.parseSimpleCommand(r2, n2);
        case Z.SUBSTITUTE:
          return this.parseSubstituteFromToken(r2, n2);
        case Z.TRANSLITERATE:
          return this.parseTransliterateFromToken(r2, n2);
        case Z.LABEL_DEF:
          return this.advance(), { command: { type: "label", name: r2.label || "" } };
        case Z.BRANCH:
          return this.advance(), { command: { type: "branch", address: n2, label: r2.label } };
        case Z.BRANCH_ON_SUBST:
          return this.advance(), { command: { type: "branchOnSubst", address: n2, label: r2.label } };
        case Z.BRANCH_ON_NO_SUBST:
          return this.advance(), { command: { type: "branchOnNoSubst", address: n2, label: r2.label } };
        case Z.TEXT_CMD:
          return this.advance(), this.parseTextCommand(r2, n2);
        case Z.FILE_READ:
          return this.advance(), { command: { type: "readFile", address: n2, filename: r2.filename || "" } };
        case Z.FILE_READ_LINE:
          return this.advance(), { command: { type: "readFileLine", address: n2, filename: r2.filename || "" } };
        case Z.FILE_WRITE:
          return this.advance(), { command: { type: "writeFile", address: n2, filename: r2.filename || "" } };
        case Z.FILE_WRITE_LINE:
          return this.advance(), { command: { type: "writeFirstLine", address: n2, filename: r2.filename || "" } };
        case Z.EXECUTE:
          return this.advance(), { command: { type: "execute", address: n2, command: r2.command } };
        case Z.VERSION:
          return this.advance(), { command: { type: "version", address: n2, minVersion: r2.label } };
        case Z.LBRACE:
          return this.parseGroup(n2);
        case Z.RBRACE:
          return { command: null };
        case Z.ERROR:
          return { command: null, error: `invalid command: ${r2.value}` };
        default:
          return n2 && (n2.start !== void 0 || n2.end !== void 0) ? { command: null, error: "command expected" } : { command: null };
      }
    }
    parseSimpleCommand(t2, n2) {
      this.advance();
      let r2 = t2.value;
      switch (r2) {
        case "p":
          return { command: { type: "print", address: n2 } };
        case "P":
          return { command: { type: "printFirstLine", address: n2 } };
        case "d":
          return { command: { type: "delete", address: n2 } };
        case "D":
          return { command: { type: "deleteFirstLine", address: n2 } };
        case "h":
          return { command: { type: "hold", address: n2 } };
        case "H":
          return { command: { type: "holdAppend", address: n2 } };
        case "g":
          return { command: { type: "get", address: n2 } };
        case "G":
          return { command: { type: "getAppend", address: n2 } };
        case "x":
          return { command: { type: "exchange", address: n2 } };
        case "n":
          return { command: { type: "next", address: n2 } };
        case "N":
          return { command: { type: "nextAppend", address: n2 } };
        case "q":
          return { command: { type: "quit", address: n2 } };
        case "Q":
          return { command: { type: "quitSilent", address: n2 } };
        case "z":
          return { command: { type: "zap", address: n2 } };
        case "=":
          return { command: { type: "lineNumber", address: n2 } };
        case "l":
          return { command: { type: "list", address: n2 } };
        case "F":
          return { command: { type: "printFilename", address: n2 } };
        default:
          return { command: null, error: `unknown command: ${r2}` };
      }
    }
    parseSubstituteFromToken(t2, n2) {
      this.advance();
      let r2 = t2.flags || "", s2, i2 = r2.match(/(\d+)/);
      return i2 && (s2 = parseInt(i2[1], 10)), { command: { type: "substitute", address: n2, pattern: t2.pattern || "", replacement: t2.replacement || "", global: r2.includes("g"), ignoreCase: r2.includes("i") || r2.includes("I"), printOnMatch: r2.includes("p"), nthOccurrence: s2, extendedRegex: this.extendedRegex } };
    }
    parseTransliterateFromToken(t2, n2) {
      this.advance();
      let r2 = t2.source || "", s2 = t2.dest || "";
      return r2.length !== s2.length ? { command: null, error: "transliteration sets must have same length" } : { command: { type: "transliterate", address: n2, source: r2, dest: s2 } };
    }
    parseTextCommand(t2, n2) {
      let r2 = t2.value, s2 = t2.text || "";
      switch (r2) {
        case "a":
          return { command: { type: "append", address: n2, text: s2 } };
        case "i":
          return { command: { type: "insert", address: n2, text: s2 } };
        case "c":
          return { command: { type: "change", address: n2, text: s2 } };
        default:
          return { command: null, error: `unknown text command: ${r2}` };
      }
    }
    parseGroup(t2) {
      this.advance();
      let n2 = [];
      for (; !this.isAtEnd() && !this.check(Z.RBRACE); ) {
        if (this.check(Z.NEWLINE) || this.check(Z.SEMICOLON)) {
          this.advance();
          continue;
        }
        let r2 = this.parseCommand();
        if (r2.error) return { command: null, error: r2.error };
        r2.command && n2.push(r2.command);
      }
      return this.check(Z.RBRACE) ? (this.advance(), { command: { type: "group", address: t2, commands: n2 } }) : { command: null, error: "unmatched brace in grouped commands" };
    }
    parseAddressRange() {
      let t2 = this.parseAddress();
      if (t2 === void 0) return;
      let n2;
      if (this.check(Z.RELATIVE_OFFSET)) n2 = { offset: this.advance().offset || 0 };
      else if (this.check(Z.COMMA) && (this.advance(), n2 = this.parseAddress(), n2 === void 0)) return { error: "expected context address" };
      return { address: { start: t2, end: n2 } };
    }
    parseAddress() {
      let t2 = this.peek();
      switch (t2.type) {
        case Z.NUMBER:
          return this.advance(), t2.value;
        case Z.DOLLAR:
          return this.advance(), "$";
        case Z.PATTERN:
          return this.advance(), { pattern: t2.pattern || t2.value };
        case Z.STEP:
          return this.advance(), { first: t2.first || 0, step: t2.step || 0 };
        case Z.RELATIVE_OFFSET:
          return this.advance(), { offset: t2.offset || 0 };
        default:
          return;
      }
    }
    peek() {
      return this.tokens[this.pos] || { type: Z.EOF, value: "", line: 0, column: 0 };
    }
    advance() {
      return this.isAtEnd() || this.pos++, this.tokens[this.pos - 1];
    }
    check(t2) {
      return this.peek().type === t2;
    }
    isAtEnd() {
      return this.peek().type === Z.EOF;
    }
  };
});
var ku = {};
V(ku, { sedCommand: () => Xw });
async function ro(e2, t2, n2, r2 = {}) {
  let { limits: s2, filename: i2, fs: o2, cwd: a } = r2, l = e2.endsWith(`
`), c = e2.split(`
`);
  c.length > 0 && c[c.length - 1] === "" && c.pop();
  let u = c.length, f2 = "", p, d = false, m = "", h, g = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Map(), E = s2 ? { maxIterations: s2.maxSedIterations } : void 0;
  for (let C = 0; C < c.length; C++) {
    let A = { ...wu(u, i2, g), patternSpace: c[C], holdSpace: m, lastPattern: h, lineNumber: C + 1, totalLines: u, substitutionMade: false }, I = { lines: c, currentLineIndex: C }, O = 0, L = 1e4;
    A.linesConsumedInCycle = 0;
    do {
      if (O++, O > L) break;
      if (A.restartCycle = false, A.pendingFileReads = [], A.pendingFileWrites = [], to(t2, A, I, E), o2 && a) {
        for (let R2 of A.pendingFileReads) {
          let T = o2.resolvePath(a, R2.filename);
          try {
            if (R2.wholeFile) {
              let Y = await o2.readFile(T);
              A.appendBuffer.push(Y.replace(/\n$/, ""));
            } else {
              if (!b.has(T)) {
                let K = await o2.readFile(T);
                b.set(T, K.split(`
`)), y.set(T, 0);
              }
              let Y = b.get(T), ie = y.get(T);
              Y && ie !== void 0 && ie < Y.length && (A.appendBuffer.push(Y[ie]), y.set(T, ie + 1));
            }
          } catch {
          }
        }
        for (let R2 of A.pendingFileWrites) {
          let T = o2.resolvePath(a, R2.filename), Y = w.get(T) || "";
          w.set(T, Y + R2.content);
        }
      }
    } while (A.restartCycle && !A.deleted && !A.quit && !A.quitSilent);
    if (C += A.linesConsumedInCycle, m = A.holdSpace, h = A.lastPattern, !n2) for (let R2 of A.nCommandOutput) f2 += `${R2}
`;
    let D = A.lineNumberOutput.length > 0;
    for (let R2 of A.lineNumberOutput) f2 += `${R2}
`;
    let $ = [], N2 = [];
    for (let R2 of A.appendBuffer) R2.startsWith("__INSERT__") ? $.push(R2.slice(10)) : N2.push(R2);
    for (let R2 of $) f2 += `${R2}
`;
    let P = false;
    !A.deleted && !A.quitSilent ? n2 ? A.printed && (f2 += `${A.patternSpace}
`, P = true) : (f2 += `${A.patternSpace}
`, P = true) : A.changedText !== void 0 && (f2 += `${A.changedText}
`, P = true);
    for (let R2 of N2) f2 += `${R2}
`;
    if (d = (D || P) && N2.length === 0, A.quit || A.quitSilent) {
      if (A.exitCode !== void 0 && (p = A.exitCode), A.errorMessage) return { output: "", exitCode: p || 1, errorMessage: A.errorMessage };
      break;
    }
  }
  if (o2 && a) for (let [C, A] of w) try {
    await o2.writeFile(C, A);
  } catch {
  }
  return !l && d && f2.endsWith(`
`) && (f2 = f2.slice(0, -1)), { output: f2, exitCode: p };
}
var Kw, Xw, vu = v(() => {
  de();
  X();
  xu();
  Nu();
  Kw = { name: "sed", summary: "stream editor for filtering and transforming text", usage: "sed [OPTION]... {script} [input-file]...", options: ["-n, --quiet, --silent  suppress automatic printing of pattern space", "-e script              add the script to commands to be executed", "-f script-file         read script from file", "-i, --in-place         edit files in place", "-E, -r, --regexp-extended  use extended regular expressions", "    --help             display this help and exit"], description: `Commands:
  s/regexp/replacement/[flags]  substitute
  d                             delete pattern space
  p                             print pattern space
  a\\ text                       append text after line
  i\\ text                       insert text before line
  c\\ text                       change (replace) line with text
  h                             copy pattern space to hold space
  H                             append pattern space to hold space
  g                             copy hold space to pattern space
  G                             append hold space to pattern space
  x                             exchange pattern and hold spaces
  n                             read next line into pattern space
  N                             append next line to pattern space
  y/source/dest/                transliterate characters
  =                             print line number
  l                             list pattern space (escape special chars)
  b [label]                     branch to label
  t [label]                     branch on substitution
  T [label]                     branch if no substitution
  :label                        define label
  q                             quit
  Q                             quit without printing

Addresses:
  N                             line number
  $                             last line
  /regexp/                      lines matching regexp
  N,M                           range from line N to M
  first~step                    every step-th line starting at first` };
  Xw = { name: "sed", async execute(e2, t2) {
    if (_(e2)) return F$3(Kw);
    let n2 = [], r2 = [], s2 = false, i2 = false, o2 = false, a = [];
    for (let m = 0; m < e2.length; m++) {
      let h = e2[m];
      if (h === "-n" || h === "--quiet" || h === "--silent") s2 = true;
      else if (h === "-i" || h === "--in-place") i2 = true;
      else if (h.startsWith("-i")) i2 = true;
      else if (h === "-E" || h === "-r" || h === "--regexp-extended") o2 = true;
      else if (h === "-e") m + 1 < e2.length && n2.push(e2[++m]);
      else if (h === "-f") m + 1 < e2.length && r2.push(e2[++m]);
      else {
        if (h.startsWith("--")) return G("sed", h);
        if (h === "-") a.push(h);
        else if (h.startsWith("-") && h.length > 1) {
          for (let g of h.slice(1)) if (g !== "n" && g !== "e" && g !== "f" && g !== "i" && g !== "E" && g !== "r") return G("sed", `-${g}`);
          h.includes("n") && (s2 = true), h.includes("i") && (i2 = true), (h.includes("E") || h.includes("r")) && (o2 = true), h.includes("e") && !h.includes("n") && !h.includes("i") && m + 1 < e2.length && n2.push(e2[++m]), h.includes("f") && !h.includes("e") && m + 1 < e2.length && r2.push(e2[++m]);
        } else !h.startsWith("-") && n2.length === 0 && r2.length === 0 ? n2.push(h) : h.startsWith("-") || a.push(h);
      }
    }
    for (let m of r2) {
      let h = t2.fs.resolvePath(t2.cwd, m);
      try {
        let g = await t2.fs.readFile(h);
        for (let b of g.split(`
`)) {
          let y = b.trim();
          y && !y.startsWith("#") && n2.push(y);
        }
      } catch {
        return { stdout: "", stderr: `sed: couldn't open file ${m}: No such file or directory
`, exitCode: 1 };
      }
    }
    if (n2.length === 0) return { stdout: "", stderr: `sed: no script specified
`, exitCode: 1 };
    let { commands: l, error: c, silentMode: u } = Su(n2, o2);
    if (c) return { stdout: "", stderr: `sed: ${c}
`, exitCode: 1 };
    let f2 = !!(s2 || u);
    if (i2) {
      if (a.length === 0) return { stdout: "", stderr: `sed: -i requires at least one file argument
`, exitCode: 1 };
      for (let m of a) {
        if (m === "-") continue;
        let h = t2.fs.resolvePath(t2.cwd, m);
        try {
          let g = await t2.fs.readFile(h), b = await ro(g, l, f2, { limits: t2.limits, filename: m, fs: t2.fs, cwd: t2.cwd });
          if (b.errorMessage) return { stdout: "", stderr: `${b.errorMessage}
`, exitCode: b.exitCode ?? 1 };
          await t2.fs.writeFile(h, b.output);
        } catch (g) {
          return g instanceof ne ? { stdout: "", stderr: `sed: ${g.message}
`, exitCode: ne.EXIT_CODE } : { stdout: "", stderr: `sed: ${m}: No such file or directory
`, exitCode: 1 };
        }
      }
      return { stdout: "", stderr: "", exitCode: 0 };
    }
    let p = "";
    if (a.length === 0) {
      p = t2.stdin;
      try {
        let m = await ro(p, l, f2, { limits: t2.limits, fs: t2.fs, cwd: t2.cwd });
        return { stdout: m.output, stderr: m.errorMessage ? `${m.errorMessage}
` : "", exitCode: m.exitCode ?? 0 };
      } catch (m) {
        if (m instanceof ne) return { stdout: "", stderr: `sed: ${m.message}
`, exitCode: ne.EXIT_CODE };
        throw m;
      }
    }
    let d = false;
    for (let m of a) {
      let h;
      if (m === "-") d ? h = "" : (h = t2.stdin, d = true);
      else {
        let g = t2.fs.resolvePath(t2.cwd, m);
        try {
          h = await t2.fs.readFile(g);
        } catch (b) {
          return b instanceof ne ? { stdout: "", stderr: `sed: ${b.message}
`, exitCode: ne.EXIT_CODE } : { stdout: "", stderr: `sed: ${m}: No such file or directory
`, exitCode: 1 };
        }
      }
      p.length > 0 && h.length > 0 && !p.endsWith(`
`) && (p += `
`), p += h;
    }
    try {
      let m = await ro(p, l, f2, { limits: t2.limits, filename: a.length === 1 ? a[0] : void 0, fs: t2.fs, cwd: t2.cwd });
      return { stdout: m.output, stderr: m.errorMessage ? `${m.errorMessage}
` : "", exitCode: m.exitCode ?? 0 };
    } catch (m) {
      if (m instanceof ne) return { stdout: "", stderr: `sed: ${m.message}
`, exitCode: ne.EXIT_CODE };
      throw m;
    }
  } };
});
function so(e2 = {}) {
  let { fieldSep: t2 = /\s+/, maxIterations: n2 = 1e4, maxRecursionDepth: r2 = 100, fs: s2, cwd: i2, exec: o2 } = e2;
  return { FS: " ", OFS: " ", ORS: `
`, OFMT: "%.6g", NR: 0, NF: 0, FNR: 0, FILENAME: "", RSTART: 0, RLENGTH: -1, SUBSEP: "", fields: [], line: "", vars: {}, arrays: {}, arrayAliases: /* @__PURE__ */ new Map(), ARGC: 0, ARGV: {}, ENVIRON: {}, functions: /* @__PURE__ */ new Map(), fieldSep: t2, maxIterations: n2, maxRecursionDepth: r2, currentRecursionDepth: 0, exitCode: 0, shouldExit: false, shouldNext: false, shouldNextFile: false, loopBreak: false, loopContinue: false, hasReturn: false, inEndBlock: false, output: "", openedFiles: /* @__PURE__ */ new Set(), fs: s2, cwd: i2, exec: o2 };
}
var $u = v(() => {
});
function Iu(e2, t2, n2) {
  switch (n2) {
    case "+":
      return e2 + t2;
    case "-":
      return e2 - t2;
    case "*":
      return e2 * t2;
    case "/":
      return t2 !== 0 ? e2 / t2 : 0;
    case "%":
      return t2 !== 0 ? e2 % t2 : 0;
    case "^":
    case "**":
      return e2 ** t2;
    default:
      return 0;
  }
}
var Ru = v(() => {
});
function Nt(e2) {
  if (typeof e2 == "number") return e2;
  let t2 = parseFloat(e2);
  return Number.isNaN(t2) ? 0 : t2;
}
function qe(e2) {
  return typeof e2 == "string" ? e2 : String(e2);
}
async function us(e2, t2) {
  if (e2.type === "regex") return e2.pattern;
  let n2 = qe(await t2.evalExpr(e2));
  return n2.startsWith("/") && n2.endsWith("/") && (n2 = n2.slice(1, -1)), n2;
}
async function Tu(e2, t2) {
  return e2 ? e2.type === "variable" ? e2.name : e2.type === "field" ? `$${Math.floor(Nt(await t2.evalExpr(e2.index)))}` : "$0" : "$0";
}
function Ou(e2, t2) {
  if (e2 === "$0") return t2.line;
  if (e2.startsWith("$")) {
    let n2 = parseInt(e2.slice(1), 10) - 1;
    return t2.fields[n2] || "";
  }
  return qe(t2.vars[e2] ?? "");
}
function Du(e2, t2, n2) {
  if (e2 === "$0") n2.line = t2, n2.fields = n2.FS === " " ? t2.trim().split(/\s+/).filter(Boolean) : t2.split(n2.fieldSep), n2.NF = n2.fields.length;
  else if (e2.startsWith("$")) {
    let r2 = parseInt(e2.slice(1), 10) - 1;
    for (; n2.fields.length <= r2; ) n2.fields.push("");
    n2.fields[r2] = t2, n2.NF = n2.fields.length, n2.line = n2.fields.join(n2.OFS);
  } else n2.vars[e2] = t2;
}
async function Jw(e2, t2, n2) {
  return e2.length === 0 ? t2.line.length : qe(await n2.evalExpr(e2[0])).length;
}
async function Yw(e2, t2, n2) {
  if (e2.length < 2) return "";
  let r2 = qe(await n2.evalExpr(e2[0])), s2 = Math.floor(Nt(await n2.evalExpr(e2[1]))) - 1;
  if (e2.length >= 3) {
    let i2 = Math.floor(Nt(await n2.evalExpr(e2[2])));
    return r2.substr(Math.max(0, s2), i2);
  }
  return r2.substr(Math.max(0, s2));
}
async function ex(e2, t2, n2) {
  if (e2.length < 2) return 0;
  let r2 = qe(await n2.evalExpr(e2[0])), s2 = qe(await n2.evalExpr(e2[1])), i2 = r2.indexOf(s2);
  return i2 === -1 ? 0 : i2 + 1;
}
async function tx(e2, t2, n2) {
  if (e2.length < 2) return 0;
  let r2 = qe(await n2.evalExpr(e2[0])), s2 = e2[1];
  if (s2.type !== "variable") return 0;
  let i2 = s2.name, o2 = t2.FS;
  if (e2.length >= 3) {
    let l = e2[2];
    if (l.type === "regex") o2 = new RegExp(l.pattern);
    else {
      let c = qe(await n2.evalExpr(l));
      o2 = c === " " ? /\s+/ : c;
    }
  } else t2.FS === " " && (o2 = /\s+/);
  let a = r2.split(o2);
  t2.arrays[i2] = {};
  for (let l = 0; l < a.length; l++) t2.arrays[i2][String(l + 1)] = a[l];
  return a.length;
}
async function nx(e2, t2, n2) {
  if (e2.length < 2) return 0;
  let r2 = await us(e2[0], n2), s2 = qe(await n2.evalExpr(e2[1])), i2 = await Tu(e2[2], n2), o2 = Ou(i2, t2);
  try {
    let a = new RegExp(r2), l = o2.replace(a, Fu(s2)), c = l !== o2 ? 1 : 0;
    return Du(i2, l, t2), c;
  } catch {
    return 0;
  }
}
async function rx(e2, t2, n2) {
  if (e2.length < 2) return 0;
  let r2 = await us(e2[0], n2), s2 = qe(await n2.evalExpr(e2[1])), i2 = await Tu(e2[2], n2), o2 = Ou(i2, t2);
  try {
    let a = new RegExp(r2, "g"), l = o2.match(a), c = l ? l.length : 0, u = o2.replace(a, Fu(s2));
    return Du(i2, u, t2), c;
  } catch {
    return 0;
  }
}
function Fu(e2) {
  return (t2) => {
    let n2 = "", r2 = 0;
    for (; r2 < e2.length; ) if (e2[r2] === "\\" && r2 + 1 < e2.length) {
      let s2 = e2[r2 + 1];
      s2 === "&" ? (n2 += "&", r2 += 2) : s2 === "\\" ? (n2 += "\\", r2 += 2) : (n2 += e2[r2 + 1], r2 += 2);
    } else e2[r2] === "&" ? (n2 += t2, r2++) : (n2 += e2[r2], r2++);
    return n2;
  };
}
async function sx(e2, t2, n2) {
  if (e2.length < 2) return t2.RSTART = 0, t2.RLENGTH = -1, 0;
  let r2 = qe(await n2.evalExpr(e2[0])), s2 = await us(e2[1], n2);
  try {
    let o2 = new RegExp(s2).exec(r2);
    if (o2) return t2.RSTART = o2.index + 1, t2.RLENGTH = o2[0].length, t2.RSTART;
  } catch {
  }
  return t2.RSTART = 0, t2.RLENGTH = -1, 0;
}
async function ix(e2, t2, n2) {
  if (e2.length < 3) return "";
  let r2 = await us(e2[0], n2), s2 = qe(await n2.evalExpr(e2[1])), i2 = qe(await n2.evalExpr(e2[2])), o2 = e2.length >= 4 ? qe(await n2.evalExpr(e2[3])) : t2.line;
  try {
    let a = i2.toLowerCase() === "g", l = a ? 0 : parseInt(i2, 10) || 1;
    if (a) {
      let c = new RegExp(r2, "g");
      return o2.replace(c, (u, ...f2) => Pu(s2, u, f2.slice(0, -2)));
    } else {
      let c = 0, u = new RegExp(r2, "g");
      return o2.replace(u, (f2, ...p) => (c++, c === l ? Pu(s2, f2, p.slice(0, -2)) : f2));
    }
  } catch {
    return o2;
  }
}
function Pu(e2, t2, n2) {
  let r2 = "", s2 = 0;
  for (; s2 < e2.length; ) if (e2[s2] === "\\" && s2 + 1 < e2.length) {
    let i2 = e2[s2 + 1];
    if (i2 === "&") r2 += "&", s2 += 2;
    else if (i2 === "0") r2 += t2, s2 += 2;
    else if (i2 >= "1" && i2 <= "9") {
      let o2 = parseInt(i2, 10) - 1;
      r2 += n2[o2] || "", s2 += 2;
    } else i2 === "n" ? (r2 += `
`, s2 += 2) : i2 === "t" ? (r2 += "	", s2 += 2) : (r2 += i2, s2 += 2);
  } else e2[s2] === "&" ? (r2 += t2, s2++) : (r2 += e2[s2], s2++);
  return r2;
}
async function ox(e2, t2, n2) {
  return e2.length === 0 ? "" : qe(await n2.evalExpr(e2[0])).toLowerCase();
}
async function ax(e2, t2, n2) {
  return e2.length === 0 ? "" : qe(await n2.evalExpr(e2[0])).toUpperCase();
}
async function lx(e2, t2, n2) {
  if (e2.length === 0) return "";
  let r2 = qe(await n2.evalExpr(e2[0])), s2 = [];
  for (let i2 = 1; i2 < e2.length; i2++) s2.push(await n2.evalExpr(e2[i2]));
  return fs(r2, s2);
}
async function cx(e2, t2, n2) {
  return e2.length === 0 ? 0 : Math.floor(Nt(await n2.evalExpr(e2[0])));
}
async function ux(e2, t2, n2) {
  return e2.length === 0 ? 0 : Math.sqrt(Nt(await n2.evalExpr(e2[0])));
}
async function fx(e2, t2, n2) {
  return e2.length === 0 ? 0 : Math.sin(Nt(await n2.evalExpr(e2[0])));
}
async function px(e2, t2, n2) {
  return e2.length === 0 ? 0 : Math.cos(Nt(await n2.evalExpr(e2[0])));
}
async function dx(e2, t2, n2) {
  let r2 = e2.length > 0 ? Nt(await n2.evalExpr(e2[0])) : 0, s2 = e2.length > 1 ? Nt(await n2.evalExpr(e2[1])) : 0;
  return Math.atan2(r2, s2);
}
async function hx(e2, t2, n2) {
  return e2.length === 0 ? 0 : Math.log(Nt(await n2.evalExpr(e2[0])));
}
async function mx(e2, t2, n2) {
  return e2.length === 0 ? 1 : Math.exp(Nt(await n2.evalExpr(e2[0])));
}
function gx(e2, t2, n2) {
  return t2.random ? t2.random() : Math.random();
}
async function yx(e2, t2, n2) {
  let r2 = e2.length > 0 ? Nt(await n2.evalExpr(e2[0])) : Date.now();
  return t2.vars._srand_seed = r2, r2;
}
function bx(e2, t2) {
  return () => {
    throw new Error(`${e2}() is not supported - ${t2}`);
  };
}
function io(e2) {
  return () => {
    throw new Error(`function '${e2}()' is not implemented`);
  };
}
function fs(e2, t2) {
  let n2 = 0, r2 = "", s2 = 0;
  for (; s2 < e2.length; ) if (e2[s2] === "%" && s2 + 1 < e2.length) {
    let i2 = s2 + 1, o2 = "", a = "", l = "", c, u = i2;
    for (; i2 < e2.length && /\d/.test(e2[i2]); ) i2++;
    i2 > u && e2[i2] === "$" ? (c = parseInt(e2.substring(u, i2), 10) - 1, i2++) : i2 = u;
    let f2 = () => {
      if (i2 < e2.length) {
        if (i2 + 1 < e2.length && (e2[i2] === "h" && e2[i2 + 1] === "h" || e2[i2] === "l" && e2[i2 + 1] === "l")) {
          i2 += 2;
          return;
        }
        /[lzjh]/.test(e2[i2]) && i2++;
      }
    };
    for (; i2 < e2.length && /[-+ #0]/.test(e2[i2]); ) o2 += e2[i2++];
    if (e2[i2] === "*") {
      let h = t2[n2++], g = h !== void 0 ? Math.floor(Number(h)) : 0;
      g < 0 ? (o2 += "-", a = String(-g)) : a = String(g), i2++;
    } else for (; i2 < e2.length && /\d/.test(e2[i2]); ) a += e2[i2++];
    if (e2[i2] === ".") if (i2++, e2[i2] === "*") {
      let h = t2[n2++];
      l = String(h !== void 0 ? Math.floor(Number(h)) : 0), i2++;
    } else for (; i2 < e2.length && /\d/.test(e2[i2]); ) l += e2[i2++];
    f2();
    let p = e2[i2], m = t2[c !== void 0 ? c : n2];
    switch (p) {
      case "s": {
        let h = m !== void 0 ? String(m) : "";
        if (l && (h = h.substring(0, parseInt(l, 10))), a) {
          let g = parseInt(a, 10);
          o2.includes("-") ? h = h.padEnd(g) : h = h.padStart(g);
        }
        r2 += h, c === void 0 && n2++;
        break;
      }
      case "d":
      case "i": {
        let h = m !== void 0 ? Math.floor(Number(m)) : 0;
        Number.isNaN(h) && (h = 0);
        let g = h < 0, b = Math.abs(h).toString();
        if (l) {
          let E = parseInt(l, 10);
          b = b.padStart(E, "0");
        }
        let y = "";
        g ? y = "-" : o2.includes("+") ? y = "+" : o2.includes(" ") && (y = " ");
        let w = y + b;
        if (a) {
          let E = parseInt(a, 10);
          o2.includes("-") ? w = w.padEnd(E) : o2.includes("0") && !l ? w = y + b.padStart(E - y.length, "0") : w = w.padStart(E);
        }
        r2 += w, c === void 0 && n2++;
        break;
      }
      case "f": {
        let h = m !== void 0 ? Number(m) : 0;
        Number.isNaN(h) && (h = 0);
        let g = l ? parseInt(l, 10) : 6, b = h.toFixed(g);
        if (a) {
          let y = parseInt(a, 10);
          o2.includes("-") ? b = b.padEnd(y) : b = b.padStart(y);
        }
        r2 += b, c === void 0 && n2++;
        break;
      }
      case "e":
      case "E": {
        let h = m !== void 0 ? Number(m) : 0;
        Number.isNaN(h) && (h = 0);
        let g = l ? parseInt(l, 10) : 6, b = h.toExponential(g);
        if (p === "E" && (b = b.toUpperCase()), a) {
          let y = parseInt(a, 10);
          o2.includes("-") ? b = b.padEnd(y) : b = b.padStart(y);
        }
        r2 += b, c === void 0 && n2++;
        break;
      }
      case "g":
      case "G": {
        let h = m !== void 0 ? Number(m) : 0;
        Number.isNaN(h) && (h = 0);
        let g = l ? parseInt(l, 10) : 6, b = h !== 0 ? Math.floor(Math.log10(Math.abs(h))) : 0, y;
        if (h === 0 ? y = "0" : b < -4 || b >= g ? (y = h.toExponential(g - 1), p === "G" && (y = y.toUpperCase())) : y = h.toPrecision(g), y.includes(".") && (y = y.replace(/\.?0+$/, "").replace(/\.?0+e/, "e")), y.includes("e") && (y = y.replace(/\.?0+e/, "e")), a) {
          let w = parseInt(a, 10);
          o2.includes("-") ? y = y.padEnd(w) : y = y.padStart(w);
        }
        r2 += y, c === void 0 && n2++;
        break;
      }
      case "x":
      case "X": {
        let h = m !== void 0 ? Math.floor(Number(m)) : 0;
        Number.isNaN(h) && (h = 0);
        let g = Math.abs(h).toString(16);
        if (p === "X" && (g = g.toUpperCase()), l) {
          let w = parseInt(l, 10);
          g = g.padStart(w, "0");
        }
        let b = h < 0 ? "-" : "", y = b + g;
        if (a) {
          let w = parseInt(a, 10);
          o2.includes("-") ? y = y.padEnd(w) : o2.includes("0") && !l ? y = b + g.padStart(w - b.length, "0") : y = y.padStart(w);
        }
        r2 += y, c === void 0 && n2++;
        break;
      }
      case "o": {
        let h = m !== void 0 ? Math.floor(Number(m)) : 0;
        Number.isNaN(h) && (h = 0);
        let g = Math.abs(h).toString(8);
        if (l) {
          let w = parseInt(l, 10);
          g = g.padStart(w, "0");
        }
        let b = h < 0 ? "-" : "", y = b + g;
        if (a) {
          let w = parseInt(a, 10);
          o2.includes("-") ? y = y.padEnd(w) : o2.includes("0") && !l ? y = b + g.padStart(w - b.length, "0") : y = y.padStart(w);
        }
        r2 += y, c === void 0 && n2++;
        break;
      }
      case "c": {
        typeof m == "number" ? r2 += String.fromCharCode(m) : r2 += String(m ?? "").charAt(0) || "", c === void 0 && n2++;
        break;
      }
      case "%":
        r2 += "%";
        break;
      default:
        r2 += e2.substring(s2, i2 + 1);
    }
    s2 = i2 + 1;
  } else if (e2[s2] === "\\" && s2 + 1 < e2.length) {
    let i2 = e2[s2 + 1];
    switch (i2) {
      case "n":
        r2 += `
`;
        break;
      case "t":
        r2 += "	";
        break;
      case "r":
        r2 += "\r";
        break;
      case "\\":
        r2 += "\\";
        break;
      default:
        r2 += i2;
    }
    s2 += 2;
  } else r2 += e2[s2++];
  return r2;
}
var _u, oo = v(() => {
  _u = { length: Jw, substr: Yw, index: ex, split: tx, sub: nx, gsub: rx, match: sx, gensub: ix, tolower: ox, toupper: ax, sprintf: lx, int: cx, sqrt: ux, sin: fx, cos: px, atan2: dx, log: hx, exp: mx, rand: gx, srand: yx, system: bx("system", "shell execution not allowed in sandboxed environment"), close: () => 0, fflush: () => 0, systime: io("systime"), mktime: io("mktime"), strftime: io("strftime") };
});
function rt(e2) {
  return typeof e2 == "number" ? e2 !== 0 : !(e2 === "" || e2 === "0");
}
function Ie(e2) {
  if (typeof e2 == "number") return e2;
  let t2 = parseFloat(e2);
  return Number.isNaN(t2) ? 0 : t2;
}
function we(e2) {
  return typeof e2 == "string" ? e2 : String(e2);
}
function ao(e2) {
  if (typeof e2 == "number") return true;
  let t2 = String(e2).trim();
  return t2 === "" ? false : !Number.isNaN(Number(t2));
}
function br(e2, t2) {
  try {
    return new RegExp(e2).test(t2);
  } catch {
    return false;
  }
}
var Ln = v(() => {
});
function Lu(e2, t2) {
  return t2 === "" ? [] : e2.FS === " " ? t2.trim().split(/\s+/).filter(Boolean) : t2.split(e2.fieldSep);
}
function ps(e2, t2) {
  return t2 === 0 ? e2.line : t2 < 0 || t2 > e2.fields.length ? "" : e2.fields[t2 - 1] ?? "";
}
function lo(e2, t2, n2) {
  if (t2 === 0) e2.line = we(n2), e2.fields = Lu(e2, e2.line), e2.NF = e2.fields.length;
  else if (t2 > 0) {
    for (; e2.fields.length < t2; ) e2.fields.push("");
    e2.fields[t2 - 1] = we(n2), e2.NF = e2.fields.length, e2.line = e2.fields.join(e2.OFS);
  }
}
function Mn(e2, t2) {
  e2.line = t2, e2.fields = Lu(e2, t2), e2.NF = e2.fields.length;
}
function Mu(e2, t2) {
  if (e2.FS = t2, t2 === " ") e2.fieldSep = /\s+/;
  else try {
    e2.fieldSep = new RegExp(t2);
  } catch {
    e2.fieldSep = new RegExp(t2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
  }
}
var ds = v(() => {
  Ln();
});
function hs(e2, t2) {
  switch (t2) {
    case "FS":
      return e2.FS;
    case "OFS":
      return e2.OFS;
    case "ORS":
      return e2.ORS;
    case "OFMT":
      return e2.OFMT;
    case "NR":
      return e2.NR;
    case "NF":
      return e2.NF;
    case "FNR":
      return e2.FNR;
    case "FILENAME":
      return e2.FILENAME;
    case "RSTART":
      return e2.RSTART;
    case "RLENGTH":
      return e2.RLENGTH;
    case "SUBSEP":
      return e2.SUBSEP;
    case "ARGC":
      return e2.ARGC;
  }
  return e2.vars[t2] ?? "";
}
function Wn(e2, t2, n2) {
  switch (t2) {
    case "FS":
      Mu(e2, we(n2));
      return;
    case "OFS":
      e2.OFS = we(n2);
      return;
    case "ORS":
      e2.ORS = we(n2);
      return;
    case "OFMT":
      e2.OFMT = we(n2);
      return;
    case "NR":
      e2.NR = Math.floor(Ie(n2));
      return;
    case "NF": {
      let r2 = Math.floor(Ie(n2));
      if (r2 < e2.NF) e2.fields = e2.fields.slice(0, r2), e2.line = e2.fields.join(e2.OFS);
      else if (r2 > e2.NF) {
        for (; e2.fields.length < r2; ) e2.fields.push("");
        e2.line = e2.fields.join(e2.OFS);
      }
      e2.NF = r2;
      return;
    }
    case "FNR":
      e2.FNR = Math.floor(Ie(n2));
      return;
    case "FILENAME":
      e2.FILENAME = we(n2);
      return;
    case "RSTART":
      e2.RSTART = Math.floor(Ie(n2));
      return;
    case "RLENGTH":
      e2.RLENGTH = Math.floor(Ie(n2));
      return;
    case "SUBSEP":
      e2.SUBSEP = we(n2);
      return;
  }
  e2.vars[t2] = n2;
}
function wr(e2, t2) {
  let n2 = t2, r2 = /* @__PURE__ */ new Set(), s2 = e2.arrayAliases.get(n2);
  for (; s2 !== void 0 && !r2.has(n2); ) r2.add(n2), n2 = s2, s2 = e2.arrayAliases.get(n2);
  return n2;
}
function ms(e2, t2, n2) {
  var _a3;
  if (t2 === "ARGV") return e2.ARGV[n2] ?? "";
  if (t2 === "ENVIRON") return e2.ENVIRON[n2] ?? "";
  let r2 = wr(e2, t2);
  return ((_a3 = e2.arrays[r2]) == null ? void 0 : _a3[n2]) ?? "";
}
function co(e2, t2, n2, r2) {
  let s2 = wr(e2, t2);
  e2.arrays[s2] || (e2.arrays[s2] = {}), e2.arrays[s2][n2] = r2;
}
function Wu(e2, t2, n2) {
  var _a3;
  if (t2 === "ARGV") return e2.ARGV[n2] !== void 0;
  if (t2 === "ENVIRON") return e2.ENVIRON[n2] !== void 0;
  let r2 = wr(e2, t2);
  return ((_a3 = e2.arrays[r2]) == null ? void 0 : _a3[n2]) !== void 0;
}
function Bu(e2, t2, n2) {
  let r2 = wr(e2, t2);
  e2.arrays[r2] && delete e2.arrays[r2][n2];
}
function Uu(e2, t2) {
  let n2 = wr(e2, t2);
  delete e2.arrays[n2];
}
var uo = v(() => {
  ds();
  Ln();
});
function zu(e2) {
  fo = e2;
}
async function re(e2, t2) {
  switch (t2.type) {
    case "number":
      return t2.value;
    case "string":
      return t2.value;
    case "regex":
      return br(t2.pattern, e2.line) ? 1 : 0;
    case "field":
      return wx(e2, t2);
    case "variable":
      return hs(e2, t2.name);
    case "array_access":
      return xx(e2, t2);
    case "binary":
      return Ex(e2, t2);
    case "unary":
      return Cx(e2, t2);
    case "ternary":
      return rt(await re(e2, t2.condition)) ? await re(e2, t2.consequent) : await re(e2, t2.alternate);
    case "call":
      return Nx(e2, t2.name, t2.args);
    case "assignment":
      return vx(e2, t2);
    case "pre_increment":
      return $x(e2, t2.operand);
    case "pre_decrement":
      return Ix(e2, t2.operand);
    case "post_increment":
      return Rx(e2, t2.operand);
    case "post_decrement":
      return Px(e2, t2.operand);
    case "in":
      return Tx(e2, t2.key, t2.array);
    case "getline":
      return Ox(e2, t2.variable, t2.file, t2.command);
    case "tuple":
      return _x(e2, t2.elements);
    default:
      return "";
  }
}
async function wx(e2, t2) {
  let n2 = Math.floor(Ie(await re(e2, t2.index)));
  return ps(e2, n2);
}
async function xx(e2, t2) {
  let n2 = we(await re(e2, t2.key));
  return ms(e2, t2.array, n2);
}
async function Ex(e2, t2) {
  let n2 = t2.operator;
  if (n2 === "||") return rt(await re(e2, t2.left)) || rt(await re(e2, t2.right)) ? 1 : 0;
  if (n2 === "&&") return rt(await re(e2, t2.left)) && rt(await re(e2, t2.right)) ? 1 : 0;
  if (n2 === "~") {
    let a = await re(e2, t2.left), l = t2.right.type === "regex" ? t2.right.pattern : we(await re(e2, t2.right));
    try {
      return new RegExp(l).test(we(a)) ? 1 : 0;
    } catch {
      return 0;
    }
  }
  if (n2 === "!~") {
    let a = await re(e2, t2.left), l = t2.right.type === "regex" ? t2.right.pattern : we(await re(e2, t2.right));
    try {
      return new RegExp(l).test(we(a)) ? 0 : 1;
    } catch {
      return 1;
    }
  }
  let r2 = await re(e2, t2.left), s2 = await re(e2, t2.right);
  if (n2 === " ") return we(r2) + we(s2);
  if (Sx(n2)) return Ax(r2, s2, n2);
  let i2 = Ie(r2), o2 = Ie(s2);
  return Iu(i2, o2, n2);
}
function Sx(e2) {
  return ["<", "<=", ">", ">=", "==", "!="].includes(e2);
}
function Ax(e2, t2, n2) {
  let r2 = ao(e2), s2 = ao(t2);
  if (r2 && s2) {
    let a = Ie(e2), l = Ie(t2);
    switch (n2) {
      case "<":
        return a < l ? 1 : 0;
      case "<=":
        return a <= l ? 1 : 0;
      case ">":
        return a > l ? 1 : 0;
      case ">=":
        return a >= l ? 1 : 0;
      case "==":
        return a === l ? 1 : 0;
      case "!=":
        return a !== l ? 1 : 0;
    }
  }
  let i2 = we(e2), o2 = we(t2);
  switch (n2) {
    case "<":
      return i2 < o2 ? 1 : 0;
    case "<=":
      return i2 <= o2 ? 1 : 0;
    case ">":
      return i2 > o2 ? 1 : 0;
    case ">=":
      return i2 >= o2 ? 1 : 0;
    case "==":
      return i2 === o2 ? 1 : 0;
    case "!=":
      return i2 !== o2 ? 1 : 0;
  }
  return 0;
}
async function Cx(e2, t2) {
  let n2 = await re(e2, t2.operand);
  switch (t2.operator) {
    case "!":
      return rt(n2) ? 0 : 1;
    case "-":
      return -Ie(n2);
    case "+":
      return +Ie(n2);
    default:
      return n2;
  }
}
async function Nx(e2, t2, n2) {
  let r2 = _u[t2];
  if (r2) return r2(n2, e2, { evalExpr: (i2) => re(e2, i2) });
  let s2 = e2.functions.get(t2);
  return s2 ? kx(e2, s2, n2) : "";
}
async function kx(e2, t2, n2) {
  if (e2.currentRecursionDepth++, e2.currentRecursionDepth > e2.maxRecursionDepth) throw e2.currentRecursionDepth--, new ne(`awk: recursion depth exceeded maximum (${e2.maxRecursionDepth})`, "recursion", e2.output);
  let r2 = {};
  for (let o2 of t2.params) r2[o2] = e2.vars[o2];
  let s2 = [];
  for (let o2 = 0; o2 < t2.params.length; o2++) {
    let a = t2.params[o2];
    if (o2 < n2.length) {
      let l = n2[o2];
      l.type === "variable" && (e2.arrayAliases.set(a, l.name), s2.push(a));
      let c = await re(e2, l);
      e2.vars[a] = c;
    } else e2.vars[a] = "";
  }
  e2.hasReturn = false, e2.returnValue = void 0, fo && await fo(e2, t2.body.statements);
  let i2 = e2.returnValue ?? "";
  for (let o2 of t2.params) r2[o2] !== void 0 ? e2.vars[o2] = r2[o2] : delete e2.vars[o2];
  for (let o2 of s2) e2.arrayAliases.delete(o2);
  return e2.hasReturn = false, e2.returnValue = void 0, e2.currentRecursionDepth--, i2;
}
async function vx(e2, t2) {
  let n2 = await re(e2, t2.value), r2 = t2.target, s2 = t2.operator, i2;
  if (s2 === "=") i2 = n2;
  else {
    let o2;
    if (r2.type === "field") {
      let c = Math.floor(Ie(await re(e2, r2.index)));
      o2 = ps(e2, c);
    } else if (r2.type === "variable") o2 = hs(e2, r2.name);
    else {
      let c = we(await re(e2, r2.key));
      o2 = ms(e2, r2.array, c);
    }
    let a = Ie(o2), l = Ie(n2);
    switch (s2) {
      case "+=":
        i2 = a + l;
        break;
      case "-=":
        i2 = a - l;
        break;
      case "*=":
        i2 = a * l;
        break;
      case "/=":
        i2 = l !== 0 ? a / l : 0;
        break;
      case "%=":
        i2 = l !== 0 ? a % l : 0;
        break;
      case "^=":
        i2 = a ** l;
        break;
      default:
        i2 = n2;
    }
  }
  if (r2.type === "field") {
    let o2 = Math.floor(Ie(await re(e2, r2.index)));
    lo(e2, o2, i2);
  } else if (r2.type === "variable") Wn(e2, r2.name, i2);
  else {
    let o2 = we(await re(e2, r2.key));
    co(e2, r2.array, o2, i2);
  }
  return i2;
}
async function gs(e2, t2, n2, r2) {
  let s2;
  if (t2.type === "field") {
    let i2 = Math.floor(Ie(await re(e2, t2.index)));
    s2 = Ie(ps(e2, i2)), lo(e2, i2, s2 + n2);
  } else if (t2.type === "variable") s2 = Ie(hs(e2, t2.name)), Wn(e2, t2.name, s2 + n2);
  else {
    let i2 = we(await re(e2, t2.key));
    s2 = Ie(ms(e2, t2.array, i2)), co(e2, t2.array, i2, s2 + n2);
  }
  return r2 ? s2 + n2 : s2;
}
async function $x(e2, t2) {
  return gs(e2, t2, 1, true);
}
async function Ix(e2, t2) {
  return gs(e2, t2, -1, true);
}
async function Rx(e2, t2) {
  return gs(e2, t2, 1, false);
}
async function Px(e2, t2) {
  return gs(e2, t2, -1, false);
}
async function Tx(e2, t2, n2) {
  let r2;
  if (t2.type === "tuple") {
    let s2 = [];
    for (let i2 of t2.elements) s2.push(we(await re(e2, i2)));
    r2 = s2.join(e2.SUBSEP);
  } else r2 = we(await re(e2, t2));
  return Wu(e2, n2, r2) ? 1 : 0;
}
async function Ox(e2, t2, n2, r2) {
  if (r2) return Dx(e2, t2, r2);
  if (n2) return Fx(e2, t2, n2);
  if (!e2.lines || e2.lineIndex === void 0) return -1;
  let s2 = e2.lineIndex + 1;
  if (s2 >= e2.lines.length) return 0;
  let i2 = e2.lines[s2];
  return t2 ? Wn(e2, t2, i2) : Mn(e2, i2), e2.NR++, e2.lineIndex = s2, 1;
}
async function Dx(e2, t2, n2) {
  if (!e2.exec) return -1;
  let r2 = we(await re(e2, n2)), s2 = `__cmd_${r2}`, i2 = `__cmdi_${r2}`, o2, a;
  if (e2.vars[s2] === void 0) try {
    o2 = (await e2.exec(r2)).stdout.split(`
`), o2.length > 0 && o2[o2.length - 1] === "" && o2.pop(), e2.vars[s2] = JSON.stringify(o2), e2.vars[i2] = -1, a = -1;
  } catch {
    return -1;
  }
  else o2 = JSON.parse(e2.vars[s2]), a = e2.vars[i2];
  let l = a + 1;
  if (l >= o2.length) return 0;
  let c = o2[l];
  return e2.vars[i2] = l, t2 ? Wn(e2, t2, c) : Mn(e2, c), 1;
}
async function Fx(e2, t2, n2) {
  if (!e2.fs || !e2.cwd) return -1;
  let r2 = we(await re(e2, n2));
  if (r2 === "/dev/null") return 0;
  let s2 = e2.fs.resolvePath(e2.cwd, r2), i2 = `__fc_${s2}`, o2 = `__fi_${s2}`, a, l;
  if (e2.vars[i2] === void 0) try {
    a = (await e2.fs.readFile(s2)).split(`
`), a.length > 0 && a[a.length - 1] === "" && a.pop(), e2.vars[i2] = JSON.stringify(a), e2.vars[o2] = -1, l = -1;
  } catch {
    return -1;
  }
  else a = JSON.parse(e2.vars[i2]), l = e2.vars[o2];
  let c = l + 1;
  if (c >= a.length) return 0;
  let u = a[c];
  return e2.vars[o2] = c, t2 ? Wn(e2, t2, u) : Mn(e2, u), 1;
}
async function _x(e2, t2) {
  if (t2.length === 0) return "";
  for (let n2 = 0; n2 < t2.length - 1; n2++) await re(e2, t2[n2]);
  return re(e2, t2[t2.length - 1]);
}
var fo, po = v(() => {
  de();
  Ru();
  oo();
  ds();
  Ln();
  uo();
  fo = null;
});
async function Bn(e2, t2) {
  for (let n2 of t2) if (await hn(e2, n2), Lx(e2)) break;
}
function Lx(e2) {
  return e2.shouldExit || e2.shouldNext || e2.shouldNextFile || e2.loopBreak || e2.loopContinue || e2.hasReturn;
}
async function hn(e2, t2) {
  switch (t2.type) {
    case "block":
      await Bn(e2, t2.statements);
      break;
    case "expr_stmt":
      await re(e2, t2.expression);
      break;
    case "print":
      await Mx(e2, t2.args, t2.output);
      break;
    case "printf":
      await Wx(e2, t2.format, t2.args, t2.output);
      break;
    case "if":
      await Bx(e2, t2);
      break;
    case "while":
      await Ux(e2, t2);
      break;
    case "do_while":
      await zx(e2, t2);
      break;
    case "for":
      await jx(e2, t2);
      break;
    case "for_in":
      await Hx(e2, t2);
      break;
    case "break":
      e2.loopBreak = true;
      break;
    case "continue":
      e2.loopContinue = true;
      break;
    case "next":
      e2.shouldNext = true;
      break;
    case "nextfile":
      e2.shouldNextFile = true;
      break;
    case "exit":
      e2.shouldExit = true, e2.exitCode = t2.code ? Math.floor(Ie(await re(e2, t2.code))) : 0;
      break;
    case "return":
      e2.hasReturn = true, e2.returnValue = t2.value ? await re(e2, t2.value) : "";
      break;
    case "delete":
      await Vx(e2, t2.target);
      break;
  }
}
async function Mx(e2, t2, n2) {
  let r2 = [];
  for (let i2 of t2) {
    let o2 = await re(e2, i2);
    typeof o2 == "number" ? Number.isInteger(o2) && Math.abs(o2) < Number.MAX_SAFE_INTEGER ? r2.push(String(o2)) : r2.push(fs(e2.OFMT, [o2])) : r2.push(we(o2));
  }
  let s2 = r2.join(e2.OFS) + e2.ORS;
  n2 ? await ju(e2, n2.redirect, n2.file, s2) : e2.output += s2;
}
async function Wx(e2, t2, n2, r2) {
  let s2 = we(await re(e2, t2)), i2 = [];
  for (let a of n2) i2.push(await re(e2, a));
  let o2 = fs(s2, i2);
  r2 ? await ju(e2, r2.redirect, r2.file, o2) : e2.output += o2;
}
async function ju(e2, t2, n2, r2) {
  if (!e2.fs || !e2.cwd) {
    e2.output += r2;
    return;
  }
  let s2 = we(await re(e2, n2)), i2 = e2.fs.resolvePath(e2.cwd, s2);
  t2 === ">" ? e2.openedFiles.has(i2) ? await e2.fs.appendFile(i2, r2) : (await e2.fs.writeFile(i2, r2), e2.openedFiles.add(i2)) : (e2.openedFiles.has(i2) || e2.openedFiles.add(i2), await e2.fs.appendFile(i2, r2));
}
async function Bx(e2, t2) {
  rt(await re(e2, t2.condition)) ? await hn(e2, t2.consequent) : t2.alternate && await hn(e2, t2.alternate);
}
async function Ux(e2, t2) {
  let n2 = 0;
  for (; rt(await re(e2, t2.condition)); ) {
    if (n2++, n2 > e2.maxIterations) throw new ne(`awk: while loop exceeded maximum iterations (${e2.maxIterations})`, "iterations", e2.output);
    if (e2.loopContinue = false, await hn(e2, t2.body), e2.loopBreak) {
      e2.loopBreak = false;
      break;
    }
    if (e2.shouldExit || e2.shouldNext || e2.hasReturn) break;
  }
}
async function zx(e2, t2) {
  let n2 = 0;
  do {
    if (n2++, n2 > e2.maxIterations) throw new ne(`awk: do-while loop exceeded maximum iterations (${e2.maxIterations})`, "iterations", e2.output);
    if (e2.loopContinue = false, await hn(e2, t2.body), e2.loopBreak) {
      e2.loopBreak = false;
      break;
    }
    if (e2.shouldExit || e2.shouldNext || e2.hasReturn) break;
  } while (rt(await re(e2, t2.condition)));
}
async function jx(e2, t2) {
  t2.init && await re(e2, t2.init);
  let n2 = 0;
  for (; !t2.condition || rt(await re(e2, t2.condition)); ) {
    if (n2++, n2 > e2.maxIterations) throw new ne(`awk: for loop exceeded maximum iterations (${e2.maxIterations})`, "iterations", e2.output);
    if (e2.loopContinue = false, await hn(e2, t2.body), e2.loopBreak) {
      e2.loopBreak = false;
      break;
    }
    if (e2.shouldExit || e2.shouldNext || e2.hasReturn) break;
    t2.update && await re(e2, t2.update);
  }
}
async function Hx(e2, t2) {
  let n2 = e2.arrays[t2.array];
  if (n2) for (let r2 of Object.keys(n2)) {
    if (e2.vars[t2.variable] = r2, e2.loopContinue = false, await hn(e2, t2.body), e2.loopBreak) {
      e2.loopBreak = false;
      break;
    }
    if (e2.shouldExit || e2.shouldNext || e2.hasReturn) break;
  }
}
async function Vx(e2, t2) {
  if (t2.type === "array_access") {
    let n2 = we(await re(e2, t2.key));
    Bu(e2, t2.array, n2);
  } else t2.type === "variable" && Uu(e2, t2.name);
}
var Hu = v(() => {
  de();
  oo();
  po();
  Ln();
  uo();
  zu(Bn);
});
var xr, Vu = v(() => {
  po();
  ds();
  Hu();
  Ln();
  xr = class {
    constructor(t2) {
      __publicField(this, "ctx");
      __publicField(this, "program", null);
      __publicField(this, "rangeStates", []);
      this.ctx = t2;
    }
    execute(t2) {
      this.program = t2, this.ctx.output = "";
      for (let n2 of t2.functions) this.ctx.functions.set(n2.name, n2);
      this.rangeStates = t2.rules.map(() => false);
    }
    async executeBegin() {
      var _a3;
      if (this.program) {
        for (let t2 of this.program.rules) if (((_a3 = t2.pattern) == null ? void 0 : _a3.type) === "begin" && (await Bn(this.ctx, t2.action.statements), this.ctx.shouldExit)) break;
      }
    }
    async executeLine(t2) {
      var _a3, _b3;
      if (!(!this.program || this.ctx.shouldExit)) {
        Mn(this.ctx, t2), this.ctx.NR++, this.ctx.FNR++, this.ctx.shouldNext = false;
        for (let n2 = 0; n2 < this.program.rules.length && !(this.ctx.shouldExit || this.ctx.shouldNext || this.ctx.shouldNextFile); n2++) {
          let r2 = this.program.rules[n2];
          ((_a3 = r2.pattern) == null ? void 0 : _a3.type) === "begin" || ((_b3 = r2.pattern) == null ? void 0 : _b3.type) === "end" || await this.matchesRule(r2, n2) && await Bn(this.ctx, r2.action.statements);
        }
      }
    }
    async executeEnd() {
      var _a3;
      if (this.program && !this.ctx.inEndBlock) {
        this.ctx.inEndBlock = true, this.ctx.shouldExit = false;
        for (let t2 of this.program.rules) if (((_a3 = t2.pattern) == null ? void 0 : _a3.type) === "end" && (await Bn(this.ctx, t2.action.statements), this.ctx.shouldExit)) break;
        this.ctx.inEndBlock = false;
      }
    }
    getOutput() {
      return this.ctx.output;
    }
    getExitCode() {
      return this.ctx.exitCode;
    }
    getContext() {
      return this.ctx;
    }
    async matchesRule(t2, n2) {
      let r2 = t2.pattern;
      if (!r2) return true;
      switch (r2.type) {
        case "begin":
        case "end":
          return false;
        case "regex_pattern":
          return br(r2.pattern, this.ctx.line);
        case "expr_pattern":
          return rt(await re(this.ctx, r2.expression));
        case "range": {
          let s2 = await this.matchPattern(r2.start), i2 = await this.matchPattern(r2.end);
          return this.rangeStates[n2] ? (i2 && (this.rangeStates[n2] = false), true) : s2 ? (this.rangeStates[n2] = true, i2 && (this.rangeStates[n2] = false), true) : false;
        }
        default:
          return false;
      }
    }
    async matchPattern(t2) {
      switch (t2.type) {
        case "regex_pattern":
          return br(t2.pattern, this.ctx.line);
        case "expr_pattern":
          return rt(await re(this.ctx, t2.expression));
        default:
          return false;
      }
    }
  };
});
var qu = v(() => {
  $u();
  Vu();
});
function Gx(e2) {
  return e2.replace(/\[\[:space:\]\]/g, "[ \\t\\n\\r\\f\\v]").replace(/\[\[:blank:\]\]/g, "[ \\t]").replace(/\[\[:alpha:\]\]/g, "[a-zA-Z]").replace(/\[\[:digit:\]\]/g, "[0-9]").replace(/\[\[:alnum:\]\]/g, "[a-zA-Z0-9]").replace(/\[\[:upper:\]\]/g, "[A-Z]").replace(/\[\[:lower:\]\]/g, "[a-z]").replace(/\[\[:punct:\]\]/g, "[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~]").replace(/\[\[:xdigit:\]\]/g, "[0-9A-Fa-f]").replace(/\[\[:graph:\]\]/g, "[!-~]").replace(/\[\[:print:\]\]/g, "[ -~]").replace(/\[\[:cntrl:\]\]/g, "[\\x00-\\x1f\\x7f]");
}
var S, qx, ys, Gu = v(() => {
  (function(e2) {
    e2.NUMBER = "NUMBER", e2.STRING = "STRING", e2.REGEX = "REGEX", e2.IDENT = "IDENT", e2.BEGIN = "BEGIN", e2.END = "END", e2.IF = "IF", e2.ELSE = "ELSE", e2.WHILE = "WHILE", e2.DO = "DO", e2.FOR = "FOR", e2.IN = "IN", e2.BREAK = "BREAK", e2.CONTINUE = "CONTINUE", e2.NEXT = "NEXT", e2.NEXTFILE = "NEXTFILE", e2.EXIT = "EXIT", e2.RETURN = "RETURN", e2.DELETE = "DELETE", e2.FUNCTION = "FUNCTION", e2.PRINT = "PRINT", e2.PRINTF = "PRINTF", e2.GETLINE = "GETLINE", e2.PLUS = "PLUS", e2.MINUS = "MINUS", e2.STAR = "STAR", e2.SLASH = "SLASH", e2.PERCENT = "PERCENT", e2.CARET = "CARET", e2.EQ = "EQ", e2.NE = "NE", e2.LT = "LT", e2.GT = "GT", e2.LE = "LE", e2.GE = "GE", e2.MATCH = "MATCH", e2.NOT_MATCH = "NOT_MATCH", e2.AND = "AND", e2.OR = "OR", e2.NOT = "NOT", e2.ASSIGN = "ASSIGN", e2.PLUS_ASSIGN = "PLUS_ASSIGN", e2.MINUS_ASSIGN = "MINUS_ASSIGN", e2.STAR_ASSIGN = "STAR_ASSIGN", e2.SLASH_ASSIGN = "SLASH_ASSIGN", e2.PERCENT_ASSIGN = "PERCENT_ASSIGN", e2.CARET_ASSIGN = "CARET_ASSIGN", e2.INCREMENT = "INCREMENT", e2.DECREMENT = "DECREMENT", e2.QUESTION = "QUESTION", e2.COLON = "COLON", e2.COMMA = "COMMA", e2.SEMICOLON = "SEMICOLON", e2.NEWLINE = "NEWLINE", e2.LPAREN = "LPAREN", e2.RPAREN = "RPAREN", e2.LBRACE = "LBRACE", e2.RBRACE = "RBRACE", e2.LBRACKET = "LBRACKET", e2.RBRACKET = "RBRACKET", e2.DOLLAR = "DOLLAR", e2.APPEND = "APPEND", e2.PIPE = "PIPE", e2.EOF = "EOF";
  })(S || (S = {}));
  qx = { BEGIN: S.BEGIN, END: S.END, if: S.IF, else: S.ELSE, while: S.WHILE, do: S.DO, for: S.FOR, in: S.IN, break: S.BREAK, continue: S.CONTINUE, next: S.NEXT, nextfile: S.NEXTFILE, exit: S.EXIT, return: S.RETURN, delete: S.DELETE, function: S.FUNCTION, print: S.PRINT, printf: S.PRINTF, getline: S.GETLINE };
  ys = class {
    constructor(t2) {
      __publicField(this, "input");
      __publicField(this, "pos", 0);
      __publicField(this, "line", 1);
      __publicField(this, "column", 1);
      __publicField(this, "lastTokenType", null);
      this.input = t2;
    }
    tokenize() {
      let t2 = [];
      for (; this.pos < this.input.length; ) {
        let n2 = this.nextToken();
        n2 && (t2.push(n2), this.lastTokenType = n2.type);
      }
      return t2.push(this.makeToken(S.EOF, "")), t2;
    }
    makeToken(t2, n2) {
      return { type: t2, value: n2, line: this.line, column: this.column };
    }
    peek(t2 = 0) {
      return this.input[this.pos + t2] || "";
    }
    advance() {
      let t2 = this.input[this.pos++] || "";
      return t2 === `
` ? (this.line++, this.column = 1) : this.column++, t2;
    }
    skipWhitespace() {
      for (; this.pos < this.input.length; ) {
        let t2 = this.peek();
        if (t2 === " " || t2 === "	" || t2 === "\r") this.advance();
        else if (t2 === "\\") if (this.peek(1) === `
`) this.advance(), this.advance();
        else break;
        else if (t2 === "#") for (; this.pos < this.input.length && this.peek() !== `
`; ) this.advance();
        else break;
      }
    }
    nextToken() {
      if (this.skipWhitespace(), this.pos >= this.input.length) return null;
      let t2 = this.line, n2 = this.column, r2 = this.peek();
      return r2 === `
` ? (this.advance(), { type: S.NEWLINE, value: `
`, line: t2, column: n2 }) : r2 === '"' ? this.readString() : r2 === "/" && this.canBeRegex() ? this.readRegex() : this.isDigit(r2) || r2 === "." && this.isDigit(this.peek(1)) ? this.readNumber() : this.isAlpha(r2) || r2 === "_" ? this.readIdentifier() : this.readOperator();
    }
    canBeRegex() {
      return (/* @__PURE__ */ new Set([null, S.NEWLINE, S.SEMICOLON, S.LBRACE, S.RBRACE, S.LPAREN, S.LBRACKET, S.COMMA, S.ASSIGN, S.PLUS_ASSIGN, S.MINUS_ASSIGN, S.STAR_ASSIGN, S.SLASH_ASSIGN, S.PERCENT_ASSIGN, S.CARET_ASSIGN, S.AND, S.OR, S.NOT, S.MATCH, S.NOT_MATCH, S.QUESTION, S.COLON, S.LT, S.GT, S.LE, S.GE, S.EQ, S.NE, S.PLUS, S.MINUS, S.STAR, S.PERCENT, S.CARET, S.PRINT, S.PRINTF, S.IF, S.WHILE, S.DO, S.FOR, S.RETURN])).has(this.lastTokenType);
    }
    readString() {
      let t2 = this.line, n2 = this.column;
      this.advance();
      let r2 = "";
      for (; this.pos < this.input.length && this.peek() !== '"'; ) if (this.peek() === "\\") {
        this.advance();
        let s2 = this.advance();
        switch (s2) {
          case "n":
            r2 += `
`;
            break;
          case "t":
            r2 += "	";
            break;
          case "r":
            r2 += "\r";
            break;
          case "f":
            r2 += "\f";
            break;
          case "b":
            r2 += "\b";
            break;
          case "v":
            r2 += "\v";
            break;
          case "a":
            r2 += "\x07";
            break;
          case "\\":
            r2 += "\\";
            break;
          case '"':
            r2 += '"';
            break;
          case "/":
            r2 += "/";
            break;
          case "x": {
            let i2 = "";
            for (; i2.length < 2 && /[0-9a-fA-F]/.test(this.peek()); ) i2 += this.advance();
            i2.length > 0 ? r2 += String.fromCharCode(parseInt(i2, 16)) : r2 += "x";
            break;
          }
          default:
            if (/[0-7]/.test(s2)) {
              let i2 = s2;
              for (; i2.length < 3 && /[0-7]/.test(this.peek()); ) i2 += this.advance();
              r2 += String.fromCharCode(parseInt(i2, 8));
            } else r2 += s2;
        }
      } else r2 += this.advance();
      return this.peek() === '"' && this.advance(), { type: S.STRING, value: r2, line: t2, column: n2 };
    }
    readRegex() {
      let t2 = this.line, n2 = this.column;
      this.advance();
      let r2 = "";
      for (; this.pos < this.input.length && this.peek() !== "/"; ) if (this.peek() === "\\") r2 += this.advance(), this.pos < this.input.length && (r2 += this.advance());
      else {
        if (this.peek() === `
`) break;
        r2 += this.advance();
      }
      return this.peek() === "/" && this.advance(), r2 = Gx(r2), { type: S.REGEX, value: r2, line: t2, column: n2 };
    }
    readNumber() {
      let t2 = this.line, n2 = this.column, r2 = "";
      for (; this.isDigit(this.peek()); ) r2 += this.advance();
      if (this.peek() === "." && this.isDigit(this.peek(1))) for (r2 += this.advance(); this.isDigit(this.peek()); ) r2 += this.advance();
      if (this.peek() === "e" || this.peek() === "E") for (r2 += this.advance(), (this.peek() === "+" || this.peek() === "-") && (r2 += this.advance()); this.isDigit(this.peek()); ) r2 += this.advance();
      return { type: S.NUMBER, value: parseFloat(r2), line: t2, column: n2 };
    }
    readIdentifier() {
      let t2 = this.line, n2 = this.column, r2 = "";
      for (; this.isAlphaNumeric(this.peek()) || this.peek() === "_"; ) r2 += this.advance();
      let s2 = qx[r2];
      return s2 ? { type: s2, value: r2, line: t2, column: n2 } : { type: S.IDENT, value: r2, line: t2, column: n2 };
    }
    readOperator() {
      let t2 = this.line, n2 = this.column, r2 = this.advance(), s2 = this.peek();
      switch (r2) {
        case "+":
          return s2 === "+" ? (this.advance(), { type: S.INCREMENT, value: "++", line: t2, column: n2 }) : s2 === "=" ? (this.advance(), { type: S.PLUS_ASSIGN, value: "+=", line: t2, column: n2 }) : { type: S.PLUS, value: "+", line: t2, column: n2 };
        case "-":
          return s2 === "-" ? (this.advance(), { type: S.DECREMENT, value: "--", line: t2, column: n2 }) : s2 === "=" ? (this.advance(), { type: S.MINUS_ASSIGN, value: "-=", line: t2, column: n2 }) : { type: S.MINUS, value: "-", line: t2, column: n2 };
        case "*":
          return s2 === "*" ? (this.advance(), { type: S.CARET, value: "**", line: t2, column: n2 }) : s2 === "=" ? (this.advance(), { type: S.STAR_ASSIGN, value: "*=", line: t2, column: n2 }) : { type: S.STAR, value: "*", line: t2, column: n2 };
        case "/":
          return s2 === "=" ? (this.advance(), { type: S.SLASH_ASSIGN, value: "/=", line: t2, column: n2 }) : { type: S.SLASH, value: "/", line: t2, column: n2 };
        case "%":
          return s2 === "=" ? (this.advance(), { type: S.PERCENT_ASSIGN, value: "%=", line: t2, column: n2 }) : { type: S.PERCENT, value: "%", line: t2, column: n2 };
        case "^":
          return s2 === "=" ? (this.advance(), { type: S.CARET_ASSIGN, value: "^=", line: t2, column: n2 }) : { type: S.CARET, value: "^", line: t2, column: n2 };
        case "=":
          return s2 === "=" ? (this.advance(), { type: S.EQ, value: "==", line: t2, column: n2 }) : { type: S.ASSIGN, value: "=", line: t2, column: n2 };
        case "!":
          return s2 === "=" ? (this.advance(), { type: S.NE, value: "!=", line: t2, column: n2 }) : s2 === "~" ? (this.advance(), { type: S.NOT_MATCH, value: "!~", line: t2, column: n2 }) : { type: S.NOT, value: "!", line: t2, column: n2 };
        case "<":
          return s2 === "=" ? (this.advance(), { type: S.LE, value: "<=", line: t2, column: n2 }) : { type: S.LT, value: "<", line: t2, column: n2 };
        case ">":
          return s2 === "=" ? (this.advance(), { type: S.GE, value: ">=", line: t2, column: n2 }) : s2 === ">" ? (this.advance(), { type: S.APPEND, value: ">>", line: t2, column: n2 }) : { type: S.GT, value: ">", line: t2, column: n2 };
        case "&":
          return s2 === "&" ? (this.advance(), { type: S.AND, value: "&&", line: t2, column: n2 }) : { type: S.IDENT, value: "&", line: t2, column: n2 };
        case "|":
          return s2 === "|" ? (this.advance(), { type: S.OR, value: "||", line: t2, column: n2 }) : { type: S.PIPE, value: "|", line: t2, column: n2 };
        case "~":
          return { type: S.MATCH, value: "~", line: t2, column: n2 };
        case "?":
          return { type: S.QUESTION, value: "?", line: t2, column: n2 };
        case ":":
          return { type: S.COLON, value: ":", line: t2, column: n2 };
        case ",":
          return { type: S.COMMA, value: ",", line: t2, column: n2 };
        case ";":
          return { type: S.SEMICOLON, value: ";", line: t2, column: n2 };
        case "(":
          return { type: S.LPAREN, value: "(", line: t2, column: n2 };
        case ")":
          return { type: S.RPAREN, value: ")", line: t2, column: n2 };
        case "{":
          return { type: S.LBRACE, value: "{", line: t2, column: n2 };
        case "}":
          return { type: S.RBRACE, value: "}", line: t2, column: n2 };
        case "[":
          return { type: S.LBRACKET, value: "[", line: t2, column: n2 };
        case "]":
          return { type: S.RBRACKET, value: "]", line: t2, column: n2 };
        case "$":
          return { type: S.DOLLAR, value: "$", line: t2, column: n2 };
        default:
          return { type: S.IDENT, value: r2, line: t2, column: n2 };
      }
    }
    isDigit(t2) {
      return t2 >= "0" && t2 <= "9";
    }
    isAlpha(t2) {
      return t2 >= "a" && t2 <= "z" || t2 >= "A" && t2 <= "Z";
    }
    isAlphaNumeric(t2) {
      return this.isDigit(t2) || this.isAlpha(t2);
    }
  };
});
function Ju(e2) {
  e2.expect(H.PRINT);
  let t2 = [];
  if (e2.check(H.NEWLINE) || e2.check(H.SEMICOLON) || e2.check(H.RBRACE) || e2.check(H.PIPE) || e2.check(H.GT) || e2.check(H.APPEND)) t2.push({ type: "field", index: { type: "number", value: 0 } });
  else for (t2.push(bs(e2)); e2.check(H.COMMA); ) e2.advance(), t2.push(bs(e2));
  let n2;
  return e2.check(H.GT) ? (e2.advance(), n2 = { redirect: ">", file: e2.parsePrimary() }) : e2.check(H.APPEND) && (e2.advance(), n2 = { redirect: ">>", file: e2.parsePrimary() }), { type: "print", args: t2, output: n2 };
}
function bs(e2) {
  return Zx(e2) ? ho(e2, true) : ho(e2, false);
}
function ho(e2, t2) {
  let n2 = t2 ? e2.parseTernary() : Qx(e2);
  if (e2.match(H.ASSIGN, H.PLUS_ASSIGN, H.MINUS_ASSIGN, H.STAR_ASSIGN, H.SLASH_ASSIGN, H.PERCENT_ASSIGN, H.CARET_ASSIGN)) {
    let r2 = e2.advance(), s2 = ho(e2, t2);
    if (n2.type !== "variable" && n2.type !== "field" && n2.type !== "array_access") throw new Error("Invalid assignment target");
    return { type: "assignment", operator: { "=": "=", "+=": "+=", "-=": "-=", "*=": "*=", "/=": "/=", "%=": "%=", "^=": "^=" }[r2.value], target: n2, value: s2 };
  }
  return n2;
}
function Zx(e2) {
  let t2 = 0, n2 = e2.pos;
  for (; n2 < e2.tokens.length; ) {
    let r2 = e2.tokens[n2];
    if (r2.type === H.LPAREN && t2++, r2.type === H.RPAREN && t2--, r2.type === H.QUESTION && t2 === 0) return true;
    if (r2.type === H.NEWLINE || r2.type === H.SEMICOLON || r2.type === H.RBRACE || r2.type === H.COMMA || r2.type === H.PIPE) return false;
    n2++;
  }
  return false;
}
function Qx(e2) {
  let t2 = Zu(e2);
  for (; e2.check(H.OR); ) {
    e2.advance();
    let n2 = Zu(e2);
    t2 = { type: "binary", operator: "||", left: t2, right: n2 };
  }
  return t2;
}
function Zu(e2) {
  let t2 = Qu(e2);
  for (; e2.check(H.AND); ) {
    e2.advance();
    let n2 = Qu(e2);
    t2 = { type: "binary", operator: "&&", left: t2, right: n2 };
  }
  return t2;
}
function Qu(e2) {
  let t2 = Kx(e2);
  if (e2.check(H.IN)) {
    e2.advance();
    let n2 = String(e2.expect(H.IDENT).value);
    return { type: "in", key: t2, array: n2 };
  }
  return t2;
}
function Kx(e2) {
  let t2 = Ku(e2);
  for (; Xx(e2) && !Jx(e2); ) {
    let n2 = Ku(e2);
    t2 = { type: "binary", operator: " ", left: t2, right: n2 };
  }
  return t2;
}
function Ku(e2) {
  let t2 = Xu(e2);
  for (; e2.match(H.MATCH, H.NOT_MATCH); ) {
    let n2 = e2.advance().type === H.MATCH ? "~" : "!~", r2 = Xu(e2);
    t2 = { type: "binary", operator: n2, left: t2, right: r2 };
  }
  return t2;
}
function Xu(e2) {
  let t2 = e2.parseAddSub();
  for (; e2.match(H.LT, H.LE, H.GE, H.EQ, H.NE); ) {
    let n2 = e2.advance(), r2 = e2.parseAddSub();
    t2 = { type: "binary", operator: { "<": "<", "<=": "<=", ">=": ">=", "==": "==", "!=": "!=" }[n2.value], left: t2, right: r2 };
  }
  return t2;
}
function Xx(e2) {
  return e2.match(H.NUMBER, H.STRING, H.IDENT, H.DOLLAR, H.LPAREN, H.NOT, H.MINUS, H.PLUS, H.INCREMENT, H.DECREMENT);
}
function Jx(e2) {
  return e2.match(H.AND, H.OR, H.QUESTION, H.ASSIGN, H.PLUS_ASSIGN, H.MINUS_ASSIGN, H.STAR_ASSIGN, H.SLASH_ASSIGN, H.PERCENT_ASSIGN, H.CARET_ASSIGN, H.COMMA, H.SEMICOLON, H.NEWLINE, H.RBRACE, H.RPAREN, H.RBRACKET, H.COLON, H.PIPE, H.APPEND, H.GT, H.IN);
}
function Yu(e2) {
  e2.expect(H.PRINTF);
  let t2 = e2.check(H.LPAREN);
  t2 && (e2.advance(), e2.skipNewlines());
  let n2 = t2 ? e2.parseExpression() : bs(e2), r2 = [];
  for (; e2.check(H.COMMA); ) e2.advance(), t2 && e2.skipNewlines(), r2.push(t2 ? e2.parseExpression() : bs(e2));
  t2 && (e2.skipNewlines(), e2.expect(H.RPAREN));
  let s2;
  return e2.check(H.GT) ? (e2.advance(), s2 = { redirect: ">", file: e2.parsePrimary() }) : e2.check(H.APPEND) && (e2.advance(), s2 = { redirect: ">>", file: e2.parsePrimary() }), { type: "printf", format: n2, args: r2, output: s2 };
}
var H, ef = v(() => {
  H = { LPAREN: "LPAREN", RPAREN: "RPAREN", QUESTION: "QUESTION", NEWLINE: "NEWLINE", SEMICOLON: "SEMICOLON", RBRACE: "RBRACE", COMMA: "COMMA", PIPE: "PIPE", GT: "GT", APPEND: "APPEND", AND: "AND", OR: "OR", ASSIGN: "ASSIGN", PLUS_ASSIGN: "PLUS_ASSIGN", MINUS_ASSIGN: "MINUS_ASSIGN", STAR_ASSIGN: "STAR_ASSIGN", SLASH_ASSIGN: "SLASH_ASSIGN", PERCENT_ASSIGN: "PERCENT_ASSIGN", CARET_ASSIGN: "CARET_ASSIGN", RBRACKET: "RBRACKET", COLON: "COLON", IN: "IN", PRINT: "PRINT", PRINTF: "PRINTF", IDENT: "IDENT", LT: "LT", LE: "LE", GE: "GE", EQ: "EQ", NE: "NE", MATCH: "MATCH", NOT_MATCH: "NOT_MATCH", NUMBER: "NUMBER", STRING: "STRING", DOLLAR: "DOLLAR", NOT: "NOT", MINUS: "MINUS", PLUS: "PLUS", INCREMENT: "INCREMENT", DECREMENT: "DECREMENT" };
});
var ws, tf = v(() => {
  Gu();
  ef();
  ws = class {
    constructor() {
      __publicField(this, "tokens", []);
      __publicField(this, "pos", 0);
    }
    parse(t2) {
      let n2 = new ys(t2);
      return this.tokens = n2.tokenize(), this.pos = 0, this.parseProgram();
    }
    setPos(t2) {
      this.pos = t2;
    }
    current() {
      return this.tokens[this.pos] || { type: S.EOF, value: "", line: 0, column: 0 };
    }
    advance() {
      let t2 = this.current();
      return this.pos < this.tokens.length && this.pos++, t2;
    }
    match(...t2) {
      return t2.includes(this.current().type);
    }
    check(t2) {
      return this.current().type === t2;
    }
    expect(t2, n2) {
      if (!this.check(t2)) {
        let r2 = this.current();
        throw new Error(n2 || `Expected ${t2}, got ${r2.type} at line ${r2.line}:${r2.column}`);
      }
      return this.advance();
    }
    skipNewlines() {
      for (; this.check(S.NEWLINE); ) this.advance();
    }
    skipTerminators() {
      for (; this.check(S.NEWLINE) || this.check(S.SEMICOLON); ) this.advance();
    }
    parseProgram() {
      let t2 = [], n2 = [];
      for (this.skipNewlines(); !this.check(S.EOF) && (this.skipNewlines(), !this.check(S.EOF)); ) this.check(S.FUNCTION) ? t2.push(this.parseFunction()) : n2.push(this.parseRule()), this.skipTerminators();
      return { functions: t2, rules: n2 };
    }
    parseFunction() {
      this.expect(S.FUNCTION);
      let t2 = this.expect(S.IDENT).value;
      this.expect(S.LPAREN);
      let n2 = [];
      if (!this.check(S.RPAREN)) for (n2.push(this.expect(S.IDENT).value); this.check(S.COMMA); ) this.advance(), n2.push(this.expect(S.IDENT).value);
      this.expect(S.RPAREN), this.skipNewlines();
      let r2 = this.parseBlock();
      return { name: t2, params: n2, body: r2 };
    }
    parseRule() {
      let t2;
      if (this.check(S.BEGIN)) this.advance(), t2 = { type: "begin" };
      else if (this.check(S.END)) this.advance(), t2 = { type: "end" };
      else if (this.check(S.LBRACE)) t2 = void 0;
      else if (this.check(S.REGEX)) {
        let r2 = this.advance();
        if (this.check(S.AND) || this.check(S.OR)) {
          let s2 = { type: "binary", operator: "~", left: { type: "field", index: { type: "number", value: 0 } }, right: { type: "regex", pattern: r2.value } };
          t2 = { type: "expr_pattern", expression: this.parseLogicalOrRest(s2) };
        } else {
          let s2 = { type: "regex_pattern", pattern: r2.value };
          if (this.check(S.COMMA)) {
            this.advance();
            let i2;
            this.check(S.REGEX) ? i2 = { type: "regex_pattern", pattern: this.advance().value } : i2 = { type: "expr_pattern", expression: this.parseExpression() }, t2 = { type: "range", start: s2, end: i2 };
          } else t2 = s2;
        }
      } else {
        let s2 = { type: "expr_pattern", expression: this.parseExpression() };
        if (this.check(S.COMMA)) {
          this.advance();
          let i2;
          this.check(S.REGEX) ? i2 = { type: "regex_pattern", pattern: this.advance().value } : i2 = { type: "expr_pattern", expression: this.parseExpression() }, t2 = { type: "range", start: s2, end: i2 };
        } else t2 = s2;
      }
      this.skipNewlines();
      let n2;
      return this.check(S.LBRACE) ? n2 = this.parseBlock() : n2 = { type: "block", statements: [{ type: "print", args: [{ type: "field", index: { type: "number", value: 0 } }] }] }, { pattern: t2, action: n2 };
    }
    parseBlock() {
      this.expect(S.LBRACE), this.skipNewlines();
      let t2 = [];
      for (; !this.check(S.RBRACE) && !this.check(S.EOF); ) t2.push(this.parseStatement()), this.skipTerminators();
      return this.expect(S.RBRACE), { type: "block", statements: t2 };
    }
    parseStatement() {
      if (this.check(S.SEMICOLON) || this.check(S.NEWLINE)) return this.advance(), { type: "block", statements: [] };
      if (this.check(S.LBRACE)) return this.parseBlock();
      if (this.check(S.IF)) return this.parseIf();
      if (this.check(S.WHILE)) return this.parseWhile();
      if (this.check(S.DO)) return this.parseDoWhile();
      if (this.check(S.FOR)) return this.parseFor();
      if (this.check(S.BREAK)) return this.advance(), { type: "break" };
      if (this.check(S.CONTINUE)) return this.advance(), { type: "continue" };
      if (this.check(S.NEXT)) return this.advance(), { type: "next" };
      if (this.check(S.NEXTFILE)) return this.advance(), { type: "nextfile" };
      if (this.check(S.EXIT)) {
        this.advance();
        let n2;
        return !this.check(S.NEWLINE) && !this.check(S.SEMICOLON) && !this.check(S.RBRACE) && !this.check(S.EOF) && (n2 = this.parseExpression()), { type: "exit", code: n2 };
      }
      if (this.check(S.RETURN)) {
        this.advance();
        let n2;
        return !this.check(S.NEWLINE) && !this.check(S.SEMICOLON) && !this.check(S.RBRACE) && !this.check(S.EOF) && (n2 = this.parseExpression()), { type: "return", value: n2 };
      }
      if (this.check(S.DELETE)) {
        this.advance();
        let n2 = this.parsePrimary();
        if (n2.type !== "array_access" && n2.type !== "variable") throw new Error("delete requires array element or array");
        return { type: "delete", target: n2 };
      }
      return this.check(S.PRINT) ? Ju(this) : this.check(S.PRINTF) ? Yu(this) : { type: "expr_stmt", expression: this.parseExpression() };
    }
    parseIf() {
      this.expect(S.IF), this.expect(S.LPAREN);
      let t2 = this.parseExpression();
      this.expect(S.RPAREN), this.skipNewlines();
      let n2 = this.parseStatement();
      this.skipTerminators();
      let r2;
      return this.check(S.ELSE) && (this.advance(), this.skipNewlines(), r2 = this.parseStatement()), { type: "if", condition: t2, consequent: n2, alternate: r2 };
    }
    parseWhile() {
      this.expect(S.WHILE), this.expect(S.LPAREN);
      let t2 = this.parseExpression();
      this.expect(S.RPAREN), this.skipNewlines();
      let n2 = this.parseStatement();
      return { type: "while", condition: t2, body: n2 };
    }
    parseDoWhile() {
      this.expect(S.DO), this.skipNewlines();
      let t2 = this.parseStatement();
      this.skipNewlines(), this.expect(S.WHILE), this.expect(S.LPAREN);
      let n2 = this.parseExpression();
      return this.expect(S.RPAREN), { type: "do_while", body: t2, condition: n2 };
    }
    parseFor() {
      if (this.expect(S.FOR), this.expect(S.LPAREN), this.check(S.IDENT)) {
        let i2 = this.advance();
        if (this.check(S.IN)) {
          this.advance();
          let o2 = this.expect(S.IDENT).value;
          this.expect(S.RPAREN), this.skipNewlines();
          let a = this.parseStatement();
          return { type: "for_in", variable: i2.value, array: o2, body: a };
        }
        this.pos--;
      }
      let t2;
      this.check(S.SEMICOLON) || (t2 = this.parseExpression()), this.expect(S.SEMICOLON);
      let n2;
      this.check(S.SEMICOLON) || (n2 = this.parseExpression()), this.expect(S.SEMICOLON);
      let r2;
      this.check(S.RPAREN) || (r2 = this.parseExpression()), this.expect(S.RPAREN), this.skipNewlines();
      let s2 = this.parseStatement();
      return { type: "for", init: t2, condition: n2, update: r2, body: s2 };
    }
    parseExpression() {
      return this.parseAssignment();
    }
    parseAssignment() {
      let t2 = this.parseTernary();
      if (this.match(S.ASSIGN, S.PLUS_ASSIGN, S.MINUS_ASSIGN, S.STAR_ASSIGN, S.SLASH_ASSIGN, S.PERCENT_ASSIGN, S.CARET_ASSIGN)) {
        let n2 = this.advance(), r2 = this.parseAssignment();
        if (t2.type !== "variable" && t2.type !== "field" && t2.type !== "array_access") throw new Error("Invalid assignment target");
        return { type: "assignment", operator: { "=": "=", "+=": "+=", "-=": "-=", "*=": "*=", "/=": "/=", "%=": "%=", "^=": "^=" }[n2.value], target: t2, value: r2 };
      }
      return t2;
    }
    parseTernary() {
      let t2 = this.parsePipeGetline();
      if (this.check(S.QUESTION)) {
        this.advance();
        let n2 = this.parseExpression();
        this.expect(S.COLON);
        let r2 = this.parseExpression();
        t2 = { type: "ternary", condition: t2, consequent: n2, alternate: r2 };
      }
      return t2;
    }
    parsePipeGetline() {
      let t2 = this.parseOr();
      if (this.check(S.PIPE)) {
        if (this.advance(), !this.check(S.GETLINE)) throw new Error("Expected 'getline' after '|' in expression context");
        this.advance();
        let n2;
        return this.check(S.IDENT) && (n2 = this.advance().value), { type: "getline", command: t2, variable: n2 };
      }
      return t2;
    }
    parseOr() {
      let t2 = this.parseAnd();
      for (; this.check(S.OR); ) {
        this.advance();
        let n2 = this.parseAnd();
        t2 = { type: "binary", operator: "||", left: t2, right: n2 };
      }
      return t2;
    }
    parseLogicalOrRest(t2) {
      for (t2 = this.parseLogicalAndRest(t2); this.check(S.OR); ) {
        this.advance();
        let n2 = this.parseAnd();
        t2 = { type: "binary", operator: "||", left: t2, right: n2 };
      }
      return t2;
    }
    parseLogicalAndRest(t2) {
      for (; this.check(S.AND); ) {
        this.advance();
        let n2 = this.parseIn();
        t2 = { type: "binary", operator: "&&", left: t2, right: n2 };
      }
      return t2;
    }
    parseAnd() {
      let t2 = this.parseIn();
      for (; this.check(S.AND); ) {
        this.advance();
        let n2 = this.parseIn();
        t2 = { type: "binary", operator: "&&", left: t2, right: n2 };
      }
      return t2;
    }
    parseIn() {
      let t2 = this.parseConcatenation();
      if (this.check(S.IN)) {
        this.advance();
        let n2 = this.expect(S.IDENT).value;
        return { type: "in", key: t2, array: n2 };
      }
      return t2;
    }
    parseConcatenation() {
      let t2 = this.parseMatch();
      for (; this.canStartExpression() && !this.isConcatTerminator(); ) {
        let n2 = this.parseMatch();
        t2 = { type: "binary", operator: " ", left: t2, right: n2 };
      }
      return t2;
    }
    parseMatch() {
      let t2 = this.parseComparison();
      for (; this.match(S.MATCH, S.NOT_MATCH); ) {
        let n2 = this.advance().type === S.MATCH ? "~" : "!~", r2 = this.parseComparison();
        t2 = { type: "binary", operator: n2, left: t2, right: r2 };
      }
      return t2;
    }
    parseComparison() {
      let t2 = this.parseAddSub();
      for (; this.match(S.LT, S.LE, S.GT, S.GE, S.EQ, S.NE); ) {
        let n2 = this.advance(), r2 = this.parseAddSub();
        t2 = { type: "binary", operator: { "<": "<", "<=": "<=", ">": ">", ">=": ">=", "==": "==", "!=": "!=" }[n2.value], left: t2, right: r2 };
      }
      return t2;
    }
    canStartExpression() {
      return this.match(S.NUMBER, S.STRING, S.IDENT, S.DOLLAR, S.LPAREN, S.NOT, S.MINUS, S.PLUS, S.INCREMENT, S.DECREMENT);
    }
    isConcatTerminator() {
      return this.match(S.AND, S.OR, S.QUESTION, S.ASSIGN, S.PLUS_ASSIGN, S.MINUS_ASSIGN, S.STAR_ASSIGN, S.SLASH_ASSIGN, S.PERCENT_ASSIGN, S.CARET_ASSIGN, S.COMMA, S.SEMICOLON, S.NEWLINE, S.RBRACE, S.RPAREN, S.RBRACKET, S.COLON, S.PIPE, S.APPEND, S.IN);
    }
    parseAddSub() {
      let t2 = this.parseMulDiv();
      for (; this.match(S.PLUS, S.MINUS); ) {
        let n2 = this.advance().value, r2 = this.parseMulDiv();
        t2 = { type: "binary", operator: n2, left: t2, right: r2 };
      }
      return t2;
    }
    parseMulDiv() {
      let t2 = this.parseUnary();
      for (; this.match(S.STAR, S.SLASH, S.PERCENT); ) {
        let n2 = this.advance(), r2 = this.parseUnary();
        t2 = { type: "binary", operator: { "*": "*", "/": "/", "%": "%" }[n2.value], left: t2, right: r2 };
      }
      return t2;
    }
    parseUnary() {
      if (this.check(S.INCREMENT)) {
        this.advance();
        let t2 = this.parseUnary();
        return t2.type !== "variable" && t2.type !== "field" && t2.type !== "array_access" ? { type: "unary", operator: "+", operand: { type: "unary", operator: "+", operand: t2 } } : { type: "pre_increment", operand: t2 };
      }
      if (this.check(S.DECREMENT)) {
        this.advance();
        let t2 = this.parseUnary();
        return t2.type !== "variable" && t2.type !== "field" && t2.type !== "array_access" ? { type: "unary", operator: "-", operand: { type: "unary", operator: "-", operand: t2 } } : { type: "pre_decrement", operand: t2 };
      }
      if (this.match(S.NOT, S.MINUS, S.PLUS)) {
        let t2 = this.advance().value, n2 = this.parseUnary();
        return { type: "unary", operator: t2, operand: n2 };
      }
      return this.parsePower();
    }
    parsePower() {
      let t2 = this.parsePostfix();
      if (this.check(S.CARET)) {
        this.advance();
        let n2 = this.parsePower();
        t2 = { type: "binary", operator: "^", left: t2, right: n2 };
      }
      return t2;
    }
    parsePostfix() {
      let t2 = this.parsePrimary();
      if (this.check(S.INCREMENT)) {
        if (this.advance(), t2.type !== "variable" && t2.type !== "field" && t2.type !== "array_access") throw new Error("Invalid increment operand");
        return { type: "post_increment", operand: t2 };
      }
      if (this.check(S.DECREMENT)) {
        if (this.advance(), t2.type !== "variable" && t2.type !== "field" && t2.type !== "array_access") throw new Error("Invalid decrement operand");
        return { type: "post_decrement", operand: t2 };
      }
      return t2;
    }
    parseFieldIndex() {
      if (this.check(S.INCREMENT)) {
        this.advance();
        let t2 = this.parseFieldIndex();
        return t2.type !== "variable" && t2.type !== "field" && t2.type !== "array_access" ? { type: "unary", operator: "+", operand: { type: "unary", operator: "+", operand: t2 } } : { type: "pre_increment", operand: t2 };
      }
      if (this.check(S.DECREMENT)) {
        this.advance();
        let t2 = this.parseFieldIndex();
        return t2.type !== "variable" && t2.type !== "field" && t2.type !== "array_access" ? { type: "unary", operator: "-", operand: { type: "unary", operator: "-", operand: t2 } } : { type: "pre_decrement", operand: t2 };
      }
      if (this.match(S.NOT, S.MINUS, S.PLUS)) {
        let t2 = this.advance().value, n2 = this.parseFieldIndex();
        return { type: "unary", operator: t2, operand: n2 };
      }
      return this.parseFieldIndexPower();
    }
    parseFieldIndexPower() {
      let t2 = this.parseFieldIndexPrimary();
      if (this.check(S.CARET)) {
        this.advance();
        let n2 = this.parseFieldIndexPower();
        t2 = { type: "binary", operator: "^", left: t2, right: n2 };
      }
      return t2;
    }
    parseFieldIndexPrimary() {
      if (this.check(S.NUMBER)) return { type: "number", value: this.advance().value };
      if (this.check(S.STRING)) return { type: "string", value: this.advance().value };
      if (this.check(S.DOLLAR)) return this.advance(), { type: "field", index: this.parseFieldIndex() };
      if (this.check(S.LPAREN)) {
        this.advance();
        let t2 = this.parseExpression();
        return this.expect(S.RPAREN), t2;
      }
      if (this.check(S.IDENT)) {
        let t2 = this.advance().value;
        if (this.check(S.LPAREN)) {
          this.advance();
          let n2 = [];
          if (!this.check(S.RPAREN)) for (n2.push(this.parseExpression()); this.check(S.COMMA); ) this.advance(), n2.push(this.parseExpression());
          return this.expect(S.RPAREN), { type: "call", name: t2, args: n2 };
        }
        if (this.check(S.LBRACKET)) {
          this.advance();
          let n2 = this.parseExpression();
          if (this.check(S.COMMA)) {
            let r2 = [n2];
            for (; this.check(S.COMMA); ) this.advance(), r2.push(this.parseExpression());
            this.expect(S.RBRACKET);
            let s2 = r2.reduce((i2, o2) => ({ type: "binary", operator: " ", left: { type: "binary", operator: " ", left: i2, right: { type: "variable", name: "SUBSEP" } }, right: o2 }));
            return { type: "array_access", array: t2, key: s2 };
          }
          return this.expect(S.RBRACKET), { type: "array_access", array: t2, key: n2 };
        }
        return { type: "variable", name: t2 };
      }
      throw new Error(`Unexpected token in field index: ${this.current().type} at line ${this.current().line}:${this.current().column}`);
    }
    parsePrimary() {
      if (this.check(S.NUMBER)) return { type: "number", value: this.advance().value };
      if (this.check(S.STRING)) return { type: "string", value: this.advance().value };
      if (this.check(S.REGEX)) return { type: "regex", pattern: this.advance().value };
      if (this.check(S.DOLLAR)) return this.advance(), { type: "field", index: this.parseFieldIndex() };
      if (this.check(S.LPAREN)) {
        this.advance();
        let t2 = this.parseExpression();
        if (this.check(S.COMMA)) {
          let n2 = [t2];
          for (; this.check(S.COMMA); ) this.advance(), n2.push(this.parseExpression());
          return this.expect(S.RPAREN), { type: "tuple", elements: n2 };
        }
        return this.expect(S.RPAREN), t2;
      }
      if (this.check(S.GETLINE)) {
        this.advance();
        let t2, n2;
        return this.check(S.IDENT) && (t2 = this.advance().value), this.check(S.LT) && (this.advance(), n2 = this.parsePrimary()), { type: "getline", variable: t2, file: n2 };
      }
      if (this.check(S.IDENT)) {
        let t2 = this.advance().value;
        if (this.check(S.LPAREN)) {
          this.advance();
          let n2 = [];
          if (this.skipNewlines(), !this.check(S.RPAREN)) for (n2.push(this.parseExpression()); this.check(S.COMMA); ) this.advance(), this.skipNewlines(), n2.push(this.parseExpression());
          return this.skipNewlines(), this.expect(S.RPAREN), { type: "call", name: t2, args: n2 };
        }
        if (this.check(S.LBRACKET)) {
          this.advance();
          let n2 = [this.parseExpression()];
          for (; this.check(S.COMMA); ) this.advance(), n2.push(this.parseExpression());
          this.expect(S.RBRACKET);
          let r2;
          if (n2.length === 1) r2 = n2[0];
          else {
            r2 = n2[0];
            for (let s2 = 1; s2 < n2.length; s2++) r2 = { type: "binary", operator: " ", left: { type: "binary", operator: " ", left: r2, right: { type: "variable", name: "SUBSEP" } }, right: n2[s2] };
          }
          return { type: "array_access", array: t2, key: r2 };
        }
        return { type: "variable", name: t2 };
      }
      throw new Error(`Unexpected token: ${this.current().type} at line ${this.current().line}:${this.current().column}`);
    }
  };
});
var sf = {};
V(sf, { awkCommand2: () => e1 });
function mo(e2) {
  return e2.replace(/\\t/g, "	").replace(/\\n/g, `
`).replace(/\\r/g, "\r").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\a/g, "\x07").replace(/\\v/g, "\v").replace(/\\\\/g, "\\");
}
function nf(e2) {
  if (e2 === " ") return /\s+/;
  if (/[[\](){}.*+?^$|\\]/.test(e2)) try {
    return new RegExp(e2);
  } catch {
    return new RegExp(rf(e2));
  }
  return new RegExp(rf(e2));
}
function rf(e2) {
  return e2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var Yx, e1, of = v(() => {
  de();
  X();
  qu();
  tf();
  Yx = { name: "awk", summary: "pattern scanning and text processing language", usage: "awk [OPTIONS] 'PROGRAM' [FILE...]", options: ["-F FS      use FS as field separator", "-v VAR=VAL assign VAL to variable VAR", "    --help display this help and exit"] }, e1 = { name: "awk", async execute(e2, t2) {
    var _a3;
    if (_(e2)) return F$3(Yx);
    let n2 = /\s+/, r2 = " ", s2 = {}, i2 = 0;
    for (let h = 0; h < e2.length; h++) {
      let g = e2[h];
      if (g === "-F" && h + 1 < e2.length) r2 = mo(e2[++h]), n2 = nf(r2), i2 = h + 1;
      else if (g.startsWith("-F")) r2 = mo(g.slice(2)), n2 = nf(r2), i2 = h + 1;
      else if (g === "-v" && h + 1 < e2.length) {
        let b = e2[++h], y = b.indexOf("=");
        if (y > 0) {
          let w = b.slice(0, y), E = mo(b.slice(y + 1));
          s2[w] = E;
        }
        i2 = h + 1;
      } else {
        if (g.startsWith("--")) return G("awk", g);
        if (g.startsWith("-") && g.length > 1) {
          let b = g[1];
          if (b !== "F" && b !== "v") return G("awk", `-${b}`);
          i2 = h + 1;
        } else if (!g.startsWith("-")) {
          i2 = h;
          break;
        }
      }
    }
    if (i2 >= e2.length) return { stdout: "", stderr: `awk: missing program
`, exitCode: 1 };
    let o2 = e2[i2], a = e2.slice(i2 + 1), l = new ws(), c;
    try {
      c = l.parse(o2);
    } catch (h) {
      return { stdout: "", stderr: `awk: ${h instanceof Error ? h.message : String(h)}
`, exitCode: 1 };
    }
    let u = { readFile: t2.fs.readFile.bind(t2.fs), writeFile: t2.fs.writeFile.bind(t2.fs), appendFile: async (h, g) => {
      try {
        let b = await t2.fs.readFile(h);
        await t2.fs.writeFile(h, b + g);
      } catch {
        await t2.fs.writeFile(h, g);
      }
    }, resolvePath: t2.fs.resolvePath.bind(t2.fs) }, f2 = so({ fieldSep: n2, maxIterations: (_a3 = t2.limits) == null ? void 0 : _a3.maxAwkIterations, fs: u, cwd: t2.cwd, exec: t2.exec ? (h) => t2.exec(h, { cwd: t2.cwd }) : void 0 });
    f2.FS = r2, f2.vars = { ...s2 }, f2.ARGC = a.length + 1, f2.ARGV = { 0: "awk" };
    for (let h = 0; h < a.length; h++) f2.ARGV[String(h + 1)] = a[h];
    f2.ENVIRON = { ...t2.env };
    let p = new xr(f2);
    p.execute(c);
    let d = c.rules.some((h) => {
      var _a4, _b3;
      return ((_a4 = h.pattern) == null ? void 0 : _a4.type) !== "begin" && ((_b3 = h.pattern) == null ? void 0 : _b3.type) !== "end";
    }), m = c.rules.some((h) => {
      var _a4;
      return ((_a4 = h.pattern) == null ? void 0 : _a4.type) === "end";
    });
    try {
      if (await p.executeBegin(), f2.shouldExit) return await p.executeEnd(), { stdout: p.getOutput(), stderr: "", exitCode: p.getExitCode() };
      if (!d && !m) return { stdout: p.getOutput(), stderr: "", exitCode: p.getExitCode() };
      let h = [];
      if (a.length > 0) for (let g of a) try {
        let b = t2.fs.resolvePath(t2.cwd, g), w = (await t2.fs.readFile(b)).split(`
`);
        w.length > 0 && w[w.length - 1] === "" && w.pop(), h.push({ filename: g, lines: w });
      } catch {
        return { stdout: "", stderr: `awk: ${g}: No such file or directory
`, exitCode: 1 };
      }
      else {
        let g = t2.stdin.split(`
`);
        g.length > 0 && g[g.length - 1] === "" && g.pop(), h.push({ filename: "", lines: g });
      }
      for (let g of h) {
        for (f2.FILENAME = g.filename, f2.FNR = 0, f2.lines = g.lines, f2.lineIndex = -1, f2.shouldNextFile = false; f2.lineIndex < g.lines.length - 1 && (f2.lineIndex++, await p.executeLine(g.lines[f2.lineIndex]), !(f2.shouldExit || f2.shouldNextFile)); ) ;
        if (f2.shouldExit) break;
      }
      return await p.executeEnd(), { stdout: p.getOutput(), stderr: "", exitCode: p.getExitCode() };
    } catch (h) {
      let g = h instanceof Error ? h.message : String(h), b = h instanceof ne ? ne.EXIT_CODE : 2;
      return { stdout: p.getOutput(), stderr: `awk: ${g}
`, exitCode: b };
    }
  } };
});
function af(e2) {
  let t2 = e2.trim(), n2 = t2.match(/^([+-]?\d*\.?\d+)\s*([kmgtpeKMGTPE])?[iI]?[bB]?$/);
  if (!n2) {
    let o2 = parseFloat(t2);
    return Number.isNaN(o2) ? 0 : o2;
  }
  let r2 = parseFloat(n2[1]), s2 = (n2[2] || "").toLowerCase(), i2 = t1[s2] || 1;
  return r2 * i2;
}
function lf(e2) {
  let t2 = e2.trim().toLowerCase().slice(0, 3);
  return n1[t2] || 0;
}
function r1(e2, t2) {
  let n2 = e2.split(/(\d+)/), r2 = t2.split(/(\d+)/), s2 = Math.max(n2.length, r2.length);
  for (let i2 = 0; i2 < s2; i2++) {
    let o2 = n2[i2] || "", a = r2[i2] || "", l = /^\d+$/.test(o2) ? parseInt(o2, 10) : null, c = /^\d+$/.test(a) ? parseInt(a, 10) : null;
    if (l !== null && c !== null) {
      if (l !== c) return l - c;
    } else if (o2 !== a) return o2.localeCompare(a);
  }
  return 0;
}
function cf(e2) {
  return e2.replace(/[^a-zA-Z0-9\s]/g, "");
}
function go(e2, t2, n2) {
  let r2 = n2 !== null ? n2 : /\s+/, s2 = e2.split(r2), i2 = t2.startField - 1;
  if (i2 >= s2.length) return "";
  if (t2.endField === void 0) {
    let l = s2[i2] || "";
    return t2.startChar !== void 0 && (l = l.slice(t2.startChar - 1)), t2.ignoreLeading && (l = l.trimStart()), l;
  }
  let o2 = Math.min(t2.endField - 1, s2.length - 1), a = "";
  for (let l = i2; l <= o2 && l < s2.length; l++) {
    let c = s2[l] || "";
    if (l === i2 && t2.startChar !== void 0 && (c = c.slice(t2.startChar - 1)), l === o2 && t2.endChar !== void 0) {
      let u = l === i2 && t2.startChar !== void 0 ? t2.endChar - t2.startChar + 1 : t2.endChar;
      c = c.slice(0, u);
    }
    l > i2 && (a += n2 || " "), a += c;
  }
  return t2.ignoreLeading && (a = a.trimStart()), a;
}
function uf(e2, t2, n2) {
  let r2 = e2, s2 = t2;
  if (n2.dictionaryOrder && (r2 = cf(r2), s2 = cf(s2)), n2.ignoreCase && (r2 = r2.toLowerCase(), s2 = s2.toLowerCase()), n2.monthSort) {
    let i2 = lf(r2), o2 = lf(s2);
    return i2 - o2;
  }
  if (n2.humanNumeric) {
    let i2 = af(r2), o2 = af(s2);
    return i2 - o2;
  }
  if (n2.versionSort) return r1(r2, s2);
  if (n2.numeric) {
    let i2 = parseFloat(r2) || 0, o2 = parseFloat(s2) || 0;
    return i2 - o2;
  }
  return r2.localeCompare(s2);
}
function ff(e2) {
  let { keys: t2, fieldDelimiter: n2, numeric: r2, ignoreCase: s2, reverse: i2, humanNumeric: o2, versionSort: a, dictionaryOrder: l, monthSort: c, ignoreLeadingBlanks: u, stable: f2 } = e2;
  return (p, d) => {
    let m = p, h = d;
    if (u && (m = m.trimStart(), h = h.trimStart()), t2.length === 0) {
      let b = uf(m, h, { numeric: r2, ignoreCase: s2, humanNumeric: o2, versionSort: a, dictionaryOrder: l, monthSort: c });
      if (b !== 0) return i2 ? -b : b;
      if (!f2) {
        let y = p.localeCompare(d);
        return i2 ? -y : y;
      }
      return 0;
    }
    for (let g of t2) {
      let b = go(m, g, n2), y = go(h, g, n2);
      g.ignoreLeading && (b = b.trimStart(), y = y.trimStart());
      let w = { numeric: g.numeric ?? r2, ignoreCase: g.ignoreCase ?? s2, humanNumeric: g.humanNumeric ?? o2, versionSort: g.versionSort ?? a, dictionaryOrder: g.dictionaryOrder ?? l, monthSort: g.monthSort ?? c }, E = g.reverse ?? i2, C = uf(b, y, w);
      if (C !== 0) return E ? -C : C;
    }
    if (!f2) {
      let g = p.localeCompare(d);
      return i2 ? -g : g;
    }
    return 0;
  };
}
function pf(e2, t2) {
  if (t2.keys.length === 0) {
    if (t2.ignoreCase) {
      let s2 = /* @__PURE__ */ new Set();
      return e2.filter((i2) => {
        let o2 = i2.toLowerCase();
        return s2.has(o2) ? false : (s2.add(o2), true);
      });
    }
    return [...new Set(e2)];
  }
  let n2 = t2.keys[0], r2 = /* @__PURE__ */ new Set();
  return e2.filter((s2) => {
    let i2 = go(s2, n2, t2.fieldDelimiter);
    return (n2.ignoreCase ?? t2.ignoreCase) && (i2 = i2.toLowerCase()), r2.has(i2) ? false : (r2.add(i2), true);
  });
}
var t1, n1, df = v(() => {
  t1 = { "": 1, k: 1024, m: 1048576, g: 1073741824, t: 1099511627776, p: 1125899906842624, e: 1152921504606847e3 }, n1 = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12 };
});
function xs(e2) {
  let t2 = { startField: 1 }, n2 = "", r2 = e2, s2 = r2.match(/([bdfhMnrV]+)$/);
  s2 && (n2 = s2[1], r2 = r2.slice(0, -n2.length)), n2.includes("n") && (t2.numeric = true), n2.includes("r") && (t2.reverse = true), n2.includes("f") && (t2.ignoreCase = true), n2.includes("b") && (t2.ignoreLeading = true), n2.includes("h") && (t2.humanNumeric = true), n2.includes("V") && (t2.versionSort = true), n2.includes("d") && (t2.dictionaryOrder = true), n2.includes("M") && (t2.monthSort = true);
  let i2 = r2.split(",");
  if (i2.length === 0 || i2[0] === "") return null;
  let o2 = i2[0].split("."), a = parseInt(o2[0], 10);
  if (Number.isNaN(a) || a < 1) return null;
  if (t2.startField = a, o2.length > 1 && o2[1]) {
    let l = parseInt(o2[1], 10);
    !Number.isNaN(l) && l >= 1 && (t2.startChar = l);
  }
  if (i2.length > 1 && i2[1]) {
    let l = i2[1], c = l.match(/([bdfhMnrV]+)$/);
    if (c) {
      let f2 = c[1];
      f2.includes("n") && (t2.numeric = true), f2.includes("r") && (t2.reverse = true), f2.includes("f") && (t2.ignoreCase = true), f2.includes("b") && (t2.ignoreLeading = true), f2.includes("h") && (t2.humanNumeric = true), f2.includes("V") && (t2.versionSort = true), f2.includes("d") && (t2.dictionaryOrder = true), f2.includes("M") && (t2.monthSort = true), l = l.slice(0, -f2.length);
    }
    let u = l.split(".");
    if (u[0]) {
      let f2 = parseInt(u[0], 10);
      if (!Number.isNaN(f2) && f2 >= 1 && (t2.endField = f2), u.length > 1 && u[1]) {
        let p = parseInt(u[1], 10);
        !Number.isNaN(p) && p >= 1 && (t2.endChar = p);
      }
    }
  }
  return t2;
}
var hf = v(() => {
});
var mf = {};
V(mf, { sortCommand: () => i1 });
var s1, i1, gf = v(() => {
  pn();
  X();
  df();
  hf();
  s1 = { name: "sort", summary: "sort lines of text files", usage: "sort [OPTION]... [FILE]...", options: ["-b, --ignore-leading-blanks  ignore leading blanks", "-d, --dictionary-order  consider only blanks and alphanumeric characters", "-f, --ignore-case    fold lower case to upper case characters", "-h, --human-numeric-sort  compare human readable numbers (e.g., 2K 1G)", "-M, --month-sort     compare (unknown) < 'JAN' < ... < 'DEC'", "-n, --numeric-sort   compare according to string numerical value", "-r, --reverse        reverse the result of comparisons", "-V, --version-sort   natural sort of (version) numbers within text", "-c, --check          check for sorted input; do not sort", "-o, --output=FILE    write result to FILE instead of stdout", "-s, --stable         stabilize sort by disabling last-resort comparison", "-u, --unique         output only unique lines", "-k, --key=KEYDEF     sort via a key; KEYDEF gives location and type", "-t, --field-separator=SEP  use SEP as field separator", "    --help           display this help and exit"], description: `KEYDEF is F[.C][OPTS][,F[.C][OPTS]]
  F is a field number (1-indexed)
  C is a character position within the field (1-indexed)
  OPTS can be: b d f h M n r V (per-key modifiers)

Examples:
  -k1        sort by first field
  -k2,2      sort by second field only
  -k1.3      sort by first field starting at 3rd character
  -k1,2n     sort by fields 1-2 numerically
  -k2 -k1    sort by field 2, then by field 1` }, i1 = { name: "sort", async execute(e2, t2) {
    if (_(e2)) return F$3(s1);
    let n2 = { reverse: false, numeric: false, unique: false, ignoreCase: false, humanNumeric: false, versionSort: false, dictionaryOrder: false, monthSort: false, ignoreLeadingBlanks: false, stable: false, checkOnly: false, outputFile: null, keys: [], fieldDelimiter: null }, r2 = [];
    for (let c = 0; c < e2.length; c++) {
      let u = e2[c];
      if (u === "-r" || u === "--reverse") n2.reverse = true;
      else if (u === "-n" || u === "--numeric-sort") n2.numeric = true;
      else if (u === "-u" || u === "--unique") n2.unique = true;
      else if (u === "-f" || u === "--ignore-case") n2.ignoreCase = true;
      else if (u === "-h" || u === "--human-numeric-sort") n2.humanNumeric = true;
      else if (u === "-V" || u === "--version-sort") n2.versionSort = true;
      else if (u === "-d" || u === "--dictionary-order") n2.dictionaryOrder = true;
      else if (u === "-M" || u === "--month-sort") n2.monthSort = true;
      else if (u === "-b" || u === "--ignore-leading-blanks") n2.ignoreLeadingBlanks = true;
      else if (u === "-s" || u === "--stable") n2.stable = true;
      else if (u === "-c" || u === "--check") n2.checkOnly = true;
      else if (u === "-o" || u === "--output") n2.outputFile = e2[++c] || null;
      else if (u.startsWith("-o")) n2.outputFile = u.slice(2) || null;
      else if (u.startsWith("--output=")) n2.outputFile = u.slice(9) || null;
      else if (u === "-t" || u === "--field-separator") n2.fieldDelimiter = e2[++c] || null;
      else if (u.startsWith("-t")) n2.fieldDelimiter = u.slice(2) || null;
      else if (u.startsWith("--field-separator=")) n2.fieldDelimiter = u.slice(18) || null;
      else if (u === "-k" || u === "--key") {
        let f2 = e2[++c];
        if (f2) {
          let p = xs(f2);
          p && n2.keys.push(p);
        }
      } else if (u.startsWith("-k")) {
        let f2 = xs(u.slice(2));
        f2 && n2.keys.push(f2);
      } else if (u.startsWith("--key=")) {
        let f2 = xs(u.slice(6));
        f2 && n2.keys.push(f2);
      } else {
        if (u.startsWith("--")) return G("sort", u);
        if (u.startsWith("-") && !u.startsWith("--")) {
          let f2 = false;
          for (let p of u.slice(1)) if (p === "r") n2.reverse = true;
          else if (p === "n") n2.numeric = true;
          else if (p === "u") n2.unique = true;
          else if (p === "f") n2.ignoreCase = true;
          else if (p === "h") n2.humanNumeric = true;
          else if (p === "V") n2.versionSort = true;
          else if (p === "d") n2.dictionaryOrder = true;
          else if (p === "M") n2.monthSort = true;
          else if (p === "b") n2.ignoreLeadingBlanks = true;
          else if (p === "s") n2.stable = true;
          else if (p === "c") n2.checkOnly = true;
          else {
            f2 = true;
            break;
          }
          if (f2) return G("sort", u);
        } else r2.push(u);
      }
    }
    let s2 = await Tn(t2, r2, { cmdName: "sort" });
    if (!s2.ok) return s2.error;
    let o2 = s2.content.split(`
`);
    o2.length > 0 && o2[o2.length - 1] === "" && o2.pop();
    let a = ff(n2);
    if (n2.checkOnly) {
      let c = r2.length > 0 ? r2[0] : "-";
      for (let u = 1; u < o2.length; u++) if (a(o2[u - 1], o2[u]) > 0) return { stdout: "", stderr: `sort: ${c}:${u + 1}: disorder: ${o2[u]}
`, exitCode: 1 };
      return { stdout: "", stderr: "", exitCode: 0 };
    }
    o2.sort(a), n2.unique && (o2 = pf(o2, n2));
    let l = o2.length > 0 ? `${o2.join(`
`)}
` : "";
    if (n2.outputFile) {
      let c = t2.fs.resolvePath(t2.cwd, n2.outputFile);
      return await t2.fs.writeFile(c, l), { stdout: "", stderr: "", exitCode: 0 };
    }
    return { stdout: l, stderr: "", exitCode: 0 };
  } };
});
var yf = {};
V(yf, { uniqCommand: () => l1 });
var o1, a1, l1, bf = v(() => {
  Oe();
  pn();
  X();
  o1 = { name: "uniq", summary: "report or omit repeated lines", usage: "uniq [OPTION]... [INPUT [OUTPUT]]", options: ["-c, --count        prefix lines by the number of occurrences", "-d, --repeated     only print duplicate lines", "-i, --ignore-case  ignore case when comparing", "-u, --unique       only print unique lines", "    --help         display this help and exit"] }, a1 = { count: { short: "c", long: "count", type: "boolean" }, duplicatesOnly: { short: "d", long: "repeated", type: "boolean" }, uniqueOnly: { short: "u", long: "unique", type: "boolean" }, ignoreCase: { short: "i", long: "ignore-case", type: "boolean" } }, l1 = { name: "uniq", async execute(e2, t2) {
    if (_(e2)) return F$3(o1);
    let n2 = fe("uniq", e2, a1);
    if (!n2.ok) return n2.error;
    let { count: r2, duplicatesOnly: s2, uniqueOnly: i2, ignoreCase: o2 } = n2.result.flags, a = n2.result.positional, l = await Tn(t2, a, { cmdName: "uniq" });
    if (!l.ok) return l.error;
    let u = l.content.split(`
`);
    if (u.length > 0 && u[u.length - 1] === "" && u.pop(), u.length === 0) return { stdout: "", stderr: "", exitCode: 0 };
    let f2 = [], p = u[0], d = 1, m = (b, y) => o2 ? b.toLowerCase() === y.toLowerCase() : b === y;
    for (let b = 1; b < u.length; b++) m(u[b], p) ? d++ : (f2.push({ line: p, count: d }), p = u[b], d = 1);
    f2.push({ line: p, count: d });
    let h = f2;
    s2 ? h = f2.filter((b) => b.count > 1) : i2 && (h = f2.filter((b) => b.count === 1));
    let g = "";
    for (let { line: b, count: y } of h) r2 ? g += `${String(y).padStart(4)} ${b}
` : g += `${b}
`;
    return { stdout: g, stderr: "", exitCode: 0 };
  } };
});
var wf = {};
V(wf, { commCommand: () => u1 });
var c1, u1, xf = v(() => {
  X();
  c1 = { name: "comm", summary: "compare two sorted files line by line", usage: "comm [OPTION]... FILE1 FILE2", options: ["-1             suppress column 1 (lines unique to FILE1)", "-2             suppress column 2 (lines unique to FILE2)", "-3             suppress column 3 (lines that appear in both files)", "    --help     display this help and exit"] }, u1 = { name: "comm", async execute(e2, t2) {
    if (_(e2)) return F$3(c1);
    let n2 = false, r2 = false, s2 = false, i2 = [];
    for (let g of e2) if (g === "-1") n2 = true;
    else if (g === "-2") r2 = true;
    else if (g === "-3") s2 = true;
    else if (g === "-12" || g === "-21") n2 = true, r2 = true;
    else if (g === "-13" || g === "-31") n2 = true, s2 = true;
    else if (g === "-23" || g === "-32") r2 = true, s2 = true;
    else if (g === "-123" || g === "-132" || g === "-213" || g === "-231" || g === "-312" || g === "-321") n2 = true, r2 = true, s2 = true;
    else {
      if (g.startsWith("-") && g !== "-") return G("comm", g);
      i2.push(g);
    }
    if (i2.length !== 2) return { stdout: "", stderr: `comm: missing operand
Try 'comm --help' for more information.
`, exitCode: 1 };
    let o2 = async (g) => {
      if (g === "-") return t2.stdin;
      try {
        let b = t2.fs.resolvePath(t2.cwd, g);
        return await t2.fs.readFile(b);
      } catch {
        return null;
      }
    }, a = await o2(i2[0]);
    if (a === null) return { stdout: "", stderr: `comm: ${i2[0]}: No such file or directory
`, exitCode: 1 };
    let l = await o2(i2[1]);
    if (l === null) return { stdout: "", stderr: `comm: ${i2[1]}: No such file or directory
`, exitCode: 1 };
    let c = a.split(`
`), u = l.split(`
`);
    c.length > 0 && c[c.length - 1] === "" && c.pop(), u.length > 0 && u[u.length - 1] === "" && u.pop();
    let f2 = 0, p = 0, d = "", m = n2 ? "" : "	", h = (n2 ? "" : "	") + (r2 ? "" : "	");
    for (; f2 < c.length || p < u.length; ) f2 >= c.length ? (r2 || (d += `${m}${u[p]}
`), p++) : p >= u.length ? (n2 || (d += `${c[f2]}
`), f2++) : c[f2] < u[p] ? (n2 || (d += `${c[f2]}
`), f2++) : c[f2] > u[p] ? (r2 || (d += `${m}${u[p]}
`), p++) : (s2 || (d += `${h}${c[f2]}
`), f2++, p++);
    return { stdout: d, stderr: "", exitCode: 0 };
  } };
});
var Ef = {};
V(Ef, { cutCommand: () => h1 });
function p1(e2) {
  let t2 = [], n2 = e2.split(",");
  for (let r2 of n2) if (r2.includes("-")) {
    let [s2, i2] = r2.split("-");
    t2.push({ start: s2 ? parseInt(s2, 10) : 1, end: i2 ? parseInt(i2, 10) : null });
  } else {
    let s2 = parseInt(r2, 10);
    t2.push({ start: s2, end: s2 });
  }
  return t2;
}
function d1(e2, t2) {
  let n2 = [];
  for (let r2 of t2) {
    let s2 = r2.start - 1, i2 = r2.end === null ? e2.length : r2.end;
    for (let o2 = s2; o2 < i2 && o2 < e2.length; o2++) o2 >= 0 && !n2.includes(e2[o2]) && n2.push(e2[o2]);
  }
  return n2;
}
var f1, h1, Sf = v(() => {
  pn();
  X();
  f1 = { name: "cut", summary: "remove sections from each line of files", usage: "cut [OPTION]... [FILE]...", options: ["-c LIST              select only these characters", "-d DELIM             use DELIM instead of TAB for field delimiter", "-f LIST              select only these fields", "-s, --only-delimited  do not print lines without delimiters", "    --help           display this help and exit"] };
  h1 = { name: "cut", async execute(e2, t2) {
    if (_(e2)) return F$3(f1);
    let n2 = "	", r2 = null, s2 = null, i2 = false, o2 = [];
    for (let p = 0; p < e2.length; p++) {
      let d = e2[p];
      if (d === "-d") n2 = e2[++p] || "	";
      else if (d.startsWith("-d")) n2 = d.slice(2);
      else if (d === "-f") r2 = e2[++p];
      else if (d.startsWith("-f")) r2 = d.slice(2);
      else if (d === "-c") s2 = e2[++p];
      else if (d.startsWith("-c")) s2 = d.slice(2);
      else if (d === "-s" || d === "--only-delimited") i2 = true;
      else {
        if (d.startsWith("--")) return G("cut", d);
        if (d.startsWith("-")) {
          let m = false;
          for (let h of d.slice(1)) if (h === "s") i2 = true;
          else if (!"dfc".includes(h)) {
            m = true;
            break;
          }
          if (m) return G("cut", d);
        } else o2.push(d);
      }
    }
    if (!r2 && !s2) return { stdout: "", stderr: `cut: you must specify a list of bytes, characters, or fields
`, exitCode: 1 };
    let a = await Tn(t2, o2, { cmdName: "cut" });
    if (!a.ok) return a.error;
    let c = a.content.split(`
`);
    c.length > 0 && c[c.length - 1] === "" && c.pop();
    let u = p1(r2 || s2 || "1"), f2 = "";
    for (let p of c) if (s2) {
      let d = p.split(""), m = [];
      for (let h of u) {
        let g = h.start - 1, b = h.end === null ? d.length : h.end;
        for (let y = g; y < b && y < d.length; y++) y >= 0 && m.push(d[y]);
      }
      f2 += `${m.join("")}
`;
    } else {
      if (i2 && !p.includes(n2)) continue;
      let d = p.split(n2), m = d1(d, u);
      f2 += `${m.join(n2)}
`;
    }
    return { stdout: f2, stderr: "", exitCode: 0 };
  } };
});
var Cf = {};
V(Cf, { pasteCommand: () => y1 });
function Af(e2, t2) {
  if (e2.length === 0) return "";
  if (e2.length === 1) return e2[0];
  let n2 = e2[0];
  for (let r2 = 1; r2 < e2.length; r2++) {
    let s2 = (r2 - 1) % t2.length;
    n2 += t2[s2] + e2[r2];
  }
  return n2;
}
var m1, g1, y1, Nf = v(() => {
  Oe();
  X();
  m1 = { name: "paste", summary: "merge lines of files", usage: "paste [OPTION]... [FILE]...", description: ["Write lines consisting of the sequentially corresponding lines from", "each FILE, separated by TABs, to standard output.", "", "With no FILE, or when FILE is -, read standard input."], options: ["-d, --delimiters=LIST   reuse characters from LIST instead of TABs", "-s, --serial            paste one file at a time instead of in parallel", "    --help              display this help and exit"], examples: ["paste file1 file2       Merge file1 and file2 side by side", "paste -d, file1 file2   Use comma as delimiter", "paste -s file1          Paste all lines of file1 on one line", "paste - - < file        Paste pairs of lines from file"] }, g1 = { delimiter: { short: "d", long: "delimiters", type: "string", default: "	" }, serial: { short: "s", long: "serial", type: "boolean" } }, y1 = { name: "paste", async execute(e2, t2) {
    if (_(e2)) return F$3(m1);
    let n2 = fe("paste", e2, g1);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.delimiter, s2 = n2.result.flags.serial, i2 = n2.result.positional;
    if (i2.length === 0) return { stdout: "", stderr: `usage: paste [-s] [-d delimiters] file ...
`, exitCode: 1 };
    let o2 = t2.stdin ? t2.stdin.split(`
`) : [""];
    o2.length > 0 && o2[o2.length - 1] === "" && o2.pop();
    let a = i2.filter((f2) => f2 === "-").length, l = [], c = 0;
    for (let f2 of i2) if (f2 === "-") {
      let p = [];
      for (let d = c; d < o2.length; d += a) p.push(o2[d]);
      l.push(p), c++;
    } else {
      let p = t2.fs.resolvePath(t2.cwd, f2);
      try {
        let m = (await t2.fs.readFile(p)).split(`
`);
        m.length > 0 && m[m.length - 1] === "" && m.pop(), l.push(m);
      } catch {
        return { stdout: "", stderr: `paste: ${f2}: No such file or directory
`, exitCode: 1 };
      }
    }
    let u = "";
    if (s2) for (let f2 of l) f2 && (u += `${Af(f2, r2)}
`);
    else {
      let f2 = Math.max(...l.map((p) => (p == null ? void 0 : p.length) ?? 0));
      for (let p = 0; p < f2; p++) {
        let d = [];
        for (let m of l) d.push((m == null ? void 0 : m[p]) ?? "");
        u += `${Af(d, r2)}
`;
      }
    }
    return { stdout: u, stderr: "", exitCode: 0 };
  } };
});
var vf = {};
V(vf, { trCommand: () => E1 });
function kf(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) {
    if (e2[n2] === "[" && e2[n2 + 1] === ":") {
      let r2 = false;
      for (let [s2, i2] of Object.entries(w1)) if (e2.slice(n2).startsWith(s2)) {
        t2 += i2, n2 += s2.length, r2 = true;
        break;
      }
      if (r2) continue;
    }
    if (e2[n2] === "\\" && n2 + 1 < e2.length) {
      let r2 = e2[n2 + 1];
      r2 === "n" ? t2 += `
` : r2 === "t" ? t2 += "	" : r2 === "r" ? t2 += "\r" : t2 += r2, n2 += 2;
      continue;
    }
    if (n2 + 2 < e2.length && e2[n2 + 1] === "-") {
      let r2 = e2.charCodeAt(n2), s2 = e2.charCodeAt(n2 + 2);
      for (let i2 = r2; i2 <= s2; i2++) t2 += String.fromCharCode(i2);
      n2 += 3;
      continue;
    }
    t2 += e2[n2], n2++;
  }
  return t2;
}
var b1, w1, x1, E1, $f = v(() => {
  Oe();
  X();
  b1 = { name: "tr", summary: "translate or delete characters", usage: "tr [OPTION]... SET1 [SET2]", options: ["-c, -C, --complement   use the complement of SET1", "-d, --delete           delete characters in SET1", "-s, --squeeze-repeats  squeeze repeated characters", "    --help             display this help and exit"], description: `SET syntax:
  a-z         character range
  [:alnum:]   all letters and digits
  [:alpha:]   all letters
  [:digit:]   all digits
  [:lower:]   all lowercase letters
  [:upper:]   all uppercase letters
  [:space:]   all whitespace
  [:blank:]   horizontal whitespace
  [:punct:]   all punctuation
  [:print:]   all printable characters
  [:graph:]   all printable characters except space
  [:cntrl:]   all control characters
  [:xdigit:]  all hexadecimal digits
  \\n, \\t, \\r  escape sequences` }, w1 = { "[:alnum:]": "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "[:alpha:]": "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", "[:blank:]": " 	", "[:cntrl:]": Array.from({ length: 32 }, (e2, t2) => String.fromCharCode(t2)).join("").concat(""), "[:digit:]": "0123456789", "[:graph:]": Array.from({ length: 94 }, (e2, t2) => String.fromCharCode(33 + t2)).join(""), "[:lower:]": "abcdefghijklmnopqrstuvwxyz", "[:print:]": Array.from({ length: 95 }, (e2, t2) => String.fromCharCode(32 + t2)).join(""), "[:punct:]": "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", "[:space:]": ` 	
\r\f\v`, "[:upper:]": "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "[:xdigit:]": "0123456789ABCDEFabcdef" };
  x1 = { complement: { short: "c", long: "complement", type: "boolean" }, complementUpper: { short: "C", type: "boolean" }, delete: { short: "d", long: "delete", type: "boolean" }, squeeze: { short: "s", long: "squeeze-repeats", type: "boolean" } }, E1 = { name: "tr", async execute(e2, t2) {
    if (_(e2)) return F$3(b1);
    let n2 = fe("tr", e2, x1);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.complement || n2.result.flags.complementUpper, s2 = n2.result.flags.delete, i2 = n2.result.flags.squeeze, o2 = n2.result.positional;
    if (o2.length < 1) return { stdout: "", stderr: `tr: missing operand
`, exitCode: 1 };
    if (!s2 && !i2 && o2.length < 2) return { stdout: "", stderr: `tr: missing operand after SET1
`, exitCode: 1 };
    let a = kf(o2[0]), l = o2.length > 1 ? kf(o2[1]) : "", c = t2.stdin, u = (p) => {
      let d = a.includes(p);
      return r2 ? !d : d;
    }, f2 = "";
    if (s2) for (let p of c) u(p) || (f2 += p);
    else if (i2 && o2.length === 1) {
      let p = "";
      for (let d of c) u(d) && d === p || (f2 += d, p = d);
    } else {
      if (r2) {
        let p = l.length > 0 ? l[l.length - 1] : "";
        for (let d of c) a.includes(d) ? f2 += d : f2 += p;
      } else {
        let p = /* @__PURE__ */ new Map();
        for (let d = 0; d < a.length; d++) {
          let m = d < l.length ? l[d] : l[l.length - 1];
          p.set(a[d], m);
        }
        for (let d of c) f2 += p.get(d) ?? d;
      }
      if (i2) {
        let p = "", d = "";
        for (let m of f2) l.includes(m) && m === d || (p += m, d = m);
        f2 = p;
      }
    }
    return { stdout: f2, stderr: "", exitCode: 0 };
  } };
});
var If = {};
V(If, { rev: () => C1 });
function A1(e2) {
  return Array.from(e2).reverse().join("");
}
var S1, C1, Rf = v(() => {
  X();
  S1 = { name: "rev", summary: "reverse lines characterwise", usage: "rev [file ...]", description: "Copies the specified files to standard output, reversing the order of characters in every line. If no files are specified, standard input is read.", examples: ["echo 'hello' | rev     # Output: olleh", "rev file.txt           # Reverse each line in file"] };
  C1 = { name: "rev", execute: async (e2, t2) => {
    if (_(e2)) return F$3(S1);
    let n2 = [];
    for (let i2 of e2) if (i2 === "--") {
      let o2 = e2.indexOf(i2);
      n2.push(...e2.slice(o2 + 1));
      break;
    } else {
      if (i2.startsWith("-") && i2 !== "-") return G("rev", i2);
      n2.push(i2);
    }
    let r2 = "", s2 = (i2) => {
      let o2 = i2.split(`
`), a = i2.endsWith(`
`) && o2[o2.length - 1] === "";
      return a && o2.pop(), o2.map(A1).join(`
`) + (a ? `
` : "");
    };
    if (n2.length === 0) {
      let i2 = t2.stdin ?? "";
      r2 = s2(i2);
    } else for (let i2 of n2) if (i2 === "-") {
      let o2 = t2.stdin ?? "";
      r2 += s2(o2);
    } else {
      let o2 = t2.fs.resolvePath(t2.cwd, i2), a = await t2.fs.readFile(o2);
      if (a === null) return { exitCode: 1, stdout: r2, stderr: `rev: ${i2}: No such file or directory
` };
      r2 += s2(a);
    }
    return { exitCode: 0, stdout: r2, stderr: "" };
  } };
});
var Tf = {};
V(Tf, { nl: () => $1 });
function k1(e2, t2, n2) {
  let r2 = String(e2);
  switch (t2) {
    case "ln":
      return r2.padEnd(n2);
    case "rn":
      return r2.padStart(n2);
    case "rz":
      return r2.padStart(n2, "0");
    default:
      return t2;
  }
}
function v1(e2, t2) {
  switch (t2) {
    case "a":
      return true;
    case "t":
      return e2.trim().length > 0;
    case "n":
      return false;
    default:
      return t2;
  }
}
function Pf(e2, t2, n2) {
  if (e2 === "") return { output: "", nextNumber: n2 };
  let r2 = e2.split(`
`), s2 = [], i2 = n2, o2 = e2.endsWith(`
`) && r2[r2.length - 1] === "";
  o2 && r2.pop();
  for (let a of r2) if (v1(a, t2.bodyStyle)) {
    let l = k1(i2, t2.numberFormat, t2.width);
    s2.push(`${l}${t2.separator}${a}`), i2 += t2.increment;
  } else {
    let l = " ".repeat(t2.width);
    s2.push(`${l}${t2.separator}${a}`);
  }
  return { output: s2.join(`
`) + (o2 ? `
` : ""), nextNumber: i2 };
}
var N1, $1, Of = v(() => {
  X();
  N1 = { name: "nl", summary: "number lines of files", usage: "nl [OPTION]... [FILE]...", description: "Write each FILE to standard output, with line numbers added. If no FILE is specified, standard input is read.", options: ["-b STYLE     Body numbering style: a (all), t (non-empty), n (none)", "-n FORMAT    Number format: ln (left), rn (right), rz (right zeros)", "-w WIDTH     Number width (default: 6)", "-s SEP       Separator after number (default: TAB)", "-v START     Starting line number (default: 1)", "-i INCR      Line number increment (default: 1)"], examples: ["nl file.txt              # Number non-empty lines", "nl -ba file.txt          # Number all lines", "nl -n rz -w 3 file.txt   # Right-justified with zeros", "nl -s ': ' file.txt      # Use ': ' as separator"] };
  $1 = { name: "nl", execute: async (e2, t2) => {
    if (_(e2)) return F$3(N1);
    let n2 = { bodyStyle: "t", numberFormat: "rn", width: 6, separator: "	", startNumber: 1, increment: 1 }, r2 = [], s2 = 0;
    for (; s2 < e2.length; ) {
      let a = e2[s2];
      if (a === "-b" && s2 + 1 < e2.length) {
        let l = e2[s2 + 1];
        if (l !== "a" && l !== "t" && l !== "n") return { exitCode: 1, stdout: "", stderr: `nl: invalid body numbering style: '${l}'
` };
        n2.bodyStyle = l, s2 += 2;
      } else if (a.startsWith("-b")) {
        let l = a.slice(2);
        if (l !== "a" && l !== "t" && l !== "n") return { exitCode: 1, stdout: "", stderr: `nl: invalid body numbering style: '${l}'
` };
        n2.bodyStyle = l, s2++;
      } else if (a === "-n" && s2 + 1 < e2.length) {
        let l = e2[s2 + 1];
        if (l !== "ln" && l !== "rn" && l !== "rz") return { exitCode: 1, stdout: "", stderr: `nl: invalid line numbering format: '${l}'
` };
        n2.numberFormat = l, s2 += 2;
      } else if (a.startsWith("-n")) {
        let l = a.slice(2);
        if (l !== "ln" && l !== "rn" && l !== "rz") return { exitCode: 1, stdout: "", stderr: `nl: invalid line numbering format: '${l}'
` };
        n2.numberFormat = l, s2++;
      } else if (a === "-w" && s2 + 1 < e2.length) {
        let l = parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(l) || l < 1) return { exitCode: 1, stdout: "", stderr: `nl: invalid line number field width: '${e2[s2 + 1]}'
` };
        n2.width = l, s2 += 2;
      } else if (a.startsWith("-w")) {
        let l = parseInt(a.slice(2), 10);
        if (Number.isNaN(l) || l < 1) return { exitCode: 1, stdout: "", stderr: `nl: invalid line number field width: '${a.slice(2)}'
` };
        n2.width = l, s2++;
      } else if (a === "-s" && s2 + 1 < e2.length) n2.separator = e2[s2 + 1], s2 += 2;
      else if (a.startsWith("-s")) n2.separator = a.slice(2), s2++;
      else if (a === "-v" && s2 + 1 < e2.length) {
        let l = parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(l)) return { exitCode: 1, stdout: "", stderr: `nl: invalid starting line number: '${e2[s2 + 1]}'
` };
        n2.startNumber = l, s2 += 2;
      } else if (a.startsWith("-v")) {
        let l = parseInt(a.slice(2), 10);
        if (Number.isNaN(l)) return { exitCode: 1, stdout: "", stderr: `nl: invalid starting line number: '${a.slice(2)}'
` };
        n2.startNumber = l, s2++;
      } else if (a === "-i" && s2 + 1 < e2.length) {
        let l = parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(l)) return { exitCode: 1, stdout: "", stderr: `nl: invalid line number increment: '${e2[s2 + 1]}'
` };
        n2.increment = l, s2 += 2;
      } else if (a.startsWith("-i")) {
        let l = parseInt(a.slice(2), 10);
        if (Number.isNaN(l)) return { exitCode: 1, stdout: "", stderr: `nl: invalid line number increment: '${a.slice(2)}'
` };
        n2.increment = l, s2++;
      } else if (a === "--") {
        r2.push(...e2.slice(s2 + 1));
        break;
      } else {
        if (a.startsWith("-") && a !== "-") return G("nl", a);
        r2.push(a), s2++;
      }
    }
    let i2 = "", o2 = n2.startNumber;
    if (r2.length === 0) {
      let a = t2.stdin ?? "";
      i2 = Pf(a, n2, o2).output;
    } else for (let a of r2) {
      let l = t2.fs.resolvePath(t2.cwd, a), c = await t2.fs.readFile(l);
      if (c === null) return { exitCode: 1, stdout: i2, stderr: `nl: ${a}: No such file or directory
` };
      let u = Pf(c, n2, o2);
      i2 += u.output, o2 = u.nextNumber;
    }
    return { exitCode: 0, stdout: i2, stderr: "" };
  } };
});
var Ff = {};
V(Ff, { fold: () => T1 });
function R1(e2, t2, n2) {
  return n2 ? new TextEncoder().encode(e2).length : e2 === "	" ? 8 - t2 % 8 : e2 === "\b" ? -1 : 1;
}
function P1(e2, t2) {
  if (e2.length === 0) return e2;
  let { width: n2, breakAtSpaces: r2, countBytes: s2 } = t2, i2 = [], o2 = "", a = 0, l = -1, c = 0;
  for (let u = 0; u < e2.length; u++) {
    let f2 = e2[u], p = R1(f2, a, s2);
    a + p > n2 && o2.length > 0 ? r2 && l >= 0 ? (i2.push(o2.slice(0, l + 1)), o2 = o2.slice(l + 1) + f2, a = a - c - 1 + p, l = -1, c = 0) : (i2.push(o2), o2 = f2, a = p, l = -1, c = 0) : (o2 += f2, a += p, (f2 === " " || f2 === "	") && (l = o2.length - 1, c = a - p));
  }
  return o2.length > 0 && i2.push(o2), i2.join(`
`);
}
function Df(e2, t2) {
  if (e2 === "") return "";
  let n2 = e2.split(`
`), r2 = e2.endsWith(`
`) && n2[n2.length - 1] === "";
  return r2 && n2.pop(), n2.map((i2) => P1(i2, t2)).join(`
`) + (r2 ? `
` : "");
}
var I1, T1, _f = v(() => {
  X();
  I1 = { name: "fold", summary: "wrap each input line to fit in specified width", usage: "fold [OPTION]... [FILE]...", description: "Wrap input lines in each FILE, writing to standard output. If no FILE is specified, standard input is read.", options: ["-w WIDTH    Use WIDTH columns instead of 80", "-s          Break at spaces", "-b          Count bytes rather than columns"], examples: ["fold -w 40 file.txt           # Wrap at 40 columns", "fold -sw 40 file.txt          # Word wrap at 40 columns", "echo 'long line' | fold -w 5  # Force wrap at 5"] };
  T1 = { name: "fold", execute: async (e2, t2) => {
    if (_(e2)) return F$3(I1);
    let n2 = { width: 80, breakAtSpaces: false, countBytes: false }, r2 = [], s2 = 0;
    for (; s2 < e2.length; ) {
      let o2 = e2[s2];
      if (o2 === "-w" && s2 + 1 < e2.length) {
        let a = parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(a) || a < 1) return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${e2[s2 + 1]}'
` };
        n2.width = a, s2 += 2;
      } else if (o2.startsWith("-w") && o2.length > 2) {
        let a = parseInt(o2.slice(2), 10);
        if (Number.isNaN(a) || a < 1) return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${o2.slice(2)}'
` };
        n2.width = a, s2++;
      } else if (o2 === "-s") n2.breakAtSpaces = true, s2++;
      else if (o2 === "-b") n2.countBytes = true, s2++;
      else if (o2 === "-bs" || o2 === "-sb") n2.breakAtSpaces = true, n2.countBytes = true, s2++;
      else if (o2.match(/^-[sb]+w\d+$/)) {
        o2.includes("s") && (n2.breakAtSpaces = true), o2.includes("b") && (n2.countBytes = true);
        let a = o2.replace(/^-[sb]+w/, ""), l = parseInt(a, 10);
        if (Number.isNaN(l) || l < 1) return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${a}'
` };
        n2.width = l, s2++;
      } else if (o2.match(/^-[sb]+w$/) && s2 + 1 < e2.length) {
        o2.includes("s") && (n2.breakAtSpaces = true), o2.includes("b") && (n2.countBytes = true);
        let a = parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(a) || a < 1) return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${e2[s2 + 1]}'
` };
        n2.width = a, s2 += 2;
      } else if (o2 === "--") {
        r2.push(...e2.slice(s2 + 1));
        break;
      } else if (o2.startsWith("-") && o2 !== "-") {
        let a = o2.slice(1), l = false;
        for (let c of a) if (c === "s") n2.breakAtSpaces = true;
        else if (c === "b") n2.countBytes = true;
        else {
          l = true;
          break;
        }
        if (l) return G("fold", o2);
        s2++;
      } else r2.push(o2), s2++;
    }
    let i2 = "";
    if (r2.length === 0) {
      let o2 = t2.stdin ?? "";
      i2 = Df(o2, n2);
    } else for (let o2 of r2) {
      let a = t2.fs.resolvePath(t2.cwd, o2), l = await t2.fs.readFile(a);
      if (l === null) return { exitCode: 1, stdout: i2, stderr: `fold: ${o2}: No such file or directory
` };
      i2 += Df(l, n2);
    }
    return { exitCode: 0, stdout: i2, stderr: "" };
  } };
});
var Mf = {};
V(Mf, { expand: () => _1 });
function Es(e2) {
  let t2 = e2.split(",").map((r2) => r2.trim()), n2 = [];
  for (let r2 of t2) {
    let s2 = parseInt(r2, 10);
    if (Number.isNaN(s2) || s2 < 1) return null;
    n2.push(s2);
  }
  for (let r2 = 1; r2 < n2.length; r2++) if (n2[r2] <= n2[r2 - 1]) return null;
  return n2;
}
function D1(e2, t2) {
  if (t2.length === 1) {
    let n2 = t2[0];
    return n2 - e2 % n2;
  }
  for (let n2 of t2) if (n2 > e2) return n2 - e2;
  if (t2.length >= 2) {
    let n2 = t2[t2.length - 1] - t2[t2.length - 2], r2 = t2[t2.length - 1], s2 = Math.floor((e2 - r2) / n2) + 1;
    return r2 + s2 * n2 - e2;
  }
  return 1;
}
function F1(e2, t2) {
  let { tabStops: n2, leadingOnly: r2 } = t2, s2 = "", i2 = 0, o2 = true;
  for (let a of e2) if (a === "	") if (r2 && !o2) s2 += a, i2++;
  else {
    let l = D1(i2, n2);
    s2 += " ".repeat(l), i2 += l;
  }
  else a !== " " && a !== "	" && (o2 = false), s2 += a, i2++;
  return s2;
}
function Lf(e2, t2) {
  if (e2 === "") return "";
  let n2 = e2.split(`
`), r2 = e2.endsWith(`
`) && n2[n2.length - 1] === "";
  return r2 && n2.pop(), n2.map((i2) => F1(i2, t2)).join(`
`) + (r2 ? `
` : "");
}
var O1, _1, Wf = v(() => {
  X();
  O1 = { name: "expand", summary: "convert tabs to spaces", usage: "expand [OPTION]... [FILE]...", description: "Convert TABs in each FILE to spaces, writing to standard output. If no FILE is specified, standard input is read.", options: ["-t N        Use N spaces per tab (default: 8)", "-t LIST     Use comma-separated list of tab stops", "-i          Only convert leading tabs on each line"], examples: ["expand file.txt             # Convert all tabs to 8 spaces", "expand -t 4 file.txt        # Use 4-space tabs", "expand -t 4,8,12 file.txt   # Custom tab stops"] };
  _1 = { name: "expand", execute: async (e2, t2) => {
    if (_(e2)) return F$3(O1);
    let n2 = { tabStops: [8], leadingOnly: false }, r2 = [], s2 = 0;
    for (; s2 < e2.length; ) {
      let o2 = e2[s2];
      if (o2 === "-t" && s2 + 1 < e2.length) {
        let a = Es(e2[s2 + 1]);
        if (!a) return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${e2[s2 + 1]}'
` };
        n2.tabStops = a, s2 += 2;
      } else if (o2.startsWith("-t") && o2.length > 2) {
        let a = Es(o2.slice(2));
        if (!a) return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${o2.slice(2)}'
` };
        n2.tabStops = a, s2++;
      } else if (o2 === "--tabs" && s2 + 1 < e2.length) {
        let a = Es(e2[s2 + 1]);
        if (!a) return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${e2[s2 + 1]}'
` };
        n2.tabStops = a, s2 += 2;
      } else if (o2.startsWith("--tabs=")) {
        let a = Es(o2.slice(7));
        if (!a) return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${o2.slice(7)}'
` };
        n2.tabStops = a, s2++;
      } else if (o2 === "-i" || o2 === "--initial") n2.leadingOnly = true, s2++;
      else if (o2 === "--") {
        r2.push(...e2.slice(s2 + 1));
        break;
      } else {
        if (o2.startsWith("-") && o2 !== "-") return G("expand", o2);
        r2.push(o2), s2++;
      }
    }
    let i2 = "";
    if (r2.length === 0) {
      let o2 = t2.stdin ?? "";
      i2 = Lf(o2, n2);
    } else for (let o2 of r2) {
      let a = t2.fs.resolvePath(t2.cwd, o2), l = await t2.fs.readFile(a);
      if (l === null) return { exitCode: 1, stdout: i2, stderr: `expand: ${o2}: No such file or directory
` };
      i2 += Lf(l, n2);
    }
    return { exitCode: 0, stdout: i2, stderr: "" };
  } };
});
var zf = {};
V(zf, { unexpand: () => W1 });
function Ss(e2) {
  let t2 = e2.split(",").map((r2) => r2.trim()), n2 = [];
  for (let r2 of t2) {
    let s2 = parseInt(r2, 10);
    if (Number.isNaN(s2) || s2 < 1) return null;
    n2.push(s2);
  }
  for (let r2 = 1; r2 < n2.length; r2++) if (n2[r2] <= n2[r2 - 1]) return null;
  return n2;
}
function Bf(e2, t2) {
  if (t2.length === 1) {
    let n2 = t2[0];
    return e2 + (n2 - e2 % n2);
  }
  for (let n2 of t2) if (n2 > e2) return n2;
  if (t2.length >= 2) {
    let n2 = t2[t2.length - 1] - t2[t2.length - 2], r2 = t2[t2.length - 1], s2 = Math.floor((e2 - r2) / n2) + 1;
    return r2 + s2 * n2;
  }
  return -1;
}
function M1(e2, t2) {
  let { tabStops: n2, allBlanks: r2 } = t2, s2 = "", i2 = 0, o2 = "", a = 0, l = true, c = () => {
    if (o2.length === 0) return;
    let u = a + o2.length;
    if (!r2 && !l) {
      s2 += o2, o2 = "";
      return;
    }
    let f2 = a, p = "";
    for (; f2 < u; ) {
      let m = Bf(f2, n2);
      if (m <= u && m > f2) p += "	", f2 = m;
      else break;
    }
    let d = u - f2;
    d > 0 && (p += " ".repeat(d)), s2 += p, o2 = "";
  };
  for (let u of e2) u === " " ? (o2.length === 0 && (a = i2), o2 += u, i2++) : u === "	" ? (c(), s2 += u, i2 = Bf(i2, n2)) : (c(), s2 += u, i2++, l = false);
  return c(), s2;
}
function Uf(e2, t2) {
  if (e2 === "") return "";
  let n2 = e2.split(`
`), r2 = e2.endsWith(`
`) && n2[n2.length - 1] === "";
  return r2 && n2.pop(), n2.map((i2) => M1(i2, t2)).join(`
`) + (r2 ? `
` : "");
}
var L1, W1, jf = v(() => {
  X();
  L1 = { name: "unexpand", summary: "convert spaces to tabs", usage: "unexpand [OPTION]... [FILE]...", description: "Convert blanks in each FILE to TABs, writing to standard output. If no FILE is specified, standard input is read.", options: ["-t N        Use N spaces per tab (default: 8)", "-t LIST     Use comma-separated list of tab stops", "-a          Convert all sequences of blanks (not just leading)"], examples: ["unexpand file.txt           # Convert leading spaces to tabs", "unexpand -a file.txt        # Convert all space sequences", "unexpand -t 4 file.txt      # Use 4-space tabs"] };
  W1 = { name: "unexpand", execute: async (e2, t2) => {
    if (_(e2)) return F$3(L1);
    let n2 = { tabStops: [8], allBlanks: false }, r2 = [], s2 = 0;
    for (; s2 < e2.length; ) {
      let o2 = e2[s2];
      if (o2 === "-t" && s2 + 1 < e2.length) {
        let a = Ss(e2[s2 + 1]);
        if (!a) return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${e2[s2 + 1]}'
` };
        n2.tabStops = a, s2 += 2;
      } else if (o2.startsWith("-t") && o2.length > 2) {
        let a = Ss(o2.slice(2));
        if (!a) return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${o2.slice(2)}'
` };
        n2.tabStops = a, s2++;
      } else if (o2 === "--tabs" && s2 + 1 < e2.length) {
        let a = Ss(e2[s2 + 1]);
        if (!a) return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${e2[s2 + 1]}'
` };
        n2.tabStops = a, s2 += 2;
      } else if (o2.startsWith("--tabs=")) {
        let a = Ss(o2.slice(7));
        if (!a) return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${o2.slice(7)}'
` };
        n2.tabStops = a, s2++;
      } else if (o2 === "-a" || o2 === "--all") n2.allBlanks = true, s2++;
      else if (o2 === "--") {
        r2.push(...e2.slice(s2 + 1));
        break;
      } else {
        if (o2.startsWith("-") && o2 !== "-") return G("unexpand", o2);
        r2.push(o2), s2++;
      }
    }
    let i2 = "";
    if (r2.length === 0) {
      let o2 = t2.stdin ?? "";
      i2 = Uf(o2, n2);
    } else for (let o2 of r2) {
      let a = t2.fs.resolvePath(t2.cwd, o2), l = await t2.fs.readFile(a);
      if (l === null) return { exitCode: 1, stdout: i2, stderr: `unexpand: ${o2}: No such file or directory
` };
      i2 += Uf(l, n2);
    }
    return { exitCode: 0, stdout: i2, stderr: "" };
  } };
});
var qf = {};
V(qf, { strings: () => z1 });
function U1(e2) {
  return e2 >= 32 && e2 <= 126 || e2 === 9;
}
function Hf(e2, t2) {
  if (t2 === null) return "";
  switch (t2) {
    case "o":
      return `${e2.toString(8).padStart(7, " ")} `;
    case "x":
      return `${e2.toString(16).padStart(7, " ")} `;
    case "d":
      return `${e2.toString(10).padStart(7, " ")} `;
    default:
      return t2;
  }
}
function Vf(e2, t2) {
  let n2 = [], r2 = "", s2 = 0, i2 = typeof e2 == "string" ? new TextEncoder().encode(e2) : e2;
  for (let o2 = 0; o2 < i2.length; o2++) {
    let a = i2[o2];
    if (U1(a)) r2.length === 0 && (s2 = o2), r2 += String.fromCharCode(a);
    else {
      if (r2.length >= t2.minLength) {
        let l = Hf(s2, t2.offsetFormat);
        n2.push(`${l}${r2}`);
      }
      r2 = "";
    }
  }
  if (r2.length >= t2.minLength) {
    let o2 = Hf(s2, t2.offsetFormat);
    n2.push(`${o2}${r2}`);
  }
  return n2;
}
var B1, z1, Gf = v(() => {
  X();
  B1 = { name: "strings", summary: "print the sequences of printable characters in files", usage: "strings [OPTION]... [FILE]...", description: "For each FILE, print the printable character sequences that are at least MIN characters long. If no FILE is specified, standard input is read.", options: ["-n MIN       Print sequences of at least MIN characters (default: 4)", "-t FORMAT    Print offset before each string (o=octal, x=hex, d=decimal)", "-a           Scan the entire file (default behavior)", "-e ENCODING  Select character encoding (s=7-bit, S=8-bit)"], examples: ["strings file.bin          # Extract strings (min 4 chars)", "strings -n 8 file.bin     # Extract strings (min 8 chars)", "strings -t x file.bin     # Show hex offset", "echo 'hello' | strings    # Read from stdin"] };
  z1 = { name: "strings", execute: async (e2, t2) => {
    if (_(e2)) return F$3(B1);
    let n2 = { minLength: 4, offsetFormat: null }, r2 = [], s2 = 0;
    for (; s2 < e2.length; ) {
      let o2 = e2[s2];
      if (o2 === "-n" && s2 + 1 < e2.length) {
        let a = Number.parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(a) || a < 1) return { exitCode: 1, stdout: "", stderr: `strings: invalid minimum string length: '${e2[s2 + 1]}'
` };
        n2.minLength = a, s2 += 2;
      } else if (o2.match(/^-n\d+$/)) {
        let a = Number.parseInt(o2.slice(2), 10);
        if (Number.isNaN(a) || a < 1) return { exitCode: 1, stdout: "", stderr: `strings: invalid minimum string length: '${o2.slice(2)}'
` };
        n2.minLength = a, s2++;
      } else if (o2.match(/^-\d+$/)) {
        let a = Number.parseInt(o2.slice(1), 10);
        if (Number.isNaN(a) || a < 1) return { exitCode: 1, stdout: "", stderr: `strings: invalid minimum string length: '${o2.slice(1)}'
` };
        n2.minLength = a, s2++;
      } else if (o2 === "-t" && s2 + 1 < e2.length) {
        let a = e2[s2 + 1];
        if (a !== "o" && a !== "x" && a !== "d") return { exitCode: 1, stdout: "", stderr: `strings: invalid radix: '${a}'
` };
        n2.offsetFormat = a, s2 += 2;
      } else if (o2.startsWith("-t") && o2.length === 3) {
        let a = o2[2];
        if (a !== "o" && a !== "x" && a !== "d") return { exitCode: 1, stdout: "", stderr: `strings: invalid radix: '${a}'
` };
        n2.offsetFormat = a, s2++;
      } else if (o2 === "-a" || o2 === "--all" || o2 === "-") o2 === "-" && r2.push(o2), s2++;
      else if (o2 === "-e" && s2 + 1 < e2.length) {
        let a = e2[s2 + 1];
        if (a !== "s" && a !== "S") return { exitCode: 1, stdout: "", stderr: `strings: invalid encoding: '${a}'
` };
        s2 += 2;
      } else if (o2.startsWith("-e") && o2.length === 3) {
        let a = o2[2];
        if (a !== "s" && a !== "S") return { exitCode: 1, stdout: "", stderr: `strings: invalid encoding: '${a}'
` };
        s2++;
      } else if (o2 === "--") {
        r2.push(...e2.slice(s2 + 1));
        break;
      } else {
        if (o2.startsWith("-") && o2 !== "-") return G("strings", o2);
        r2.push(o2), s2++;
      }
    }
    let i2 = "";
    if (r2.length === 0) {
      let o2 = t2.stdin ?? "", a = Vf(o2, n2);
      i2 = a.length > 0 ? `${a.join(`
`)}
` : "";
    } else for (let o2 of r2) {
      let a;
      if (o2 === "-") a = t2.stdin ?? "";
      else {
        let c = t2.fs.resolvePath(t2.cwd, o2);
        if (a = await t2.fs.readFile(c), a === null) return { exitCode: 1, stdout: i2, stderr: `strings: ${o2}: No such file or directory
` };
      }
      let l = Vf(a, n2);
      l.length > 0 && (i2 += `${l.join(`
`)}
`);
    }
    return { exitCode: 0, stdout: i2, stderr: "" };
  } };
});
var Qf = {};
V(Qf, { split: () => Z1 });
function Zf(e2) {
  let t2 = e2.match(/^(\d+)([KMGTPEZY]?)([B]?)$/i);
  if (!t2) return null;
  let n2 = Number.parseInt(t2[1], 10);
  if (Number.isNaN(n2) || n2 < 1) return null;
  let r2 = (t2[2] || "").toUpperCase(), i2 = { "": 1, K: 1024, M: 1024 * 1024, G: 1024 * 1024 * 1024, T: 1024 * 1024 * 1024 * 1024, P: 1024 * 1024 * 1024 * 1024 * 1024 }[r2];
  return i2 === void 0 ? null : n2 * i2;
}
function H1(e2, t2, n2) {
  if (t2) return e2.toString().padStart(n2, "0");
  let r2 = "abcdefghijklmnopqrstuvwxyz", s2 = "", i2 = e2;
  for (let o2 = 0; o2 < n2; o2++) s2 = r2[i2 % 26] + s2, i2 = Math.floor(i2 / 26);
  return s2;
}
function V1(e2, t2) {
  let n2 = e2.split(`
`), r2 = e2.endsWith(`
`) && n2[n2.length - 1] === "";
  r2 && n2.pop();
  let s2 = [];
  for (let i2 = 0; i2 < n2.length; i2 += t2) {
    let o2 = n2.slice(i2, i2 + t2), l = i2 + t2 >= n2.length && !r2 ? o2.join(`
`) : `${o2.join(`
`)}
`;
    s2.push({ content: l, hasContent: true });
  }
  return s2;
}
function q1(e2, t2) {
  let r2 = new TextEncoder().encode(e2), s2 = new TextDecoder(), i2 = [];
  for (let o2 = 0; o2 < r2.length; o2 += t2) {
    let a = r2.slice(o2, o2 + t2);
    i2.push({ content: s2.decode(a), hasContent: a.length > 0 });
  }
  return i2;
}
function G1(e2, t2) {
  let r2 = new TextEncoder().encode(e2), s2 = new TextDecoder(), i2 = [], o2 = Math.ceil(r2.length / t2);
  for (let a = 0; a < t2; a++) {
    let l = a * o2, c = Math.min(l + o2, r2.length), u = r2.slice(l, c);
    i2.push({ content: s2.decode(u), hasContent: u.length > 0 });
  }
  return i2;
}
var j1, Z1, Kf = v(() => {
  X();
  j1 = { name: "split", summary: "split a file into pieces", usage: "split [OPTION]... [FILE [PREFIX]]", description: "Output pieces of FILE to PREFIXaa, PREFIXab, ...; default size is 1000 lines, and default PREFIX is 'x'.", options: ["-l N         Put N lines per output file", "-b SIZE      Put SIZE bytes per output file (K, M, G suffixes)", "-n CHUNKS    Split into CHUNKS equal-sized files", "-d           Use numeric suffixes (00, 01, ...) instead of alphabetic", "-a LENGTH    Use suffixes of length LENGTH (default: 2)", "--additional-suffix=SUFFIX  Append SUFFIX to file names"], examples: ["split -l 100 file.txt        # Split into 100-line chunks", "split -b 1M file.bin         # Split into 1MB chunks", "split -n 5 file.txt          # Split into 5 equal parts", "split -d file.txt part_      # part_00, part_01, ...", "split -a 3 -d file.txt x     # x000, x001, ..."] };
  Z1 = { name: "split", execute: async (e2, t2) => {
    if (_(e2)) return F$3(j1);
    let n2 = { mode: "lines", lines: 1e3, bytes: 0, chunks: 0, useNumericSuffix: false, suffixLength: 2, additionalSuffix: "" }, r2 = [], s2 = 0;
    for (; s2 < e2.length; ) {
      let c = e2[s2];
      if (c === "-l" && s2 + 1 < e2.length) {
        let u = Number.parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(u) || u < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid number of lines: '${e2[s2 + 1]}'
` };
        n2.mode = "lines", n2.lines = u, s2 += 2;
      } else if (c.match(/^-l\d+$/)) {
        let u = Number.parseInt(c.slice(2), 10);
        if (Number.isNaN(u) || u < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid number of lines: '${c.slice(2)}'
` };
        n2.mode = "lines", n2.lines = u, s2++;
      } else if (c === "-b" && s2 + 1 < e2.length) {
        let u = Zf(e2[s2 + 1]);
        if (u === null) return { exitCode: 1, stdout: "", stderr: `split: invalid number of bytes: '${e2[s2 + 1]}'
` };
        n2.mode = "bytes", n2.bytes = u, s2 += 2;
      } else if (c.match(/^-b.+$/)) {
        let u = Zf(c.slice(2));
        if (u === null) return { exitCode: 1, stdout: "", stderr: `split: invalid number of bytes: '${c.slice(2)}'
` };
        n2.mode = "bytes", n2.bytes = u, s2++;
      } else if (c === "-n" && s2 + 1 < e2.length) {
        let u = Number.parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(u) || u < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid number of chunks: '${e2[s2 + 1]}'
` };
        n2.mode = "chunks", n2.chunks = u, s2 += 2;
      } else if (c.match(/^-n\d+$/)) {
        let u = Number.parseInt(c.slice(2), 10);
        if (Number.isNaN(u) || u < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid number of chunks: '${c.slice(2)}'
` };
        n2.mode = "chunks", n2.chunks = u, s2++;
      } else if (c === "-a" && s2 + 1 < e2.length) {
        let u = Number.parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(u) || u < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid suffix length: '${e2[s2 + 1]}'
` };
        n2.suffixLength = u, s2 += 2;
      } else if (c.match(/^-a\d+$/)) {
        let u = Number.parseInt(c.slice(2), 10);
        if (Number.isNaN(u) || u < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid suffix length: '${c.slice(2)}'
` };
        n2.suffixLength = u, s2++;
      } else if (c === "-d" || c === "--numeric-suffixes") n2.useNumericSuffix = true, s2++;
      else if (c.startsWith("--additional-suffix=")) n2.additionalSuffix = c.slice(20), s2++;
      else if (c === "--additional-suffix" && s2 + 1 < e2.length) n2.additionalSuffix = e2[s2 + 1], s2 += 2;
      else if (c === "--") {
        r2.push(...e2.slice(s2 + 1));
        break;
      } else {
        if (c.startsWith("-") && c !== "-") return G("split", c);
        r2.push(c), s2++;
      }
    }
    let i2 = "-", o2 = "x";
    r2.length >= 1 && (i2 = r2[0]), r2.length >= 2 && (o2 = r2[1]);
    let a;
    if (i2 === "-") a = t2.stdin ?? "";
    else {
      let c = t2.fs.resolvePath(t2.cwd, i2), u = await t2.fs.readFile(c);
      if (u === null) return { exitCode: 1, stdout: "", stderr: `split: ${i2}: No such file or directory
` };
      a = u;
    }
    if (a === "") return { exitCode: 0, stdout: "", stderr: "" };
    let l;
    switch (n2.mode) {
      case "lines":
        l = V1(a, n2.lines);
        break;
      case "bytes":
        l = q1(a, n2.bytes);
        break;
      case "chunks":
        l = G1(a, n2.chunks);
        break;
      default:
        return n2.mode;
    }
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (!u.hasContent) continue;
      let f2 = H1(c, n2.useNumericSuffix, n2.suffixLength), p = `${o2}${f2}${n2.additionalSuffix}`, d = t2.fs.resolvePath(t2.cwd, p);
      await t2.fs.writeFile(d, u.content);
    }
    return { exitCode: 0, stdout: "", stderr: "" };
  } };
});
var Jf = {};
V(Jf, { column: () => eE });
function Xf(e2, t2, n2) {
  return t2 ? n2 ? e2.split(t2) : e2.split(t2).filter((r2) => r2.length > 0) : n2 ? e2.split(/[ \t]/) : e2.split(/[ \t]+/).filter((r2) => r2.length > 0);
}
function X1(e2) {
  let t2 = [];
  for (let n2 of e2) for (let r2 = 0; r2 < n2.length; r2++) {
    let s2 = n2[r2].length;
    (t2[r2] === void 0 || s2 > t2[r2]) && (t2[r2] = s2);
  }
  return t2;
}
function J1(e2, t2) {
  if (e2.length === 0) return "";
  let n2 = X1(e2), r2 = [];
  for (let s2 of e2) {
    let i2 = [];
    for (let o2 = 0; o2 < s2.length; o2++) o2 === s2.length - 1 ? i2.push(s2[o2]) : i2.push(s2[o2].padEnd(n2[o2]));
    r2.push(i2.join(t2));
  }
  return r2.join(`
`);
}
function Y1(e2, t2, n2) {
  if (e2.length === 0) return "";
  let r2 = Math.max(...e2.map((c) => c.length)), s2 = n2.length, i2 = r2 + s2, o2 = Math.max(1, Math.floor((t2 + s2) / i2)), a = Math.ceil(e2.length / o2), l = [];
  for (let c = 0; c < a; c++) {
    let u = [];
    for (let f2 = 0; f2 < o2; f2++) {
      let p = f2 * a + c;
      p < e2.length && (f2 === o2 - 1 || (f2 + 1) * a + c >= e2.length ? u.push(e2[p]) : u.push(e2[p].padEnd(r2)));
    }
    l.push(u.join(n2));
  }
  return l.join(`
`);
}
var Q1, K1, eE, Yf = v(() => {
  Oe();
  X();
  Q1 = { name: "column", summary: "columnate lists", usage: "column [OPTION]... [FILE]...", description: "Format input into multiple columns. By default, fills rows first. Use -t to create a table based on whitespace-delimited input.", options: ["-t           Create a table (determine columns from input)", "-s SEP       Input field delimiter (default: whitespace)", "-o SEP       Output field delimiter (default: two spaces)", "-c WIDTH     Output width for fill mode (default: 80)", "-n           Don't merge multiple adjacent delimiters"], examples: ["ls | column              # Fill columns with ls output", "cat data | column -t     # Format as table", "column -t -s ',' file    # Format CSV as table", "column -c 40 file        # Fill 40-char wide columns"] }, K1 = { table: { short: "t", long: "table", type: "boolean" }, separator: { short: "s", type: "string" }, outputSep: { short: "o", type: "string" }, width: { short: "c", type: "number", default: 80 }, noMerge: { short: "n", type: "boolean" } };
  eE = { name: "column", execute: async (e2, t2) => {
    if (_(e2)) return F$3(Q1);
    let n2 = fe("column", e2, K1);
    if (!n2.ok) return n2.error;
    let { table: r2, separator: s2, outputSep: i2, width: o2, noMerge: a } = n2.result.flags, l = n2.result.positional, c = i2 ?? "  ", u;
    if (l.length === 0) u = t2.stdin ?? "";
    else {
      let h = [];
      for (let g of l) if (g === "-") h.push(t2.stdin ?? "");
      else {
        let b = t2.fs.resolvePath(t2.cwd, g), y = await t2.fs.readFile(b);
        if (y === null) return { exitCode: 1, stdout: "", stderr: `column: ${g}: No such file or directory
` };
        h.push(y);
      }
      u = h.join("");
    }
    if (u === "" || u.trim() === "") return { exitCode: 0, stdout: "", stderr: "" };
    let f2 = u.split(`
`);
    u.endsWith(`
`) && f2[f2.length - 1] === "" && f2.pop();
    let d = f2.filter((h) => h.trim().length > 0), m;
    if (r2) {
      let h = d.map((g) => Xf(g, s2, a));
      m = J1(h, c);
    } else {
      let h = [];
      for (let g of d) {
        let b = Xf(g, s2, a);
        h.push(...b);
      }
      m = Y1(h, o2, c);
    }
    return m.length > 0 && (m += `
`), { exitCode: 0, stdout: m, stderr: "" };
  } };
});
var ep = {};
V(ep, { join: () => iE });
function nE(e2, t2) {
  return t2 ? e2.split(t2) : e2.split(/[ \t]+/).filter((n2) => n2.length > 0);
}
function rE(e2, t2, n2, r2) {
  let s2 = nE(e2, t2), i2 = s2[n2 - 1] ?? "";
  return r2 && (i2 = i2.toLowerCase()), { fields: s2, joinKey: i2, original: e2 };
}
function yo(e2, t2, n2) {
  let r2 = n2.separator ?? " ";
  if (n2.outputFormat) {
    let o2 = [];
    for (let { file: a, field: l } of n2.outputFormat) {
      let c = a === 1 ? e2 : t2;
      c && l === 0 ? o2.push(c.joinKey) : c && c.fields[l - 1] !== void 0 ? o2.push(c.fields[l - 1]) : o2.push(n2.emptyString);
    }
    return o2.join(r2);
  }
  let s2 = [], i2 = (e2 == null ? void 0 : e2.joinKey) ?? (t2 == null ? void 0 : t2.joinKey) ?? "";
  if (s2.push(i2), e2) for (let o2 = 0; o2 < e2.fields.length; o2++) o2 !== n2.field1 - 1 && s2.push(e2.fields[o2]);
  if (t2) for (let o2 = 0; o2 < t2.fields.length; o2++) o2 !== n2.field2 - 1 && s2.push(t2.fields[o2]);
  return s2.join(r2);
}
function sE(e2) {
  let t2 = e2.split(","), n2 = [];
  for (let r2 of t2) {
    let s2 = r2.trim().match(/^(\d+)\.(\d+)$/);
    if (!s2) return null;
    let i2 = Number.parseInt(s2[1], 10), o2 = Number.parseInt(s2[2], 10);
    if (i2 !== 1 && i2 !== 2) return null;
    n2.push({ file: i2, field: o2 });
  }
  return n2;
}
var tE, iE, tp = v(() => {
  X();
  tE = { name: "join", summary: "join lines of two files on a common field", usage: "join [OPTION]... FILE1 FILE2", description: "For each pair of input lines with identical join fields, write a line to standard output. The default join field is the first, delimited by blanks.", options: ["-1 FIELD     Join on this FIELD of file 1 (default: 1)", "-2 FIELD     Join on this FIELD of file 2 (default: 1)", "-t CHAR      Use CHAR as input and output field separator", "-a FILENUM   Also print unpairable lines from file FILENUM (1 or 2)", "-v FILENUM   Like -a but only output unpairable lines", "-e STRING    Replace missing fields with STRING", "-o FORMAT    Output format (comma-separated list of FILENUM.FIELD)", "-i           Ignore case when comparing fields"], examples: ["join file1 file2               # Join on first field", "join -1 2 -2 1 file1 file2     # Join file1 col 2 with file2 col 1", "join -t ',' file1.csv file2.csv  # Join CSV files", "join -a 1 file1 file2          # Left outer join"] };
  iE = { name: "join", execute: async (e2, t2) => {
    if (_(e2)) return F$3(tE);
    let n2 = { field1: 1, field2: 1, separator: null, printUnpairable: /* @__PURE__ */ new Set(), onlyUnpairable: /* @__PURE__ */ new Set(), emptyString: "", outputFormat: null, ignoreCase: false }, r2 = [], s2 = 0;
    for (; s2 < e2.length; ) {
      let p = e2[s2];
      if (p === "-1" && s2 + 1 < e2.length) {
        let d = Number.parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(d) || d < 1) return { exitCode: 1, stdout: "", stderr: `join: invalid field number: '${e2[s2 + 1]}'
` };
        n2.field1 = d, s2 += 2;
      } else if (p === "-2" && s2 + 1 < e2.length) {
        let d = Number.parseInt(e2[s2 + 1], 10);
        if (Number.isNaN(d) || d < 1) return { exitCode: 1, stdout: "", stderr: `join: invalid field number: '${e2[s2 + 1]}'
` };
        n2.field2 = d, s2 += 2;
      } else if ((p === "-t" || p === "--field-separator") && s2 + 1 < e2.length) n2.separator = e2[s2 + 1], s2 += 2;
      else if (p.startsWith("-t") && p.length > 2) n2.separator = p.slice(2), s2++;
      else if (p === "-a" && s2 + 1 < e2.length) {
        let d = Number.parseInt(e2[s2 + 1], 10);
        if (d !== 1 && d !== 2) return { exitCode: 1, stdout: "", stderr: `join: invalid file number: '${e2[s2 + 1]}'
` };
        n2.printUnpairable.add(d), s2 += 2;
      } else if (p.match(/^-a[12]$/)) n2.printUnpairable.add(Number.parseInt(p[2], 10)), s2++;
      else if (p === "-v" && s2 + 1 < e2.length) {
        let d = Number.parseInt(e2[s2 + 1], 10);
        if (d !== 1 && d !== 2) return { exitCode: 1, stdout: "", stderr: `join: invalid file number: '${e2[s2 + 1]}'
` };
        n2.onlyUnpairable.add(d), s2 += 2;
      } else if (p.match(/^-v[12]$/)) n2.onlyUnpairable.add(Number.parseInt(p[2], 10)), s2++;
      else if (p === "-e" && s2 + 1 < e2.length) n2.emptyString = e2[s2 + 1], s2 += 2;
      else if (p === "-o" && s2 + 1 < e2.length) {
        let d = sE(e2[s2 + 1]);
        if (!d) return { exitCode: 1, stdout: "", stderr: `join: invalid field spec: '${e2[s2 + 1]}'
` };
        n2.outputFormat = d, s2 += 2;
      } else if (p === "-i" || p === "--ignore-case") n2.ignoreCase = true, s2++;
      else if (p === "--") {
        r2.push(...e2.slice(s2 + 1));
        break;
      } else {
        if (p.startsWith("-") && p !== "-") return G("join", p);
        r2.push(p), s2++;
      }
    }
    if (r2.length !== 2) return { exitCode: 1, stdout: "", stderr: r2.length < 2 ? `join: missing file operand
` : `join: extra operand
` };
    let i2 = [];
    for (let p of r2) if (p === "-") i2.push(t2.stdin ?? "");
    else {
      let d = t2.fs.resolvePath(t2.cwd, p), m = await t2.fs.readFile(d);
      if (m === null) return { exitCode: 1, stdout: "", stderr: `join: ${p}: No such file or directory
` };
      i2.push(m);
    }
    let o2 = (p, d) => {
      let m = p.split(`
`);
      return p.endsWith(`
`) && m[m.length - 1] === "" && m.pop(), m.filter((h) => h.length > 0).map((h) => rE(h, n2.separator, d, n2.ignoreCase));
    }, a = o2(i2[0], n2.field1), l = o2(i2[1], n2.field2), c = /* @__PURE__ */ new Map();
    for (let p of l) {
      let d = c.get(p.joinKey);
      d ? d.push(p) : c.set(p.joinKey, [p]);
    }
    let u = [], f2 = /* @__PURE__ */ new Set();
    for (let p of a) {
      let d = c.get(p.joinKey);
      if (d && d.length > 0) {
        if (f2.add(p.joinKey), n2.onlyUnpairable.size === 0) for (let m of d) u.push(yo(p, m, n2));
      } else (n2.printUnpairable.has(1) || n2.onlyUnpairable.has(1)) && u.push(yo(p, null, n2));
    }
    if (n2.printUnpairable.has(2) || n2.onlyUnpairable.has(2)) for (let p of l) f2.has(p.joinKey) || u.push(yo(null, p, n2));
    return { exitCode: 0, stdout: u.length > 0 ? `${u.join(`
`)}
` : "", stderr: "" };
  } };
});
var np = {};
V(np, { teeCommand: () => lE });
var oE, aE, lE, rp = v(() => {
  Oe();
  X();
  oE = { name: "tee", summary: "read from stdin and write to stdout and files", usage: "tee [OPTION]... [FILE]...", options: ["-a, --append     append to the given FILEs, do not overwrite", "    --help       display this help and exit"] }, aE = { append: { short: "a", long: "append", type: "boolean" } }, lE = { name: "tee", async execute(e2, t2) {
    if (_(e2)) return F$3(oE);
    let n2 = fe("tee", e2, aE);
    if (!n2.ok) return n2.error;
    let { append: r2 } = n2.result.flags, s2 = n2.result.positional, i2 = t2.stdin, o2 = "", a = 0;
    for (let l of s2) try {
      let c = t2.fs.resolvePath(t2.cwd, l);
      r2 ? await t2.fs.appendFile(c, i2) : await t2.fs.writeFile(c, i2);
    } catch {
      o2 += `tee: ${l}: No such file or directory
`, a = 1;
    }
    return { stdout: i2, stderr: o2, exitCode: a };
  } };
});
function kt(e2, t2) {
  switch (e2.type) {
    case "name": {
      let n2 = e2.pattern, r2 = n2.match(/^\*(\.[a-zA-Z0-9]+)$/);
      if (r2) {
        let s2 = r2[1], i2 = t2.name;
        if (e2.ignoreCase) {
          if (!i2.toLowerCase().endsWith(s2.toLowerCase())) return { matches: false, pruned: false, printed: false };
        } else if (!i2.endsWith(s2)) return { matches: false, pruned: false, printed: false };
        return { matches: true, pruned: false, printed: false };
      }
      return { matches: Ye(t2.name, n2, e2.ignoreCase), pruned: false, printed: false };
    }
    case "path": {
      let n2 = e2.pattern, r2 = t2.relativePath, s2 = n2.split("/");
      for (let o2 = 0; o2 < s2.length - 1; o2++) {
        let a = s2[o2];
        if (a && a !== "." && a !== ".." && !a.includes("*") && !a.includes("?") && !a.includes("[")) {
          let l = `/${a}/`;
          if (e2.ignoreCase) {
            if (!r2.toLowerCase().includes(l.toLowerCase())) return { matches: false, pruned: false, printed: false };
          } else if (!r2.includes(l)) return { matches: false, pruned: false, printed: false };
        }
      }
      let i2 = n2.match(/\*(\.[a-zA-Z0-9]+)$/);
      if (i2) {
        let o2 = i2[1];
        if (e2.ignoreCase) {
          if (!r2.toLowerCase().endsWith(o2.toLowerCase())) return { matches: false, pruned: false, printed: false };
        } else if (!r2.endsWith(o2)) return { matches: false, pruned: false, printed: false };
      }
      return { matches: Ye(r2, n2, e2.ignoreCase), pruned: false, printed: false };
    }
    case "regex":
      try {
        let n2 = e2.ignoreCase ? "i" : "";
        return { matches: new RegExp(e2.pattern, n2).test(t2.relativePath), pruned: false, printed: false };
      } catch {
        return { matches: false, pruned: false, printed: false };
      }
    case "type":
      return e2.fileType === "f" ? { matches: t2.isFile, pruned: false, printed: false } : e2.fileType === "d" ? { matches: t2.isDirectory, pruned: false, printed: false } : { matches: false, pruned: false, printed: false };
    case "empty":
      return { matches: t2.isEmpty, pruned: false, printed: false };
    case "mtime": {
      let r2 = (Date.now() - t2.mtime) / (1e3 * 60 * 60 * 24), s2;
      return e2.comparison === "more" ? s2 = r2 > e2.days : e2.comparison === "less" ? s2 = r2 < e2.days : s2 = Math.floor(r2) === e2.days, { matches: s2, pruned: false, printed: false };
    }
    case "newer": {
      let n2 = t2.newerRefTimes.get(e2.refPath);
      return n2 === void 0 ? { matches: false, pruned: false, printed: false } : { matches: t2.mtime > n2, pruned: false, printed: false };
    }
    case "size": {
      let n2 = e2.value;
      switch (e2.unit) {
        case "c":
          n2 = e2.value;
          break;
        case "k":
          n2 = e2.value * 1024;
          break;
        case "M":
          n2 = e2.value * 1024 * 1024;
          break;
        case "G":
          n2 = e2.value * 1024 * 1024 * 1024;
          break;
        case "b":
          n2 = e2.value * 512;
          break;
      }
      let r2;
      return e2.comparison === "more" ? r2 = t2.size > n2 : e2.comparison === "less" ? r2 = t2.size < n2 : e2.unit === "b" ? r2 = Math.ceil(t2.size / 512) === e2.value : r2 = t2.size === n2, { matches: r2, pruned: false, printed: false };
    }
    case "perm": {
      let n2 = t2.mode & 511, r2 = e2.mode & 511, s2;
      return e2.matchType === "exact" ? s2 = n2 === r2 : e2.matchType === "all" ? s2 = (n2 & r2) === r2 : s2 = (n2 & r2) !== 0, { matches: s2, pruned: false, printed: false };
    }
    case "prune":
      return { matches: true, pruned: true, printed: false };
    case "print":
      return { matches: true, pruned: false, printed: true };
    case "not": {
      let n2 = kt(e2.expr, t2);
      return { matches: !n2.matches, pruned: n2.pruned, printed: false };
    }
    case "and": {
      let n2 = kt(e2.left, t2);
      if (!n2.matches) return { matches: false, pruned: n2.pruned, printed: false };
      let r2 = kt(e2.right, t2);
      return { matches: r2.matches, pruned: n2.pruned || r2.pruned, printed: n2.printed || r2.printed };
    }
    case "or": {
      let n2 = kt(e2.left, t2);
      if (n2.matches) return n2;
      let r2 = kt(e2.right, t2);
      return { matches: r2.matches, pruned: n2.pruned || r2.pruned, printed: r2.printed };
    }
  }
}
function Er(e2) {
  if (!e2) return false;
  switch (e2.type) {
    case "name":
    case "path":
    case "regex":
    case "type":
    case "prune":
    case "print":
      return false;
    case "empty":
    case "mtime":
    case "newer":
    case "size":
    case "perm":
      return true;
    case "not":
      return Er(e2.expr);
    case "and":
    case "or":
      return Er(e2.left) || Er(e2.right);
  }
}
function Sr(e2) {
  if (!e2) return false;
  switch (e2.type) {
    case "empty":
      return true;
    case "not":
      return Sr(e2.expr);
    case "and":
    case "or":
      return Sr(e2.left) || Sr(e2.right);
    default:
      return false;
  }
}
function sp(e2) {
  let t2 = { terminalDirName: null, requiredExtension: null };
  if (!e2) return t2;
  let n2 = cE(e2);
  if (uE(e2) && n2.length === 1) {
    let i2 = n2[0].split("/").filter((o2) => o2.length > 0);
    if (i2.length >= 2) for (let o2 = i2.length - 2; o2 >= 0; o2--) {
      let a = i2[o2];
      if (!a.includes("*") && !a.includes("?") && !a.includes("[") && a !== "." && a !== "..") {
        let l = i2[o2 + 1];
        if (l && (l.includes("*") || l.includes("?"))) {
          t2.terminalDirName = a;
          let c = l.match(/^\*(\.[a-zA-Z0-9]+)$/);
          c && (t2.requiredExtension = c[1]);
        }
        break;
      }
    }
  }
  return t2;
}
function cE(e2) {
  let t2 = [], n2 = (r2) => {
    r2.type === "path" ? t2.push(r2.pattern) : r2.type === "not" ? n2(r2.expr) : (r2.type === "and" || r2.type === "or") && (n2(r2.left), n2(r2.right));
  };
  return n2(e2), t2;
}
function uE(e2) {
  let t2 = (n2) => n2.type === "type" && n2.fileType === "f" ? true : n2.type === "not" ? t2(n2.expr) : n2.type === "and" || n2.type === "or" ? t2(n2.left) || t2(n2.right) : false;
  return t2(e2);
}
function ip(e2) {
  let t2 = [], n2 = (r2) => {
    r2 && (r2.type === "newer" ? t2.push(r2.refPath) : r2.type === "not" ? n2(r2.expr) : (r2.type === "and" || r2.type === "or") && (n2(r2.left), n2(r2.right)));
  };
  return n2(e2), t2;
}
function Ar(e2) {
  if (!e2) return true;
  switch (e2.type) {
    case "name":
    case "path":
    case "regex":
    case "type":
    case "prune":
    case "print":
      return true;
    case "empty":
    case "mtime":
    case "newer":
    case "size":
    case "perm":
      return false;
    case "not":
      return Ar(e2.expr);
    case "and":
    case "or":
      return Ar(e2.left) && Ar(e2.right);
  }
}
function mn(e2, t2, n2, r2, s2) {
  switch (e2.type) {
    case "name": {
      let i2 = e2.pattern, o2 = i2.match(/^\*(\.[a-zA-Z0-9]+)$/);
      if (o2) {
        let a = o2[1];
        if (e2.ignoreCase) {
          if (!t2.toLowerCase().endsWith(a.toLowerCase())) return { matches: false, pruned: false, printed: false };
        } else if (!t2.endsWith(a)) return { matches: false, pruned: false, printed: false };
        return { matches: true, pruned: false, printed: false };
      }
      return { matches: Ye(t2, i2, e2.ignoreCase), pruned: false, printed: false };
    }
    case "path": {
      let i2 = e2.pattern, o2 = i2.split("/");
      for (let l = 0; l < o2.length - 1; l++) {
        let c = o2[l];
        if (c && c !== "." && c !== ".." && !c.includes("*") && !c.includes("?") && !c.includes("[")) {
          let u = `/${c}/`;
          if (e2.ignoreCase) {
            if (!n2.toLowerCase().includes(u.toLowerCase())) return { matches: false, pruned: false, printed: false };
          } else if (!n2.includes(u)) return { matches: false, pruned: false, printed: false };
        }
      }
      let a = i2.match(/\*(\.[a-zA-Z0-9]+)$/);
      if (a) {
        let l = a[1];
        if (e2.ignoreCase) {
          if (!n2.toLowerCase().endsWith(l.toLowerCase())) return { matches: false, pruned: false, printed: false };
        } else if (!n2.endsWith(l)) return { matches: false, pruned: false, printed: false };
      }
      return { matches: Ye(n2, i2, e2.ignoreCase), pruned: false, printed: false };
    }
    case "regex":
      try {
        let i2 = e2.ignoreCase ? "i" : "";
        return { matches: new RegExp(e2.pattern, i2).test(n2), pruned: false, printed: false };
      } catch {
        return { matches: false, pruned: false, printed: false };
      }
    case "type":
      return e2.fileType === "f" ? { matches: r2, pruned: false, printed: false } : e2.fileType === "d" ? { matches: s2, pruned: false, printed: false } : { matches: false, pruned: false, printed: false };
    case "prune":
      return { matches: true, pruned: true, printed: false };
    case "print":
      return { matches: true, pruned: false, printed: true };
    case "not": {
      let i2 = mn(e2.expr, t2, n2, r2, s2);
      return { matches: !i2.matches, pruned: i2.pruned, printed: false };
    }
    case "and": {
      let i2 = mn(e2.left, t2, n2, r2, s2);
      if (!i2.matches) return { matches: false, pruned: i2.pruned, printed: false };
      let o2 = mn(e2.right, t2, n2, r2, s2);
      return { matches: o2.matches, pruned: i2.pruned || o2.pruned, printed: i2.printed || o2.printed };
    }
    case "or": {
      let i2 = mn(e2.left, t2, n2, r2, s2);
      if (i2.matches) return i2;
      let o2 = mn(e2.right, t2, n2, r2, s2);
      return { matches: o2.matches, pruned: i2.pruned || o2.pruned, printed: o2.printed };
    }
    default:
      return { matches: false, pruned: false, printed: false };
  }
}
function Cr(e2) {
  if (!e2) return false;
  switch (e2.type) {
    case "prune":
      return true;
    case "not":
      return Cr(e2.expr);
    case "and":
    case "or":
      return Cr(e2.left) || Cr(e2.right);
    default:
      return false;
  }
}
function Yt(e2) {
  switch (e2.type) {
    case "name":
    case "path":
    case "regex":
    case "type":
    case "prune":
    case "print":
      return true;
    case "empty":
    case "mtime":
    case "newer":
    case "size":
    case "perm":
      return false;
    case "not":
      return Yt(e2.expr);
    case "and":
    case "or":
      return Yt(e2.left) && Yt(e2.right);
  }
}
function op(e2, t2) {
  if (!e2 || !t2.isDirectory) return { shouldPrune: false };
  if (!Yt(e2)) return bo(e2, t2);
  let n2 = { name: t2.name, relativePath: t2.relativePath, isFile: t2.isFile, isDirectory: t2.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
  return { shouldPrune: kt(e2, n2).pruned };
}
function bo(e2, t2) {
  switch (e2.type) {
    case "or": {
      if (Yt(e2.left)) {
        let n2 = { name: t2.name, relativePath: t2.relativePath, isFile: t2.isFile, isDirectory: t2.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
        if (kt(e2.left, n2).pruned) return { shouldPrune: true };
      }
      return bo(e2.right, t2);
    }
    case "and": {
      if (Yt(e2.left) && Yt(e2.right)) {
        let n2 = { name: t2.name, relativePath: t2.relativePath, isFile: t2.isFile, isDirectory: t2.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
        return { shouldPrune: kt(e2, n2).pruned };
      }
      if (Yt(e2.left)) {
        let n2 = { name: t2.name, relativePath: t2.relativePath, isFile: t2.isFile, isDirectory: t2.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
        return kt(e2.left, n2).matches ? bo(e2.right, t2) : { shouldPrune: false };
      }
      return { shouldPrune: false };
    }
    case "not":
      return { shouldPrune: false };
    default:
      return { shouldPrune: false };
  }
}
var ap = v(() => {
  Hi();
});
function lp(e2, t2) {
  let n2 = [], r2 = [], s2 = t2;
  for (; s2 < e2.length; ) {
    let o2 = e2[s2];
    if (o2 === "(" || o2 === "\\(") {
      n2.push({ type: "lparen" }), s2++;
      continue;
    }
    if (o2 === ")" || o2 === "\\)") {
      n2.push({ type: "rparen" }), s2++;
      continue;
    }
    if (o2 === "-name" && s2 + 1 < e2.length) n2.push({ type: "expr", expr: { type: "name", pattern: e2[++s2] } });
    else if (o2 === "-iname" && s2 + 1 < e2.length) n2.push({ type: "expr", expr: { type: "name", pattern: e2[++s2], ignoreCase: true } });
    else if (o2 === "-path" && s2 + 1 < e2.length) n2.push({ type: "expr", expr: { type: "path", pattern: e2[++s2] } });
    else if (o2 === "-ipath" && s2 + 1 < e2.length) n2.push({ type: "expr", expr: { type: "path", pattern: e2[++s2], ignoreCase: true } });
    else if (o2 === "-regex" && s2 + 1 < e2.length) n2.push({ type: "expr", expr: { type: "regex", pattern: e2[++s2] } });
    else if (o2 === "-iregex" && s2 + 1 < e2.length) n2.push({ type: "expr", expr: { type: "regex", pattern: e2[++s2], ignoreCase: true } });
    else if (o2 === "-type" && s2 + 1 < e2.length) {
      let a = e2[++s2];
      if (a === "f" || a === "d") n2.push({ type: "expr", expr: { type: "type", fileType: a } });
      else return { expr: null, pathIndex: s2, error: `find: Unknown argument to -type: ${a}
`, actions: [] };
    } else if (o2 === "-empty") n2.push({ type: "expr", expr: { type: "empty" } });
    else if (o2 === "-mtime" && s2 + 1 < e2.length) {
      let a = e2[++s2], l = "exact", c = a;
      a.startsWith("+") ? (l = "more", c = a.slice(1)) : a.startsWith("-") && (l = "less", c = a.slice(1));
      let u = parseInt(c, 10);
      Number.isNaN(u) || n2.push({ type: "expr", expr: { type: "mtime", days: u, comparison: l } });
    } else if (o2 === "-newer" && s2 + 1 < e2.length) {
      let a = e2[++s2];
      n2.push({ type: "expr", expr: { type: "newer", refPath: a } });
    } else if (o2 === "-size" && s2 + 1 < e2.length) {
      let a = e2[++s2], l = "exact", c = a;
      a.startsWith("+") ? (l = "more", c = a.slice(1)) : a.startsWith("-") && (l = "less", c = a.slice(1));
      let u = c.match(/^(\d+)([ckMGb])?$/);
      if (u) {
        let f2 = parseInt(u[1], 10), p = u[2] || "b";
        n2.push({ type: "expr", expr: { type: "size", value: f2, unit: p, comparison: l } });
      }
    } else if (o2 === "-perm" && s2 + 1 < e2.length) {
      let a = e2[++s2], l = "exact", c = a;
      a.startsWith("-") ? (l = "all", c = a.slice(1)) : a.startsWith("/") && (l = "any", c = a.slice(1));
      let u = parseInt(c, 8);
      Number.isNaN(u) || n2.push({ type: "expr", expr: { type: "perm", mode: u, matchType: l } });
    } else if (o2 === "-prune") n2.push({ type: "expr", expr: { type: "prune" } });
    else if (o2 === "-not" || o2 === "!") n2.push({ type: "not" });
    else if (o2 === "-o" || o2 === "-or") n2.push({ type: "op", op: "or" });
    else if (o2 === "-a" || o2 === "-and") n2.push({ type: "op", op: "and" });
    else if (o2 === "-maxdepth" || o2 === "-mindepth") s2++;
    else if (o2 !== "-depth") if (o2 === "-exec") {
      let a = [];
      for (s2++; s2 < e2.length && e2[s2] !== ";" && e2[s2] !== "+"; ) a.push(e2[s2]), s2++;
      if (s2 >= e2.length) return { expr: null, pathIndex: s2, error: "find: missing argument to `-exec'\n", actions: [] };
      let l = e2[s2] === "+";
      r2.push({ type: "exec", command: a, batchMode: l });
    } else if (o2 === "-print") n2.push({ type: "expr", expr: { type: "print" } }), r2.push({ type: "print" });
    else if (o2 === "-print0") r2.push({ type: "print0" });
    else if (o2 === "-printf" && s2 + 1 < e2.length) {
      let a = e2[++s2];
      r2.push({ type: "printf", format: a });
    } else if (o2 === "-delete") r2.push({ type: "delete" });
    else {
      if (o2.startsWith("-")) return { expr: null, pathIndex: s2, error: `find: unknown predicate '${o2}'
`, actions: [] };
      if (n2.length === 0) {
        s2++;
        continue;
      }
      break;
    }
    s2++;
  }
  if (n2.length === 0) return { expr: null, pathIndex: s2, actions: r2 };
  let i2 = fE(n2);
  return i2.error ? { expr: null, pathIndex: s2, error: i2.error, actions: r2 } : { expr: i2.expr, pathIndex: s2, actions: r2 };
}
function fE(e2) {
  let t2 = 0;
  function n2() {
    let a = r2();
    if (!a) return null;
    for (; t2 < e2.length; ) {
      let l = e2[t2];
      if (l.type === "op" && l.op === "or") {
        t2++;
        let c = r2();
        if (!c) return a;
        a = { type: "or", left: a, right: c };
      } else break;
    }
    return a;
  }
  function r2() {
    let a = s2();
    if (!a) return null;
    for (; t2 < e2.length; ) {
      let l = e2[t2];
      if (l.type === "op" && l.op === "and") {
        t2++;
        let c = s2();
        if (!c) return a;
        a = { type: "and", left: a, right: c };
      } else if (l.type === "expr" || l.type === "not" || l.type === "lparen") {
        let c = s2();
        if (!c) return a;
        a = { type: "and", left: a, right: c };
      } else break;
    }
    return a;
  }
  function s2() {
    if (t2 < e2.length && e2[t2].type === "not") {
      t2++;
      let a = s2();
      return a ? { type: "not", expr: a } : null;
    }
    return i2();
  }
  function i2() {
    if (t2 >= e2.length) return null;
    let a = e2[t2];
    if (a.type === "lparen") {
      t2++;
      let l = n2();
      return t2 < e2.length && e2[t2].type === "rparen" && t2++, l;
    }
    return a.type === "expr" ? (t2++, a.expr) : (a.type === "rparen", null);
  }
  return { expr: n2() };
}
var cp = v(() => {
});
var fp = {};
V(fp, { findCommand: () => gE });
function pE() {
  return { readdirCalls: 0, readdirTime: 0, statCalls: 0, statTime: 0, evalCalls: 0, evalTime: 0, nodeCount: 0, batchCount: 0, batchTime: 0, earlyPrunes: 0 };
}
function dE(e2, t2, n2) {
  e2({ category: "find", name: "summary", durationMs: n2, details: { readdirCalls: t2.readdirCalls, readdirTimeMs: t2.readdirTime, statCalls: t2.statCalls, statTimeMs: t2.statTime, evalCalls: t2.evalCalls, evalTimeMs: t2.evalTime, nodeCount: t2.nodeCount, batchCount: t2.batchCount, batchTimeMs: t2.batchTime, earlyPrunes: t2.earlyPrunes, otherTimeMs: n2 - t2.readdirTime - t2.statTime - t2.evalTime - t2.batchTime } });
}
function yE(e2, t2) {
  let n2 = Jr(e2), r2 = "", s2 = 0;
  for (; s2 < n2.length; ) if (n2[s2] === "%" && s2 + 1 < n2.length) {
    if (s2++, n2[s2] === "%") {
      r2 += "%", s2++;
      continue;
    }
    let [i2, o2, a] = tc(n2, s2);
    if (s2 += a, s2 >= n2.length) {
      r2 += "%";
      break;
    }
    let l = n2[s2], c;
    switch (l) {
      case "f":
        c = t2.name, s2++;
        break;
      case "h": {
        let u = t2.path.lastIndexOf("/");
        c = u > 0 ? t2.path.slice(0, u) : ".", s2++;
        break;
      }
      case "p":
        c = t2.path, s2++;
        break;
      case "P": {
        let u = t2.startingPoint;
        t2.path === u ? c = "" : t2.path.startsWith(`${u}/`) ? c = t2.path.slice(u.length + 1) : u === "." && t2.path.startsWith("./") ? c = t2.path.slice(2) : c = t2.path, s2++;
        break;
      }
      case "s":
        c = String(t2.size), s2++;
        break;
      case "d":
        c = String(t2.depth), s2++;
        break;
      case "m":
        c = (t2.mode & 511).toString(8), s2++;
        break;
      case "M":
        c = bE(t2.mode, t2.isDirectory), s2++;
        break;
      case "t": {
        let u = new Date(t2.mtime);
        c = wE(u), s2++;
        break;
      }
      case "T": {
        if (s2 + 1 < n2.length) {
          let u = n2[s2 + 1], f2 = new Date(t2.mtime);
          c = xE(f2, u), s2 += 2;
        } else c = "%T", s2++;
        break;
      }
      default:
        r2 += `%${i2 !== 0 || o2 !== -1 ? `${i2}.${o2}` : ""}${l}`, s2++;
        continue;
    }
    r2 += Xr(c, i2, o2);
  } else r2 += n2[s2], s2++;
  return r2;
}
function bE(e2, t2) {
  let n2 = e2 & 511, r2 = t2 ? "d" : "-";
  return r2 += n2 & 256 ? "r" : "-", r2 += n2 & 128 ? "w" : "-", r2 += n2 & 64 ? "x" : "-", r2 += n2 & 32 ? "r" : "-", r2 += n2 & 16 ? "w" : "-", r2 += n2 & 8 ? "x" : "-", r2 += n2 & 4 ? "r" : "-", r2 += n2 & 2 ? "w" : "-", r2 += n2 & 1 ? "x" : "-", r2;
}
function wE(e2) {
  let t2 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], n2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], r2 = t2[e2.getDay()], s2 = n2[e2.getMonth()], i2 = String(e2.getDate()).padStart(2, " "), o2 = String(e2.getHours()).padStart(2, "0"), a = String(e2.getMinutes()).padStart(2, "0"), l = String(e2.getSeconds()).padStart(2, "0"), c = e2.getFullYear();
  return `${r2} ${s2} ${i2} ${o2}:${a}:${l} ${c}`;
}
function xE(e2, t2) {
  switch (t2) {
    case "@":
      return String(e2.getTime() / 1e3);
    case "Y":
      return String(e2.getFullYear());
    case "m":
      return String(e2.getMonth() + 1).padStart(2, "0");
    case "d":
      return String(e2.getDate()).padStart(2, "0");
    case "H":
      return String(e2.getHours()).padStart(2, "0");
    case "M":
      return String(e2.getMinutes()).padStart(2, "0");
    case "S":
      return String(e2.getSeconds()).padStart(2, "0");
    case "T":
      return `${String(e2.getHours()).padStart(2, "0")}:${String(e2.getMinutes()).padStart(2, "0")}:${String(e2.getSeconds()).padStart(2, "0")}`;
    case "F":
      return `${e2.getFullYear()}-${String(e2.getMonth() + 1).padStart(2, "0")}-${String(e2.getDate()).padStart(2, "0")}`;
    default:
      return `%T${t2}`;
  }
}
var up, hE, mE, gE, pp$a = v(() => {
  X();
  Bi();
  ap();
  cp();
  up = 500;
  hE = { name: "find", summary: "search for files in a directory hierarchy", usage: "find [path...] [expression]", options: ["-name PATTERN    file name matches shell pattern PATTERN", "-iname PATTERN   like -name but case insensitive", "-path PATTERN    file path matches shell pattern PATTERN", "-ipath PATTERN   like -path but case insensitive", "-regex PATTERN   file path matches regular expression PATTERN", "-iregex PATTERN  like -regex but case insensitive", "-type TYPE       file is of type: f (regular file), d (directory)", "-empty           file is empty or directory is empty", "-mtime N         file's data was modified N*24 hours ago", "-newer FILE      file was modified more recently than FILE", "-size N[ckMGb]   file uses N units of space (c=bytes, k=KB, M=MB, G=GB, b=512B blocks)", "-perm MODE       file's permission bits are exactly MODE (octal)", "-perm -MODE      all permission bits MODE are set", "-perm /MODE      any permission bits MODE are set", "-maxdepth LEVELS descend at most LEVELS directories", "-mindepth LEVELS do not apply tests at levels less than LEVELS", "-depth           process directory contents before directory itself", "-prune           do not descend into this directory", "-not, !          negate the following expression", "-a, -and         logical AND (default)", "-o, -or          logical OR", "-exec CMD {} ;   execute CMD on each file ({} is replaced by filename)", "-exec CMD {} +   execute CMD with multiple files at once", "-print           print the full file name (default action)", "-print0          print the full file name followed by a null character", "-printf FORMAT   print FORMAT with directives: %f %h %p %P %s %d %m %M %t", "-delete          delete found files/directories", "    --help       display this help and exit"] }, mE = /* @__PURE__ */ new Set(["-name", "-iname", "-path", "-ipath", "-regex", "-iregex", "-type", "-maxdepth", "-mindepth", "-mtime", "-newer", "-size", "-perm"]), gE = { name: "find", async execute(e2, t2) {
    var _a3;
    if (_(e2)) return F$3(hE);
    let n2 = [], r2 = null, s2 = null, i2 = false, o2 = false;
    for (let N2 = 0; N2 < e2.length; N2++) {
      let P = e2[N2];
      if (P === "-maxdepth" && N2 + 1 < e2.length) o2 = true, r2 = parseInt(e2[++N2], 10);
      else if (P === "-mindepth" && N2 + 1 < e2.length) o2 = true, s2 = parseInt(e2[++N2], 10);
      else if (P === "-depth") o2 = true, i2 = true;
      else if (P === "-exec") for (o2 = true, N2++; N2 < e2.length && e2[N2] !== ";" && e2[N2] !== "+"; ) N2++;
      else !P.startsWith("-") && P !== ";" && P !== "+" && P !== "(" && P !== ")" && P !== "\\(" && P !== "\\)" && P !== "!" ? o2 || n2.push(P) : mE.has(P) ? (o2 = true, N2++) : (P.startsWith("-") || P === "(" || P === "\\(" || P === "!") && (o2 = true);
    }
    n2.length === 0 && n2.push(".");
    let { expr: a, error: l, actions: c } = lp(e2, 0);
    if (l) return { stdout: "", stderr: l, exitCode: 1 };
    let u = c.some((N2) => N2.type === "print"), f2 = c.length === 0, p = [], d = c.some((N2) => N2.type === "printf"), m = [], h = "", g = 0, b = ip(a), y = /* @__PURE__ */ new Map();
    for (let N2 of b) {
      let P = t2.fs.resolvePath(t2.cwd, N2);
      try {
        let k = await t2.fs.stat(P);
        y.set(N2, ((_a3 = k.mtime) == null ? void 0 : _a3.getTime()) ?? Date.now());
      } catch {
      }
    }
    let w = c.some((N2) => {
      if (N2.type !== "printf") return false;
      let P = N2.format.replace(/%%/g, "");
      return /%[-+]?[0-9]*\.?[0-9]*(s|m|M|t|T)/.test(P);
    }), E = Er(a) || w, C = Sr(a), A = sp(a), I = Cr(a), O = Ar(a), L = typeof t2.fs.readdirWithFileTypes == "function";
    for (let N2 of n2) {
      let Y = function(B) {
        var _a4, _b3, _c2, _d2, _e2, _f2, _g2, _h2;
        let be = s2 === null || B.depth >= s2, ee = false;
        if (be && a !== null) {
          let U2 = Date.now(), ye;
          if (O) ye = mn(a, B.name, B.relativePath, B.isFile, B.isDirectory);
          else {
            let Ce = { name: B.name, relativePath: B.relativePath, isFile: B.isFile, isDirectory: B.isDirectory, isEmpty: B.isEmpty, mtime: ((_b3 = (_a4 = B.stat) == null ? void 0 : _a4.mtime) == null ? void 0 : _b3.getTime()) ?? Date.now(), size: ((_c2 = B.stat) == null ? void 0 : _c2.size) ?? 0, mode: ((_d2 = B.stat) == null ? void 0 : _d2.mode) ?? 420, newerRefTimes: y };
            ye = kt(a, Ce);
          }
          be = ye.matches, ee = u ? ye.printed : be, k.evalCalls++, k.evalTime += Date.now() - U2;
        } else be && (ee = true);
        return ee ? { print: true, printfData: d ? { path: B.relativePath, name: B.name, size: ((_e2 = B.stat) == null ? void 0 : _e2.size) ?? 0, mtime: ((_g2 = (_f2 = B.stat) == null ? void 0 : _f2.mtime) == null ? void 0 : _g2.getTime()) ?? Date.now(), mode: ((_h2 = B.stat) == null ? void 0 : _h2.mode) ?? 420, isDirectory: B.isDirectory, depth: B.depth, startingPoint: N2 } : null } : { print: false, printfData: null };
      };
      N2.length > 1 && N2.endsWith("/") && (N2 = N2.slice(0, -1));
      let P = t2.fs.resolvePath(t2.cwd, N2);
      try {
        await t2.fs.stat(P);
      } catch {
        h += `find: ${N2}: No such file or directory
`, g = 1;
        continue;
      }
      let k = pE(), R2 = Date.now();
      async function T(B) {
        var _a4;
        let { path: q, depth: be, typeInfo: ee } = B;
        if (k.nodeCount++, r2 !== null && be > r2) return null;
        let ge, U2, ye;
        if (ee && !E) ge = ee.isFile, U2 = ee.isDirectory;
        else {
          try {
            let un = Date.now();
            ye = await t2.fs.stat(q), k.statCalls++, k.statTime += Date.now() - un;
          } catch {
            return null;
          }
          if (!ye) return null;
          ge = ye.isFile, U2 = ye.isDirectory;
        }
        let Ce;
        q === P ? Ce = N2.split("/").pop() || N2 : Ce = q.split("/").pop() || "";
        let Re = q === P ? N2 : N2 === "." ? `./${q.slice(P === "/" ? P.length : P.length + 1)}` : N2 + q.slice(P.length), Me = [], ze = null, We = null, Be = false;
        U2 && I && !i2 && (Be = op(a, { name: Ce, relativePath: Re, isFile: ge, isDirectory: U2 }).shouldPrune, Be && k.earlyPrunes++);
        let yt = r2 !== null && be >= r2, bt = A.terminalDirName !== null && Ce === A.terminalDirName, dr = !yt && !bt && !Be;
        if (U2 && ((dr || C || bt) && !Be)) {
          let un = Date.now();
          if (L && t2.fs.readdirWithFileTypes) {
            if (ze = await t2.fs.readdirWithFileTypes(q), We = ze.map((at2) => at2.name), k.readdirCalls++, k.readdirTime += Date.now() - un, dr) Me = ze.map((at2, Ct) => ({ path: q === "/" ? `/${at2.name}` : `${q}/${at2.name}`, depth: be + 1, typeInfo: { isFile: at2.isFile, isDirectory: at2.isDirectory }, resultIndex: Ct }));
            else if (bt) {
              let at2 = A.requiredExtension;
              Me = ze.filter((Ct) => Ct.isFile && (!at2 || Ct.name.endsWith(at2))).map((Ct, Vy) => ({ path: q === "/" ? `/${Ct.name}` : `${q}/${Ct.name}`, depth: be + 1, typeInfo: { isFile: Ct.isFile, isDirectory: Ct.isDirectory }, resultIndex: Vy }));
            }
          } else We = await t2.fs.readdir(q), k.readdirCalls++, k.readdirTime += Date.now() - un, dr && (Me = We.map((at2, Ct) => ({ path: q === "/" ? `/${at2}` : `${q}/${at2}`, depth: be + 1, resultIndex: Ct })));
        }
        let Qr = ge ? ((ye == null ? void 0 : ye.size) ?? 0) === 0 : We !== null && We.length === 0, Rn = Be;
        if (!i2 && a !== null && !Be && I) {
          let un = Date.now(), at2 = { name: Ce, relativePath: Re, isFile: ge, isDirectory: U2, isEmpty: Qr, mtime: ((_a4 = ye == null ? void 0 : ye.mtime) == null ? void 0 : _a4.getTime()) ?? Date.now(), size: (ye == null ? void 0 : ye.size) ?? 0, mode: (ye == null ? void 0 : ye.mode) ?? 420, newerRefTimes: y };
          Rn = kt(a, at2).pruned, k.evalCalls++, k.evalTime += Date.now() - un;
        }
        return { relativePath: Re, name: Ce, isFile: ge, isDirectory: U2, isEmpty: Qr, stat: ye, depth: be, children: Rn ? [] : Me, pruned: Rn };
      }
      async function ie() {
        let B = { paths: [], printfData: [] };
        if (i2) {
          let ye = function(Ce) {
            let Re = { paths: [], printfData: [] }, Me = ee[Ce];
            if (!Me) return Re;
            for (let Be of Me.childIndices) {
              let yt = ye(Be);
              Re.paths.push(...yt.paths), Re.printfData.push(...yt.printfData);
            }
            let { print: ze, printfData: We } = Y(Me.node);
            return ze && (Re.paths.push(Me.node.relativePath), We && Re.printfData.push(We)), Re;
          };
          let ee = [], ge = [{ item: { path: P, depth: 0, resultIndex: 0 }, parentIndex: -1, childOrderInParent: 0 }], U2 = /* @__PURE__ */ new Map();
          for (; ge.length > 0; ) {
            let Ce = Date.now(), Re = ge.splice(0, up), Me = await Promise.all(Re.map((ze) => T(ze.item)));
            k.batchCount++, k.batchTime += Date.now() - Ce;
            for (let ze = 0; ze < Re.length; ze++) {
              let We = Me[ze], Be = Re[ze];
              if (!We) continue;
              let yt = ee.length;
              if (Be.parentIndex >= 0) {
                let bt = U2.get(Be.parentIndex) || [];
                bt.push(yt), U2.set(Be.parentIndex, bt);
              }
              ee.push({ node: We, parentIndex: Be.parentIndex, childIndices: [] });
              for (let bt = 0; bt < We.children.length; bt++) ge.push({ item: We.children[bt], parentIndex: yt, childOrderInParent: bt });
            }
          }
          for (let [Ce, Re] of U2) Ce >= 0 && Ce < ee.length && (ee[Ce].childIndices = Re);
          if (ee.length > 0) {
            let Ce = ye(0);
            B.paths.push(...Ce.paths), B.printfData.push(...Ce.printfData);
          }
        } else {
          let Ce = function(Re) {
            let Me = ee.get(Re);
            Me && (B.paths.push(Me.path), Me.printfData && B.printfData.push(Me.printfData));
            let ze = ye.get(Re);
            if (ze) for (let We of ze) Ce(We);
          };
          let ee = /* @__PURE__ */ new Map(), ge = 0, U2 = [{ item: { path: P, depth: 0, resultIndex: 0 }, orderIndex: ge++ }], ye = /* @__PURE__ */ new Map();
          for (; U2.length > 0; ) {
            let Re = Date.now(), Me = U2.splice(0, up), ze = await Promise.all(Me.map(async ({ item: We, orderIndex: Be }) => {
              let yt = await T(We);
              return yt ? { node: yt, orderIndex: Be } : null;
            }));
            k.batchCount++, k.batchTime += Date.now() - Re;
            for (let We of ze) {
              if (!We) continue;
              let { node: Be, orderIndex: yt } = We, { print: bt, printfData: dr } = Y(Be);
              if (bt && ee.set(yt, { path: Be.relativePath, printfData: dr }), Be.children.length > 0) {
                let Mi = [];
                for (let Qr of Be.children) {
                  let Rn = ge++;
                  Mi.push(Rn), U2.push({ item: Qr, orderIndex: Rn });
                }
                ye.set(yt, Mi);
              }
            }
          }
          Ce(0);
        }
        return B;
      }
      let K = await ie();
      if (p.push(...K.paths), m.push(...K.printfData), t2.trace) {
        let B = Date.now() - R2;
        dE(t2.trace, k, B), t2.trace({ category: "find", name: "searchPath", durationMs: B, details: { path: N2, resultsFound: K.paths.length } });
      }
    }
    let D = "";
    if (c.length > 0) for (let N2 of c) switch (N2.type) {
      case "print":
        D += p.length > 0 ? `${p.join(`
`)}
` : "";
        break;
      case "print0":
        D += p.length > 0 ? `${p.join("\0")}\0` : "";
        break;
      case "delete": {
        let P = [...p].sort((k, R2) => R2.length - k.length);
        for (let k of P) {
          let R2 = t2.fs.resolvePath(t2.cwd, k);
          try {
            await t2.fs.rm(R2, { recursive: false });
          } catch (T) {
            let Y = T instanceof Error ? T.message : String(T);
            h += `find: cannot delete '${k}': ${Y}
`, g = 1;
          }
        }
        break;
      }
      case "printf":
        for (let P of m) D += yE(N2.format, P);
        break;
      case "exec":
        if (!t2.exec) return { stdout: "", stderr: `find: -exec not supported in this context
`, exitCode: 1 };
        if (N2.batchMode) {
          let P = [];
          for (let T of N2.command) T === "{}" ? P.push(...p) : P.push(T);
          let k = P.map((T) => `"${T}"`).join(" "), R2 = await t2.exec(k, { cwd: t2.cwd });
          D += R2.stdout, h += R2.stderr, R2.exitCode !== 0 && (g = R2.exitCode);
        } else for (let P of p) {
          let R2 = N2.command.map((Y) => Y === "{}" ? P : Y).map((Y) => `"${Y}"`).join(" "), T = await t2.exec(R2, { cwd: t2.cwd });
          D += T.stdout, h += T.stderr, T.exitCode !== 0 && (g = T.exitCode);
        }
        break;
    }
    else f2 && (D = p.length > 0 ? `${p.join(`
`)}
` : "");
    return { stdout: D, stderr: h, exitCode: g };
  } };
});
var dp = {};
V(dp, { basenameCommand: () => SE });
var EE, SE, hp = v(() => {
  X();
  EE = { name: "basename", summary: "strip directory and suffix from filenames", usage: `basename NAME [SUFFIX]
basename OPTION... NAME...`, options: ["-a, --multiple   support multiple arguments", "-s, --suffix=SUFFIX  remove a trailing SUFFIX", "    --help       display this help and exit"] }, SE = { name: "basename", async execute(e2, t2) {
    if (_(e2)) return F$3(EE);
    let n2 = false, r2 = "", s2 = [];
    for (let o2 = 0; o2 < e2.length; o2++) {
      let a = e2[o2];
      a === "-a" || a === "--multiple" ? n2 = true : a === "-s" && o2 + 1 < e2.length ? (r2 = e2[++o2], n2 = true) : a.startsWith("--suffix=") ? (r2 = a.slice(9), n2 = true) : a.startsWith("-") || s2.push(a);
    }
    if (s2.length === 0) return { stdout: "", stderr: `basename: missing operand
`, exitCode: 1 };
    !n2 && s2.length >= 2 && (r2 = s2.pop() ?? "");
    let i2 = [];
    for (let o2 of s2) {
      let a = o2.replace(/\/+$/, ""), l = a.split("/").pop() || a;
      r2 && l.endsWith(r2) && (l = l.slice(0, -r2.length)), i2.push(l);
    }
    return { stdout: `${i2.join(`
`)}
`, stderr: "", exitCode: 0 };
  } };
});
var mp = {};
V(mp, { dirnameCommand: () => CE });
var AE, CE, gp = v(() => {
  X();
  AE = { name: "dirname", summary: "strip last component from file name", usage: "dirname [OPTION] NAME...", options: ["    --help       display this help and exit"] }, CE = { name: "dirname", async execute(e2, t2) {
    if (_(e2)) return F$3(AE);
    let n2 = e2.filter((s2) => !s2.startsWith("-"));
    if (n2.length === 0) return { stdout: "", stderr: `dirname: missing operand
`, exitCode: 1 };
    let r2 = [];
    for (let s2 of n2) {
      let i2 = s2.replace(/\/+$/, ""), o2 = i2.lastIndexOf("/");
      o2 === -1 ? r2.push(".") : o2 === 0 ? r2.push("/") : r2.push(i2.slice(0, o2));
    }
    return { stdout: `${r2.join(`
`)}
`, stderr: "", exitCode: 0 };
  } };
});
var bp = {};
V(bp, { treeCommand: () => vE });
async function $E(e2, t2, n2, r2, s2) {
  let i2 = { output: "", stderr: "", dirCount: 0, fileCount: 0 }, o2 = e2.fs.resolvePath(e2.cwd, t2);
  try {
    if (!(await e2.fs.stat(o2)).isDirectory) return i2.output = `${t2}
`, i2.fileCount = 1, i2;
  } catch {
    return i2.stderr = `tree: ${t2}: No such file or directory
`, i2;
  }
  if (i2.output = `${t2}
`, n2.maxDepth !== null && s2 >= n2.maxDepth) return i2;
  try {
    let a = [];
    if (e2.fs.readdirWithFileTypes) a = (await e2.fs.readdirWithFileTypes(o2)).map((u) => ({ name: u.name, isDirectory: u.isDirectory }));
    else {
      let c = await e2.fs.readdir(o2);
      for (let u = 0; u < c.length; u += 100) {
        let f2 = c.slice(u, u + 100), p = await Promise.all(f2.map(async (d) => {
          let m = o2 === "/" ? `/${d}` : `${o2}/${d}`;
          try {
            let h = await e2.fs.stat(m);
            return { name: d, isDirectory: h.isDirectory };
          } catch {
            return null;
          }
        }));
        a.push(...p.filter((d) => d !== null));
      }
    }
    let l = a.filter((c) => !(!n2.showHidden && c.name.startsWith(".") || n2.directoriesOnly && !c.isDirectory));
    l.sort((c, u) => c.name.localeCompare(u.name));
    for (let c = 0; c < l.length; c++) {
      let u = l[c], f2 = o2 === "/" ? `/${u.name}` : `${o2}/${u.name}`, p = c === l.length - 1, d = p ? "`-- " : "|-- ", m = r2 + (p ? "    " : "|   ");
      if (u.isDirectory) {
        i2.dirCount++;
        let h = n2.fullPath ? f2 : u.name;
        if (i2.output += `${r2 + d + h}
`, n2.maxDepth === null || s2 + 1 < n2.maxDepth) {
          let g = await yp(e2, f2, n2, m, s2 + 1);
          i2.output += g.output, i2.dirCount += g.dirCount, i2.fileCount += g.fileCount;
        }
      } else {
        i2.fileCount++;
        let h = n2.fullPath ? f2 : u.name;
        i2.output += `${r2 + d + h}
`;
      }
    }
  } catch {
    i2.stderr = `tree: ${t2}: Permission denied
`;
  }
  return i2;
}
async function yp(e2, t2, n2, r2, s2) {
  let i2 = { output: "", stderr: "", dirCount: 0, fileCount: 0 };
  if (n2.maxDepth !== null && s2 >= n2.maxDepth) return i2;
  try {
    let o2 = [];
    if (e2.fs.readdirWithFileTypes) o2 = (await e2.fs.readdirWithFileTypes(t2)).map((c) => ({ name: c.name, isDirectory: c.isDirectory }));
    else {
      let l = await e2.fs.readdir(t2);
      for (let c = 0; c < l.length; c += 100) {
        let u = l.slice(c, c + 100), f2 = await Promise.all(u.map(async (p) => {
          let d = t2 === "/" ? `/${p}` : `${t2}/${p}`;
          try {
            let m = await e2.fs.stat(d);
            return { name: p, isDirectory: m.isDirectory };
          } catch {
            return null;
          }
        }));
        o2.push(...f2.filter((p) => p !== null));
      }
    }
    let a = o2.filter((l) => !(!n2.showHidden && l.name.startsWith(".") || n2.directoriesOnly && !l.isDirectory));
    a.sort((l, c) => l.name.localeCompare(c.name));
    for (let l = 0; l < a.length; l++) {
      let c = a[l], u = t2 === "/" ? `/${c.name}` : `${t2}/${c.name}`, f2 = l === a.length - 1, p = f2 ? "`-- " : "|-- ", d = r2 + (f2 ? "    " : "|   ");
      if (c.isDirectory) {
        i2.dirCount++;
        let m = n2.fullPath ? u : c.name;
        i2.output += `${r2 + p + m}
`;
        let h = await yp(e2, u, n2, d, s2 + 1);
        i2.output += h.output, i2.dirCount += h.dirCount, i2.fileCount += h.fileCount;
      } else {
        i2.fileCount++;
        let m = n2.fullPath ? u : c.name;
        i2.output += `${r2 + p + m}
`;
      }
    }
  } catch {
  }
  return i2;
}
var NE, kE, vE, wp = v(() => {
  Oe();
  Pn();
  X();
  NE = { name: "tree", summary: "list contents of directories in a tree-like format", usage: "tree [OPTION]... [DIRECTORY]...", options: ["-a          include hidden files", "-d          list directories only", "-L LEVEL    limit depth of directory tree", "-f          print full path prefix for each file", "    --help  display this help and exit"] }, kE = { showHidden: { short: "a", type: "boolean" }, directoriesOnly: { short: "d", type: "boolean" }, fullPath: { short: "f", type: "boolean" }, maxDepth: { short: "L", type: "number" } }, vE = { name: "tree", async execute(e2, t2) {
    if (_(e2)) return F$3(NE);
    let n2 = fe("tree", e2, kE);
    if (!n2.ok) return n2.error;
    let r2 = { showHidden: n2.result.flags.showHidden, directoriesOnly: n2.result.flags.directoriesOnly, maxDepth: n2.result.flags.maxDepth ?? null, fullPath: n2.result.flags.fullPath }, s2 = n2.result.positional;
    s2.length === 0 && s2.push(".");
    let i2 = "", o2 = "", a = 0, l = 0;
    for (let c of s2) {
      let u = await $E(t2, c, r2, "", 0);
      i2 += u.output, o2 += u.stderr, a += u.dirCount, l += u.fileCount;
    }
    return i2 += `
${a} director${a === 1 ? "y" : "ies"}`, r2.directoriesOnly || (i2 += `, ${l} file${l === 1 ? "" : "s"}`), i2 += `
`, { stdout: i2, stderr: o2, exitCode: o2 ? 1 : 0 };
  } };
});
var Ep = {};
V(Ep, { duCommand: () => PE });
async function xp(e2, t2, n2, r2, s2) {
  let i2 = { output: "", totalSize: 0, stderr: "" };
  try {
    let o2 = await e2.fs.stat(t2);
    if (!o2.isDirectory) return i2.totalSize = o2.size, (r2.allFiles || s2 === 0) && (i2.output = As(o2.size, r2.humanReadable) + "	" + n2 + `
`), i2;
    let a = 0, l = [];
    if (e2.fs.readdirWithFileTypes) {
      let f2 = await e2.fs.readdirWithFileTypes(t2), p = f2.filter((m) => m.isFile), d = f2.filter((m) => m.isDirectory);
      for (let m = 0; m < p.length; m += 100) {
        let h = p.slice(m, m + 100), g = await Promise.all(h.map(async (b) => {
          let y = t2 === "/" ? `/${b.name}` : `${t2}/${b.name}`;
          try {
            let w = await e2.fs.stat(y);
            return { name: b.name, isDirectory: false, size: w.size };
          } catch {
            return { name: b.name, isDirectory: false, size: 0 };
          }
        }));
        l.push(...g);
      }
      l.push(...d.map((m) => ({ name: m.name, isDirectory: true })));
    } else {
      let f2 = await e2.fs.readdir(t2);
      for (let p = 0; p < f2.length; p += 100) {
        let d = f2.slice(p, p + 100), m = await Promise.all(d.map(async (h) => {
          let g = t2 === "/" ? `/${h}` : `${t2}/${h}`;
          try {
            let b = await e2.fs.stat(g);
            return { name: h, isDirectory: b.isDirectory, size: b.isDirectory ? void 0 : b.size };
          } catch {
            return { name: h, isDirectory: false, size: 0 };
          }
        }));
        l.push(...m);
      }
    }
    l.sort((f2, p) => f2.name.localeCompare(p.name));
    let c = l.filter((f2) => !f2.isDirectory);
    for (let f2 of c) {
      let p = f2.size ?? 0;
      if (a += p, r2.allFiles && !r2.summarize) {
        let d = n2 === "." ? f2.name : `${n2}/${f2.name}`;
        i2.output += As(p, r2.humanReadable) + "	" + d + `
`;
      }
    }
    let u = l.filter((f2) => f2.isDirectory);
    for (let f2 = 0; f2 < u.length; f2 += 100) {
      let p = u.slice(f2, f2 + 100), d = await Promise.all(p.map(async (m) => {
        let h = t2 === "/" ? `/${m.name}` : `${t2}/${m.name}`, g = n2 === "." ? m.name : `${n2}/${m.name}`;
        return { name: m.name, result: await xp(e2, h, g, r2, s2 + 1) };
      }));
      d.sort((m, h) => m.name.localeCompare(h.name));
      for (let { result: m } of d) a += m.totalSize, r2.summarize || (r2.maxDepth === null || s2 + 1 <= r2.maxDepth) && (i2.output += m.output);
    }
    i2.totalSize = a, (r2.summarize || r2.maxDepth === null || s2 <= r2.maxDepth) && (i2.output += `${As(a, r2.humanReadable)}	${n2}
`);
  } catch {
    i2.stderr = `du: cannot read directory '${n2}': Permission denied
`;
  }
  return i2;
}
function As(e2, t2) {
  return t2 ? e2 < 1024 ? `${e2}` : e2 < 1024 * 1024 ? `${(e2 / 1024).toFixed(1)}K` : e2 < 1024 * 1024 * 1024 ? `${(e2 / (1024 * 1024)).toFixed(1)}M` : `${(e2 / (1024 * 1024 * 1024)).toFixed(1)}G` : String(Math.ceil(e2 / 1024) || 1);
}
var IE, RE, PE, Sp = v(() => {
  Oe();
  Pn();
  X();
  IE = { name: "du", summary: "estimate file space usage", usage: "du [OPTION]... [FILE]...", options: ["-a          write counts for all files, not just directories", "-h          print sizes in human readable format", "-s          display only a total for each argument", "-c          produce a grand total", "--max-depth=N  print total for directory only if N or fewer levels deep", "    --help  display this help and exit"] }, RE = { allFiles: { short: "a", type: "boolean" }, humanReadable: { short: "h", type: "boolean" }, summarize: { short: "s", type: "boolean" }, grandTotal: { short: "c", type: "boolean" }, maxDepth: { long: "max-depth", type: "number" } }, PE = { name: "du", async execute(e2, t2) {
    if (_(e2)) return F$3(IE);
    let n2 = fe("du", e2, RE);
    if (!n2.ok) return n2.error;
    let r2 = { allFiles: n2.result.flags.allFiles, humanReadable: n2.result.flags.humanReadable, summarize: n2.result.flags.summarize, grandTotal: n2.result.flags.grandTotal, maxDepth: n2.result.flags.maxDepth ?? null }, s2 = n2.result.positional;
    s2.length === 0 && s2.push(".");
    let i2 = "", o2 = "", a = 0;
    for (let l of s2) {
      let c = t2.fs.resolvePath(t2.cwd, l);
      try {
        await t2.fs.stat(c);
        let u = await xp(t2, c, l, r2, 0);
        i2 += u.output, a += u.totalSize, o2 += u.stderr;
      } catch {
        o2 += `du: cannot access '${l}': No such file or directory
`;
      }
    }
    return r2.grandTotal && s2.length > 0 && (i2 += `${As(a, r2.humanReadable)}	total
`), { stdout: i2, stderr: o2, exitCode: o2 ? 1 : 0 };
  } };
});
var wo = {};
V(wo, { envCommand: () => OE, printenvCommand: () => FE });
var TE, OE, DE, FE, xo = v(() => {
  X();
  TE = { name: "env", summary: "run a program in a modified environment", usage: "env [OPTION]... [NAME=VALUE]... [COMMAND [ARG]...]", options: ["-i, --ignore-environment  start with an empty environment", "-u NAME, --unset=NAME     remove NAME from the environment", "    --help                display this help and exit"] }, OE = { name: "env", async execute(e2, t2) {
    if (_(e2)) return F$3(TE);
    let n2 = false, r2 = [], s2 = {}, i2 = -1;
    for (let m = 0; m < e2.length; m++) {
      let h = e2[m];
      if (h === "-i" || h === "--ignore-environment") n2 = true;
      else if (h === "-u" && m + 1 < e2.length) r2.push(e2[++m]);
      else if (h.startsWith("-u")) r2.push(h.slice(2));
      else if (h.startsWith("--unset=")) r2.push(h.slice(8));
      else {
        if (h.startsWith("--") && h !== "--") return G("env", h);
        if (h.startsWith("-") && h !== "-") {
          for (let g of h.slice(1)) if (g !== "i" && g !== "u") return G("env", `-${g}`);
          h.includes("i") && (n2 = true);
        } else if (h.includes("=") && i2 === -1) {
          let g = h.indexOf("="), b = h.slice(0, g), y = h.slice(g + 1);
          s2[b] = y;
        } else {
          i2 = m;
          break;
        }
      }
    }
    let o2;
    if (n2) o2 = { ...s2 };
    else {
      o2 = { ...t2.env };
      for (let m of r2) delete o2[m];
      Object.assign(o2, s2);
    }
    if (i2 === -1) {
      let m = [];
      for (let [h, g] of Object.entries(o2)) m.push(`${h}=${g}`);
      return { stdout: m.join(`
`) + (m.length > 0 ? `
` : ""), stderr: "", exitCode: 0 };
    }
    if (!t2.exec) return { stdout: "", stderr: `env: command execution not supported in this context
`, exitCode: 1 };
    let a = e2.slice(i2), l = a[0], u = a.slice(1).map((m) => /[\s"'\\$`!*?[\]{}|&;<>()]/.test(m) ? `'${m.replace(/'/g, "'\\''")}'` : m), f2 = ["command", l, ...u].join(" "), p = Object.entries(s2).map(([m, h]) => `${m}="${h}"`).join(" "), d = p ? `${p} ${f2}` : f2;
    return t2.exec(d, { cwd: t2.cwd });
  } }, DE = { name: "printenv", summary: "print all or part of environment", usage: "printenv [OPTION]... [VARIABLE]...", options: ["    --help       display this help and exit"] }, FE = { name: "printenv", async execute(e2, t2) {
    if (_(e2)) return F$3(DE);
    let n2 = e2.filter((i2) => !i2.startsWith("-"));
    if (n2.length === 0) {
      let i2 = [];
      for (let [o2, a] of Object.entries(t2.env)) i2.push(`${o2}=${a}`);
      return { stdout: i2.join(`
`) + (i2.length > 0 ? `
` : ""), stderr: "", exitCode: 0 };
    }
    let r2 = [], s2 = 0;
    for (let i2 of n2) i2 in t2.env ? r2.push(t2.env[i2]) : s2 = 1;
    return { stdout: r2.join(`
`) + (r2.length > 0 ? `
` : ""), stderr: "", exitCode: s2 };
  } };
});
var Eo = {};
V(Eo, { aliasCommand: () => LE, unaliasCommand: () => ME });
var _E, Un, LE, ME, So = v(() => {
  X();
  _E = { name: "alias", summary: "define or display aliases", usage: "alias [name[=value] ...]", options: ["    --help display this help and exit"] }, Un = "BASH_ALIAS_", LE = { name: "alias", async execute(e2, t2) {
    if (_(e2)) return F$3(_E);
    if (e2.length === 0) {
      let r2 = "";
      for (let [s2, i2] of Object.entries(t2.env)) if (s2.startsWith(Un)) {
        let o2 = s2.slice(Un.length);
        r2 += `alias ${o2}='${i2}'
`;
      }
      return { stdout: r2, stderr: "", exitCode: 0 };
    }
    let n2 = e2[0] === "--" ? e2.slice(1) : e2;
    for (let r2 of n2) {
      let s2 = r2.indexOf("=");
      if (s2 === -1) {
        let i2 = Un + r2;
        return t2.env[i2] ? { stdout: `alias ${r2}='${t2.env[i2]}'
`, stderr: "", exitCode: 0 } : { stdout: "", stderr: `alias: ${r2}: not found
`, exitCode: 1 };
      } else {
        let i2 = r2.slice(0, s2), o2 = r2.slice(s2 + 1);
        (o2.startsWith("'") && o2.endsWith("'") || o2.startsWith('"') && o2.endsWith('"')) && (o2 = o2.slice(1, -1)), t2.env[Un + i2] = o2;
      }
    }
    return { stdout: "", stderr: "", exitCode: 0 };
  } }, ME = { name: "unalias", async execute(e2, t2) {
    if (_(e2)) return F$3({ name: "unalias", summary: "remove alias definitions", usage: "unalias name [name ...]", options: ["-a      remove all aliases", "    --help display this help and exit"] });
    if (e2.length === 0) return { stdout: "", stderr: `unalias: usage: unalias [-a] name [name ...]
`, exitCode: 1 };
    if (e2[0] === "-a") {
      for (let i2 of Object.keys(t2.env)) i2.startsWith(Un) && delete t2.env[i2];
      return { stdout: "", stderr: "", exitCode: 0 };
    }
    let n2 = e2[0] === "--" ? e2.slice(1) : e2, r2 = false, s2 = "";
    for (let i2 of n2) {
      let o2 = Un + i2;
      t2.env[o2] ? delete t2.env[o2] : (s2 += `unalias: ${i2}: not found
`, r2 = true);
    }
    return { stdout: "", stderr: s2, exitCode: r2 ? 1 : 0 };
  } };
});
var Cp = {};
V(Cp, { historyCommand: () => BE });
var WE, Ap, BE, Np = v(() => {
  X();
  WE = { name: "history", summary: "display command history", usage: "history [n]", options: ["-c      clear the history list", "    --help display this help and exit"] }, Ap = "BASH_HISTORY", BE = { name: "history", async execute(e2, t2) {
    if (_(e2)) return F$3(WE);
    let n2 = t2.env[Ap] || "[]", r2;
    try {
      r2 = JSON.parse(n2);
    } catch {
      r2 = [];
    }
    if (e2[0] === "-c") return t2.env[Ap] = "[]", { stdout: "", stderr: "", exitCode: 0 };
    let s2 = r2.length;
    e2[0] && /^\d+$/.test(e2[0]) && (s2 = Math.min(parseInt(e2[0], 10), r2.length));
    let i2 = r2.length - s2, o2 = "";
    for (let a = i2; a < r2.length; a++) {
      let l = (a + 1).toString().padStart(5, " ");
      o2 += `${l}  ${r2[a]}
`;
    }
    return { stdout: o2, stderr: "", exitCode: 0 };
  } };
});
var kp = {};
V(kp, { xargsCommand: () => zE });
var UE, zE, vp = v(() => {
  X();
  UE = { name: "xargs", summary: "build and execute command lines from standard input", usage: "xargs [OPTION]... [COMMAND [INITIAL-ARGS]]", options: ["-I REPLACE   replace occurrences of REPLACE with input", "-d DELIM     use DELIM as input delimiter (e.g., -d '\\n' for newline)", "-n NUM       use at most NUM arguments per command line", "-P NUM       run at most NUM processes at a time", "-0, --null   items are separated by null, not whitespace", "-t, --verbose  print commands before executing", "-r, --no-run-if-empty  do not run command if input is empty", "    --help   display this help and exit"] }, zE = { name: "xargs", async execute(e2, t2) {
    if (_(e2)) return F$3(UE);
    let n2 = null, r2 = null, s2 = null, i2 = null, o2 = false, a = false, l = false, c = 0;
    for (let y = 0; y < e2.length; y++) {
      let w = e2[y];
      if (w === "-I" && y + 1 < e2.length) n2 = e2[++y], c = y + 1;
      else if (w === "-d" && y + 1 < e2.length) r2 = e2[++y].replace(/\\n/g, `
`).replace(/\\t/g, "	").replace(/\\r/g, "\r").replace(/\\0/g, "\0").replace(/\\\\/g, "\\"), c = y + 1;
      else if (w === "-n" && y + 1 < e2.length) s2 = parseInt(e2[++y], 10), c = y + 1;
      else if (w === "-P" && y + 1 < e2.length) i2 = parseInt(e2[++y], 10), c = y + 1;
      else if (w === "-0" || w === "--null") o2 = true, c = y + 1;
      else if (w === "-t" || w === "--verbose") a = true, c = y + 1;
      else if (w === "-r" || w === "--no-run-if-empty") l = true, c = y + 1;
      else {
        if (w.startsWith("--")) return G("xargs", w);
        if (w.startsWith("-") && w.length > 1) {
          for (let E of w.slice(1)) if (!"0tr".includes(E)) return G("xargs", `-${E}`);
          w.includes("0") && (o2 = true), w.includes("t") && (a = true), w.includes("r") && (l = true), c = y + 1;
        } else if (!w.startsWith("-")) {
          c = y;
          break;
        }
      }
    }
    let u = e2.slice(c);
    u.length === 0 && u.push("echo");
    let f2;
    if (o2 ? f2 = t2.stdin.split("\0").filter((y) => y.length > 0) : r2 !== null ? f2 = t2.stdin.replace(/\n$/, "").split(r2).filter((w) => w.length > 0) : f2 = t2.stdin.split(/\s+/).map((y) => y.trim()).filter((y) => y.length > 0), f2.length === 0) return l ? { stdout: "", stderr: "", exitCode: 0 } : { stdout: "", stderr: "", exitCode: 0 };
    let p = "", d = "", m = 0, h = (y) => /[\s"'\\$`!*?[\]{}();&|<>#]/.test(y) ? `"${y.replace(/([\\"`$])/g, "\\$1")}"` : y, g = async (y) => {
      let w = y.map(h).join(" ");
      return a && (d += `${w}
`), t2.exec ? t2.exec(w, { cwd: t2.cwd }) : { stdout: `${w}
`, stderr: "", exitCode: 0 };
    }, b = async (y) => {
      if (i2 !== null && i2 > 1) for (let w = 0; w < y.length; w += i2) {
        let E = y.slice(w, w + i2), C = await Promise.all(E.map(g));
        for (let A of C) p += A.stdout, d += A.stderr, A.exitCode !== 0 && (m = A.exitCode);
      }
      else for (let w of y) {
        let E = await g(w);
        p += E.stdout, d += E.stderr, E.exitCode !== 0 && (m = E.exitCode);
      }
    };
    if (n2 !== null) {
      let y = f2.map((w) => u.map((E) => E.replaceAll(n2, w)));
      await b(y);
    } else if (s2 !== null) {
      let y = [];
      for (let w = 0; w < f2.length; w += s2) {
        let E = f2.slice(w, w + s2);
        y.push([...u, ...E]);
      }
      await b(y);
    } else {
      let y = [...u, ...f2], w = await g(y);
      p += w.stdout, d += w.stderr, m = w.exitCode;
    }
    return { stdout: p, stderr: d, exitCode: m };
  } };
});
var Ao = {};
V(Ao, { falseCommand: () => HE, trueCommand: () => jE });
var jE, HE, Co = v(() => {
  jE = { name: "true", async execute() {
    return { stdout: "", stderr: "", exitCode: 0 };
  } }, HE = { name: "false", async execute() {
    return { stdout: "", stderr: "", exitCode: 1 };
  } };
});
var $p = {};
V($p, { clearCommand: () => qE });
var VE, qE, Ip = v(() => {
  X();
  VE = { name: "clear", summary: "clear the terminal screen", usage: "clear [OPTIONS]", options: ["    --help display this help and exit"] }, qE = { name: "clear", async execute(e2, t2) {
    return _(e2) ? F$3(VE) : { stdout: "\x1B[2J\x1B[H", stderr: "", exitCode: 0 };
  } };
});
var No = {};
V(No, { bashCommand: () => GE, shCommand: () => ZE });
async function zn(e2, t2, n2, r2) {
  if (!r2.exec) return { stdout: "", stderr: `bash: internal error: exec function not available
`, exitCode: 1 };
  let s2 = { ...r2.exportedEnv || {}, 0: t2, "#": String(n2.length), "@": n2.join(" "), "*": n2.join(" ") };
  n2.forEach((a, l) => {
    s2[String(l + 1)] = a;
  });
  let i2 = e2;
  if (i2.startsWith("#!")) {
    let a = i2.indexOf(`
`);
    a !== -1 && (i2 = i2.slice(a + 1));
  }
  return await r2.exec(i2, { env: s2, cwd: r2.cwd });
}
var Rp, GE, ZE, ko = v(() => {
  X();
  Rp = { name: "bash", summary: "execute shell commands or scripts", usage: "bash [OPTIONS] [SCRIPT_FILE] [ARGUMENTS...]", options: ["-c COMMAND  execute COMMAND string", "    --help  display this help and exit"], notes: ["Without -c, reads and executes commands from SCRIPT_FILE.", "Arguments are passed as $1, $2, etc. to the script.", '$0 is set to the script name (or "bash" with -c).'] }, GE = { name: "bash", async execute(e2, t2) {
    var _a3;
    if (_(e2)) return F$3(Rp);
    if (e2[0] === "-c" && e2.length >= 2) {
      let s2 = e2[1], i2 = e2[2] || "bash", o2 = e2.slice(3);
      return zn(s2, i2, o2, t2);
    }
    if (e2.length === 0) return ((_a3 = t2.stdin) == null ? void 0 : _a3.trim()) ? zn(t2.stdin, "bash", [], t2) : { stdout: "", stderr: "", exitCode: 0 };
    let n2 = e2[0], r2 = e2.slice(1);
    try {
      let s2 = t2.fs.resolvePath(t2.cwd, n2), i2 = await t2.fs.readFile(s2);
      return zn(i2, n2, r2, t2);
    } catch {
      return { stdout: "", stderr: `bash: ${n2}: No such file or directory
`, exitCode: 127 };
    }
  } }, ZE = { name: "sh", async execute(e2, t2) {
    var _a3;
    if (_(e2)) return F$3({ ...Rp, name: "sh", summary: "execute shell commands or scripts (POSIX shell)" });
    if (e2[0] === "-c" && e2.length >= 2) {
      let s2 = e2[1], i2 = e2[2] || "sh", o2 = e2.slice(3);
      return zn(s2, i2, o2, t2);
    }
    if (e2.length === 0) return ((_a3 = t2.stdin) == null ? void 0 : _a3.trim()) ? zn(t2.stdin, "sh", [], t2) : { stdout: "", stderr: "", exitCode: 0 };
    let n2 = e2[0], r2 = e2.slice(1);
    try {
      let s2 = t2.fs.resolvePath(t2.cwd, n2), i2 = await t2.fs.readFile(s2);
      return zn(i2, n2, r2, t2);
    } catch {
      return { stdout: "", stderr: `sh: ${n2}: No such file or directory
`, exitCode: 127 };
    }
  } };
});
function vo(e2, t2, n2, r2, s2, i2, o2, a, l, c) {
  var _a3;
  switch (t2) {
    case "sort":
      return Array.isArray(e2) ? [[...e2].sort(o2)] : [null];
    case "sort_by":
      return !Array.isArray(e2) || n2.length === 0 ? [null] : [[...e2].sort((f2, p) => {
        let d = s2(f2, n2[0], r2)[0], m = s2(p, n2[0], r2)[0];
        return o2(d, m);
      })];
    case "bsearch": {
      if (!Array.isArray(e2)) {
        let f2 = e2 === null ? "null" : typeof e2 == "object" ? "object" : typeof e2;
        throw new Error(`${f2} (${JSON.stringify(e2)}) cannot be searched from`);
      }
      return n2.length === 0 ? [null] : s2(e2, n2[0], r2).map((f2) => {
        let p = 0, d = e2.length;
        for (; p < d; ) {
          let m = p + d >>> 1;
          o2(e2[m], f2) < 0 ? p = m + 1 : d = m;
        }
        return p < e2.length && o2(e2[p], f2) === 0 ? p : -p - 1;
      });
    }
    case "unique_by": {
      if (!Array.isArray(e2) || n2.length === 0) return [null];
      let u = /* @__PURE__ */ new Map();
      for (let p of e2) {
        let d = s2(p, n2[0], r2)[0], m = JSON.stringify(d);
        u.has(m) || u.set(m, { item: p, key: d });
      }
      let f2 = [...u.values()];
      return f2.sort((p, d) => o2(p.key, d.key)), [f2.map((p) => p.item)];
    }
    case "group_by": {
      if (!Array.isArray(e2) || n2.length === 0) return [null];
      let u = /* @__PURE__ */ new Map();
      for (let f2 of e2) {
        let p = JSON.stringify(s2(f2, n2[0], r2)[0]);
        u.has(p) || u.set(p, []), (_a3 = u.get(p)) == null ? void 0 : _a3.push(f2);
      }
      return [[...u.values()]];
    }
    case "max":
      return Array.isArray(e2) && e2.length > 0 ? [e2.reduce((u, f2) => o2(u, f2) > 0 ? u : f2)] : [null];
    case "max_by":
      return !Array.isArray(e2) || e2.length === 0 || n2.length === 0 ? [null] : [e2.reduce((u, f2) => {
        let p = s2(u, n2[0], r2)[0], d = s2(f2, n2[0], r2)[0];
        return o2(p, d) > 0 ? u : f2;
      })];
    case "min":
      return Array.isArray(e2) && e2.length > 0 ? [e2.reduce((u, f2) => o2(u, f2) < 0 ? u : f2)] : [null];
    case "min_by":
      return !Array.isArray(e2) || e2.length === 0 || n2.length === 0 ? [null] : [e2.reduce((u, f2) => {
        let p = s2(u, n2[0], r2)[0], d = s2(f2, n2[0], r2)[0];
        return o2(p, d) < 0 ? u : f2;
      })];
    case "add": {
      let u = (f2) => {
        let p = f2.filter((d) => d !== null);
        return p.length === 0 ? null : p.every((d) => typeof d == "number") ? p.reduce((d, m) => d + m, 0) : p.every((d) => typeof d == "string") ? p.join("") : p.every((d) => Array.isArray(d)) ? p.flat() : p.every((d) => d && typeof d == "object" && !Array.isArray(d)) ? Object.assign({}, ...p) : null;
      };
      if (n2.length >= 1) {
        let f2 = s2(e2, n2[0], r2);
        return [u(f2)];
      }
      return Array.isArray(e2) ? [u(e2)] : [null];
    }
    case "any": {
      if (n2.length >= 2) {
        try {
          let u = i2(e2, n2[0], r2);
          for (let f2 of u) if (s2(f2, n2[1], r2).some(a)) return [true];
        } catch (u) {
          if (u instanceof c) throw u;
        }
        return [false];
      }
      return n2.length === 1 ? Array.isArray(e2) ? [e2.some((u) => a(s2(u, n2[0], r2)[0]))] : [false] : Array.isArray(e2) ? [e2.some(a)] : [false];
    }
    case "all": {
      if (n2.length >= 2) {
        try {
          let u = i2(e2, n2[0], r2);
          for (let f2 of u) if (!s2(f2, n2[1], r2).some(a)) return [false];
        } catch (u) {
          if (u instanceof c) throw u;
        }
        return [true];
      }
      return n2.length === 1 ? Array.isArray(e2) ? [e2.every((u) => a(s2(u, n2[0], r2)[0]))] : [true] : Array.isArray(e2) ? [e2.every(a)] : [true];
    }
    case "select":
      return n2.length === 0 ? [e2] : s2(e2, n2[0], r2).some(a) ? [e2] : [];
    case "map":
      return n2.length === 0 || !Array.isArray(e2) ? [null] : [e2.flatMap((f2) => s2(f2, n2[0], r2))];
    case "map_values": {
      if (n2.length === 0) return [null];
      if (Array.isArray(e2)) return [e2.flatMap((u) => s2(u, n2[0], r2))];
      if (e2 && typeof e2 == "object") {
        let u = {};
        for (let [f2, p] of Object.entries(e2)) {
          let d = s2(p, n2[0], r2);
          d.length > 0 && (u[f2] = d[0]);
        }
        return [u];
      }
      return [null];
    }
    case "has": {
      if (n2.length === 0) return [false];
      let f2 = s2(e2, n2[0], r2)[0];
      return Array.isArray(e2) && typeof f2 == "number" ? [f2 >= 0 && f2 < e2.length] : e2 && typeof e2 == "object" && typeof f2 == "string" ? [f2 in e2] : [false];
    }
    case "in": {
      if (n2.length === 0) return [false];
      let f2 = s2(e2, n2[0], r2)[0];
      return Array.isArray(f2) && typeof e2 == "number" ? [e2 >= 0 && e2 < f2.length] : f2 && typeof f2 == "object" && typeof e2 == "string" ? [e2 in f2] : [false];
    }
    case "contains": {
      if (n2.length === 0) return [false];
      let u = s2(e2, n2[0], r2);
      return [l(e2, u[0])];
    }
    case "inside": {
      if (n2.length === 0) return [false];
      let u = s2(e2, n2[0], r2);
      return [l(u[0], e2)];
    }
    default:
      return null;
  }
}
var Pp = v(() => {
});
function $o(e2, t2, n2, r2, s2, i2, o2, a) {
  switch (t2) {
    case "first":
      if (n2.length > 0) try {
        let l = i2(e2, n2[0], r2);
        return l.length > 0 ? [l[0]] : [];
      } catch (l) {
        if (l instanceof a) throw l;
        return [];
      }
      return Array.isArray(e2) && e2.length > 0 ? [e2[0]] : [null];
    case "last":
      if (n2.length > 0) {
        let l = s2(e2, n2[0], r2);
        return l.length > 0 ? [l[l.length - 1]] : [];
      }
      return Array.isArray(e2) && e2.length > 0 ? [e2[e2.length - 1]] : [null];
    case "nth": {
      if (n2.length < 1) return [null];
      let l = s2(e2, n2[0], r2);
      if (n2.length > 1) {
        for (let u of l) if (u < 0) throw new Error("nth doesn't support negative indices");
        let c;
        try {
          c = i2(e2, n2[1], r2);
        } catch (u) {
          if (u instanceof a) throw u;
          c = [];
        }
        return l.flatMap((u) => {
          let f2 = u;
          return f2 < c.length ? [c[f2]] : [];
        });
      }
      return Array.isArray(e2) ? l.flatMap((c) => {
        let u = c;
        if (u < 0) throw new Error("nth doesn't support negative indices");
        return u < e2.length ? [e2[u]] : [null];
      }) : [null];
    }
    case "range": {
      if (n2.length === 0) return [];
      let l = s2(e2, n2[0], r2);
      if (n2.length === 1) {
        let p = [];
        for (let d of l) {
          let m = d;
          for (let h = 0; h < m; h++) p.push(h);
        }
        return p;
      }
      let c = s2(e2, n2[1], r2);
      if (n2.length === 2) {
        let p = [];
        for (let d of l) for (let m of c) {
          let h = d, g = m;
          for (let b = h; b < g; b++) p.push(b);
        }
        return p;
      }
      let u = s2(e2, n2[2], r2), f2 = [];
      for (let p of l) for (let d of c) for (let m of u) {
        let h = p, g = d, b = m;
        if (b !== 0) if (b > 0) for (let y = h; y < g; y += b) f2.push(y);
        else for (let y = h; y > g; y += b) f2.push(y);
      }
      return f2;
    }
    case "limit":
      return n2.length < 2 ? [] : s2(e2, n2[0], r2).flatMap((c) => {
        let u = c;
        if (u < 0) throw new Error("limit doesn't support negative count");
        if (u === 0) return [];
        let f2;
        try {
          f2 = i2(e2, n2[1], r2);
        } catch (p) {
          if (p instanceof a) throw p;
          f2 = [];
        }
        return f2.slice(0, u);
      });
    case "isempty": {
      if (n2.length < 1) return [true];
      try {
        return [i2(e2, n2[0], r2).length === 0];
      } catch (l) {
        if (l instanceof a) throw l;
        return [true];
      }
    }
    case "isvalid": {
      if (n2.length < 1) return [true];
      try {
        return [s2(e2, n2[0], r2).length > 0];
      } catch (l) {
        if (l instanceof a) throw l;
        return [false];
      }
    }
    case "skip":
      return n2.length < 2 ? [] : s2(e2, n2[0], r2).flatMap((c) => {
        let u = c;
        if (u < 0) throw new Error("skip doesn't support negative count");
        return s2(e2, n2[1], r2).slice(u);
      });
    case "until": {
      if (n2.length < 2) return [e2];
      let l = e2, c = r2.limits.maxIterations;
      for (let u = 0; u < c; u++) {
        if (s2(l, n2[0], r2).some(o2)) return [l];
        let p = s2(l, n2[1], r2);
        if (p.length === 0) return [l];
        l = p[0];
      }
      throw new a(`jq until: too many iterations (${c}), increase executionLimits.maxJqIterations`, "iterations");
    }
    case "while": {
      if (n2.length < 2) return [e2];
      let l = [], c = e2, u = r2.limits.maxIterations;
      for (let f2 = 0; f2 < u && s2(c, n2[0], r2).some(o2); f2++) {
        l.push(c);
        let d = s2(c, n2[1], r2);
        if (d.length === 0) break;
        c = d[0];
      }
      if (l.length >= u) throw new a(`jq while: too many iterations (${u}), increase executionLimits.maxJqIterations`, "iterations");
      return l;
    }
    case "repeat": {
      if (n2.length === 0) return [e2];
      let l = [], c = e2, u = r2.limits.maxIterations;
      for (let f2 = 0; f2 < u; f2++) {
        l.push(c);
        let p = s2(c, n2[0], r2);
        if (p.length === 0) break;
        c = p[0];
      }
      if (l.length >= u) throw new a(`jq repeat: too many iterations (${u}), increase executionLimits.maxJqIterations`, "iterations");
      return l;
    }
    default:
      return null;
  }
}
var Tp = v(() => {
});
function Io(e2, t2, n2, r2, s2) {
  switch (t2) {
    case "now":
      return [Date.now() / 1e3];
    case "gmtime": {
      if (typeof e2 != "number") return [null];
      let i2 = new Date(e2 * 1e3), o2 = i2.getUTCFullYear(), a = i2.getUTCMonth(), l = i2.getUTCDate(), c = i2.getUTCHours(), u = i2.getUTCMinutes(), f2 = i2.getUTCSeconds(), p = i2.getUTCDay(), d = Date.UTC(o2, 0, 1), m = Math.floor((i2.getTime() - d) / (1440 * 60 * 1e3));
      return [[o2, a, l, c, u, f2, p, m]];
    }
    case "mktime": {
      if (!Array.isArray(e2)) throw new Error("mktime requires parsed datetime inputs");
      let [i2, o2, a, l = 0, c = 0, u = 0] = e2;
      if (typeof i2 != "number" || typeof o2 != "number") throw new Error("mktime requires parsed datetime inputs");
      let f2 = Date.UTC(i2, o2, a ?? 1, l ?? 0, c ?? 0, u ?? 0);
      return [Math.floor(f2 / 1e3)];
    }
    case "strftime": {
      if (n2.length === 0) return [null];
      let o2 = s2(e2, n2[0], r2)[0];
      if (typeof o2 != "string") throw new Error("strftime/1 requires a string format");
      let a;
      if (typeof e2 == "number") a = new Date(e2 * 1e3);
      else if (Array.isArray(e2)) {
        let [p, d, m, h = 0, g = 0, b = 0] = e2;
        if (typeof p != "number" || typeof d != "number") throw new Error("strftime/1 requires parsed datetime inputs");
        a = new Date(Date.UTC(p, d, m ?? 1, h ?? 0, g ?? 0, b ?? 0));
      } else throw new Error("strftime/1 requires parsed datetime inputs");
      let l = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], c = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], u = (p, d = 2) => String(p).padStart(d, "0");
      return [o2.replace(/%Y/g, String(a.getUTCFullYear())).replace(/%m/g, u(a.getUTCMonth() + 1)).replace(/%d/g, u(a.getUTCDate())).replace(/%H/g, u(a.getUTCHours())).replace(/%M/g, u(a.getUTCMinutes())).replace(/%S/g, u(a.getUTCSeconds())).replace(/%A/g, l[a.getUTCDay()]).replace(/%B/g, c[a.getUTCMonth()]).replace(/%Z/g, "UTC").replace(/%%/g, "%")];
    }
    case "strptime": {
      if (n2.length === 0) return [null];
      if (typeof e2 != "string") throw new Error("strptime/1 requires a string input");
      let o2 = s2(e2, n2[0], r2)[0];
      if (typeof o2 != "string") throw new Error("strptime/1 requires a string format");
      if (o2 === "%Y-%m-%dT%H:%M:%SZ") {
        let l = e2.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})Z$/);
        if (l) {
          let [, c, u, f2, p, d, m] = l.map(Number), h = new Date(Date.UTC(c, u - 1, f2, p, d, m)), g = h.getUTCDay(), b = Date.UTC(c, 0, 1), y = Math.floor((h.getTime() - b) / (1440 * 60 * 1e3));
          return [[c, u - 1, f2, p, d, m, g, y]];
        }
      }
      let a = new Date(e2);
      if (!Number.isNaN(a.getTime())) {
        let l = a.getUTCFullYear(), c = a.getUTCMonth(), u = a.getUTCDate(), f2 = a.getUTCHours(), p = a.getUTCMinutes(), d = a.getUTCSeconds(), m = a.getUTCDay(), h = Date.UTC(l, 0, 1), g = Math.floor((a.getTime() - h) / (1440 * 60 * 1e3));
        return [[l, c, u, f2, p, d, m, g]];
      }
      throw new Error(`Cannot parse date: ${e2}`);
    }
    case "fromdate": {
      if (typeof e2 != "string") throw new Error("fromdate requires a string input");
      let i2 = new Date(e2);
      if (Number.isNaN(i2.getTime())) throw new Error(`date "${e2}" does not match format "%Y-%m-%dT%H:%M:%SZ"`);
      return [Math.floor(i2.getTime() / 1e3)];
    }
    case "todate": {
      if (typeof e2 != "number") throw new Error("todate requires a number input");
      return [new Date(e2 * 1e3).toISOString().replace(/\.\d{3}Z$/, "Z")];
    }
    default:
      return null;
  }
}
var Op = v(() => {
});
function vt(e2) {
  return e2 !== false && e2 !== null;
}
function jn(e2, t2) {
  return JSON.stringify(e2) === JSON.stringify(t2);
}
function Nr(e2, t2) {
  return typeof e2 == "number" && typeof t2 == "number" ? e2 - t2 : typeof e2 == "string" && typeof t2 == "string" ? e2.localeCompare(t2) : 0;
}
function Ro(e2, t2) {
  let n2 = { ...e2 };
  for (let r2 of Object.keys(t2)) r2 in n2 && n2[r2] && typeof n2[r2] == "object" && !Array.isArray(n2[r2]) && t2[r2] && typeof t2[r2] == "object" && !Array.isArray(t2[r2]) ? n2[r2] = Ro(n2[r2], t2[r2]) : n2[r2] = t2[r2];
  return n2;
}
function Hn(e2, t2 = 3e3) {
  let n2 = 0, r2 = e2;
  for (; n2 < t2; ) if (Array.isArray(r2)) {
    if (r2.length === 0) return n2 + 1;
    r2 = r2[0], n2++;
  } else if (r2 !== null && typeof r2 == "object") {
    let s2 = Object.keys(r2);
    if (s2.length === 0) return n2 + 1;
    r2 = r2[s2[0]], n2++;
  } else return n2;
  return n2;
}
function Cs(e2, t2) {
  let n2 = (i2) => i2 === null ? 0 : typeof i2 == "boolean" ? 1 : typeof i2 == "number" ? 2 : typeof i2 == "string" ? 3 : Array.isArray(i2) ? 4 : typeof i2 == "object" ? 5 : 6, r2 = n2(e2), s2 = n2(t2);
  if (r2 !== s2) return r2 - s2;
  if (typeof e2 == "number" && typeof t2 == "number") return e2 - t2;
  if (typeof e2 == "string" && typeof t2 == "string") return e2.localeCompare(t2);
  if (typeof e2 == "boolean" && typeof t2 == "boolean") return (e2 ? 1 : 0) - (t2 ? 1 : 0);
  if (Array.isArray(e2) && Array.isArray(t2)) {
    for (let i2 = 0; i2 < Math.min(e2.length, t2.length); i2++) {
      let o2 = Cs(e2[i2], t2[i2]);
      if (o2 !== 0) return o2;
    }
    return e2.length - t2.length;
  }
  if (e2 && t2 && typeof e2 == "object" && typeof t2 == "object") {
    let i2 = e2, o2 = t2, a = Object.keys(i2).sort(), l = Object.keys(o2).sort();
    for (let c = 0; c < Math.min(a.length, l.length); c++) {
      let u = a[c].localeCompare(l[c]);
      if (u !== 0) return u;
    }
    if (a.length !== l.length) return a.length - l.length;
    for (let c of a) {
      let u = Cs(i2[c], o2[c]);
      if (u !== 0) return u;
    }
  }
  return 0;
}
function Ns(e2, t2) {
  if (jn(e2, t2)) return true;
  if (typeof e2 == "string" && typeof t2 == "string") return e2.includes(t2);
  if (Array.isArray(e2) && Array.isArray(t2)) return t2.every((n2) => e2.some((r2) => Ns(r2, n2)));
  if (e2 && t2 && typeof e2 == "object" && typeof t2 == "object" && !Array.isArray(e2) && !Array.isArray(t2)) {
    let n2 = e2, r2 = t2;
    return Object.keys(r2).every((s2) => s2 in n2 && Ns(n2[s2], r2[s2]));
  }
  return false;
}
var ks = v(() => {
});
function Po(e2, t2, n2) {
  switch (t2) {
    case "@base64":
      return typeof e2 == "string" ? typeof Buffer < "u" ? [Buffer.from(e2, "utf-8").toString("base64")] : [btoa(e2)] : [null];
    case "@base64d":
      return typeof e2 == "string" ? typeof Buffer < "u" ? [Buffer.from(e2, "base64").toString("utf-8")] : [atob(e2)] : [null];
    case "@uri":
      return typeof e2 == "string" ? [encodeURIComponent(e2).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A")] : [null];
    case "@urid":
      return typeof e2 == "string" ? [decodeURIComponent(e2)] : [null];
    case "@csv":
      return Array.isArray(e2) ? [e2.map((s2) => {
        if (s2 === null) return "";
        if (typeof s2 == "boolean") return s2 ? "true" : "false";
        if (typeof s2 == "number") return String(s2);
        let i2 = String(s2);
        return i2.includes(",") || i2.includes('"') || i2.includes(`
`) || i2.includes("\r") ? `"${i2.replace(/"/g, '""')}"` : i2;
      }).join(",")] : [null];
    case "@tsv":
      return Array.isArray(e2) ? [e2.map((r2) => String(r2 ?? "").replace(/\t/g, "\\t").replace(/\n/g, "\\n")).join("	")] : [null];
    case "@json": {
      let r2 = n2 ?? QE;
      return Hn(e2, r2 + 1) > r2 ? [null] : [JSON.stringify(e2)];
    }
    case "@html":
      return typeof e2 == "string" ? [e2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;")] : [null];
    case "@sh":
      return typeof e2 == "string" ? [`'${e2.replace(/'/g, "'\\''")}'`] : [null];
    case "@text":
      return typeof e2 == "string" ? [e2] : e2 == null ? [""] : [String(e2)];
    default:
      return null;
  }
}
var QE, Dp = v(() => {
  ks();
  QE = 2e3;
});
function To(e2, t2, n2, r2, s2, i2) {
  switch (t2) {
    case "index":
      return n2.length === 0 ? [null] : s2(e2, n2[0], r2).map((a) => {
        if (typeof e2 == "string" && typeof a == "string") {
          if (a === "" && e2 === "") return null;
          let l = e2.indexOf(a);
          return l >= 0 ? l : null;
        }
        if (Array.isArray(e2)) {
          if (Array.isArray(a)) {
            for (let c = 0; c <= e2.length - a.length; c++) {
              let u = true;
              for (let f2 = 0; f2 < a.length; f2++) if (!i2(e2[c + f2], a[f2])) {
                u = false;
                break;
              }
              if (u) return c;
            }
            return null;
          }
          let l = e2.findIndex((c) => i2(c, a));
          return l >= 0 ? l : null;
        }
        return null;
      });
    case "rindex":
      return n2.length === 0 ? [null] : s2(e2, n2[0], r2).map((a) => {
        if (typeof e2 == "string" && typeof a == "string") {
          let l = e2.lastIndexOf(a);
          return l >= 0 ? l : null;
        }
        if (Array.isArray(e2)) {
          if (Array.isArray(a)) {
            for (let l = e2.length - a.length; l >= 0; l--) {
              let c = true;
              for (let u = 0; u < a.length; u++) if (!i2(e2[l + u], a[u])) {
                c = false;
                break;
              }
              if (c) return l;
            }
            return null;
          }
          for (let l = e2.length - 1; l >= 0; l--) if (i2(e2[l], a)) return l;
          return null;
        }
        return null;
      });
    case "indices":
      return n2.length === 0 ? [[]] : s2(e2, n2[0], r2).map((a) => {
        let l = [];
        if (typeof e2 == "string" && typeof a == "string") {
          let c = e2.indexOf(a);
          for (; c !== -1; ) l.push(c), c = e2.indexOf(a, c + 1);
        } else if (Array.isArray(e2)) if (Array.isArray(a)) {
          let c = a.length;
          if (c === 0) for (let u = 0; u <= e2.length; u++) l.push(u);
          else for (let u = 0; u <= e2.length - c; u++) {
            let f2 = true;
            for (let p = 0; p < c; p++) if (!i2(e2[u + p], a[p])) {
              f2 = false;
              break;
            }
            f2 && l.push(u);
          }
        } else for (let c = 0; c < e2.length; c++) i2(e2[c], a) && l.push(c);
        return l;
      });
    default:
      return null;
  }
}
var Fp = v(() => {
});
function Oo(e2, t2, n2, r2, s2) {
  switch (t2) {
    case "fabs":
    case "abs":
      return typeof e2 == "number" ? [Math.abs(e2)] : typeof e2 == "string" ? [e2] : [null];
    case "exp10":
      return typeof e2 == "number" ? [10 ** e2] : [null];
    case "exp2":
      return typeof e2 == "number" ? [2 ** e2] : [null];
    case "pow": {
      if (n2.length < 2) return [null];
      let i2 = s2(e2, n2[0], r2), o2 = s2(e2, n2[1], r2), a = i2[0], l = o2[0];
      return typeof a != "number" || typeof l != "number" ? [null] : [a ** l];
    }
    case "atan2": {
      if (n2.length < 2) return [null];
      let i2 = s2(e2, n2[0], r2), o2 = s2(e2, n2[1], r2), a = i2[0], l = o2[0];
      return typeof a != "number" || typeof l != "number" ? [null] : [Math.atan2(a, l)];
    }
    case "hypot": {
      if (typeof e2 != "number" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2)[0];
      return [Math.hypot(e2, i2)];
    }
    case "fma": {
      if (typeof e2 != "number" || n2.length < 2) return [null];
      let i2 = s2(e2, n2[0], r2)[0], o2 = s2(e2, n2[1], r2)[0];
      return [e2 * i2 + o2];
    }
    case "copysign": {
      if (typeof e2 != "number" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2)[0];
      return [Math.sign(i2) * Math.abs(e2)];
    }
    case "drem":
    case "remainder": {
      if (typeof e2 != "number" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2)[0];
      return [e2 - Math.round(e2 / i2) * i2];
    }
    case "fdim": {
      if (typeof e2 != "number" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2)[0];
      return [Math.max(0, e2 - i2)];
    }
    case "fmax": {
      if (typeof e2 != "number" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2)[0];
      return [Math.max(e2, i2)];
    }
    case "fmin": {
      if (typeof e2 != "number" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2)[0];
      return [Math.min(e2, i2)];
    }
    case "ldexp": {
      if (typeof e2 != "number" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2)[0];
      return [e2 * 2 ** i2];
    }
    case "scalbn":
    case "scalbln": {
      if (typeof e2 != "number" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2)[0];
      return [e2 * 2 ** i2];
    }
    case "nearbyint":
      return typeof e2 == "number" ? [Math.round(e2)] : [null];
    case "logb":
      return typeof e2 == "number" ? [Math.floor(Math.log2(Math.abs(e2)))] : [null];
    case "significand":
      if (typeof e2 == "number") {
        let i2 = Math.floor(Math.log2(Math.abs(e2)));
        return [e2 / 2 ** i2];
      }
      return [null];
    case "frexp":
      if (typeof e2 == "number") {
        if (e2 === 0) return [[0, 0]];
        let i2 = Math.floor(Math.log2(Math.abs(e2))) + 1;
        return [[e2 / 2 ** i2, i2]];
      }
      return [null];
    case "modf":
      if (typeof e2 == "number") {
        let i2 = Math.trunc(e2);
        return [[e2 - i2, i2]];
      }
      return [null];
    default:
      return null;
  }
}
var _p = v(() => {
});
function Do(e2, t2, n2, r2, s2, i2, o2, a) {
  switch (t2) {
    case "recurse": {
      if (n2.length === 0) {
        let d = [], m = (h) => {
          if (d.push(h), Array.isArray(h)) for (let g of h) m(g);
          else if (h && typeof h == "object") for (let g of Object.keys(h)) m(h[g]);
        };
        return m(e2), d;
      }
      let l = [], c = n2.length >= 2 ? n2[1] : null, u = 1e4, f2 = 0, p = (d) => {
        if (f2++ > u || c && !s2(d, c, r2).some(i2)) return;
        l.push(d);
        let m = s2(d, n2[0], r2);
        for (let h of m) h != null && p(h);
      };
      return p(e2), l;
    }
    case "recurse_down":
      return a(e2, "recurse", n2, r2);
    case "walk": {
      if (n2.length === 0) return [e2];
      let l = /* @__PURE__ */ new WeakSet(), c = (u) => {
        if (u && typeof u == "object") {
          if (l.has(u)) return u;
          l.add(u);
        }
        let f2;
        if (Array.isArray(u)) f2 = u.map(c);
        else if (u && typeof u == "object") {
          let d = {};
          for (let [m, h] of Object.entries(u)) d[m] = c(h);
          f2 = d;
        } else f2 = u;
        return s2(f2, n2[0], r2)[0];
      };
      return [c(e2)];
    }
    case "transpose": {
      if (!Array.isArray(e2)) return [null];
      if (e2.length === 0) return [[]];
      let l = Math.max(...e2.map((u) => Array.isArray(u) ? u.length : 0)), c = [];
      for (let u = 0; u < l; u++) c.push(e2.map((f2) => Array.isArray(f2) ? f2[u] : null));
      return [c];
    }
    case "combinations": {
      if (n2.length > 0) {
        let f2 = s2(e2, n2[0], r2)[0];
        if (!Array.isArray(e2) || f2 < 0) return [];
        if (f2 === 0) return [[]];
        let p = [], d = (m, h) => {
          if (h === f2) {
            p.push([...m]);
            return;
          }
          for (let g of e2) m.push(g), d(m, h + 1), m.pop();
        };
        return d([], 0), p;
      }
      if (!Array.isArray(e2)) return [];
      if (e2.length === 0) return [[]];
      for (let u of e2) if (!Array.isArray(u)) return [];
      let l = [], c = (u, f2) => {
        if (u === e2.length) {
          l.push([...f2]);
          return;
        }
        let p = e2[u];
        for (let d of p) f2.push(d), c(u + 1, f2), f2.pop();
      };
      return c(0, []), l;
    }
    case "parent": {
      if (r2.root === void 0 || r2.currentPath === void 0) return [];
      let l = r2.currentPath;
      if (l.length === 0) return [];
      let c = n2.length > 0 ? s2(e2, n2[0], r2)[0] : 1;
      if (c >= 0) {
        if (c > l.length) return [];
        let u = l.slice(0, l.length - c);
        return [o2(r2.root, u)];
      } else {
        let u = -c - 1;
        if (u >= l.length) return [e2];
        let f2 = l.slice(0, u);
        return [o2(r2.root, f2)];
      }
    }
    case "parents": {
      if (r2.root === void 0 || r2.currentPath === void 0) return [[]];
      let l = r2.currentPath, c = [];
      for (let u = l.length - 1; u >= 0; u--) c.push(o2(r2.root, l.slice(0, u)));
      return [c];
    }
    case "root":
      return r2.root !== void 0 ? [r2.root] : [];
    default:
      return null;
  }
}
var Lp = v(() => {
});
function Fo(e2, t2, n2, r2, s2) {
  switch (t2) {
    case "keys":
      return Array.isArray(e2) ? [e2.map((i2, o2) => o2)] : e2 && typeof e2 == "object" ? [Object.keys(e2).sort()] : [null];
    case "keys_unsorted":
      return Array.isArray(e2) ? [e2.map((i2, o2) => o2)] : e2 && typeof e2 == "object" ? [Object.keys(e2)] : [null];
    case "length":
      return typeof e2 == "string" ? [e2.length] : Array.isArray(e2) ? [e2.length] : e2 && typeof e2 == "object" ? [Object.keys(e2).length] : e2 === null ? [0] : typeof e2 == "number" ? [Math.abs(e2)] : [null];
    case "utf8bytelength": {
      if (typeof e2 == "string") return [new TextEncoder().encode(e2).length];
      let i2 = e2 === null ? "null" : Array.isArray(e2) ? "array" : typeof e2, o2 = i2 === "array" || i2 === "object" ? JSON.stringify(e2) : String(e2);
      throw new Error(`${i2} (${o2}) only strings have UTF-8 byte length`);
    }
    case "to_entries":
      return e2 && typeof e2 == "object" && !Array.isArray(e2) ? [Object.entries(e2).map(([i2, o2]) => ({ key: i2, value: o2 }))] : [null];
    case "from_entries":
      if (Array.isArray(e2)) {
        let i2 = {};
        for (let o2 of e2) if (o2 && typeof o2 == "object") {
          let a = o2, l = a.key ?? a.Key ?? a.name ?? a.Name ?? a.k, c = a.value ?? a.Value ?? a.v;
          l !== void 0 && (i2[String(l)] = c);
        }
        return [i2];
      }
      return [null];
    case "with_entries": {
      if (n2.length === 0) return [e2];
      if (e2 && typeof e2 == "object" && !Array.isArray(e2)) {
        let o2 = Object.entries(e2).map(([l, c]) => ({ key: l, value: c })).flatMap((l) => s2(l, n2[0], r2)), a = {};
        for (let l of o2) if (l && typeof l == "object") {
          let c = l, u = c.key ?? c.name ?? c.k, f2 = c.value ?? c.v;
          u !== void 0 && (a[String(u)] = f2);
        }
        return [a];
      }
      return [null];
    }
    case "reverse":
      return Array.isArray(e2) ? [[...e2].reverse()] : typeof e2 == "string" ? [e2.split("").reverse().join("")] : [null];
    case "flatten":
      return Array.isArray(e2) ? (n2.length > 0 ? s2(e2, n2[0], r2) : [Number.POSITIVE_INFINITY]).map((o2) => {
        let a = o2;
        if (a < 0) throw new Error("flatten depth must not be negative");
        return e2.flat(a);
      }) : [null];
    case "unique":
      if (Array.isArray(e2)) {
        let i2 = /* @__PURE__ */ new Set(), o2 = [];
        for (let a of e2) {
          let l = JSON.stringify(a);
          i2.has(l) || (i2.add(l), o2.push(a));
        }
        return [o2];
      }
      return [null];
    case "tojson":
    case "tojsonstream": {
      let i2 = r2.limits.maxDepth ?? KE;
      return Hn(e2, i2 + 1) > i2 ? [null] : [JSON.stringify(e2)];
    }
    case "fromjson": {
      if (typeof e2 == "string") {
        let i2 = e2.trim().toLowerCase();
        if (i2 === "nan") return [Number.NaN];
        if (i2 === "inf" || i2 === "infinity") return [Number.POSITIVE_INFINITY];
        if (i2 === "-inf" || i2 === "-infinity") return [Number.NEGATIVE_INFINITY];
        try {
          return [JSON.parse(e2)];
        } catch {
          throw new Error(`Invalid JSON: ${e2}`);
        }
      }
      return [e2];
    }
    case "tostring":
      return typeof e2 == "string" ? [e2] : [JSON.stringify(e2)];
    case "tonumber":
      if (typeof e2 == "number") return [e2];
      if (typeof e2 == "string") {
        let i2 = Number(e2);
        if (Number.isNaN(i2)) throw new Error(`${JSON.stringify(e2)} cannot be parsed as a number`);
        return [i2];
      }
      throw new Error(`${typeof e2} cannot be parsed as a number`);
    case "toboolean": {
      if (typeof e2 == "boolean") return [e2];
      if (typeof e2 == "string") {
        if (e2 === "true") return [true];
        if (e2 === "false") return [false];
        throw new Error(`string (${JSON.stringify(e2)}) cannot be parsed as a boolean`);
      }
      let i2 = e2 === null ? "null" : Array.isArray(e2) ? "array" : typeof e2, o2 = i2 === "array" || i2 === "object" ? JSON.stringify(e2) : String(e2);
      throw new Error(`${i2} (${o2}) cannot be parsed as a boolean`);
    }
    case "tostream": {
      let i2 = [], o2 = (a, l) => {
        if (a === null || typeof a != "object") i2.push([l, a]);
        else if (Array.isArray(a)) if (a.length === 0) i2.push([l, []]);
        else for (let c = 0; c < a.length; c++) o2(a[c], [...l, c]);
        else {
          let c = Object.keys(a);
          if (c.length === 0) i2.push([l, {}]);
          else for (let u of c) o2(a[u], [...l, u]);
        }
      };
      return o2(e2, []), i2.push([[]]), i2;
    }
    case "fromstream": {
      if (n2.length === 0) return [e2];
      let i2 = s2(e2, n2[0], r2), o2 = null;
      for (let a of i2) {
        if (!Array.isArray(a) || a.length === 1 && Array.isArray(a[0]) && a[0].length === 0 || a.length !== 2) continue;
        let [l, c] = a;
        if (!Array.isArray(l)) continue;
        if (l.length === 0) {
          o2 = c;
          continue;
        }
        o2 === null && (o2 = typeof l[0] == "number" ? [] : {});
        let u = o2;
        for (let p = 0; p < l.length - 1; p++) {
          let d = l[p], m = l[p + 1];
          if (Array.isArray(u) && typeof d == "number") {
            for (; u.length <= d; ) u.push(null);
            u[d] === null && (u[d] = typeof m == "number" ? [] : {}), u = u[d];
          } else if (u && typeof u == "object" && !Array.isArray(u)) {
            let h = u;
            (h[String(d)] === null || h[String(d)] === void 0) && (h[String(d)] = typeof m == "number" ? [] : {}), u = h[String(d)];
          }
        }
        let f2 = l[l.length - 1];
        if (Array.isArray(u) && typeof f2 == "number") {
          for (; u.length <= f2; ) u.push(null);
          u[f2] = c;
        } else u && typeof u == "object" && !Array.isArray(u) && (u[String(f2)] = c);
      }
      return [o2];
    }
    case "truncate_stream": {
      let i2 = typeof e2 == "number" ? Math.floor(e2) : 0;
      if (n2.length === 0) return [];
      let o2 = [], a = s2(e2, n2[0], r2);
      for (let l of a) if (Array.isArray(l)) {
        if (l.length === 1 && Array.isArray(l[0])) {
          let c = l[0];
          c.length > i2 && o2.push([c.slice(i2)]);
          continue;
        }
        if (l.length === 2 && Array.isArray(l[0])) {
          let c = l[0], u = l[1];
          c.length > i2 && o2.push([c.slice(i2), u]);
        }
      }
      return o2;
    }
    default:
      return null;
  }
}
var KE, Mp = v(() => {
  ks();
  KE = 2e3;
});
function _o(e2, t2, n2, r2, s2, i2, o2, a, l, c) {
  switch (t2) {
    case "getpath": {
      if (n2.length === 0) return [null];
      let u = s2(e2, n2[0], r2), f2 = [];
      for (let p of u) {
        let d = p, m = e2;
        for (let h of d) {
          if (m == null) {
            m = null;
            break;
          }
          if (Array.isArray(m) && typeof h == "number") m = m[h];
          else if (typeof m == "object" && typeof h == "string") m = m[h];
          else {
            m = null;
            break;
          }
        }
        f2.push(m);
      }
      return f2;
    }
    case "setpath": {
      if (n2.length < 2) return [null];
      let f2 = s2(e2, n2[0], r2)[0], d = s2(e2, n2[1], r2)[0];
      return [o2(e2, f2, d)];
    }
    case "delpaths": {
      if (n2.length === 0) return [e2];
      let f2 = s2(e2, n2[0], r2)[0], p = e2;
      for (let d of f2.sort((m, h) => h.length - m.length)) p = a(p, d);
      return [p];
    }
    case "path": {
      if (n2.length === 0) return [[]];
      let u = [];
      return c(e2, n2[0], r2, [], u), u;
    }
    case "del":
      return n2.length === 0 ? [e2] : [l(e2, n2[0], r2)];
    case "pick": {
      if (n2.length === 0) return [null];
      let u = [];
      for (let p of n2) c(e2, p, r2, [], u);
      let f2 = null;
      for (let p of u) {
        for (let m of p) if (typeof m == "number" && m < 0) throw new Error("Out of bounds negative array index");
        let d = e2;
        for (let m of p) {
          if (d == null) break;
          if (Array.isArray(d) && typeof m == "number") d = d[m];
          else if (typeof d == "object" && typeof m == "string") d = d[m];
          else {
            d = null;
            break;
          }
        }
        f2 = o2(f2, p, d);
      }
      return [f2];
    }
    case "paths": {
      let u = [], f2 = (p, d) => {
        if (p && typeof p == "object") if (Array.isArray(p)) for (let m = 0; m < p.length; m++) u.push([...d, m]), f2(p[m], [...d, m]);
        else for (let m of Object.keys(p)) u.push([...d, m]), f2(p[m], [...d, m]);
      };
      return f2(e2, []), n2.length > 0 ? u.filter((p) => {
        let d = e2;
        for (let h of p) if (Array.isArray(d) && typeof h == "number") d = d[h];
        else if (d && typeof d == "object" && typeof h == "string") d = d[h];
        else return false;
        return s2(d, n2[0], r2).some(i2);
      }) : u;
    }
    case "leaf_paths": {
      let u = [], f2 = (p, d) => {
        if (p === null || typeof p != "object") u.push(d);
        else if (Array.isArray(p)) for (let m = 0; m < p.length; m++) f2(p[m], [...d, m]);
        else for (let m of Object.keys(p)) f2(p[m], [...d, m]);
      };
      return f2(e2, []), u;
    }
    default:
      return null;
  }
}
var Wp = v(() => {
});
function Lo(e2, t2, n2, r2, s2, i2) {
  switch (t2) {
    case "IN": {
      if (n2.length === 0) return [false];
      if (n2.length === 1) {
        let c = s2(e2, n2[0], r2);
        for (let u of c) if (i2(e2, u)) return [true];
        return [false];
      }
      let o2 = s2(e2, n2[0], r2), a = s2(e2, n2[1], r2), l = new Set(a.map((c) => JSON.stringify(c)));
      for (let c of o2) if (l.has(JSON.stringify(c))) return [true];
      return [false];
    }
    case "INDEX": {
      if (n2.length === 0) return [{}];
      if (n2.length === 1) {
        let l = s2(e2, n2[0], r2), c = {};
        for (let u of l) {
          let f2 = String(u);
          c[f2] = u;
        }
        return [c];
      }
      if (n2.length === 2) {
        let l = s2(e2, n2[0], r2), c = {};
        for (let u of l) {
          let f2 = s2(u, n2[1], r2);
          if (f2.length > 0) {
            let p = String(f2[0]);
            c[p] = u;
          }
        }
        return [c];
      }
      let o2 = s2(e2, n2[0], r2), a = {};
      for (let l of o2) {
        let c = s2(l, n2[1], r2), u = s2(l, n2[2], r2);
        if (c.length > 0 && u.length > 0) {
          let f2 = String(c[0]);
          a[f2] = u[0];
        }
      }
      return [a];
    }
    case "JOIN": {
      if (n2.length < 2) return [null];
      let o2 = s2(e2, n2[0], r2)[0];
      if (!o2 || typeof o2 != "object" || Array.isArray(o2)) return [null];
      let a = o2;
      if (!Array.isArray(e2)) return [null];
      let l = [];
      for (let c of e2) {
        let u = s2(c, n2[1], r2), f2 = u.length > 0 ? String(u[0]) : "", p = f2 in a ? a[f2] : null;
        l.push([c, p]);
      }
      return [l];
    }
    default:
      return null;
  }
}
var Bp = v(() => {
});
function Mo(e2, t2, n2, r2, s2) {
  switch (t2) {
    case "join": {
      if (!Array.isArray(e2)) return [null];
      let i2 = n2.length > 0 ? s2(e2, n2[0], r2) : [""];
      for (let o2 of e2) if (Array.isArray(o2) || o2 !== null && typeof o2 == "object") throw new Error("cannot join: contains arrays or objects");
      return i2.map((o2) => e2.map((a) => a === null ? "" : typeof a == "string" ? a : String(a)).join(String(o2)));
    }
    case "split": {
      if (typeof e2 != "string" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2), o2 = String(i2[0]);
      return [e2.split(o2)];
    }
    case "splits": {
      if (typeof e2 != "string" || n2.length === 0) return [];
      let i2 = s2(e2, n2[0], r2), o2 = String(i2[0]);
      try {
        let a = n2.length > 1 ? String(s2(e2, n2[1], r2)[0]) : "g", l = new RegExp(o2, a.includes("g") ? a : `${a}g`);
        return e2.split(l);
      } catch {
        return [];
      }
    }
    case "scan": {
      if (typeof e2 != "string" || n2.length === 0) return [];
      let i2 = s2(e2, n2[0], r2), o2 = String(i2[0]);
      try {
        let a = n2.length > 1 ? String(s2(e2, n2[1], r2)[0]) : "", l = new RegExp(o2, a.includes("g") ? a : `${a}g`);
        return [...e2.matchAll(l)].map((u) => u.length > 1 ? u.slice(1) : u[0]);
      } catch {
        return [];
      }
    }
    case "test": {
      if (typeof e2 != "string" || n2.length === 0) return [false];
      let i2 = s2(e2, n2[0], r2), o2 = String(i2[0]);
      try {
        let a = n2.length > 1 ? String(s2(e2, n2[1], r2)[0]) : "";
        return [new RegExp(o2, a).test(e2)];
      } catch {
        return [false];
      }
    }
    case "match": {
      if (typeof e2 != "string" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2), o2 = String(i2[0]);
      try {
        let a = n2.length > 1 ? String(s2(e2, n2[1], r2)[0]) : "", c = new RegExp(o2, `${a}d`).exec(e2);
        if (!c) return [];
        let u = c.indices;
        return [{ offset: c.index, length: c[0].length, string: c[0], captures: c.slice(1).map((f2, p) => {
          var _a3;
          return { offset: ((_a3 = u == null ? void 0 : u[p + 1]) == null ? void 0 : _a3[0]) ?? null, length: (f2 == null ? void 0 : f2.length) ?? 0, string: f2 ?? "", name: null };
        }) }];
      } catch {
        return [null];
      }
    }
    case "capture": {
      if (typeof e2 != "string" || n2.length === 0) return [null];
      let i2 = s2(e2, n2[0], r2), o2 = String(i2[0]);
      try {
        let a = n2.length > 1 ? String(s2(e2, n2[1], r2)[0]) : "", l = new RegExp(o2, a), c = e2.match(l);
        return !c || !c.groups ? [{}] : [c.groups];
      } catch {
        return [null];
      }
    }
    case "sub": {
      if (typeof e2 != "string" || n2.length < 2) return [null];
      let i2 = s2(e2, n2[0], r2), o2 = s2(e2, n2[1], r2), a = String(i2[0]), l = String(o2[0]);
      try {
        let c = n2.length > 2 ? String(s2(e2, n2[2], r2)[0]) : "";
        return [e2.replace(new RegExp(a, c), l)];
      } catch {
        return [e2];
      }
    }
    case "gsub": {
      if (typeof e2 != "string" || n2.length < 2) return [null];
      let i2 = s2(e2, n2[0], r2), o2 = s2(e2, n2[1], r2), a = String(i2[0]), l = String(o2[0]);
      try {
        let c = n2.length > 2 ? String(s2(e2, n2[2], r2)[0]) : "g", u = c.includes("g") ? c : `${c}g`;
        return [e2.replace(new RegExp(a, u), l)];
      } catch {
        return [e2];
      }
    }
    case "ascii_downcase":
      return typeof e2 == "string" ? [e2.replace(/[A-Z]/g, (i2) => String.fromCharCode(i2.charCodeAt(0) + 32))] : [null];
    case "ascii_upcase":
      return typeof e2 == "string" ? [e2.replace(/[a-z]/g, (i2) => String.fromCharCode(i2.charCodeAt(0) - 32))] : [null];
    case "ltrimstr": {
      if (typeof e2 != "string" || n2.length === 0) return [e2];
      let i2 = s2(e2, n2[0], r2), o2 = String(i2[0]);
      return [e2.startsWith(o2) ? e2.slice(o2.length) : e2];
    }
    case "rtrimstr": {
      if (typeof e2 != "string" || n2.length === 0) return [e2];
      let i2 = s2(e2, n2[0], r2), o2 = String(i2[0]);
      return o2 === "" ? [e2] : [e2.endsWith(o2) ? e2.slice(0, -o2.length) : e2];
    }
    case "trimstr": {
      if (typeof e2 != "string" || n2.length === 0) return [e2];
      let i2 = s2(e2, n2[0], r2), o2 = String(i2[0]);
      if (o2 === "") return [e2];
      let a = e2;
      return a.startsWith(o2) && (a = a.slice(o2.length)), a.endsWith(o2) && (a = a.slice(0, -o2.length)), [a];
    }
    case "trim":
      if (typeof e2 == "string") return [e2.trim()];
      throw new Error("trim input must be a string");
    case "ltrim":
      if (typeof e2 == "string") return [e2.trimStart()];
      throw new Error("trim input must be a string");
    case "rtrim":
      if (typeof e2 == "string") return [e2.trimEnd()];
      throw new Error("trim input must be a string");
    case "startswith": {
      if (typeof e2 != "string" || n2.length === 0) return [false];
      let i2 = s2(e2, n2[0], r2);
      return [e2.startsWith(String(i2[0]))];
    }
    case "endswith": {
      if (typeof e2 != "string" || n2.length === 0) return [false];
      let i2 = s2(e2, n2[0], r2);
      return [e2.endsWith(String(i2[0]))];
    }
    case "ascii":
      return typeof e2 == "string" && e2.length > 0 ? [e2.charCodeAt(0)] : [null];
    case "explode":
      return typeof e2 == "string" ? [Array.from(e2).map((i2) => i2.codePointAt(0))] : [null];
    case "implode":
      if (!Array.isArray(e2)) throw new Error("implode input must be an array");
      return [e2.map((a) => {
        if (typeof a == "string") throw new Error(`string (${JSON.stringify(a)}) can't be imploded, unicode codepoint needs to be numeric`);
        if (typeof a != "number" || Number.isNaN(a)) throw new Error("number (null) can't be imploded, unicode codepoint needs to be numeric");
        let l = Math.trunc(a);
        return l < 0 || l > 1114111 || l >= 55296 && l <= 57343 ? String.fromCodePoint(65533) : String.fromCodePoint(l);
      }).join("")];
    default:
      return null;
  }
}
var Up = v(() => {
});
function Wo(e2, t2) {
  switch (t2) {
    case "type":
      return e2 === null ? ["null"] : Array.isArray(e2) ? ["array"] : typeof e2 == "boolean" ? ["boolean"] : typeof e2 == "number" ? ["number"] : typeof e2 == "string" ? ["string"] : typeof e2 == "object" ? ["object"] : ["null"];
    case "infinite":
      return [Number.POSITIVE_INFINITY];
    case "nan":
      return [Number.NaN];
    case "isinfinite":
      return [typeof e2 == "number" && !Number.isFinite(e2)];
    case "isnan":
      return [typeof e2 == "number" && Number.isNaN(e2)];
    case "isnormal":
      return [typeof e2 == "number" && Number.isFinite(e2) && e2 !== 0];
    case "isfinite":
      return [typeof e2 == "number" && Number.isFinite(e2)];
    case "numbers":
      return typeof e2 == "number" ? [e2] : [];
    case "strings":
      return typeof e2 == "string" ? [e2] : [];
    case "booleans":
      return typeof e2 == "boolean" ? [e2] : [];
    case "nulls":
      return e2 === null ? [e2] : [];
    case "arrays":
      return Array.isArray(e2) ? [e2] : [];
    case "objects":
      return e2 && typeof e2 == "object" && !Array.isArray(e2) ? [e2] : [];
    case "iterables":
      return Array.isArray(e2) || e2 && typeof e2 == "object" && !Array.isArray(e2) ? [e2] : [];
    case "scalars":
      return !Array.isArray(e2) && !(e2 && typeof e2 == "object") ? [e2] : [];
    case "values":
      return e2 === null ? [] : [e2];
    case "not":
      return e2 === false || e2 === null ? [true] : [false];
    case "null":
      return [null];
    case "true":
      return [true];
    case "false":
      return [false];
    case "empty":
      return [];
    default:
      return null;
  }
}
var zp = v(() => {
});
var jp = v(() => {
  Pp();
  Tp();
  Op();
  Dp();
  Fp();
  _p();
  Lp();
  Mp();
  Wp();
  Bp();
  Up();
  zp();
});
function vs(e2, t2, n2) {
  if (t2.length === 0) return n2;
  let [r2, ...s2] = t2;
  if (typeof r2 == "number") {
    if (e2 && typeof e2 == "object" && !Array.isArray(e2)) throw new Error("Cannot index object with number");
    if (r2 > 536870911) throw new Error("Array index too large");
    if (r2 < 0) throw new Error("Out of bounds negative array index");
    let a = Array.isArray(e2) ? [...e2] : [];
    for (; a.length <= r2; ) a.push(null);
    return a[r2] = vs(a[r2], s2, n2), a;
  }
  if (Array.isArray(e2)) throw new Error("Cannot index array with string");
  let i2 = e2 && typeof e2 == "object" && !Array.isArray(e2) ? { ...e2 } : {};
  return i2[r2] = vs(i2[r2], s2, n2), i2;
}
function $s(e2, t2) {
  if (t2.length === 0) return null;
  if (t2.length === 1) {
    let s2 = t2[0];
    if (Array.isArray(e2) && typeof s2 == "number") {
      let i2 = [...e2];
      return i2.splice(s2, 1), i2;
    }
    if (e2 && typeof e2 == "object" && !Array.isArray(e2)) {
      let i2 = { ...e2 };
      return delete i2[String(s2)], i2;
    }
    return e2;
  }
  let [n2, ...r2] = t2;
  if (Array.isArray(e2) && typeof n2 == "number") {
    let s2 = [...e2];
    return s2[n2] = $s(s2[n2], r2), s2;
  }
  if (e2 && typeof e2 == "object" && !Array.isArray(e2)) {
    let s2 = { ...e2 };
    return s2[String(n2)] = $s(s2[String(n2)], r2), s2;
  }
  return e2;
}
var Hp = v(() => {
});
function YE(e2) {
  var _a3, _b3;
  return { vars: /* @__PURE__ */ new Map(), limits: { maxIterations: ((_a3 = e2 == null ? void 0 : e2.limits) == null ? void 0 : _a3.maxIterations) ?? XE, maxDepth: ((_b3 = e2 == null ? void 0 : e2.limits) == null ? void 0 : _b3.maxDepth) ?? Gp }, env: e2 == null ? void 0 : e2.env };
}
function Ps(e2, t2, n2) {
  let r2 = new Map(e2.vars);
  return r2.set(t2, n2), { vars: r2, limits: e2.limits, env: e2.env, root: e2.root, currentPath: e2.currentPath, funcs: e2.funcs, labels: e2.labels };
}
function kr(e2, t2, n2) {
  switch (t2.type) {
    case "var":
      return Ps(e2, t2.name, n2);
    case "array": {
      if (!Array.isArray(n2)) return null;
      let r2 = e2;
      for (let s2 = 0; s2 < t2.elements.length; s2++) {
        let i2 = t2.elements[s2], o2 = s2 < n2.length ? n2[s2] : null, a = kr(r2, i2, o2);
        if (a === null) return null;
        r2 = a;
      }
      return r2;
    }
    case "object": {
      if (n2 === null || typeof n2 != "object" || Array.isArray(n2)) return null;
      let r2 = n2, s2 = e2;
      for (let i2 of t2.fields) {
        let o2;
        if (typeof i2.key == "string") o2 = i2.key;
        else {
          let c = z(n2, i2.key, e2);
          if (c.length === 0) return null;
          o2 = String(c[0]);
        }
        let a = o2 in r2 ? r2[o2] : null;
        i2.keyVar && (s2 = Ps(s2, i2.keyVar, a));
        let l = kr(s2, i2.pattern, a);
        if (l === null) return null;
        s2 = l;
      }
      return s2;
    }
  }
}
function eS(e2, t2) {
  let n2 = e2;
  for (let r2 of t2) if (n2 && typeof n2 == "object") n2 = n2[r2];
  else return;
  return n2;
}
function en(e2) {
  if (e2.type === "Identity") return [];
  if (e2.type === "Field") {
    let t2 = e2.base ? en(e2.base) : [];
    return t2 === null ? null : [...t2, e2.name];
  }
  if (e2.type === "Index" && e2.index.type === "Literal") {
    let t2 = e2.base ? en(e2.base) : [];
    if (t2 === null) return null;
    let n2 = e2.index.value;
    return typeof n2 == "number" || typeof n2 == "string" ? [...t2, n2] : null;
  }
  if (e2.type === "Pipe") {
    let t2 = en(e2.left);
    return t2 === null ? null : Bo(t2, e2.right);
  }
  if (e2.type === "Call") {
    if (e2.name === "parent" || e2.name === "root") return null;
    if (e2.name === "first" && e2.args.length === 0) return [0];
    if (e2.name === "last" && e2.args.length === 0) return [-1];
  }
  return null;
}
function Bo(e2, t2) {
  if (t2.type === "Call") {
    if (t2.name === "parent") {
      let n2 = 1;
      if (t2.args.length > 0 && t2.args[0].type === "Literal") {
        let r2 = t2.args[0].value;
        typeof r2 == "number" && (n2 = r2);
      }
      if (n2 >= 0) return e2.slice(0, Math.max(0, e2.length - n2));
      {
        let r2 = -n2 - 1;
        return e2.slice(0, Math.min(r2, e2.length));
      }
    }
    if (t2.name === "root") return [];
  }
  if (t2.type === "Field") {
    let n2 = en(t2);
    if (n2 !== null) return [...e2, ...n2];
  }
  if (t2.type === "Index" && t2.index.type === "Literal") {
    let n2 = en(t2);
    if (n2 !== null) return [...e2, ...n2];
  }
  if (t2.type === "Pipe") {
    let n2 = Bo(e2, t2.left);
    return n2 === null ? null : Bo(n2, t2.right);
  }
  return t2.type === "Identity" ? e2 : null;
}
function Vp(e2, t2, n2) {
  if (t2.type === "Comma") {
    let r2 = [];
    try {
      r2.push(...z(e2, t2.left, n2));
    } catch (s2) {
      if (s2 instanceof ne) throw s2;
      if (r2.length > 0) return r2;
      throw new Error("evaluation failed");
    }
    try {
      r2.push(...z(e2, t2.right, n2));
    } catch (s2) {
      if (s2 instanceof ne) throw s2;
      return r2;
    }
    return r2;
  }
  return z(e2, t2, n2);
}
function z(e2, t2, n2) {
  let r2 = n2 && "vars" in n2 ? n2 : YE(n2);
  switch (r2.root === void 0 && (r2 = { ...r2, root: e2, currentPath: [] }), t2.type) {
    case "Identity":
      return [e2];
    case "Field":
      return (t2.base ? z(e2, t2.base, r2) : [e2]).flatMap((i2) => {
        if (i2 && typeof i2 == "object" && !Array.isArray(i2)) {
          let a = i2[t2.name];
          return [a === void 0 ? null : a];
        }
        if (i2 === null) return [null];
        let o2 = Array.isArray(i2) ? "array" : typeof i2;
        throw new Error(`Cannot index ${o2} with string "${t2.name}"`);
      });
    case "Index":
      return (t2.base ? z(e2, t2.base, r2) : [e2]).flatMap((i2) => z(i2, t2.index, r2).flatMap((a) => {
        if (typeof a == "number" && Array.isArray(i2)) {
          if (Number.isNaN(a)) return [null];
          let l = Math.trunc(a), c = l < 0 ? i2.length + l : l;
          return c >= 0 && c < i2.length ? [i2[c]] : [null];
        }
        return typeof a == "string" && i2 && typeof i2 == "object" && !Array.isArray(i2) ? [i2[a]] : [null];
      }));
    case "Slice":
      return (t2.base ? z(e2, t2.base, r2) : [e2]).flatMap((i2) => {
        if (i2 === null) return [null];
        if (!Array.isArray(i2) && typeof i2 != "string") throw new Error(`Cannot slice ${typeof i2} (${JSON.stringify(i2)})`);
        let o2 = i2.length, a = t2.start ? z(e2, t2.start, r2) : [0], l = t2.end ? z(e2, t2.end, r2) : [o2];
        return a.flatMap((c) => l.map((u) => {
          let f2 = c, p = u, d = Number.isNaN(f2) ? 0 : Number.isInteger(f2) ? f2 : Math.floor(f2), m = Number.isNaN(p) ? o2 : Number.isInteger(p) ? p : Math.ceil(p), h = qp(d, o2), g = qp(m, o2);
          return i2.slice(h, g);
        }));
      });
    case "Iterate":
      return (t2.base ? z(e2, t2.base, r2) : [e2]).flatMap((i2) => Array.isArray(i2) ? i2 : i2 && typeof i2 == "object" ? Object.values(i2) : []);
    case "Pipe": {
      let s2 = z(e2, t2.left, r2), i2 = en(t2.left), o2 = [];
      for (let a of s2) try {
        if (i2 !== null) {
          let l = { ...r2, currentPath: [...r2.currentPath ?? [], ...i2] };
          o2.push(...z(a, t2.right, l));
        } else o2.push(...z(a, t2.right, r2));
      } catch (l) {
        throw l instanceof Vn ? l.withPrependedResults(o2) : l;
      }
      return o2;
    }
    case "Comma": {
      let s2 = z(e2, t2.left, r2), i2 = z(e2, t2.right, r2);
      return [...s2, ...i2];
    }
    case "Literal":
      return [t2.value];
    case "Array":
      return t2.elements ? [z(e2, t2.elements, r2)] : [[]];
    case "Object": {
      let s2 = [{}];
      for (let i2 of t2.entries) {
        let o2 = typeof i2.key == "string" ? [i2.key] : z(e2, i2.key, r2), a = z(e2, i2.value, r2), l = [];
        for (let c of s2) for (let u of o2) {
          if (typeof u != "string") {
            let f2 = u === null ? "null" : Array.isArray(u) ? "array" : typeof u;
            throw new Error(`Cannot use ${f2} (${JSON.stringify(u)}) as object key`);
          }
          for (let f2 of a) l.push({ ...c, [u]: f2 });
        }
        s2.length = 0, s2.push(...l);
      }
      return s2;
    }
    case "Paren":
      return z(e2, t2.expr, r2);
    case "BinaryOp":
      return rS(e2, t2.op, t2.left, t2.right, r2);
    case "UnaryOp":
      return z(e2, t2.operand, r2).map((i2) => {
        if (t2.op === "-") {
          if (typeof i2 == "number") return -i2;
          if (typeof i2 == "string") {
            let o2 = (a) => a.length > 5 ? `"${a.slice(0, 3)}...` : JSON.stringify(a);
            throw new Error(`string (${o2(i2)}) cannot be negated`);
          }
          return null;
        }
        return t2.op === "not" ? !vt(i2) : null;
      });
    case "Cond":
      return z(e2, t2.cond, r2).flatMap((i2) => {
        if (vt(i2)) return z(e2, t2.then, r2);
        for (let o2 of t2.elifs) if (z(e2, o2.cond, r2).some(vt)) return z(e2, o2.then, r2);
        return t2.else ? z(e2, t2.else, r2) : [e2];
      });
    case "Try":
      try {
        return z(e2, t2.body, r2);
      } catch (s2) {
        if (t2.catch) {
          let i2 = s2 instanceof Rs ? s2.value : s2 instanceof Error ? s2.message : String(s2);
          return z(i2, t2.catch, r2);
        }
        return [];
      }
    case "Call":
      return Zp(e2, t2.name, t2.args, r2);
    case "VarBind":
      return z(e2, t2.value, r2).flatMap((i2) => {
        let o2 = null, a = [];
        t2.pattern ? a.push(t2.pattern) : t2.name && a.push({ type: "var", name: t2.name }), t2.alternatives && a.push(...t2.alternatives);
        for (let l of a) if (o2 = kr(r2, l, i2), o2 !== null) break;
        return o2 === null ? [] : z(e2, t2.body, o2);
      });
    case "VarRef": {
      if (t2.name === "$ENV") return [r2.env ?? {}];
      let s2 = r2.vars.get(t2.name);
      return s2 !== void 0 ? [s2] : [null];
    }
    case "Recurse": {
      let s2 = [], i2 = /* @__PURE__ */ new WeakSet(), o2 = (a) => {
        if (a && typeof a == "object") {
          if (i2.has(a)) return;
          i2.add(a);
        }
        if (s2.push(a), Array.isArray(a)) for (let l of a) o2(l);
        else if (a && typeof a == "object") for (let l of Object.keys(a)) o2(a[l]);
      };
      return o2(e2), s2;
    }
    case "Optional":
      try {
        return z(e2, t2.expr, r2);
      } catch {
        return [];
      }
    case "StringInterp":
      return [t2.parts.map((i2) => typeof i2 == "string" ? i2 : z(e2, i2, r2).map((a) => typeof a == "string" ? a : JSON.stringify(a)).join("")).join("")];
    case "UpdateOp":
      return [tS(e2, t2.path, t2.op, t2.value, r2)];
    case "Reduce": {
      let s2 = z(e2, t2.expr, r2), i2 = z(e2, t2.init, r2)[0], o2 = r2.limits.maxDepth ?? Gp;
      for (let a of s2) {
        let l;
        if (t2.pattern) {
          if (l = kr(r2, t2.pattern, a), l === null) continue;
        } else l = Ps(r2, t2.varName, a);
        if (i2 = z(i2, t2.update, l)[0], Hn(i2, o2 + 1) > o2) return [null];
      }
      return [i2];
    }
    case "Foreach": {
      let s2 = z(e2, t2.expr, r2), i2 = z(e2, t2.init, r2)[0], o2 = [];
      for (let a of s2) try {
        let l;
        if (t2.pattern) {
          if (l = kr(r2, t2.pattern, a), l === null) continue;
        } else l = Ps(r2, t2.varName, a);
        if (i2 = z(i2, t2.update, l)[0], t2.extract) {
          let c = z(i2, t2.extract, l);
          o2.push(...c);
        } else o2.push(i2);
      } catch (l) {
        throw l instanceof Vn ? l.withPrependedResults(o2) : l;
      }
      return o2;
    }
    case "Label":
      try {
        return z(e2, t2.body, { ...r2, labels: /* @__PURE__ */ new Set([...r2.labels ?? [], t2.name]) });
      } catch (s2) {
        if (s2 instanceof Vn && s2.label === t2.name) return s2.partialResults;
        throw s2;
      }
    case "Break":
      throw new Vn(t2.name);
    case "Def": {
      let s2 = new Map(r2.funcs ?? []), i2 = `${t2.name}/${t2.params.length}`;
      s2.set(i2, { params: t2.params, body: t2.funcBody, closure: new Map(r2.funcs ?? []) });
      let o2 = { ...r2, funcs: s2 };
      return z(e2, t2.body, o2);
    }
    default: {
      let s2 = t2;
      throw new Error(`Unknown AST node type: ${s2.type}`);
    }
  }
}
function qp(e2, t2) {
  return e2 < 0 ? Math.max(0, t2 + e2) : Math.min(e2, t2);
}
function tS(e2, t2, n2, r2, s2) {
  function i2(l, c) {
    switch (n2) {
      case "=":
        return c;
      case "|=":
        return z(l, r2, s2)[0] ?? null;
      case "+=":
        return typeof l == "number" && typeof c == "number" || typeof l == "string" && typeof c == "string" ? l + c : Array.isArray(l) && Array.isArray(c) ? [...l, ...c] : l && c && typeof l == "object" && typeof c == "object" ? { ...l, ...c } : c;
      case "-=":
        return typeof l == "number" && typeof c == "number" ? l - c : l;
      case "*=":
        return typeof l == "number" && typeof c == "number" ? l * c : l;
      case "/=":
        return typeof l == "number" && typeof c == "number" ? l / c : l;
      case "%=":
        return typeof l == "number" && typeof c == "number" ? l % c : l;
      case "//=":
        return l === null || l === false ? c : l;
      default:
        return c;
    }
  }
  function o2(l, c, u) {
    switch (c.type) {
      case "Identity":
        return u(l);
      case "Field": {
        if (c.base) return o2(l, c.base, (f2) => {
          if (f2 && typeof f2 == "object" && !Array.isArray(f2)) {
            let p = { ...f2 };
            return p[c.name] = u(p[c.name]), p;
          }
          return f2;
        });
        if (l && typeof l == "object" && !Array.isArray(l)) {
          let f2 = { ...l };
          return f2[c.name] = u(f2[c.name]), f2;
        }
        return l;
      }
      case "Index": {
        let p = z(e2, c.index, s2)[0];
        if (typeof p == "number" && Number.isNaN(p)) throw new Error("Cannot set array element at NaN index");
        if (typeof p == "number" && !Number.isInteger(p) && (p = Math.trunc(p)), c.base) return o2(l, c.base, (d) => {
          if (typeof p == "number" && Array.isArray(d)) {
            let m = [...d], h = p < 0 ? m.length + p : p;
            if (h >= 0) {
              for (; m.length <= h; ) m.push(null);
              m[h] = u(m[h]);
            }
            return m;
          }
          if (typeof p == "string" && d && typeof d == "object" && !Array.isArray(d)) {
            let m = { ...d };
            return m[p] = u(m[p]), m;
          }
          return d;
        });
        if (typeof p == "number") {
          if (p > 536870911) throw new Error("Array index too large");
          if (p < 0 && (!l || !Array.isArray(l))) throw new Error("Out of bounds negative array index");
          if (Array.isArray(l)) {
            let m = [...l], h = p < 0 ? m.length + p : p;
            if (h >= 0) {
              for (; m.length <= h; ) m.push(null);
              m[h] = u(m[h]);
            }
            return m;
          }
          if (l == null) {
            let m = [];
            for (; m.length <= p; ) m.push(null);
            return m[p] = u(null), m;
          }
          return l;
        }
        if (typeof p == "string" && l && typeof l == "object" && !Array.isArray(l)) {
          let d = { ...l };
          return d[p] = u(d[p]), d;
        }
        return l;
      }
      case "Iterate": {
        let f2 = (p) => {
          if (Array.isArray(p)) return p.map((d) => u(d));
          if (p && typeof p == "object") {
            let d = {};
            for (let [m, h] of Object.entries(p)) d[m] = u(h);
            return d;
          }
          return p;
        };
        return c.base ? o2(l, c.base, f2) : f2(l);
      }
      case "Pipe": {
        let f2 = o2(l, c.left, (p) => p);
        return o2(f2, c.right, u);
      }
      default:
        return u(l);
    }
  }
  return o2(e2, t2, (l) => {
    if (n2 === "|=") return i2(l, l);
    let c = z(e2, r2, s2);
    return i2(l, c[0] ?? null);
  });
}
function nS(e2, t2, n2) {
  function r2(i2, o2, a) {
    switch (o2.type) {
      case "Identity":
        return a;
      case "Field": {
        if (o2.base) {
          let l = z(i2, o2.base, n2)[0], c = r2(l, { type: "Field", name: o2.name }, a);
          return r2(i2, o2.base, c);
        }
        return i2 && typeof i2 == "object" && !Array.isArray(i2) ? { ...i2, [o2.name]: a } : i2;
      }
      case "Index": {
        if (o2.base) {
          let u = z(i2, o2.base, n2)[0], f2 = r2(u, { type: "Index", index: o2.index }, a);
          return r2(i2, o2.base, f2);
        }
        let c = z(e2, o2.index, n2)[0];
        if (typeof c == "number" && Array.isArray(i2)) {
          let u = [...i2], f2 = c < 0 ? u.length + c : c;
          return f2 >= 0 && f2 < u.length && (u[f2] = a), u;
        }
        return typeof c == "string" && i2 && typeof i2 == "object" && !Array.isArray(i2) ? { ...i2, [c]: a } : i2;
      }
      default:
        return i2;
    }
  }
  function s2(i2, o2) {
    switch (o2.type) {
      case "Identity":
        return null;
      case "Field": {
        if (o2.base) {
          let l = z(i2, o2.base, n2)[0];
          if (l == null) return i2;
          let c = s2(l, { type: "Field", name: o2.name });
          return r2(i2, o2.base, c);
        }
        if (i2 && typeof i2 == "object" && !Array.isArray(i2)) {
          let l = { ...i2 };
          return delete l[o2.name], l;
        }
        return i2;
      }
      case "Index": {
        if (o2.base) {
          let u = z(i2, o2.base, n2)[0];
          if (u == null) return i2;
          let f2 = s2(u, { type: "Index", index: o2.index });
          return r2(i2, o2.base, f2);
        }
        let c = z(e2, o2.index, n2)[0];
        if (typeof c == "number" && Array.isArray(i2)) {
          let u = [...i2], f2 = c < 0 ? u.length + c : c;
          return f2 >= 0 && f2 < u.length && u.splice(f2, 1), u;
        }
        if (typeof c == "string" && i2 && typeof i2 == "object" && !Array.isArray(i2)) {
          let u = { ...i2 };
          return delete u[c], u;
        }
        return i2;
      }
      case "Iterate":
        return Array.isArray(i2) ? [] : i2 && typeof i2 == "object" ? {} : i2;
      case "Pipe": {
        let u = function(d, m, h) {
          switch (m.type) {
            case "Identity":
              return h;
            case "Field":
              return d && typeof d == "object" && !Array.isArray(d) ? { ...d, [m.name]: h } : d;
            case "Index": {
              let b = z(e2, m.index, n2)[0];
              if (typeof b == "number" && Array.isArray(d)) {
                let y = [...d], w = b < 0 ? y.length + b : b;
                return w >= 0 && w < y.length && (y[w] = h), y;
              }
              return typeof b == "string" && d && typeof d == "object" && !Array.isArray(d) ? { ...d, [b]: h } : d;
            }
            case "Pipe": {
              let g = z(d, m.left, n2)[0], b = u(g, m.right, h);
              return u(d, m.left, b);
            }
            default:
              return d;
          }
        };
        let l = o2.left, c = o2.right, f2 = z(i2, l, n2)[0];
        if (f2 == null) return i2;
        let p = s2(f2, c);
        return u(i2, l, p);
      }
      default:
        return i2;
    }
  }
  return s2(e2, t2);
}
function rS(e2, t2, n2, r2, s2) {
  if (t2 === "and") return z(e2, n2, s2).flatMap((l) => vt(l) ? z(e2, r2, s2).map((u) => vt(u)) : [false]);
  if (t2 === "or") return z(e2, n2, s2).flatMap((l) => vt(l) ? [true] : z(e2, r2, s2).map((u) => vt(u)));
  if (t2 === "//") {
    let l = z(e2, n2, s2).filter((c) => c != null && c !== false);
    return l.length > 0 ? l : z(e2, r2, s2);
  }
  let i2 = z(e2, n2, s2), o2 = z(e2, r2, s2);
  return i2.flatMap((a) => o2.map((l) => {
    switch (t2) {
      case "+":
        return a === null ? l : l === null ? a : typeof a == "number" && typeof l == "number" || typeof a == "string" && typeof l == "string" ? a + l : Array.isArray(a) && Array.isArray(l) ? [...a, ...l] : a && l && typeof a == "object" && typeof l == "object" && !Array.isArray(a) && !Array.isArray(l) ? { ...a, ...l } : null;
      case "-":
        if (typeof a == "number" && typeof l == "number") return a - l;
        if (Array.isArray(a) && Array.isArray(l)) {
          let c = new Set(l.map((u) => JSON.stringify(u)));
          return a.filter((u) => !c.has(JSON.stringify(u)));
        }
        if (typeof a == "string" && typeof l == "string") {
          let c = (u) => u.length > 10 ? `"${u.slice(0, 10)}...` : JSON.stringify(u);
          throw new Error(`string (${c(a)}) and string (${c(l)}) cannot be subtracted`);
        }
        return null;
      case "*":
        return typeof a == "number" && typeof l == "number" ? a * l : typeof a == "string" && typeof l == "number" ? a.repeat(l) : a && l && typeof a == "object" && typeof l == "object" && !Array.isArray(a) && !Array.isArray(l) ? Ro(a, l) : null;
      case "/":
        if (typeof a == "number" && typeof l == "number") {
          if (l === 0) throw new Error(`number (${a}) and number (${l}) cannot be divided because the divisor is zero`);
          return a / l;
        }
        return typeof a == "string" && typeof l == "string" ? a.split(l) : null;
      case "%":
        if (typeof a == "number" && typeof l == "number") {
          if (l === 0) throw new Error(`number (${a}) and number (${l}) cannot be divided (remainder) because the divisor is zero`);
          return !Number.isFinite(a) && !Number.isNaN(a) ? !Number.isFinite(l) && !Number.isNaN(l) && a < 0 && l > 0 ? -1 : 0 : a % l;
        }
        return null;
      case "==":
        return jn(a, l);
      case "!=":
        return !jn(a, l);
      case "<":
        return Nr(a, l) < 0;
      case "<=":
        return Nr(a, l) <= 0;
      case ">":
        return Nr(a, l) > 0;
      case ">=":
        return Nr(a, l) >= 0;
      default:
        return null;
    }
  }));
}
function Zp(e2, t2, n2, r2) {
  var _a3;
  let s2 = JE[t2];
  if (s2) return typeof e2 == "number" ? [s2(e2)] : [null];
  let i2 = Oo(e2, t2, n2, r2, z);
  if (i2 !== null) return i2;
  let o2 = Mo(e2, t2, n2, r2, z);
  if (o2 !== null) return o2;
  let a = Io(e2, t2, n2, r2, z);
  if (a !== null) return a;
  let l = Po(e2, t2, r2.limits.maxDepth);
  if (l !== null) return l;
  let c = Wo(e2, t2);
  if (c !== null) return c;
  let u = Fo(e2, t2, n2, r2, z);
  if (u !== null) return u;
  let f2 = vo(e2, t2, n2, r2, z, Vp, Cs, vt, Ns, ne);
  if (f2 !== null) return f2;
  let p = _o(e2, t2, n2, r2, z, vt, vs, $s, nS, Is);
  if (p !== null) return p;
  let d = To(e2, t2, n2, r2, z, jn);
  if (d !== null) return d;
  let m = $o(e2, t2, n2, r2, z, Vp, vt, ne);
  if (m !== null) return m;
  let h = Do(e2, t2, n2, r2, z, vt, eS, Zp);
  if (h !== null) return h;
  let g = Lo(e2, t2, n2, r2, z, jn);
  if (g !== null) return g;
  switch (t2) {
    case "builtins":
      return [["add/0", "all/0", "all/1", "all/2", "any/0", "any/1", "any/2", "arrays/0", "ascii/0", "ascii_downcase/0", "ascii_upcase/0", "booleans/0", "bsearch/1", "builtins/0", "combinations/0", "combinations/1", "contains/1", "debug/0", "del/1", "delpaths/1", "empty/0", "env/0", "error/0", "error/1", "explode/0", "first/0", "first/1", "flatten/0", "flatten/1", "floor/0", "from_entries/0", "fromdate/0", "fromjson/0", "getpath/1", "gmtime/0", "group_by/1", "gsub/2", "gsub/3", "has/1", "implode/0", "IN/1", "IN/2", "INDEX/1", "INDEX/2", "index/1", "indices/1", "infinite/0", "inside/1", "isempty/1", "isnan/0", "isnormal/0", "isvalid/1", "iterables/0", "join/1", "keys/0", "keys_unsorted/0", "last/0", "last/1", "length/0", "limit/2", "ltrimstr/1", "map/1", "map_values/1", "match/1", "match/2", "max/0", "max_by/1", "min/0", "min_by/1", "mktime/0", "modulemeta/1", "nan/0", "not/0", "nth/1", "nth/2", "null/0", "nulls/0", "numbers/0", "objects/0", "path/1", "paths/0", "paths/1", "pick/1", "range/1", "range/2", "range/3", "recurse/0", "recurse/1", "recurse_down/0", "repeat/1", "reverse/0", "rindex/1", "rtrimstr/1", "scalars/0", "scan/1", "scan/2", "select/1", "setpath/2", "skip/2", "sort/0", "sort_by/1", "split/1", "splits/1", "splits/2", "sqrt/0", "startswith/1", "strftime/1", "strings/0", "strptime/1", "sub/2", "sub/3", "test/1", "test/2", "to_entries/0", "toboolean/0", "todate/0", "tojson/0", "tostream/0", "fromstream/1", "truncate_stream/1", "tonumber/0", "tostring/0", "transpose/0", "trim/0", "ltrim/0", "rtrim/0", "type/0", "unique/0", "unique_by/1", "until/2", "utf8bytelength/0", "values/0", "walk/1", "while/2", "with_entries/1"]];
    case "error": {
      let b = n2.length > 0 ? z(e2, n2[0], r2)[0] : e2;
      throw new Rs(b);
    }
    case "env":
      return [r2.env ?? {}];
    case "debug":
      return [e2];
    case "input_line_number":
      return [1];
    default: {
      let b = `${t2}/${n2.length}`, y = (_a3 = r2.funcs) == null ? void 0 : _a3.get(b);
      if (y) {
        let w = y.closure ?? r2.funcs ?? /* @__PURE__ */ new Map(), E = new Map(w);
        E.set(b, y);
        for (let A = 0; A < y.params.length; A++) {
          let I = y.params[A], O = n2[A];
          if (O) {
            let L = z(e2, O, r2), D;
            if (L.length === 0) D = { type: "Call", name: "empty", args: [] };
            else if (L.length === 1) D = { type: "Literal", value: L[0] };
            else {
              D = { type: "Literal", value: L[L.length - 1] };
              for (let $ = L.length - 2; $ >= 0; $--) D = { type: "Comma", left: { type: "Literal", value: L[$] }, right: D };
            }
            E.set(`${I}/0`, { params: [], body: D });
          }
        }
        let C = { ...r2, funcs: E };
        return z(e2, y.body, C);
      }
      throw new Error(`Unknown function: ${t2}`);
    }
  }
}
function Is(e2, t2, n2, r2, s2) {
  if (t2.type === "Comma") {
    let a = t2;
    Is(e2, a.left, n2, r2, s2), Is(e2, a.right, n2, r2, s2);
    return;
  }
  let i2 = en(t2);
  if (i2 !== null) {
    s2.push([...r2, ...i2]);
    return;
  }
  if (t2.type === "Iterate") {
    if (Array.isArray(e2)) for (let a = 0; a < e2.length; a++) s2.push([...r2, a]);
    else if (e2 && typeof e2 == "object") for (let a of Object.keys(e2)) s2.push([...r2, a]);
    return;
  }
  if (t2.type === "Recurse") {
    let a = (l, c) => {
      if (s2.push([...r2, ...c]), l && typeof l == "object") if (Array.isArray(l)) for (let u = 0; u < l.length; u++) a(l[u], [...c, u]);
      else for (let u of Object.keys(l)) a(l[u], [...c, u]);
    };
    a(e2, []);
    return;
  }
  if (t2.type === "Pipe") {
    let a = en(t2.left);
    if (a !== null) {
      let l = z(e2, t2.left, n2);
      for (let c of l) Is(c, t2.right, n2, [...r2, ...a], s2);
      return;
    }
  }
  z(e2, t2, n2).length > 0 && s2.push(r2);
}
var Vn, Rs, XE, Gp, JE, Qp = v(() => {
  de();
  jp();
  Hp();
  ks();
  Vn = class e2 extends Error {
    constructor(t2, n2 = []) {
      super(`break ${t2}`);
      __publicField(this, "label");
      __publicField(this, "partialResults");
      this.label = t2, this.partialResults = n2, this.name = "BreakError";
    }
    withPrependedResults(t2) {
      return new e2(this.label, [...t2, ...this.partialResults]);
    }
  }, Rs = class extends Error {
    constructor(t2) {
      super(typeof t2 == "string" ? t2 : JSON.stringify(t2));
      __publicField(this, "value");
      this.value = t2, this.name = "JqError";
    }
  }, XE = 1e4, Gp = 2e3, JE = { floor: Math.floor, ceil: Math.ceil, round: Math.round, sqrt: Math.sqrt, log: Math.log, log10: Math.log10, log2: Math.log2, exp: Math.exp, sin: Math.sin, cos: Math.cos, tan: Math.tan, asin: Math.asin, acos: Math.acos, atan: Math.atan, sinh: Math.sinh, cosh: Math.cosh, tanh: Math.tanh, asinh: Math.asinh, acosh: Math.acosh, atanh: Math.atanh, cbrt: Math.cbrt, expm1: Math.expm1, log1p: Math.log1p, trunc: Math.trunc };
});
function Kp(e2) {
  let t2 = [], n2 = 0, r2 = (c = 0) => e2[n2 + c], s2 = () => e2[n2++], i2 = () => n2 >= e2.length, o2 = (c) => c >= "0" && c <= "9", a = (c) => c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "_", l = (c) => a(c) || o2(c);
  for (; !i2(); ) {
    let c = n2, u = s2();
    if (!(u === " " || u === "	" || u === `
` || u === "\r")) {
      if (u === "#") {
        for (; !i2() && r2() !== `
`; ) s2();
        continue;
      }
      if (u === "." && r2() === ".") {
        s2(), t2.push({ type: "DOTDOT", pos: c });
        continue;
      }
      if (u === "=" && r2() === "=") {
        s2(), t2.push({ type: "EQ", pos: c });
        continue;
      }
      if (u === "!" && r2() === "=") {
        s2(), t2.push({ type: "NE", pos: c });
        continue;
      }
      if (u === "<" && r2() === "=") {
        s2(), t2.push({ type: "LE", pos: c });
        continue;
      }
      if (u === ">" && r2() === "=") {
        s2(), t2.push({ type: "GE", pos: c });
        continue;
      }
      if (u === "/" && r2() === "/") {
        s2(), r2() === "=" ? (s2(), t2.push({ type: "UPDATE_ALT", pos: c })) : t2.push({ type: "ALT", pos: c });
        continue;
      }
      if (u === "+" && r2() === "=") {
        s2(), t2.push({ type: "UPDATE_ADD", pos: c });
        continue;
      }
      if (u === "-" && r2() === "=") {
        s2(), t2.push({ type: "UPDATE_SUB", pos: c });
        continue;
      }
      if (u === "*" && r2() === "=") {
        s2(), t2.push({ type: "UPDATE_MUL", pos: c });
        continue;
      }
      if (u === "/" && r2() === "=") {
        s2(), t2.push({ type: "UPDATE_DIV", pos: c });
        continue;
      }
      if (u === "%" && r2() === "=") {
        s2(), t2.push({ type: "UPDATE_MOD", pos: c });
        continue;
      }
      if (u === "=" && r2() !== "=") {
        t2.push({ type: "ASSIGN", pos: c });
        continue;
      }
      if (u === ".") {
        t2.push({ type: "DOT", pos: c });
        continue;
      }
      if (u === "|") {
        r2() === "=" ? (s2(), t2.push({ type: "UPDATE_PIPE", pos: c })) : t2.push({ type: "PIPE", pos: c });
        continue;
      }
      if (u === ",") {
        t2.push({ type: "COMMA", pos: c });
        continue;
      }
      if (u === ":") {
        t2.push({ type: "COLON", pos: c });
        continue;
      }
      if (u === ";") {
        t2.push({ type: "SEMICOLON", pos: c });
        continue;
      }
      if (u === "(") {
        t2.push({ type: "LPAREN", pos: c });
        continue;
      }
      if (u === ")") {
        t2.push({ type: "RPAREN", pos: c });
        continue;
      }
      if (u === "[") {
        t2.push({ type: "LBRACKET", pos: c });
        continue;
      }
      if (u === "]") {
        t2.push({ type: "RBRACKET", pos: c });
        continue;
      }
      if (u === "{") {
        t2.push({ type: "LBRACE", pos: c });
        continue;
      }
      if (u === "}") {
        t2.push({ type: "RBRACE", pos: c });
        continue;
      }
      if (u === "?") {
        t2.push({ type: "QUESTION", pos: c });
        continue;
      }
      if (u === "+") {
        t2.push({ type: "PLUS", pos: c });
        continue;
      }
      if (u === "-") {
        t2.push({ type: "MINUS", pos: c });
        continue;
      }
      if (u === "*") {
        t2.push({ type: "STAR", pos: c });
        continue;
      }
      if (u === "/") {
        t2.push({ type: "SLASH", pos: c });
        continue;
      }
      if (u === "%") {
        t2.push({ type: "PERCENT", pos: c });
        continue;
      }
      if (u === "<") {
        t2.push({ type: "LT", pos: c });
        continue;
      }
      if (u === ">") {
        t2.push({ type: "GT", pos: c });
        continue;
      }
      if (o2(u)) {
        let f2 = u;
        for (; !i2() && (o2(r2()) || r2() === "." || r2() === "e" || r2() === "E"); ) (r2() === "e" || r2() === "E") && (e2[n2 + 1] === "+" || e2[n2 + 1] === "-") && (f2 += s2()), f2 += s2();
        t2.push({ type: "NUMBER", value: Number(f2), pos: c });
        continue;
      }
      if (u === '"') {
        let f2 = "";
        for (; !i2() && r2() !== '"'; ) if (r2() === "\\") {
          if (s2(), i2()) break;
          let p = s2();
          switch (p) {
            case "n":
              f2 += `
`;
              break;
            case "r":
              f2 += "\r";
              break;
            case "t":
              f2 += "	";
              break;
            case "\\":
              f2 += "\\";
              break;
            case '"':
              f2 += '"';
              break;
            case "(":
              f2 += "\\(";
              break;
            default:
              f2 += p;
          }
        } else f2 += s2();
        i2() || s2(), t2.push({ type: "STRING", value: f2, pos: c });
        continue;
      }
      if (a(u) || u === "$" || u === "@") {
        let f2 = u;
        for (; !i2() && l(r2()); ) f2 += s2();
        let p = sS[f2];
        p ? t2.push({ type: p, pos: c }) : t2.push({ type: "IDENT", value: f2, pos: c });
        continue;
      }
      throw new Error(`Unexpected character '${u}' at position ${c}`);
    }
  }
  return t2.push({ type: "EOF", pos: n2 }), t2;
}
function Xp(e2) {
  let t2 = Kp(e2);
  return new Uo(t2).parse();
}
var sS, Uo, Jp = v(() => {
  sS = { and: "AND", or: "OR", not: "NOT", if: "IF", then: "THEN", elif: "ELIF", else: "ELSE", end: "END", as: "AS", try: "TRY", catch: "CATCH", true: "TRUE", false: "FALSE", null: "NULL", reduce: "REDUCE", foreach: "FOREACH", label: "LABEL", break: "BREAK", def: "DEF" };
  Uo = class e2 {
    constructor(t2) {
      __publicField(this, "tokens");
      __publicField(this, "pos", 0);
      this.tokens = t2;
    }
    peek(t2 = 0) {
      return this.tokens[this.pos + t2] ?? { type: "EOF", pos: -1 };
    }
    advance() {
      return this.tokens[this.pos++];
    }
    check(t2) {
      return this.peek().type === t2;
    }
    match(...t2) {
      for (let n2 of t2) if (this.check(n2)) return this.advance();
      return null;
    }
    expect(t2, n2) {
      if (!this.check(t2)) throw new Error(`${n2} at position ${this.peek().pos}, got ${this.peek().type}`);
      return this.advance();
    }
    parse() {
      let t2 = this.parseExpr();
      if (!this.check("EOF")) throw new Error(`Unexpected token ${this.peek().type} at position ${this.peek().pos}`);
      return t2;
    }
    parseExpr() {
      return this.parsePipe();
    }
    parsePattern() {
      if (this.match("LBRACKET")) {
        let r2 = [];
        if (!this.check("RBRACKET")) for (r2.push(this.parsePattern()); this.match("COMMA") && !this.check("RBRACKET"); ) r2.push(this.parsePattern());
        return this.expect("RBRACKET", "Expected ']' after array pattern"), { type: "array", elements: r2 };
      }
      if (this.match("LBRACE")) {
        let r2 = [];
        if (!this.check("RBRACE")) for (r2.push(this.parsePatternField()); this.match("COMMA") && !this.check("RBRACE"); ) r2.push(this.parsePatternField());
        return this.expect("RBRACE", "Expected '}' after object pattern"), { type: "object", fields: r2 };
      }
      let t2 = this.expect("IDENT", "Expected variable name in pattern"), n2 = t2.value;
      if (!n2.startsWith("$")) throw new Error(`Variable name must start with $ at position ${t2.pos}`);
      return { type: "var", name: n2 };
    }
    parsePatternField() {
      if (this.match("LPAREN")) {
        let n2 = this.parseExpr();
        this.expect("RPAREN", "Expected ')' after computed key"), this.expect("COLON", "Expected ':' after computed key");
        let r2 = this.parsePattern();
        return { key: n2, pattern: r2 };
      }
      let t2 = this.peek();
      if (t2.type === "IDENT") {
        let n2 = t2.value;
        if (n2.startsWith("$")) {
          if (this.advance(), this.match("COLON")) {
            let r2 = this.parsePattern();
            return { key: n2.slice(1), pattern: r2, keyVar: n2 };
          }
          return { key: n2.slice(1), pattern: { type: "var", name: n2 } };
        }
        if (this.advance(), this.match("COLON")) {
          let r2 = this.parsePattern();
          return { key: n2, pattern: r2 };
        }
        return { key: n2, pattern: { type: "var", name: `$${n2}` } };
      }
      throw new Error(`Expected field name in object pattern at position ${t2.pos}`);
    }
    parsePipe() {
      let t2 = this.parseComma();
      for (; this.match("PIPE"); ) {
        let n2 = this.parseComma();
        t2 = { type: "Pipe", left: t2, right: n2 };
      }
      return t2;
    }
    parseComma() {
      let t2 = this.parseVarBind();
      for (; this.match("COMMA"); ) {
        let n2 = this.parseVarBind();
        t2 = { type: "Comma", left: t2, right: n2 };
      }
      return t2;
    }
    parseVarBind() {
      var _a3;
      let t2 = this.parseUpdate();
      if (this.match("AS")) {
        let n2 = this.parsePattern(), r2 = [];
        for (; this.check("QUESTION") && ((_a3 = this.peekAhead(1)) == null ? void 0 : _a3.type) === "ALT"; ) this.advance(), this.advance(), r2.push(this.parsePattern());
        this.expect("PIPE", "Expected '|' after variable binding");
        let s2 = this.parseExpr();
        return n2.type === "var" && r2.length === 0 ? { type: "VarBind", name: n2.name, value: t2, body: s2 } : { type: "VarBind", name: n2.type === "var" ? n2.name : "", value: t2, body: s2, pattern: n2.type !== "var" ? n2 : void 0, alternatives: r2.length > 0 ? r2 : void 0 };
      }
      return t2;
    }
    peekAhead(t2) {
      let n2 = this.pos + t2;
      return n2 < this.tokens.length ? this.tokens[n2] : void 0;
    }
    parseUpdate() {
      let t2 = this.parseAlt(), n2 = { ASSIGN: "=", UPDATE_ADD: "+=", UPDATE_SUB: "-=", UPDATE_MUL: "*=", UPDATE_DIV: "/=", UPDATE_MOD: "%=", UPDATE_ALT: "//=", UPDATE_PIPE: "|=" }, r2 = this.match("ASSIGN", "UPDATE_ADD", "UPDATE_SUB", "UPDATE_MUL", "UPDATE_DIV", "UPDATE_MOD", "UPDATE_ALT", "UPDATE_PIPE");
      if (r2) {
        let s2 = this.parseVarBind();
        return { type: "UpdateOp", op: n2[r2.type], path: t2, value: s2 };
      }
      return t2;
    }
    parseAlt() {
      let t2 = this.parseOr();
      for (; this.match("ALT"); ) {
        let n2 = this.parseOr();
        t2 = { type: "BinaryOp", op: "//", left: t2, right: n2 };
      }
      return t2;
    }
    parseOr() {
      let t2 = this.parseAnd();
      for (; this.match("OR"); ) {
        let n2 = this.parseAnd();
        t2 = { type: "BinaryOp", op: "or", left: t2, right: n2 };
      }
      return t2;
    }
    parseAnd() {
      let t2 = this.parseNot();
      for (; this.match("AND"); ) {
        let n2 = this.parseNot();
        t2 = { type: "BinaryOp", op: "and", left: t2, right: n2 };
      }
      return t2;
    }
    parseNot() {
      return this.parseComparison();
    }
    parseComparison() {
      let t2 = this.parseAddSub(), n2 = { EQ: "==", NE: "!=", LT: "<", LE: "<=", GT: ">", GE: ">=" }, r2 = this.match("EQ", "NE", "LT", "LE", "GT", "GE");
      if (r2) {
        let s2 = this.parseAddSub();
        t2 = { type: "BinaryOp", op: n2[r2.type], left: t2, right: s2 };
      }
      return t2;
    }
    parseAddSub() {
      let t2 = this.parseMulDiv();
      for (; ; ) if (this.match("PLUS")) {
        let n2 = this.parseMulDiv();
        t2 = { type: "BinaryOp", op: "+", left: t2, right: n2 };
      } else if (this.match("MINUS")) {
        let n2 = this.parseMulDiv();
        t2 = { type: "BinaryOp", op: "-", left: t2, right: n2 };
      } else break;
      return t2;
    }
    parseMulDiv() {
      let t2 = this.parseUnary();
      for (; ; ) if (this.match("STAR")) {
        let n2 = this.parseUnary();
        t2 = { type: "BinaryOp", op: "*", left: t2, right: n2 };
      } else if (this.match("SLASH")) {
        let n2 = this.parseUnary();
        t2 = { type: "BinaryOp", op: "/", left: t2, right: n2 };
      } else if (this.match("PERCENT")) {
        let n2 = this.parseUnary();
        t2 = { type: "BinaryOp", op: "%", left: t2, right: n2 };
      } else break;
      return t2;
    }
    parseUnary() {
      return this.match("MINUS") ? { type: "UnaryOp", op: "-", operand: this.parseUnary() } : this.parsePostfix();
    }
    parsePostfix() {
      let t2 = this.parsePrimary();
      for (; ; ) if (this.match("QUESTION")) t2 = { type: "Optional", expr: t2 };
      else if (this.check("DOT") && (this.peek(1).type === "IDENT" || this.peek(1).type === "STRING")) this.advance(), t2 = { type: "Field", name: this.advance().value, base: t2 };
      else if (this.check("LBRACKET")) if (this.advance(), this.match("RBRACKET")) t2 = { type: "Iterate", base: t2 };
      else if (this.check("COLON")) {
        this.advance();
        let n2 = this.check("RBRACKET") ? void 0 : this.parseExpr();
        this.expect("RBRACKET", "Expected ']'"), t2 = { type: "Slice", end: n2, base: t2 };
      } else {
        let n2 = this.parseExpr();
        if (this.match("COLON")) {
          let r2 = this.check("RBRACKET") ? void 0 : this.parseExpr();
          this.expect("RBRACKET", "Expected ']'"), t2 = { type: "Slice", start: n2, end: r2, base: t2 };
        } else this.expect("RBRACKET", "Expected ']'"), t2 = { type: "Index", index: n2, base: t2 };
      }
      else break;
      return t2;
    }
    parsePrimary() {
      if (this.match("DOTDOT")) return { type: "Recurse" };
      if (this.match("DOT")) {
        if (this.check("LBRACKET")) {
          if (this.advance(), this.match("RBRACKET")) return { type: "Iterate" };
          if (this.check("COLON")) {
            this.advance();
            let n2 = this.check("RBRACKET") ? void 0 : this.parseExpr();
            return this.expect("RBRACKET", "Expected ']'"), { type: "Slice", end: n2 };
          }
          let t2 = this.parseExpr();
          if (this.match("COLON")) {
            let n2 = this.check("RBRACKET") ? void 0 : this.parseExpr();
            return this.expect("RBRACKET", "Expected ']'"), { type: "Slice", start: t2, end: n2 };
          }
          return this.expect("RBRACKET", "Expected ']'"), { type: "Index", index: t2 };
        }
        return this.check("IDENT") || this.check("STRING") ? { type: "Field", name: this.advance().value } : { type: "Identity" };
      }
      if (this.match("TRUE")) return { type: "Literal", value: true };
      if (this.match("FALSE")) return { type: "Literal", value: false };
      if (this.match("NULL")) return { type: "Literal", value: null };
      if (this.check("NUMBER")) return { type: "Literal", value: this.advance().value };
      if (this.check("STRING")) {
        let n2 = this.advance().value;
        return n2.includes("\\(") ? this.parseStringInterpolation(n2) : { type: "Literal", value: n2 };
      }
      if (this.match("LBRACKET")) {
        if (this.match("RBRACKET")) return { type: "Array" };
        let t2 = this.parseExpr();
        return this.expect("RBRACKET", "Expected ']'"), { type: "Array", elements: t2 };
      }
      if (this.match("LBRACE")) return this.parseObjectConstruction();
      if (this.match("LPAREN")) {
        let t2 = this.parseExpr();
        return this.expect("RPAREN", "Expected ')'"), { type: "Paren", expr: t2 };
      }
      if (this.match("IF")) return this.parseIf();
      if (this.match("TRY")) {
        let t2 = this.parsePostfix(), n2;
        return this.match("CATCH") && (n2 = this.parsePostfix()), { type: "Try", body: t2, catch: n2 };
      }
      if (this.match("REDUCE")) {
        let t2 = this.parseAddSub();
        this.expect("AS", "Expected 'as' after reduce expression");
        let n2 = this.parsePattern();
        this.expect("LPAREN", "Expected '(' after variable");
        let r2 = this.parseExpr();
        this.expect("SEMICOLON", "Expected ';' after init expression");
        let s2 = this.parseExpr();
        this.expect("RPAREN", "Expected ')' after update expression");
        let i2 = n2.type === "var" ? n2.name : "";
        return { type: "Reduce", expr: t2, varName: i2, init: r2, update: s2, pattern: n2.type !== "var" ? n2 : void 0 };
      }
      if (this.match("FOREACH")) {
        let t2 = this.parseAddSub();
        this.expect("AS", "Expected 'as' after foreach expression");
        let n2 = this.parsePattern();
        this.expect("LPAREN", "Expected '(' after variable");
        let r2 = this.parseExpr();
        this.expect("SEMICOLON", "Expected ';' after init expression");
        let s2 = this.parseExpr(), i2;
        this.match("SEMICOLON") && (i2 = this.parseExpr()), this.expect("RPAREN", "Expected ')' after expressions");
        let o2 = n2.type === "var" ? n2.name : "";
        return { type: "Foreach", expr: t2, varName: o2, init: r2, update: s2, extract: i2, pattern: n2.type !== "var" ? n2 : void 0 };
      }
      if (this.match("LABEL")) {
        let t2 = this.expect("IDENT", "Expected label name (e.g., $out)"), n2 = t2.value;
        if (!n2.startsWith("$")) throw new Error(`Label name must start with $ at position ${t2.pos}`);
        this.expect("PIPE", "Expected '|' after label name");
        let r2 = this.parseExpr();
        return { type: "Label", name: n2, body: r2 };
      }
      if (this.match("BREAK")) {
        let t2 = this.expect("IDENT", "Expected label name to break to"), n2 = t2.value;
        if (!n2.startsWith("$")) throw new Error(`Break label must start with $ at position ${t2.pos}`);
        return { type: "Break", name: n2 };
      }
      if (this.match("DEF")) {
        let n2 = this.expect("IDENT", "Expected function name after def").value, r2 = [];
        if (this.match("LPAREN")) {
          if (!this.check("RPAREN")) {
            let o2 = this.expect("IDENT", "Expected parameter name");
            for (r2.push(o2.value); this.match("SEMICOLON"); ) {
              let a = this.expect("IDENT", "Expected parameter name");
              r2.push(a.value);
            }
          }
          this.expect("RPAREN", "Expected ')' after parameters");
        }
        this.expect("COLON", "Expected ':' after function name");
        let s2 = this.parseExpr();
        this.expect("SEMICOLON", "Expected ';' after function body");
        let i2 = this.parseExpr();
        return { type: "Def", name: n2, params: r2, funcBody: s2, body: i2 };
      }
      if (this.match("NOT")) return { type: "Call", name: "not", args: [] };
      if (this.check("IDENT")) {
        let n2 = this.advance().value;
        if (n2.startsWith("$")) return { type: "VarRef", name: n2 };
        if (this.match("LPAREN")) {
          let r2 = [];
          if (!this.check("RPAREN")) for (r2.push(this.parseExpr()); this.match("SEMICOLON"); ) r2.push(this.parseExpr());
          return this.expect("RPAREN", "Expected ')'"), { type: "Call", name: n2, args: r2 };
        }
        return { type: "Call", name: n2, args: [] };
      }
      throw new Error(`Unexpected token ${this.peek().type} at position ${this.peek().pos}`);
    }
    parseObjectConstruction() {
      let t2 = [];
      if (!this.check("RBRACE")) do {
        let n2, r2;
        if (this.match("LPAREN")) n2 = this.parseExpr(), this.expect("RPAREN", "Expected ')'"), this.expect("COLON", "Expected ':'"), r2 = this.parseObjectValue();
        else if (this.check("IDENT")) {
          let s2 = this.advance().value;
          this.match("COLON") ? (n2 = s2, r2 = this.parseObjectValue()) : (n2 = s2, r2 = { type: "Field", name: s2 });
        } else if (this.check("STRING")) n2 = this.advance().value, this.expect("COLON", "Expected ':'"), r2 = this.parseObjectValue();
        else throw new Error(`Expected object key at position ${this.peek().pos}`);
        t2.push({ key: n2, value: r2 });
      } while (this.match("COMMA"));
      return this.expect("RBRACE", "Expected '}'"), { type: "Object", entries: t2 };
    }
    parseObjectValue() {
      let t2 = this.parseVarBind();
      for (; this.match("PIPE"); ) {
        let n2 = this.parseVarBind();
        t2 = { type: "Pipe", left: t2, right: n2 };
      }
      return t2;
    }
    parseIf() {
      let t2 = this.parseExpr();
      this.expect("THEN", "Expected 'then'");
      let n2 = this.parseExpr(), r2 = [];
      for (; this.match("ELIF"); ) {
        let i2 = this.parseExpr();
        this.expect("THEN", "Expected 'then' after elif");
        let o2 = this.parseExpr();
        r2.push({ cond: i2, then: o2 });
      }
      let s2;
      return this.match("ELSE") && (s2 = this.parseExpr()), this.expect("END", "Expected 'end'"), { type: "Cond", cond: t2, then: n2, elifs: r2, else: s2 };
    }
    parseStringInterpolation(t2) {
      let n2 = [], r2 = "", s2 = 0;
      for (; s2 < t2.length; ) if (t2[s2] === "\\" && t2[s2 + 1] === "(") {
        r2 && (n2.push(r2), r2 = ""), s2 += 2;
        let i2 = 1, o2 = "";
        for (; s2 < t2.length && i2 > 0; ) t2[s2] === "(" ? i2++ : t2[s2] === ")" && i2--, i2 > 0 && (o2 += t2[s2]), s2++;
        let a = Kp(o2), l = new e2(a);
        n2.push(l.parse());
      } else r2 += t2[s2], s2++;
      return r2 && n2.push(r2), { type: "StringInterp", parts: n2 };
    }
  };
});
var Yp = v(() => {
  Qp();
  Jp();
});
var td = {};
V(td, { jqCommand: () => oS });
function ed(e2) {
  let t2 = [], n2 = 0, r2 = e2.length;
  for (; n2 < r2; ) {
    for (; n2 < r2 && /\s/.test(e2[n2]); ) n2++;
    if (n2 >= r2) break;
    let s2 = n2, i2 = e2[n2];
    if (i2 === "{" || i2 === "[") {
      let o2 = i2, a = i2 === "{" ? "}" : "]", l = 1, c = false, u = false;
      for (n2++; n2 < r2 && l > 0; ) {
        let f2 = e2[n2];
        u ? u = false : f2 === "\\" ? u = true : f2 === '"' ? c = !c : c || (f2 === o2 ? l++ : f2 === a && l--), n2++;
      }
      if (l !== 0) throw new Error(`Unexpected end of JSON input at position ${n2} (unclosed ${o2})`);
      t2.push(JSON.parse(e2.slice(s2, n2)));
    } else if (i2 === '"') {
      let o2 = false;
      for (n2++; n2 < r2; ) {
        let a = e2[n2];
        if (o2) o2 = false;
        else if (a === "\\") o2 = true;
        else if (a === '"') {
          n2++;
          break;
        }
        n2++;
      }
      t2.push(JSON.parse(e2.slice(s2, n2)));
    } else if (i2 === "-" || i2 >= "0" && i2 <= "9") {
      for (; n2 < r2 && /[\d.eE+-]/.test(e2[n2]); ) n2++;
      t2.push(JSON.parse(e2.slice(s2, n2)));
    } else if (e2.slice(n2, n2 + 4) === "true") t2.push(true), n2 += 4;
    else if (e2.slice(n2, n2 + 5) === "false") t2.push(false), n2 += 5;
    else if (e2.slice(n2, n2 + 4) === "null") t2.push(null), n2 += 4;
    else {
      let o2 = e2.slice(n2, n2 + 10);
      throw new Error(`Invalid JSON at position ${s2}: unexpected '${o2.split(/\s/)[0]}'`);
    }
  }
  return t2;
}
function vr(e2, t2, n2, r2, s2, i2 = 0) {
  if (e2 === null || e2 === void 0) return "null";
  if (typeof e2 == "boolean") return String(e2);
  if (typeof e2 == "number") return Number.isFinite(e2) ? String(e2) : "null";
  if (typeof e2 == "string") return n2 ? e2 : JSON.stringify(e2);
  let o2 = s2 ? "	" : "  ";
  if (Array.isArray(e2)) return e2.length === 0 ? "[]" : t2 ? `[${e2.map((l) => vr(l, true, false, r2, s2)).join(",")}]` : `[
${e2.map((l) => o2.repeat(i2 + 1) + vr(l, false, false, r2, s2, i2 + 1)).join(`,
`)}
${o2.repeat(i2)}]`;
  if (typeof e2 == "object") {
    let a = Object.keys(e2);
    return r2 && (a = a.sort()), a.length === 0 ? "{}" : t2 ? `{${a.map((c) => `${JSON.stringify(c)}:${vr(e2[c], true, false, r2, s2)}`).join(",")}}` : `{
${a.map((c) => {
      let u = vr(e2[c], false, false, r2, s2, i2 + 1);
      return `${o2.repeat(i2 + 1)}${JSON.stringify(c)}: ${u}`;
    }).join(`,
`)}
${o2.repeat(i2)}}`;
  }
  return String(e2);
}
var iS, oS, nd = v(() => {
  de();
  pn();
  X();
  Yp();
  iS = { name: "jq", summary: "command-line JSON processor", usage: "jq [OPTIONS] FILTER [FILE]", options: ["-r, --raw-output  output strings without quotes", "-c, --compact     compact output (no pretty printing)", "-e, --exit-status set exit status based on output", "-s, --slurp       read entire input into array", "-n, --null-input  don't read any input", "-j, --join-output don't print newlines after each output", "-a, --ascii       force ASCII output", "-S, --sort-keys   sort object keys", "-C, --color       colorize output (ignored)", "-M, --monochrome  monochrome output (ignored)", "    --tab         use tabs for indentation", "    --help        display this help and exit"] };
  oS = { name: "jq", async execute(e2, t2) {
    if (_(e2)) return F$3(iS);
    let n2 = false, r2 = false, s2 = false, i2 = false, o2 = false, a = false, l = false, c = false, u = ".", f2 = false, p = [];
    for (let m = 0; m < e2.length; m++) {
      let h = e2[m];
      if (h === "-r" || h === "--raw-output") n2 = true;
      else if (h === "-c" || h === "--compact-output") r2 = true;
      else if (h === "-e" || h === "--exit-status") s2 = true;
      else if (h === "-s" || h === "--slurp") i2 = true;
      else if (h === "-n" || h === "--null-input") o2 = true;
      else if (h === "-j" || h === "--join-output") a = true;
      else if (!(h === "-a" || h === "--ascii")) {
        if (h === "-S" || h === "--sort-keys") l = true;
        else if (!(h === "-C" || h === "--color")) {
          if (!(h === "-M" || h === "--monochrome")) if (h === "--tab") c = true;
          else if (h === "-") p.push("-");
          else {
            if (h.startsWith("--")) return G("jq", h);
            if (h.startsWith("-")) {
              for (let g of h.slice(1)) if (g === "r") n2 = true;
              else if (g === "c") r2 = true;
              else if (g === "e") s2 = true;
              else if (g === "s") i2 = true;
              else if (g === "n") o2 = true;
              else if (g === "j") a = true;
              else if (g !== "a") {
                if (g === "S") l = true;
                else if (g !== "C") {
                  if (g !== "M") return G("jq", `-${g}`);
                }
              }
            } else f2 ? p.push(h) : (u = h, f2 = true);
          }
        }
      }
    }
    let d = [];
    if (!o2) if (p.length === 0 || p.length === 1 && p[0] === "-") d.push({ source: "stdin", content: t2.stdin });
    else {
      let m = await fn(t2, p, { cmdName: "jq", stopOnError: true });
      if (m.exitCode !== 0) return { stdout: "", stderr: m.stderr, exitCode: 2 };
      d = m.files.map((h) => ({ source: h.filename || "stdin", content: h.content }));
    }
    try {
      let m = Xp(u), h = [], g = { limits: t2.limits ? { maxIterations: t2.limits.maxJqIterations } : void 0, env: t2.env };
      if (o2) h = z(null, m, g);
      else if (i2) {
        let C = [];
        for (let { content: A } of d) {
          let I = A.trim();
          I && C.push(...ed(I));
        }
        h = z(C, m, g);
      } else for (let { content: C } of d) {
        let A = C.trim();
        if (!A) continue;
        let I = ed(A);
        for (let O of I) h.push(...z(O, m, g));
      }
      let b = h.map((C) => vr(C, r2, n2, l, c)), y = a ? "" : `
`, w = b.join(y), E = s2 && (h.length === 0 || h.every((C) => C == null || C === false)) ? 1 : 0;
      return { stdout: w ? a ? w : `${w}
` : "", stderr: "", exitCode: E };
    } catch (m) {
      if (m instanceof ne) return { stdout: "", stderr: `jq: ${m.message}
`, exitCode: ne.EXIT_CODE };
      let h = m.message;
      return h.includes("Unknown function") ? { stdout: "", stderr: `jq: error: ${h}
`, exitCode: 3 } : { stdout: "", stderr: `jq: parse error: ${h}
`, exitCode: 5 };
    }
  } };
});
var sd = {};
V(sd, { base64Command: () => cS });
async function rd(e2, t2, n2) {
  if (t2.length === 0 || t2.length === 1 && t2[0] === "-") return { ok: true, data: Uint8Array.from(e2.stdin, (a) => a.charCodeAt(0)) };
  let r2 = [];
  for (let a of t2) {
    if (a === "-") {
      r2.push(Uint8Array.from(e2.stdin, (l) => l.charCodeAt(0)));
      continue;
    }
    try {
      let l = e2.fs.resolvePath(e2.cwd, a), c = await e2.fs.readFileBuffer(l);
      r2.push(c);
    } catch {
      return { ok: false, error: { stdout: "", stderr: `${n2}: ${a}: No such file or directory
`, exitCode: 1 } };
    }
  }
  let s2 = r2.reduce((a, l) => a + l.length, 0), i2 = new Uint8Array(s2), o2 = 0;
  for (let a of r2) i2.set(a, o2), o2 += a.length;
  return { ok: true, data: i2 };
}
var aS, lS, cS, id = v(() => {
  Oe();
  X();
  aS = { name: "base64", summary: "base64 encode/decode data and print to standard output", usage: "base64 [OPTION]... [FILE]", options: ["-d, --decode    decode data", "-w, --wrap=COLS wrap encoded lines after COLS character (default 76, 0 to disable)", "    --help      display this help and exit"] }, lS = { decode: { short: "d", long: "decode", type: "boolean" }, wrap: { short: "w", long: "wrap", type: "number", default: 76 } };
  cS = { name: "base64", async execute(e2, t2) {
    if (_(e2)) return F$3(aS);
    let n2 = fe("base64", e2, lS);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.decode, s2 = n2.result.flags.wrap, i2 = n2.result.positional;
    try {
      if (r2) {
        let l = await rd(t2, i2, "base64");
        if (!l.ok) return l.error;
        let u = String.fromCharCode(...l.data).replace(/\s/g, "");
        return { stdout: atob(u), stderr: "", exitCode: 0 };
      }
      let o2 = await rd(t2, i2, "base64");
      if (!o2.ok) return o2.error;
      let a = btoa(String.fromCharCode(...o2.data));
      if (s2 > 0) {
        let l = [];
        for (let c = 0; c < a.length; c += s2) l.push(a.slice(c, c + s2));
        a = l.join(`
`) + (a.length > 0 ? `
` : "");
      }
      return { stdout: a, stderr: "", exitCode: 0 };
    } catch {
      return { stdout: "", stderr: `base64: invalid input
`, exitCode: 1 };
    }
  } };
});
var ad = {};
V(ad, { diffCommand: () => pS });
var uS, fS, pS, ld = v(() => {
  Oe();
  X();
  uS = { name: "diff", summary: "compare files line by line", usage: "diff [OPTION]... FILE1 FILE2", options: ["-u, --unified     output unified diff format (default)", "-q, --brief       report only whether files differ", "-s, --report-identical-files  report when files are the same", "-i, --ignore-case  ignore case differences", "    --help        display this help and exit"] }, fS = { unified: { short: "u", long: "unified", type: "boolean" }, brief: { short: "q", long: "brief", type: "boolean" }, reportSame: { short: "s", long: "report-identical-files", type: "boolean" }, ignoreCase: { short: "i", long: "ignore-case", type: "boolean" } }, pS = { name: "diff", async execute(e2, t2) {
    if (_(e2)) return F$3(uS);
    let n2 = fe("diff", e2, fS);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.brief, s2 = n2.result.flags.reportSame, i2 = n2.result.flags.ignoreCase, o2 = n2.result.positional;
    if (n2.result.flags.unified, o2.length < 2) return { stdout: "", stderr: `diff: missing operand
`, exitCode: 2 };
    let a, l, [c, u] = o2;
    try {
      a = c === "-" ? t2.stdin : await t2.fs.readFile(t2.fs.resolvePath(t2.cwd, c));
    } catch {
      return { stdout: "", stderr: `diff: ${c}: No such file or directory
`, exitCode: 2 };
    }
    try {
      l = u === "-" ? t2.stdin : await t2.fs.readFile(t2.fs.resolvePath(t2.cwd, u));
    } catch {
      return { stdout: "", stderr: `diff: ${u}: No such file or directory
`, exitCode: 2 };
    }
    let f2 = a, p = l;
    return i2 && (f2 = f2.toLowerCase(), p = p.toLowerCase()), f2 === p ? s2 ? { stdout: `Files ${c} and ${u} are identical
`, stderr: "", exitCode: 0 } : { stdout: "", stderr: "", exitCode: 0 } : r2 ? { stdout: `Files ${c} and ${u} differ
`, stderr: "", exitCode: 1 } : { stdout: createTwoFilesPatch(c, u, a, l, "", "", { context: 3 }), stderr: "", exitCode: 1 };
  } };
});
var cd = {};
V(cd, { dateCommand: () => bS });
function Xe(e2, t2 = 2) {
  return String(e2).padStart(t2, "0");
}
function gS(e2) {
  let t2 = -e2.getTimezoneOffset();
  return `${t2 >= 0 ? "+" : "-"}${Xe(Math.floor(Math.abs(t2) / 60))}${Xe(Math.abs(t2) % 60)}`;
}
function Ts(e2, t2, n2) {
  let r2 = n2 ? { Y: e2.getUTCFullYear(), m: e2.getUTCMonth(), D: e2.getUTCDate(), H: e2.getUTCHours(), M: e2.getUTCMinutes(), S: e2.getUTCSeconds(), w: e2.getUTCDay() } : { Y: e2.getFullYear(), m: e2.getMonth(), D: e2.getDate(), H: e2.getHours(), M: e2.getMinutes(), S: e2.getSeconds(), w: e2.getDay() }, s2 = "", i2 = 0;
  for (; i2 < t2.length; ) {
    if (t2[i2] === "%" && i2 + 1 < t2.length) {
      let o2 = t2[++i2];
      switch (o2) {
        case "%":
          s2 += "%";
          break;
        case "a":
          s2 += hS[r2.w];
          break;
        case "b":
        case "h":
          s2 += mS[r2.m];
          break;
        case "d":
          s2 += Xe(r2.D);
          break;
        case "e":
          s2 += String(r2.D).padStart(2, " ");
          break;
        case "F":
          s2 += `${r2.Y}-${Xe(r2.m + 1)}-${Xe(r2.D)}`;
          break;
        case "H":
          s2 += Xe(r2.H);
          break;
        case "I":
          s2 += Xe(r2.H % 12 || 12);
          break;
        case "m":
          s2 += Xe(r2.m + 1);
          break;
        case "M":
          s2 += Xe(r2.M);
          break;
        case "n":
          s2 += `
`;
          break;
        case "p":
          s2 += r2.H < 12 ? "AM" : "PM";
          break;
        case "P":
          s2 += r2.H < 12 ? "am" : "pm";
          break;
        case "R":
          s2 += `${Xe(r2.H)}:${Xe(r2.M)}`;
          break;
        case "s":
          s2 += Math.floor(e2.getTime() / 1e3);
          break;
        case "S":
          s2 += Xe(r2.S);
          break;
        case "t":
          s2 += "	";
          break;
        case "T":
          s2 += `${Xe(r2.H)}:${Xe(r2.M)}:${Xe(r2.S)}`;
          break;
        case "u":
          s2 += r2.w || 7;
          break;
        case "w":
          s2 += r2.w;
          break;
        case "y":
          s2 += Xe(r2.Y % 100);
          break;
        case "Y":
          s2 += r2.Y;
          break;
        case "z":
          s2 += n2 ? "+0000" : gS(e2);
          break;
        case "Z":
          s2 += n2 ? "UTC" : Intl.DateTimeFormat().resolvedOptions().timeZone;
          break;
        default:
          s2 += `%${o2}`;
      }
    } else s2 += t2[i2];
    i2++;
  }
  return s2;
}
function yS(e2) {
  let t2 = new Date(e2);
  if (!Number.isNaN(t2.getTime())) return t2;
  if (/^\d+$/.test(e2)) return new Date(Number.parseInt(e2, 10) * 1e3);
  let n2 = e2.toLowerCase();
  return n2 === "now" || n2 === "today" ? /* @__PURE__ */ new Date() : n2 === "yesterday" ? new Date(Date.now() - 864e5) : n2 === "tomorrow" ? new Date(Date.now() + 864e5) : null;
}
var dS, hS, mS, bS, ud = v(() => {
  X();
  dS = { name: "date", summary: "display the current time in the given FORMAT", usage: "date [OPTION]... [+FORMAT]", options: ["-d, --date=STRING   display time described by STRING", "-u, --utc           print Coordinated Universal Time (UTC)", "-I, --iso-8601      output date/time in ISO 8601 format", "-R, --rfc-email     output RFC 5322 date format", "    --help          display this help and exit"] }, hS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], mS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  bS = { name: "date", async execute(e2, t2) {
    if (_(e2)) return F$3(dS);
    let n2 = false, r2 = null, s2 = null, i2 = false, o2 = false;
    for (let c = 0; c < e2.length; c++) {
      let u = e2[c];
      if (u === "-u" || u === "--utc") n2 = true;
      else if (u === "-d" || u === "--date") r2 = e2[++c] ?? "";
      else if (u.startsWith("--date=")) r2 = u.slice(7);
      else if (u === "-I" || u === "--iso-8601") i2 = true;
      else if (u === "-R" || u === "--rfc-email") o2 = true;
      else if (u.startsWith("+")) s2 = u.slice(1);
      else {
        if (u.startsWith("--")) return G("date", u);
        if (u.startsWith("-")) for (let f2 of u.slice(1)) if (f2 === "u") n2 = true;
        else if (f2 === "I") i2 = true;
        else if (f2 === "R") o2 = true;
        else return G("date", `-${f2}`);
      }
    }
    let a = r2 !== null ? yS(r2) : /* @__PURE__ */ new Date();
    if (!a) return { stdout: "", stderr: `date: invalid date '${r2}'
`, exitCode: 1 };
    let l;
    return s2 ? l = Ts(a, s2, n2) : i2 ? l = Ts(a, "%Y-%m-%dT%H:%M:%S%z", n2) : o2 ? l = Ts(a, "%a, %d %b %Y %H:%M:%S %z", n2) : l = Ts(a, "%a %b %e %H:%M:%S %Z %Y", n2), { stdout: `${l}
`, stderr: "", exitCode: 0 };
  } };
});
var fd = {};
V(fd, { sleepCommand: () => ES });
function xS(e2) {
  let t2 = e2.match(/^(\d+\.?\d*)(s|m|h|d)?$/);
  if (!t2) return null;
  let n2 = parseFloat(t2[1]);
  switch (t2[2] || "s") {
    case "s":
      return n2 * 1e3;
    case "m":
      return n2 * 60 * 1e3;
    case "h":
      return n2 * 60 * 60 * 1e3;
    case "d":
      return n2 * 24 * 60 * 60 * 1e3;
    default:
      return null;
  }
}
var wS, ES, pd = v(() => {
  X();
  wS = { name: "sleep", summary: "delay for a specified amount of time", usage: "sleep NUMBER[SUFFIX]", description: `Pause for NUMBER seconds. SUFFIX may be:
  s - seconds (default)
  m - minutes
  h - hours
  d - days

NUMBER may be a decimal number.`, options: ["    --help display this help and exit"] };
  ES = { name: "sleep", async execute(e2, t2) {
    if (_(e2)) return F$3(wS);
    if (e2.length === 0) return { stdout: "", stderr: `sleep: missing operand
`, exitCode: 1 };
    let n2 = 0;
    for (let r2 of e2) {
      let s2 = xS(r2);
      if (s2 === null) return { stdout: "", stderr: `sleep: invalid time interval '${r2}'
`, exitCode: 1 };
      n2 += s2;
    }
    return t2.sleep ? await t2.sleep(n2) : await new Promise((r2) => setTimeout(r2, n2)), { stdout: "", stderr: "", exitCode: 0 };
  } };
});
var dd = {};
V(dd, { timeoutCommand: () => CS });
function AS(e2) {
  let t2 = e2.match(/^(\d+\.?\d*)(s|m|h|d)?$/);
  if (!t2) return null;
  let n2 = parseFloat(t2[1]);
  switch (t2[2] || "s") {
    case "s":
      return n2 * 1e3;
    case "m":
      return n2 * 60 * 1e3;
    case "h":
      return n2 * 60 * 60 * 1e3;
    case "d":
      return n2 * 24 * 60 * 60 * 1e3;
    default:
      return null;
  }
}
var SS, CS, hd = v(() => {
  X();
  SS = { name: "timeout", summary: "run a command with a time limit", usage: "timeout [OPTION] DURATION COMMAND [ARG]...", description: `Start COMMAND, and kill it if still running after DURATION.

DURATION is a number with optional suffix:
  s - seconds (default)
  m - minutes
  h - hours
  d - days`, options: ["-k, --kill-after=DURATION  send KILL signal after DURATION if still running", "-s, --signal=SIGNAL        specify signal to send (default: TERM)", "    --preserve-status      exit with same status as COMMAND, even on timeout", "    --foreground           run command in foreground", "    --help                 display this help and exit"] };
  CS = { name: "timeout", async execute(e2, t2) {
    if (_(e2)) return F$3(SS);
    let r2 = 0;
    for (let p = 0; p < e2.length; p++) {
      let d = e2[p];
      if (d === "--preserve-status") r2 = p + 1;
      else if (d === "--foreground") r2 = p + 1;
      else if (d === "-k" || d === "--kill-after") p++, r2 = p + 1;
      else if (d.startsWith("--kill-after=")) r2 = p + 1;
      else if (d === "-s" || d === "--signal") p++, r2 = p + 1;
      else if (d.startsWith("--signal=")) r2 = p + 1;
      else {
        if (d.startsWith("--") && d !== "--") return G("timeout", d);
        if (d.startsWith("-") && d.length > 1 && d !== "--") if (d.startsWith("-k")) r2 = p + 1;
        else if (d.startsWith("-s")) r2 = p + 1;
        else return G("timeout", d);
        else {
          r2 = p;
          break;
        }
      }
    }
    let s2 = e2.slice(r2);
    if (s2.length === 0) return { stdout: "", stderr: `timeout: missing operand
`, exitCode: 1 };
    let i2 = s2[0], o2 = AS(i2);
    if (o2 === null) return { stdout: "", stderr: `timeout: invalid time interval '${i2}'
`, exitCode: 1 };
    let a = s2.slice(1);
    if (a.length === 0) return { stdout: "", stderr: `timeout: missing operand
`, exitCode: 1 };
    if (!t2.exec) return { stdout: "", stderr: `timeout: exec not available
`, exitCode: 1 };
    let l = a.map((p) => p.includes(" ") || p.includes("	") ? `'${p.replace(/'/g, "'\\''")}'` : p).join(" "), c = new Promise((p) => {
      setTimeout(() => p({ timedOut: true }), o2);
    }), u = t2.exec(l, { cwd: t2.cwd }).then((p) => ({ timedOut: false, result: p })), f2 = await Promise.race([c, u]);
    return f2.timedOut ? { stdout: "", stderr: "", exitCode: 124 } : f2.result;
  } };
});
var md = {};
V(md, { timeCommand: () => NS });
function kS(e2) {
  let t2 = Math.floor(e2 / 3600), n2 = Math.floor(e2 % 3600 / 60), r2 = e2 % 60;
  return t2 > 0 ? `${t2}:${n2.toString().padStart(2, "0")}:${r2.toFixed(2).padStart(5, "0")}` : `${n2}:${r2.toFixed(2).padStart(5, "0")}`;
}
var NS, gd = v(() => {
  NS = { name: "time", async execute(e2, t2) {
    let n2 = "%e %M", r2 = null, s2 = false, i2 = false, o2 = 0;
    for (; o2 < e2.length; ) {
      let m = e2[o2];
      if (m === "-f" || m === "--format") {
        if (o2++, o2 >= e2.length) return { stdout: "", stderr: `time: missing argument to '-f'
`, exitCode: 1 };
        n2 = e2[o2], o2++;
      } else if (m === "-o" || m === "--output") {
        if (o2++, o2 >= e2.length) return { stdout: "", stderr: `time: missing argument to '-o'
`, exitCode: 1 };
        r2 = e2[o2], o2++;
      } else if (m === "-a" || m === "--append") s2 = true, o2++;
      else if (m === "-v" || m === "--verbose") n2 = `Command being timed: %C
Elapsed (wall clock) time: %e seconds
Maximum resident set size (kbytes): %M`, o2++;
      else if (m === "-p" || m === "--portability") i2 = true, o2++;
      else if (m === "--") {
        o2++;
        break;
      } else if (m.startsWith("-")) o2++;
      else break;
    }
    let a = e2.slice(o2);
    if (a.length === 0) return { stdout: "", stderr: "", exitCode: 0 };
    let l = performance.now(), c = a.join(" "), u;
    try {
      if (!t2.exec) return { stdout: "", stderr: `time: exec not available
`, exitCode: 1 };
      u = await t2.exec(c, { env: t2.env, cwd: t2.cwd });
    } catch (m) {
      u = { stdout: "", stderr: `time: ${m.message}
`, exitCode: 127 };
    }
    let p = (performance.now() - l) / 1e3, d;
    if (i2 ? d = `real ${p.toFixed(2)}
user 0.00
sys 0.00
` : (d = n2.replace(/%e/g, p.toFixed(2)).replace(/%E/g, kS(p)).replace(/%M/g, "0").replace(/%S/g, "0.00").replace(/%U/g, "0.00").replace(/%P/g, "0%").replace(/%C/g, c), d.endsWith(`
`) || (d += `
`)), r2) try {
      let m = t2.fs.resolvePath(t2.cwd, r2);
      if (s2 && await t2.fs.exists(m)) {
        let h = await t2.fs.readFile(m);
        await t2.fs.writeFile(m, h + d);
      } else await t2.fs.writeFile(m, d);
    } catch (m) {
      return { stdout: u.stdout, stderr: u.stderr + `time: cannot write to '${r2}': ${m.message}
`, exitCode: u.exitCode };
    }
    else u = { ...u, stderr: u.stderr + d };
    return u;
  } };
});
var yd = {};
V(yd, { seqCommand: () => vS });
var vS, bd = v(() => {
  vS = { name: "seq", async execute(e2) {
    let t2 = `
`, n2 = false, r2 = [], s2 = 0;
    for (; s2 < e2.length; ) {
      let m = e2[s2];
      if (m === "-s" && s2 + 1 < e2.length) {
        t2 = e2[s2 + 1], s2 += 2;
        continue;
      }
      if (m === "-w") {
        n2 = true, s2++;
        continue;
      }
      if (m === "--") {
        s2++;
        break;
      }
      if (m.startsWith("-") && m !== "-") {
        if (m.startsWith("-s") && m.length > 2) {
          t2 = m.slice(2), s2++;
          continue;
        }
        if ((m === "-ws" || m === "-sw") && (n2 = true, s2 + 1 < e2.length)) {
          t2 = e2[s2 + 1], s2 += 2;
          continue;
        }
      }
      r2.push(m), s2++;
    }
    for (; s2 < e2.length; ) r2.push(e2[s2]), s2++;
    if (r2.length === 0) return { stdout: "", stderr: `seq: missing operand
`, exitCode: 1 };
    let i2 = 1, o2 = 1, a;
    if (r2.length === 1 ? a = parseFloat(r2[0]) : r2.length === 2 ? (i2 = parseFloat(r2[0]), a = parseFloat(r2[1])) : (i2 = parseFloat(r2[0]), o2 = parseFloat(r2[1]), a = parseFloat(r2[2])), Number.isNaN(i2) || Number.isNaN(o2) || Number.isNaN(a)) return { stdout: "", stderr: `seq: invalid floating point argument: '${r2.find((h) => Number.isNaN(parseFloat(h)))}'
`, exitCode: 1 };
    if (o2 === 0) return { stdout: "", stderr: `seq: invalid Zero increment value: '0'
`, exitCode: 1 };
    let l = [], c = (m) => {
      let h = String(m), g = h.indexOf(".");
      return g === -1 ? 0 : h.length - g - 1;
    }, u = Math.max(c(i2), c(o2), c(a)), f2 = 1e5, p = 0;
    if (o2 > 0) for (let m = i2; m <= a + 1e-10 && !(p++ > f2); m += o2) l.push(u > 0 ? m.toFixed(u) : String(Math.round(m)));
    else for (let m = i2; m >= a - 1e-10 && !(p++ > f2); m += o2) l.push(u > 0 ? m.toFixed(u) : String(Math.round(m)));
    if (n2 && l.length > 0) {
      let m = Math.max(...l.map((h) => h.replace("-", "").length));
      for (let h = 0; h < l.length; h++) {
        let g = l[h].startsWith("-"), y = (g ? l[h].slice(1) : l[h]).padStart(m, "0");
        l[h] = g ? `-${y}` : y;
      }
    }
    let d = l.join(t2);
    return { stdout: d ? `${d}
` : "", stderr: "", exitCode: 0 };
  } };
});
var wd = {};
V(wd, { exprCommand: () => $S });
function IS(e2) {
  if (e2.length === 1) return e2[0];
  let t2 = 0;
  function n2() {
    let c = r2();
    for (; t2 < e2.length && e2[t2] === "|"; ) {
      t2++;
      let u = r2();
      if (c !== "0" && c !== "") return c;
      c = u;
    }
    return c;
  }
  function r2() {
    let c = s2();
    for (; t2 < e2.length && e2[t2] === "&"; ) {
      t2++;
      let u = s2();
      (c === "0" || c === "" || u === "0" || u === "") && (c = "0");
    }
    return c;
  }
  function s2() {
    let c = i2();
    for (; t2 < e2.length; ) {
      let u = e2[t2];
      if (["=", "!=", "<", ">", "<=", ">="].includes(u)) {
        t2++;
        let f2 = i2(), p = parseInt(c, 10), d = parseInt(f2, 10), m = !Number.isNaN(p) && !Number.isNaN(d), h;
        u === "=" ? h = m ? p === d : c === f2 : u === "!=" ? h = m ? p !== d : c !== f2 : u === "<" ? h = m ? p < d : c < f2 : u === ">" ? h = m ? p > d : c > f2 : u === "<=" ? h = m ? p <= d : c <= f2 : h = m ? p >= d : c >= f2, c = h ? "1" : "0";
      } else break;
    }
    return c;
  }
  function i2() {
    let c = o2();
    for (; t2 < e2.length; ) {
      let u = e2[t2];
      if (u === "+" || u === "-") {
        t2++;
        let f2 = o2(), p = parseInt(c, 10), d = parseInt(f2, 10);
        if (Number.isNaN(p) || Number.isNaN(d)) throw new Error("non-integer argument");
        c = String(u === "+" ? p + d : p - d);
      } else break;
    }
    return c;
  }
  function o2() {
    let c = a();
    for (; t2 < e2.length; ) {
      let u = e2[t2];
      if (u === "*" || u === "/" || u === "%") {
        t2++;
        let f2 = a(), p = parseInt(c, 10), d = parseInt(f2, 10);
        if (Number.isNaN(p) || Number.isNaN(d)) throw new Error("non-integer argument");
        if ((u === "/" || u === "%") && d === 0) throw new Error("division by zero");
        u === "*" ? c = String(p * d) : u === "/" ? c = String(Math.trunc(p / d)) : c = String(p % d);
      } else break;
    }
    return c;
  }
  function a() {
    let c = l();
    for (; t2 < e2.length && e2[t2] === ":"; ) {
      t2++;
      let u = l(), f2 = new RegExp(`^${u}`), p = c.match(f2);
      p ? c = p[1] !== void 0 ? p[1] : String(p[0].length) : c = "0";
    }
    return c;
  }
  function l() {
    if (t2 >= e2.length) throw new Error("syntax error");
    let c = e2[t2];
    if (c === "match") {
      t2++;
      let u = l(), f2 = l(), p = new RegExp(f2), d = u.match(p);
      return d ? d[1] !== void 0 ? d[1] : String(d[0].length) : "0";
    }
    if (c === "substr") {
      t2++;
      let u = l(), f2 = parseInt(l(), 10), p = parseInt(l(), 10);
      if (Number.isNaN(f2) || Number.isNaN(p)) throw new Error("non-integer argument");
      return u.substring(f2 - 1, f2 - 1 + p);
    }
    if (c === "index") {
      t2++;
      let u = l(), f2 = l();
      for (let p = 0; p < u.length; p++) if (f2.includes(u[p])) return String(p + 1);
      return "0";
    }
    if (c === "length") {
      t2++;
      let u = l();
      return String(u.length);
    }
    if (c === "(") {
      t2++;
      let u = n2();
      if (t2 >= e2.length || e2[t2] !== ")") throw new Error("syntax error");
      return t2++, u;
    }
    return t2++, c;
  }
  return n2();
}
var $S, xd = v(() => {
  $S = { name: "expr", async execute(e2, t2) {
    if (e2.length === 0) return { stdout: "", stderr: `expr: missing operand
`, exitCode: 2 };
    try {
      let n2 = IS(e2), r2 = n2 === "0" || n2 === "" ? 1 : 0;
      return { stdout: `${n2}
`, stderr: "", exitCode: r2 };
    } catch (n2) {
      return { stdout: "", stderr: `expr: ${n2.message}
`, exitCode: 2 };
    }
  } };
});
function PS(e2) {
  function t2(d, m) {
    return d << m | d >>> 32 - m;
  }
  let n2 = new Uint32Array([3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745]), r2 = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21], s2 = e2.length * 8, i2 = (e2.length % 64 < 56 ? 56 : 120) - e2.length % 64, o2 = new Uint8Array(e2.length + i2 + 8);
  o2.set(e2), o2[e2.length] = 128;
  let a = new DataView(o2.buffer);
  a.setUint32(o2.length - 8, s2 >>> 0, true), a.setUint32(o2.length - 4, Math.floor(s2 / 4294967296), true);
  let l = 1732584193, c = 4023233417, u = 2562383102, f2 = 271733878;
  for (let d = 0; d < o2.length; d += 64) {
    let m = new Uint32Array(16);
    for (let w = 0; w < 16; w++) m[w] = a.getUint32(d + w * 4, true);
    let h = l, g = c, b = u, y = f2;
    for (let w = 0; w < 64; w++) {
      let E, C;
      w < 16 ? (E = g & b | ~g & y, C = w) : w < 32 ? (E = y & g | ~y & b, C = (5 * w + 1) % 16) : w < 48 ? (E = g ^ b ^ y, C = (3 * w + 5) % 16) : (E = b ^ (g | ~y), C = 7 * w % 16), E = E + h + n2[w] + m[C] >>> 0, h = y, y = b, b = g, g = g + t2(E, r2[w]) >>> 0;
    }
    l = l + h >>> 0, c = c + g >>> 0, u = u + b >>> 0, f2 = f2 + y >>> 0;
  }
  let p = new Uint8Array(16);
  return new DataView(p.buffer).setUint32(0, l, true), new DataView(p.buffer).setUint32(4, c, true), new DataView(p.buffer).setUint32(8, u, true), new DataView(p.buffer).setUint32(12, f2, true), Array.from(p).map((d) => d.toString(16).padStart(2, "0")).join("");
}
async function Ed(e2, t2) {
  if (e2 === "md5") return PS(t2);
  let n2 = await globalThis.crypto.subtle.digest(RS[e2], new Uint8Array(t2).buffer);
  return Array.from(new Uint8Array(n2)).map((r2) => r2.toString(16).padStart(2, "0")).join("");
}
function qn(e2, t2, n2) {
  let r2 = { name: e2, summary: n2, usage: `${e2} [OPTION]... [FILE]...`, options: ["-c, --check    read checksums from FILEs and check them", "    --help     display this help and exit"] };
  return { name: e2, async execute(s2, i2) {
    if (_(s2)) return F$3(r2);
    let o2 = false, a = [];
    for (let f2 of s2) if (f2 === "-c" || f2 === "--check") o2 = true;
    else if (!(f2 === "-b" || f2 === "-t" || f2 === "--binary" || f2 === "--text")) {
      if (f2.startsWith("-") && f2 !== "-") return G(e2, f2);
      a.push(f2);
    }
    a.length === 0 && a.push("-");
    let l = async (f2) => {
      if (f2 === "-") return Uint8Array.from(i2.stdin, (p) => p.charCodeAt(0));
      try {
        return await i2.fs.readFileBuffer(i2.fs.resolvePath(i2.cwd, f2));
      } catch {
        return null;
      }
    };
    if (o2) {
      let f2 = 0, p = "";
      for (let d of a) {
        let m = d === "-" ? i2.stdin : await i2.fs.readFile(i2.fs.resolvePath(i2.cwd, d)).catch(() => null);
        if (m === null) return { stdout: "", stderr: `${e2}: ${d}: No such file or directory
`, exitCode: 1 };
        for (let h of m.split(`
`)) {
          let g = h.match(/^([a-fA-F0-9]+)\s+[* ]?(.+)$/);
          if (!g) continue;
          let [, b, y] = g, w = await l(y);
          if (w === null) {
            p += `${y}: FAILED open or read
`, f2++;
            continue;
          }
          let E = await Ed(t2, w) === b.toLowerCase();
          p += `${y}: ${E ? "OK" : "FAILED"}
`, E || f2++;
        }
      }
      return f2 > 0 && (p += `${e2}: WARNING: ${f2} computed checksum${f2 > 1 ? "s" : ""} did NOT match
`), { stdout: p, stderr: "", exitCode: f2 > 0 ? 1 : 0 };
    }
    let c = "", u = 0;
    for (let f2 of a) {
      let p = await l(f2);
      if (p === null) {
        c += `${e2}: ${f2}: No such file or directory
`, u = 1;
        continue;
      }
      c += `${await Ed(t2, p)}  ${f2}
`;
    }
    return { stdout: c, stderr: "", exitCode: u };
  } };
}
var RS, Os = v(() => {
  X();
  RS = { sha1: "SHA-1", sha256: "SHA-256" };
});
var Sd = {};
V(Sd, { md5sumCommand: () => TS });
var TS, Ad = v(() => {
  Os();
  TS = qn("md5sum", "md5", "compute MD5 message digest");
});
var Cd = {};
V(Cd, { sha1sumCommand: () => OS });
var OS, Nd = v(() => {
  Os();
  OS = qn("sha1sum", "sha1", "compute SHA1 message digest");
});
var kd = {};
V(kd, { sha256sumCommand: () => DS });
var DS, vd = v(() => {
  Os();
  DS = qn("sha256sum", "sha256", "compute SHA256 message digest");
});
var $d = Kr((zo) => {
  zo.read = function(e2, t2, n2, r2, s2) {
    var i2, o2, a = s2 * 8 - r2 - 1, l = (1 << a) - 1, c = l >> 1, u = -7, f2 = n2 ? s2 - 1 : 0, p = n2 ? -1 : 1, d = e2[t2 + f2];
    for (f2 += p, i2 = d & (1 << -u) - 1, d >>= -u, u += a; u > 0; i2 = i2 * 256 + e2[t2 + f2], f2 += p, u -= 8) ;
    for (o2 = i2 & (1 << -u) - 1, i2 >>= -u, u += r2; u > 0; o2 = o2 * 256 + e2[t2 + f2], f2 += p, u -= 8) ;
    if (i2 === 0) i2 = 1 - c;
    else {
      if (i2 === l) return o2 ? NaN : (d ? -1 : 1) * (1 / 0);
      o2 = o2 + Math.pow(2, r2), i2 = i2 - c;
    }
    return (d ? -1 : 1) * o2 * Math.pow(2, i2 - r2);
  };
  zo.write = function(e2, t2, n2, r2, s2, i2) {
    var o2, a, l, c = i2 * 8 - s2 - 1, u = (1 << c) - 1, f2 = u >> 1, p = s2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r2 ? 0 : i2 - 1, m = r2 ? 1 : -1, h = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
    for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (a = isNaN(t2) ? 1 : 0, o2 = u) : (o2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (l = Math.pow(2, -o2)) < 1 && (o2--, l *= 2), o2 + f2 >= 1 ? t2 += p / l : t2 += p * Math.pow(2, 1 - f2), t2 * l >= 2 && (o2++, l /= 2), o2 + f2 >= u ? (a = 0, o2 = u) : o2 + f2 >= 1 ? (a = (t2 * l - 1) * Math.pow(2, s2), o2 = o2 + f2) : (a = t2 * Math.pow(2, f2 - 1) * Math.pow(2, s2), o2 = 0)); s2 >= 8; e2[n2 + d] = a & 255, d += m, a /= 256, s2 -= 8) ;
    for (o2 = o2 << s2 | a, c += s2; c > 0; e2[n2 + d] = o2 & 255, d += m, o2 /= 256, c -= 8) ;
    e2[n2 + d - m] |= h * 128;
  };
});
function Id(e2, t2 = "utf-8") {
  switch (t2.toLowerCase()) {
    case "utf-8":
    case "utf8":
      return typeof globalThis.TextDecoder < "u" ? new globalThis.TextDecoder("utf-8").decode(e2) : _S(e2);
    case "utf-16le":
      return LS(e2);
    case "ascii":
      return MS(e2);
    case "latin1":
    case "iso-8859-1":
      return WS(e2);
    case "windows-1252":
      return BS(e2);
    default:
      throw new RangeError(`Encoding '${t2}' not supported`);
  }
}
function _S(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) {
    let r2 = e2[n2++];
    if (r2 < 128) t2 += String.fromCharCode(r2);
    else if (r2 < 224) {
      let s2 = e2[n2++] & 63;
      t2 += String.fromCharCode((r2 & 31) << 6 | s2);
    } else if (r2 < 240) {
      let s2 = e2[n2++] & 63, i2 = e2[n2++] & 63;
      t2 += String.fromCharCode((r2 & 15) << 12 | s2 << 6 | i2);
    } else {
      let s2 = e2[n2++] & 63, i2 = e2[n2++] & 63, o2 = e2[n2++] & 63, a = (r2 & 7) << 18 | s2 << 12 | i2 << 6 | o2;
      a -= 65536, t2 += String.fromCharCode(55296 + (a >> 10 & 1023), 56320 + (a & 1023));
    }
  }
  return t2;
}
function LS(e2) {
  let t2 = "";
  for (let n2 = 0; n2 < e2.length; n2 += 2) t2 += String.fromCharCode(e2[n2] | e2[n2 + 1] << 8);
  return t2;
}
function MS(e2) {
  return String.fromCharCode(...e2.map((t2) => t2 & 127));
}
function WS(e2) {
  return String.fromCharCode(...e2);
}
function BS(e2) {
  let t2 = "";
  for (let n2 of e2) n2 >= 128 && n2 <= 159 && jo[n2] ? t2 += jo[n2] : t2 += String.fromCharCode(n2);
  return t2;
}
var jo, FS, Rd = v(() => {
  jo = { 128: "", 130: "", 131: "", 132: "", 133: "", 134: "", 135: "", 136: "", 137: "", 138: "", 139: "", 140: "", 142: "", 145: "", 146: "", 147: "", 148: "", 149: "", 150: "", 151: "", 152: "", 153: "", 154: "", 155: "", 156: "", 158: "", 159: "" }, FS = {};
  for (let [e2, t2] of Object.entries(jo)) FS[t2] = Number.parseInt(e2);
});
function ct(e2) {
  return new DataView(e2.buffer, e2.byteOffset);
}
var Td, Pe, Gn, De, Od, Dd, Fd, ut, $r = v(() => {
  Kl($d());
  Rd();
  Td = { len: 1, get(e2, t2) {
    return ct(e2).getUint8(t2);
  }, put(e2, t2, n2) {
    return ct(e2).setUint8(t2, n2), t2 + 1;
  } }, Pe = { len: 2, get(e2, t2) {
    return ct(e2).getUint16(t2, true);
  }, put(e2, t2, n2) {
    return ct(e2).setUint16(t2, n2, true), t2 + 2;
  } }, Gn = { len: 2, get(e2, t2) {
    return ct(e2).getUint16(t2);
  }, put(e2, t2, n2) {
    return ct(e2).setUint16(t2, n2), t2 + 2;
  } }, De = { len: 4, get(e2, t2) {
    return ct(e2).getUint32(t2, true);
  }, put(e2, t2, n2) {
    return ct(e2).setUint32(t2, n2, true), t2 + 4;
  } }, Od = { len: 4, get(e2, t2) {
    return ct(e2).getUint32(t2);
  }, put(e2, t2, n2) {
    return ct(e2).setUint32(t2, n2), t2 + 4;
  } }, Dd = { len: 4, get(e2, t2) {
    return ct(e2).getInt32(t2);
  }, put(e2, t2, n2) {
    return ct(e2).setInt32(t2, n2), t2 + 4;
  } }, Fd = { len: 8, get(e2, t2) {
    return ct(e2).getBigUint64(t2, true);
  }, put(e2, t2, n2) {
    return ct(e2).setBigUint64(t2, n2, true), t2 + 8;
  } }, ut = class {
    constructor(t2, n2) {
      this.len = t2, this.encoding = n2;
    }
    get(t2, n2 = 0) {
      let r2 = t2.subarray(n2, n2 + this.len);
      return Id(r2, this.encoding);
    }
  };
});
var zS, ke, gn, Ir = v(() => {
  zS = "End-Of-Stream", ke = class extends Error {
    constructor() {
      super(zS), this.name = "EndOfStreamError";
    }
  }, gn = class extends Error {
    constructor(t2 = "The operation was aborted") {
      super(t2), this.name = "AbortError";
    }
  };
});
var _d = v(() => {
});
var yn, Ds = v(() => {
  Ir();
  yn = class {
    constructor() {
      this.endOfStream = false, this.interrupted = false, this.peekQueue = [];
    }
    async peek(t2, n2 = false) {
      let r2 = await this.read(t2, n2);
      return this.peekQueue.push(t2.subarray(0, r2)), r2;
    }
    async read(t2, n2 = false) {
      if (t2.length === 0) return 0;
      let r2 = this.readFromPeekBuffer(t2);
      if (this.endOfStream || (r2 += await this.readRemainderFromStream(t2.subarray(r2), n2)), r2 === 0 && !n2) throw new ke();
      return r2;
    }
    readFromPeekBuffer(t2) {
      let n2 = t2.length, r2 = 0;
      for (; this.peekQueue.length > 0 && n2 > 0; ) {
        let s2 = this.peekQueue.pop();
        if (!s2) throw new Error("peekData should be defined");
        let i2 = Math.min(s2.length, n2);
        t2.set(s2.subarray(0, i2), r2), r2 += i2, n2 -= i2, i2 < s2.length && this.peekQueue.push(s2.subarray(i2));
      }
      return r2;
    }
    async readRemainderFromStream(t2, n2) {
      let r2 = 0;
      for (; r2 < t2.length && !this.endOfStream; ) {
        if (this.interrupted) throw new gn();
        let s2 = await this.readFromStream(t2.subarray(r2), n2);
        if (s2 === 0) break;
        r2 += s2;
      }
      if (!n2 && r2 < t2.length) throw new ke();
      return r2;
    }
  };
});
var Ld = v(() => {
  Ir();
  _d();
  Ds();
});
var Fs, Md = v(() => {
  Ds();
  Fs = class extends yn {
    constructor(t2) {
      super(), this.reader = t2;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };
});
var Rr, Ho = v(() => {
  Md();
  Rr = class extends Fs {
    async readFromStream(t2, n2) {
      if (t2.length === 0) return 0;
      let r2 = await this.reader.read(new Uint8Array(t2.length), { min: n2 ? void 0 : t2.length });
      return r2.done && (this.endOfStream = r2.done), r2.value ? (t2.set(r2.value), r2.value.length) : 0;
    }
  };
});
var Zn, Vo = v(() => {
  Ir();
  Ds();
  Zn = class extends yn {
    constructor(t2) {
      super(), this.reader = t2, this.buffer = null;
    }
    writeChunk(t2, n2) {
      let r2 = Math.min(n2.length, t2.length);
      return t2.set(n2.subarray(0, r2)), r2 < n2.length ? this.buffer = n2.subarray(r2) : this.buffer = null, r2;
    }
    async readFromStream(t2, n2) {
      if (t2.length === 0) return 0;
      let r2 = 0;
      for (this.buffer && (r2 += this.writeChunk(t2, this.buffer)); r2 < t2.length && !this.endOfStream; ) {
        let s2 = await this.reader.read();
        if (s2.done) {
          this.endOfStream = true;
          break;
        }
        s2.value && (r2 += this.writeChunk(t2.subarray(r2), s2.value));
      }
      if (!n2 && r2 === 0 && this.endOfStream) throw new ke();
      return r2;
    }
    abort() {
      return this.interrupted = true, this.reader.cancel();
    }
    async close() {
      await this.abort(), this.reader.releaseLock();
    }
  };
});
function qo(e2) {
  try {
    let t2 = e2.getReader({ mode: "byob" });
    return t2 instanceof ReadableStreamDefaultReader ? new Zn(t2) : new Rr(t2);
  } catch (t2) {
    if (t2 instanceof TypeError) return new Zn(e2.getReader());
    throw t2;
  }
}
var Wd = v(() => {
  Ho();
  Vo();
});
var bn = v(() => {
  Ir();
  Ld();
  Ho();
  Vo();
  Wd();
});
var Gt, Pr = v(() => {
  bn();
  Gt = class {
    constructor(t2) {
      this.numBuffer = new Uint8Array(8), this.position = 0, this.onClose = t2 == null ? void 0 : t2.onClose, (t2 == null ? void 0 : t2.abortSignal) && t2.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
    async readToken(t2, n2 = this.position) {
      let r2 = new Uint8Array(t2.len);
      if (await this.readBuffer(r2, { position: n2 }) < t2.len) throw new ke();
      return t2.get(r2, 0);
    }
    async peekToken(t2, n2 = this.position) {
      let r2 = new Uint8Array(t2.len);
      if (await this.peekBuffer(r2, { position: n2 }) < t2.len) throw new ke();
      return t2.get(r2, 0);
    }
    async readNumber(t2) {
      if (await this.readBuffer(this.numBuffer, { length: t2.len }) < t2.len) throw new ke();
      return t2.get(this.numBuffer, 0);
    }
    async peekNumber(t2) {
      if (await this.peekBuffer(this.numBuffer, { length: t2.len }) < t2.len) throw new ke();
      return t2.get(this.numBuffer, 0);
    }
    async ignore(t2) {
      if (this.fileInfo.size !== void 0) {
        let n2 = this.fileInfo.size - this.position;
        if (t2 > n2) return this.position += n2, n2;
      }
      return this.position += t2, t2;
    }
    async close() {
      var _a3;
      await this.abort(), await ((_a3 = this.onClose) == null ? void 0 : _a3.call(this));
    }
    normalizeOptions(t2, n2) {
      if (!this.supportsRandomAccess() && n2 && n2.position !== void 0 && n2.position < this.position) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      return { mayBeLess: false, offset: 0, length: t2.length, position: this.position, ...n2 };
    }
    abort() {
      return Promise.resolve();
    }
  };
});
var HS, _s, Bd = v(() => {
  Pr();
  bn();
  HS = 256e3, _s = class extends Gt {
    constructor(t2, n2) {
      super(n2), this.streamReader = t2, this.fileInfo = (n2 == null ? void 0 : n2.fileInfo) ?? {};
    }
    async readBuffer(t2, n2) {
      let r2 = this.normalizeOptions(t2, n2), s2 = r2.position - this.position;
      if (s2 > 0) return await this.ignore(s2), this.readBuffer(t2, n2);
      if (s2 < 0) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      if (r2.length === 0) return 0;
      let i2 = await this.streamReader.read(t2.subarray(0, r2.length), r2.mayBeLess);
      if (this.position += i2, (!n2 || !n2.mayBeLess) && i2 < r2.length) throw new ke();
      return i2;
    }
    async peekBuffer(t2, n2) {
      let r2 = this.normalizeOptions(t2, n2), s2 = 0;
      if (r2.position) {
        let i2 = r2.position - this.position;
        if (i2 > 0) {
          let o2 = new Uint8Array(r2.length + i2);
          return s2 = await this.peekBuffer(o2, { mayBeLess: r2.mayBeLess }), t2.set(o2.subarray(i2)), s2 - i2;
        }
        if (i2 < 0) throw new Error("Cannot peek from a negative offset in a stream");
      }
      if (r2.length > 0) {
        try {
          s2 = await this.streamReader.peek(t2.subarray(0, r2.length), r2.mayBeLess);
        } catch (i2) {
          if ((n2 == null ? void 0 : n2.mayBeLess) && i2 instanceof ke) return 0;
          throw i2;
        }
        if (!r2.mayBeLess && s2 < r2.length) throw new ke();
      }
      return s2;
    }
    async ignore(t2) {
      let n2 = Math.min(HS, t2), r2 = new Uint8Array(n2), s2 = 0;
      for (; s2 < t2; ) {
        let i2 = t2 - s2, o2 = await this.readBuffer(r2, { length: Math.min(n2, i2) });
        if (o2 < 0) return o2;
        s2 += o2;
      }
      return s2;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };
});
var Ls, Ud = v(() => {
  bn();
  Pr();
  Ls = class extends Gt {
    constructor(t2, n2) {
      super(n2), this.uint8Array = t2, this.fileInfo = { ...(n2 == null ? void 0 : n2.fileInfo) ?? {}, size: t2.length };
    }
    async readBuffer(t2, n2) {
      (n2 == null ? void 0 : n2.position) && (this.position = n2.position);
      let r2 = await this.peekBuffer(t2, n2);
      return this.position += r2, r2;
    }
    async peekBuffer(t2, n2) {
      let r2 = this.normalizeOptions(t2, n2), s2 = Math.min(this.uint8Array.length - r2.position, r2.length);
      if (!r2.mayBeLess && s2 < r2.length) throw new ke();
      return t2.set(this.uint8Array.subarray(r2.position, r2.position + s2)), s2;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(t2) {
      this.position = t2;
    }
  };
});
var Ms, zd = v(() => {
  bn();
  Pr();
  Ms = class extends Gt {
    constructor(t2, n2) {
      super(n2), this.blob = t2, this.fileInfo = { ...(n2 == null ? void 0 : n2.fileInfo) ?? {}, size: t2.size, mimeType: t2.type };
    }
    async readBuffer(t2, n2) {
      (n2 == null ? void 0 : n2.position) && (this.position = n2.position);
      let r2 = await this.peekBuffer(t2, n2);
      return this.position += r2, r2;
    }
    async peekBuffer(t2, n2) {
      let r2 = this.normalizeOptions(t2, n2), s2 = Math.min(this.blob.size - r2.position, r2.length);
      if (!r2.mayBeLess && s2 < r2.length) throw new ke();
      let i2 = await this.blob.slice(r2.position, r2.position + s2).arrayBuffer();
      return t2.set(new Uint8Array(i2)), s2;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(t2) {
      this.position = t2;
    }
  };
});
function jd(e2, t2) {
  let n2 = qo(e2), r2 = t2 ?? {}, s2 = r2.onClose;
  return r2.onClose = async () => {
    if (await n2.close(), s2) return s2();
  }, new _s(n2, r2);
}
function Hd(e2, t2) {
  return new Ls(e2, t2);
}
function Vd(e2, t2) {
  return new Ms(e2, t2);
}
var qd = v(() => {
  bn();
  Bd();
  Ud();
  zd();
  bn();
  Pr();
});
var Zd = Kr((HP, Gd) => {
  var Qn = 1e3, Kn = Qn * 60, Xn = Kn * 60, wn = Xn * 24, qS = wn * 7, GS = wn * 365.25;
  Gd.exports = function(e2, t2) {
    t2 = t2 || {};
    var n2 = typeof e2;
    if (n2 === "string" && e2.length > 0) return ZS(e2);
    if (n2 === "number" && isFinite(e2)) return t2.long ? KS(e2) : QS(e2);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
  };
  function ZS(e2) {
    if (e2 = String(e2), !(e2.length > 100)) {
      var t2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e2);
      if (t2) {
        var n2 = parseFloat(t2[1]), r2 = (t2[2] || "ms").toLowerCase();
        switch (r2) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n2 * GS;
          case "weeks":
          case "week":
          case "w":
            return n2 * qS;
          case "days":
          case "day":
          case "d":
            return n2 * wn;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n2 * Xn;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n2 * Kn;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n2 * Qn;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n2;
          default:
            return;
        }
      }
    }
  }
  function QS(e2) {
    var t2 = Math.abs(e2);
    return t2 >= wn ? Math.round(e2 / wn) + "d" : t2 >= Xn ? Math.round(e2 / Xn) + "h" : t2 >= Kn ? Math.round(e2 / Kn) + "m" : t2 >= Qn ? Math.round(e2 / Qn) + "s" : e2 + "ms";
  }
  function KS(e2) {
    var t2 = Math.abs(e2);
    return t2 >= wn ? Ws(e2, t2, wn, "day") : t2 >= Xn ? Ws(e2, t2, Xn, "hour") : t2 >= Kn ? Ws(e2, t2, Kn, "minute") : t2 >= Qn ? Ws(e2, t2, Qn, "second") : e2 + " ms";
  }
  function Ws(e2, t2, n2, r2) {
    var s2 = t2 >= n2 * 1.5;
    return Math.round(e2 / n2) + " " + r2 + (s2 ? "s" : "");
  }
});
var Kd = Kr((VP, Qd) => {
  function XS(e2) {
    n2.debug = n2, n2.default = n2, n2.coerce = l, n2.disable = o2, n2.enable = s2, n2.enabled = a, n2.humanize = Zd(), n2.destroy = c, Object.keys(e2).forEach((u) => {
      n2[u] = e2[u];
    }), n2.names = [], n2.skips = [], n2.formatters = {};
    function t2(u) {
      let f2 = 0;
      for (let p = 0; p < u.length; p++) f2 = (f2 << 5) - f2 + u.charCodeAt(p), f2 |= 0;
      return n2.colors[Math.abs(f2) % n2.colors.length];
    }
    n2.selectColor = t2;
    function n2(u) {
      let f2, p = null, d, m;
      function h(...g) {
        if (!h.enabled) return;
        let b = h, y = Number(/* @__PURE__ */ new Date()), w = y - (f2 || y);
        b.diff = w, b.prev = f2, b.curr = y, f2 = y, g[0] = n2.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
        let E = 0;
        g[0] = g[0].replace(/%([a-zA-Z%])/g, (A, I) => {
          if (A === "%%") return "%";
          E++;
          let O = n2.formatters[I];
          if (typeof O == "function") {
            let L = g[E];
            A = O.call(b, L), g.splice(E, 1), E--;
          }
          return A;
        }), n2.formatArgs.call(b, g), (b.log || n2.log).apply(b, g);
      }
      return h.namespace = u, h.useColors = n2.useColors(), h.color = n2.selectColor(u), h.extend = r2, h.destroy = n2.destroy, Object.defineProperty(h, "enabled", { enumerable: true, configurable: false, get: () => p !== null ? p : (d !== n2.namespaces && (d = n2.namespaces, m = n2.enabled(u)), m), set: (g) => {
        p = g;
      } }), typeof n2.init == "function" && n2.init(h), h;
    }
    function r2(u, f2) {
      let p = n2(this.namespace + (typeof f2 > "u" ? ":" : f2) + u);
      return p.log = this.log, p;
    }
    function s2(u) {
      n2.save(u), n2.namespaces = u, n2.names = [], n2.skips = [];
      let f2 = (typeof u == "string" ? u : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (let p of f2) p[0] === "-" ? n2.skips.push(p.slice(1)) : n2.names.push(p);
    }
    function i2(u, f2) {
      let p = 0, d = 0, m = -1, h = 0;
      for (; p < u.length; ) if (d < f2.length && (f2[d] === u[p] || f2[d] === "*")) f2[d] === "*" ? (m = d, h = p, d++) : (p++, d++);
      else if (m !== -1) d = m + 1, h++, p = h;
      else return false;
      for (; d < f2.length && f2[d] === "*"; ) d++;
      return d === f2.length;
    }
    function o2() {
      let u = [...n2.names, ...n2.skips.map((f2) => "-" + f2)].join(",");
      return n2.enable(""), u;
    }
    function a(u) {
      for (let f2 of n2.skips) if (i2(u, f2)) return false;
      for (let f2 of n2.names) if (i2(u, f2)) return true;
      return false;
    }
    function l(u) {
      return u instanceof Error ? u.stack || u.message : u;
    }
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return n2.enable(n2.load()), n2;
  }
  Qd.exports = XS;
});
var Xd = Kr((ft, Bs) => {
  ft.formatArgs = YS;
  ft.save = eA;
  ft.load = tA;
  ft.useColors = JS;
  ft.storage = nA();
  ft.destroy = /* @__PURE__ */ (() => {
    let e2 = false;
    return () => {
      e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })();
  ft.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  function JS() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
    let e2;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (e2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e2[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function YS(e2) {
    if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + Bs.exports.humanize(this.diff), !this.useColors) return;
    let t2 = "color: " + this.color;
    e2.splice(1, 0, t2, "color: inherit");
    let n2 = 0, r2 = 0;
    e2[0].replace(/%[a-zA-Z%]/g, (s2) => {
      s2 !== "%%" && (n2++, s2 === "%c" && (r2 = n2));
    }), e2.splice(r2, 0, t2);
  }
  ft.log = console.debug || console.log || (() => {
  });
  function eA(e2) {
    try {
      e2 ? ft.storage.setItem("debug", e2) : ft.storage.removeItem("debug");
    } catch {
    }
  }
  function tA() {
    let e2;
    try {
      e2 = ft.storage.getItem("debug") || ft.storage.getItem("DEBUG");
    } catch {
    }
    return !e2 && typeof process < "u" && "env" in process && (e2 = define_process_env_default.DEBUG), e2;
  }
  function nA() {
    try {
      return localStorage;
    } catch {
    }
  }
  Bs.exports = Kd()(ft);
  var { formatters: rA } = Bs.exports;
  rA.j = function(e2) {
    try {
      return JSON.stringify(e2);
    } catch (t2) {
      return "[UnexpectedJSONParseError]: " + t2.message;
    }
  };
});
var xn, Go, Jd, Yd, eh, th = v(() => {
  $r();
  xn = { LocalFileHeader: 67324752, DataDescriptor: 134695760, CentralFileHeader: 33639248, EndOfCentralDirectory: 101010256 }, Go = { get(e2) {
    return { signature: De.get(e2, 0), compressedSize: De.get(e2, 8), uncompressedSize: De.get(e2, 12) };
  }, len: 16 }, Jd = { get(e2) {
    let t2 = Pe.get(e2, 6);
    return { signature: De.get(e2, 0), minVersion: Pe.get(e2, 4), dataDescriptor: !!(t2 & 8), compressedMethod: Pe.get(e2, 8), compressedSize: De.get(e2, 18), uncompressedSize: De.get(e2, 22), filenameLength: Pe.get(e2, 26), extraFieldLength: Pe.get(e2, 28), filename: null };
  }, len: 30 }, Yd = { get(e2) {
    return { signature: De.get(e2, 0), nrOfThisDisk: Pe.get(e2, 4), nrOfThisDiskWithTheStart: Pe.get(e2, 6), nrOfEntriesOnThisDisk: Pe.get(e2, 8), nrOfEntriesOfSize: Pe.get(e2, 10), sizeOfCd: De.get(e2, 12), offsetOfStartOfCd: De.get(e2, 16), zipFileCommentLength: Pe.get(e2, 20) };
  }, len: 22 }, eh = { get(e2) {
    let t2 = Pe.get(e2, 8);
    return { signature: De.get(e2, 0), minVersion: Pe.get(e2, 6), dataDescriptor: !!(t2 & 8), compressedMethod: Pe.get(e2, 10), compressedSize: De.get(e2, 20), uncompressedSize: De.get(e2, 24), filenameLength: Pe.get(e2, 28), extraFieldLength: Pe.get(e2, 30), fileCommentLength: Pe.get(e2, 32), relativeOffsetOfLocalHeader: De.get(e2, 42), filename: null };
  }, len: 46 };
});
function rh(e2) {
  let t2 = new Uint8Array(De.len);
  return De.put(t2, 0, e2), t2;
}
function iA(e2, t2) {
  let n2 = e2.length, r2 = t2.length;
  if (r2 > n2) return -1;
  for (let s2 = 0; s2 <= n2 - r2; s2++) {
    let i2 = true;
    for (let o2 = 0; o2 < r2; o2++) if (e2[s2 + o2] !== t2[o2]) {
      i2 = false;
      break;
    }
    if (i2) return s2;
  }
  return -1;
}
function oA(e2) {
  let t2 = e2.reduce((s2, i2) => s2 + i2.length, 0), n2 = new Uint8Array(t2), r2 = 0;
  for (let s2 of e2) n2.set(s2, r2), r2 += s2.length;
  return n2;
}
var nh, Mt, Zo, sA, Us, Tr, sh = v(() => {
  $r();
  nh = Kl(Xd());
  th();
  Mt = (0, nh.default)("tokenizer:inflate"), Zo = 256 * 1024, sA = rh(xn.DataDescriptor), Us = rh(xn.EndOfCentralDirectory), Tr = class e2 {
    constructor(t2) {
      this.tokenizer = t2, this.syncBuffer = new Uint8Array(Zo);
    }
    async isZip() {
      return await this.peekSignature() === xn.LocalFileHeader;
    }
    peekSignature() {
      return this.tokenizer.peekToken(De);
    }
    async findEndOfCentralDirectoryLocator() {
      let t2 = this.tokenizer, n2 = Math.min(16 * 1024, t2.fileInfo.size), r2 = this.syncBuffer.subarray(0, n2);
      await this.tokenizer.readBuffer(r2, { position: t2.fileInfo.size - n2 });
      for (let s2 = r2.length - 4; s2 >= 0; s2--) if (r2[s2] === Us[0] && r2[s2 + 1] === Us[1] && r2[s2 + 2] === Us[2] && r2[s2 + 3] === Us[3]) return t2.fileInfo.size - n2 + s2;
      return -1;
    }
    async readCentralDirectory() {
      if (!this.tokenizer.supportsRandomAccess()) {
        Mt("Cannot reading central-directory without random-read support");
        return;
      }
      Mt("Reading central-directory...");
      let t2 = this.tokenizer.position, n2 = await this.findEndOfCentralDirectoryLocator();
      if (n2 > 0) {
        Mt("Central-directory 32-bit signature found");
        let r2 = await this.tokenizer.readToken(Yd, n2), s2 = [];
        this.tokenizer.setPosition(r2.offsetOfStartOfCd);
        for (let i2 = 0; i2 < r2.nrOfEntriesOfSize; ++i2) {
          let o2 = await this.tokenizer.readToken(eh);
          if (o2.signature !== xn.CentralFileHeader) throw new Error("Expected Central-File-Header signature");
          o2.filename = await this.tokenizer.readToken(new ut(o2.filenameLength, "utf-8")), await this.tokenizer.ignore(o2.extraFieldLength), await this.tokenizer.ignore(o2.fileCommentLength), s2.push(o2), Mt(`Add central-directory file-entry: n=${i2 + 1}/${s2.length}: filename=${s2[i2].filename}`);
        }
        return this.tokenizer.setPosition(t2), s2;
      }
      this.tokenizer.setPosition(t2);
    }
    async unzip(t2) {
      let n2 = await this.readCentralDirectory();
      if (n2) return this.iterateOverCentralDirectory(n2, t2);
      let r2 = false;
      do {
        let s2 = await this.readLocalFileHeader();
        if (!s2) break;
        let i2 = t2(s2);
        r2 = !!i2.stop;
        let o2;
        if (await this.tokenizer.ignore(s2.extraFieldLength), s2.dataDescriptor && s2.compressedSize === 0) {
          let a = [], l = Zo;
          Mt("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
          let c = -1;
          for (; c < 0 && l === Zo; ) {
            l = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true }), c = iA(this.syncBuffer.subarray(0, l), sA);
            let u = c >= 0 ? c : l;
            if (i2.handler) {
              let f2 = new Uint8Array(u);
              await this.tokenizer.readBuffer(f2), a.push(f2);
            } else await this.tokenizer.ignore(u);
          }
          Mt(`Found data-descriptor-signature at pos=${this.tokenizer.position}`), i2.handler && await this.inflate(s2, oA(a), i2.handler);
        } else i2.handler ? (Mt(`Reading compressed-file-data: ${s2.compressedSize} bytes`), o2 = new Uint8Array(s2.compressedSize), await this.tokenizer.readBuffer(o2), await this.inflate(s2, o2, i2.handler)) : (Mt(`Ignoring compressed-file-data: ${s2.compressedSize} bytes`), await this.tokenizer.ignore(s2.compressedSize));
        if (Mt(`Reading data-descriptor at pos=${this.tokenizer.position}`), s2.dataDescriptor && (await this.tokenizer.readToken(Go)).signature !== 134695760) throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - Go.len}`);
      } while (!r2);
    }
    async iterateOverCentralDirectory(t2, n2) {
      for (let r2 of t2) {
        let s2 = n2(r2);
        if (s2.handler) {
          this.tokenizer.setPosition(r2.relativeOffsetOfLocalHeader);
          let i2 = await this.readLocalFileHeader();
          if (i2) {
            await this.tokenizer.ignore(i2.extraFieldLength);
            let o2 = new Uint8Array(r2.compressedSize);
            await this.tokenizer.readBuffer(o2), await this.inflate(i2, o2, s2.handler);
          }
        }
        if (s2.stop) break;
      }
    }
    async inflate(t2, n2, r2) {
      if (t2.compressedMethod === 0) return r2(n2);
      if (t2.compressedMethod !== 8) throw new Error(`Unsupported ZIP compression method: ${t2.compressedMethod}`);
      Mt(`Decompress filename=${t2.filename}, compressed-size=${n2.length}`);
      let s2 = await e2.decompressDeflateRaw(n2);
      return r2(s2);
    }
    static async decompressDeflateRaw(t2) {
      let n2 = new ReadableStream({ start(i2) {
        i2.enqueue(t2), i2.close();
      } }), r2 = new DecompressionStream("deflate-raw"), s2 = n2.pipeThrough(r2);
      try {
        let o2 = await new Response(s2).arrayBuffer();
        return new Uint8Array(o2);
      } catch (i2) {
        let o2 = i2 instanceof Error ? `Failed to deflate ZIP entry: ${i2.message}` : "Unknown decompression error in ZIP entry";
        throw new TypeError(o2);
      }
    }
    async readLocalFileHeader() {
      let t2 = await this.tokenizer.peekToken(De);
      if (t2 === xn.LocalFileHeader) {
        let n2 = await this.tokenizer.readToken(Jd);
        return n2.filename = await this.tokenizer.readToken(new ut(n2.filenameLength, "utf-8")), n2;
      }
      if (t2 === xn.CentralFileHeader) return false;
      throw t2 === 3759263696 ? new Error("Encrypted ZIP") : new Error("Unexpected signature");
    }
  };
});
var Or, ih = v(() => {
  Or = class {
    constructor(t2) {
      this.tokenizer = t2;
    }
    inflate() {
      let t2 = this.tokenizer;
      return new ReadableStream({ async pull(n2) {
        let r2 = new Uint8Array(1024), s2 = await t2.readBuffer(r2, { mayBeLess: true });
        if (s2 === 0) {
          n2.close();
          return;
        }
        n2.enqueue(r2.subarray(0, s2));
      } }).pipeThrough(new DecompressionStream("gzip"));
    }
  };
});
var oh = v(() => {
  sh();
  ih();
});
function Qo(e2) {
  let { byteLength: t2 } = e2;
  if (t2 === 6) return e2.getUint16(0) * 2 ** 32 + e2.getUint32(2);
  if (t2 === 5) return e2.getUint8(0) * 2 ** 32 + e2.getUint32(1);
  if (t2 === 4) return e2.getUint32(0);
  if (t2 === 3) return e2.getUint8(0) * 2 ** 16 + e2.getUint16(1);
  if (t2 === 2) return e2.getUint16(0);
  if (t2 === 1) return e2.getUint8(0);
}
var ah = v(() => {
  ({ utf8: new globalThis.TextDecoder("utf8") }, new globalThis.TextEncoder()), Array.from({ length: 256 }, (e2, t2) => t2.toString(16).padStart(2, "0"));
});
function lh(e2, t2) {
  if (t2 === "utf-16le") {
    let n2 = [];
    for (let r2 = 0; r2 < e2.length; r2++) {
      let s2 = e2.charCodeAt(r2);
      n2.push(s2 & 255, s2 >> 8 & 255);
    }
    return n2;
  }
  if (t2 === "utf-16be") {
    let n2 = [];
    for (let r2 = 0; r2 < e2.length; r2++) {
      let s2 = e2.charCodeAt(r2);
      n2.push(s2 >> 8 & 255, s2 & 255);
    }
    return n2;
  }
  return [...e2].map((n2) => n2.charCodeAt(0));
}
function ch(e2, t2 = 0) {
  let n2 = Number.parseInt(new ut(6).get(e2, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(n2)) return false;
  let r2 = 256;
  for (let s2 = t2; s2 < t2 + 148; s2++) r2 += e2[s2];
  for (let s2 = t2 + 156; s2 < t2 + 512; s2++) r2 += e2[s2];
  return n2 === r2;
}
var uh, fh = v(() => {
  $r();
  uh = { get: (e2, t2) => e2[t2 + 3] & 127 | e2[t2 + 2] << 7 | e2[t2 + 1] << 14 | e2[t2] << 21, len: 4 };
});
var ph, dh, hh = v(() => {
  ph = ["jpg", "png", "apng", "gif", "webp", "flif", "xcf", "cr2", "cr3", "orf", "arw", "dng", "nef", "rw2", "raf", "tif", "bmp", "icns", "jxr", "psd", "indd", "zip", "tar", "rar", "gz", "bz2", "7z", "dmg", "mp4", "mid", "mkv", "webm", "mov", "avi", "mpg", "mp2", "mp3", "m4a", "oga", "ogg", "ogv", "opus", "flac", "wav", "spx", "amr", "pdf", "epub", "elf", "macho", "exe", "swf", "rtf", "wasm", "woff", "woff2", "eot", "ttf", "otf", "ttc", "ico", "flv", "ps", "xz", "sqlite", "nes", "crx", "xpi", "cab", "deb", "ar", "rpm", "Z", "lz", "cfb", "mxf", "mts", "blend", "bpg", "docx", "pptx", "xlsx", "3gp", "3g2", "j2c", "jp2", "jpm", "jpx", "mj2", "aif", "qcp", "odt", "ods", "odp", "xml", "mobi", "heic", "cur", "ktx", "ape", "wv", "dcm", "ics", "glb", "pcap", "dsf", "lnk", "alias", "voc", "ac3", "m4v", "m4p", "m4b", "f4v", "f4p", "f4b", "f4a", "mie", "asf", "ogm", "ogx", "mpc", "arrow", "shp", "aac", "mp1", "it", "s3m", "xm", "skp", "avif", "eps", "lzh", "pgp", "asar", "stl", "chm", "3mf", "zst", "jxl", "vcf", "jls", "pst", "dwg", "parquet", "class", "arj", "cpio", "ace", "avro", "icc", "fbx", "vsdx", "vtt", "apk", "drc", "lz4", "potx", "xltx", "dotx", "xltm", "ott", "ots", "otp", "odg", "otg", "xlsm", "docm", "dotm", "potm", "pptm", "jar", "jmp", "rm", "sav", "ppsm", "ppsx", "tar.gz", "reg", "dat"], dh = ["image/jpeg", "image/png", "image/gif", "image/webp", "image/flif", "image/x-xcf", "image/x-canon-cr2", "image/x-canon-cr3", "image/tiff", "image/bmp", "image/vnd.ms-photo", "image/vnd.adobe.photoshop", "application/x-indesign", "application/epub+zip", "application/x-xpinstall", "application/vnd.ms-powerpoint.slideshow.macroenabled.12", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.openxmlformats-officedocument.presentationml.slideshow", "application/zip", "application/x-tar", "application/x-rar-compressed", "application/gzip", "application/x-bzip2", "application/x-7z-compressed", "application/x-apple-diskimage", "application/vnd.apache.arrow.file", "video/mp4", "audio/midi", "video/matroska", "video/webm", "video/quicktime", "video/vnd.avi", "audio/wav", "audio/qcelp", "audio/x-ms-asf", "video/x-ms-asf", "application/vnd.ms-asf", "video/mpeg", "video/3gpp", "audio/mpeg", "audio/mp4", "video/ogg", "audio/ogg", "audio/ogg; codecs=opus", "application/ogg", "audio/flac", "audio/ape", "audio/wavpack", "audio/amr", "application/pdf", "application/x-elf", "application/x-mach-binary", "application/x-msdownload", "application/x-shockwave-flash", "application/rtf", "application/wasm", "font/woff", "font/woff2", "application/vnd.ms-fontobject", "font/ttf", "font/otf", "font/collection", "image/x-icon", "video/x-flv", "application/postscript", "application/eps", "application/x-xz", "application/x-sqlite3", "application/x-nintendo-nes-rom", "application/x-google-chrome-extension", "application/vnd.ms-cab-compressed", "application/x-deb", "application/x-unix-archive", "application/x-rpm", "application/x-compress", "application/x-lzip", "application/x-cfb", "application/x-mie", "application/mxf", "video/mp2t", "application/x-blender", "image/bpg", "image/j2c", "image/jp2", "image/jpx", "image/jpm", "image/mj2", "audio/aiff", "application/xml", "application/x-mobipocket-ebook", "image/heif", "image/heif-sequence", "image/heic", "image/heic-sequence", "image/icns", "image/ktx", "application/dicom", "audio/x-musepack", "text/calendar", "text/vcard", "text/vtt", "model/gltf-binary", "application/vnd.tcpdump.pcap", "audio/x-dsf", "application/x.ms.shortcut", "application/x.apple.alias", "audio/x-voc", "audio/vnd.dolby.dd-raw", "audio/x-m4a", "image/apng", "image/x-olympus-orf", "image/x-sony-arw", "image/x-adobe-dng", "image/x-nikon-nef", "image/x-panasonic-rw2", "image/x-fujifilm-raf", "video/x-m4v", "video/3gpp2", "application/x-esri-shape", "audio/aac", "audio/x-it", "audio/x-s3m", "audio/x-xm", "video/MP1S", "video/MP2P", "application/vnd.sketchup.skp", "image/avif", "application/x-lzh-compressed", "application/pgp-encrypted", "application/x-asar", "model/stl", "application/vnd.ms-htmlhelp", "model/3mf", "image/jxl", "application/zstd", "image/jls", "application/vnd.ms-outlook", "image/vnd.dwg", "application/vnd.apache.parquet", "application/java-vm", "application/x-arj", "application/x-cpio", "application/x-ace-compressed", "application/avro", "application/vnd.iccprofile", "application/x.autodesk.fbx", "application/vnd.visio", "application/vnd.android.package-archive", "application/vnd.google.draco", "application/x-lz4", "application/vnd.openxmlformats-officedocument.presentationml.template", "application/vnd.openxmlformats-officedocument.spreadsheetml.template", "application/vnd.openxmlformats-officedocument.wordprocessingml.template", "application/vnd.ms-excel.template.macroenabled.12", "application/vnd.oasis.opendocument.text-template", "application/vnd.oasis.opendocument.spreadsheet-template", "application/vnd.oasis.opendocument.presentation-template", "application/vnd.oasis.opendocument.graphics", "application/vnd.oasis.opendocument.graphics-template", "application/vnd.ms-excel.sheet.macroenabled.12", "application/vnd.ms-word.document.macroenabled.12", "application/vnd.ms-word.template.macroenabled.12", "application/vnd.ms-powerpoint.template.macroenabled.12", "application/vnd.ms-powerpoint.presentation.macroenabled.12", "application/java-archive", "application/vnd.rn-realmedia", "application/x-spss-sav", "application/x-ms-regedit", "application/x-ft-windows-registry-hive", "application/x-jmp-data"];
});
async function mh(e2, t2) {
  return new Jo(t2).fromBuffer(e2);
}
function Xo(e2) {
  switch (e2 = e2.toLowerCase(), e2) {
    case "application/epub+zip":
      return { ext: "epub", mime: e2 };
    case "application/vnd.oasis.opendocument.text":
      return { ext: "odt", mime: e2 };
    case "application/vnd.oasis.opendocument.text-template":
      return { ext: "ott", mime: e2 };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return { ext: "ods", mime: e2 };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return { ext: "ots", mime: e2 };
    case "application/vnd.oasis.opendocument.presentation":
      return { ext: "odp", mime: e2 };
    case "application/vnd.oasis.opendocument.presentation-template":
      return { ext: "otp", mime: e2 };
    case "application/vnd.oasis.opendocument.graphics":
      return { ext: "odg", mime: e2 };
    case "application/vnd.oasis.opendocument.graphics-template":
      return { ext: "otg", mime: e2 };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return { ext: "ppsx", mime: e2 };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return { ext: "xlsx", mime: e2 };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return { ext: "xlsm", mime: "application/vnd.ms-excel.sheet.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return { ext: "xltx", mime: e2 };
    case "application/vnd.ms-excel.template.macroenabled":
      return { ext: "xltm", mime: "application/vnd.ms-excel.template.macroenabled.12" };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return { ext: "ppsm", mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return { ext: "docx", mime: e2 };
    case "application/vnd.ms-word.document.macroenabled":
      return { ext: "docm", mime: "application/vnd.ms-word.document.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return { ext: "dotx", mime: e2 };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return { ext: "dotm", mime: "application/vnd.ms-word.template.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return { ext: "potx", mime: e2 };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return { ext: "potm", mime: "application/vnd.ms-powerpoint.template.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return { ext: "pptx", mime: e2 };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return { ext: "pptm", mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12" };
    case "application/vnd.ms-visio.drawing":
      return { ext: "vsdx", mime: "application/vnd.visio" };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return { ext: "3mf", mime: "model/3mf" };
  }
}
function Wt(e2, t2, n2) {
  n2 = { offset: 0, ...n2 };
  for (let [r2, s2] of t2.entries()) if (n2.mask) {
    if (s2 !== (n2.mask[r2] & e2[r2 + n2.offset])) return false;
  } else if (s2 !== e2[r2 + n2.offset]) return false;
  return true;
}
var Ko, Jo, gh = v(() => {
  $r();
  qd();
  oh();
  ah();
  fh();
  hh();
  Ko = 4100;
  Jo = class {
    constructor(t2) {
      __publicField(this, "detectConfident", async (t2) => {
        if (this.buffer = new Uint8Array(Ko), t2.fileInfo.size === void 0 && (t2.fileInfo.size = Number.MAX_SAFE_INTEGER), this.tokenizer = t2, await t2.peekBuffer(this.buffer, { length: 32, mayBeLess: true }), this.check([66, 77])) return { ext: "bmp", mime: "image/bmp" };
        if (this.check([11, 119])) return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
        if (this.check([120, 1])) return { ext: "dmg", mime: "application/x-apple-diskimage" };
        if (this.check([77, 90])) return { ext: "exe", mime: "application/x-msdownload" };
        if (this.check([37, 33])) return await t2.peekBuffer(this.buffer, { length: 24, mayBeLess: true }), this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 }) ? { ext: "eps", mime: "application/eps" } : { ext: "ps", mime: "application/postscript" };
        if (this.check([31, 160]) || this.check([31, 157])) return { ext: "Z", mime: "application/x-compress" };
        if (this.check([199, 113])) return { ext: "cpio", mime: "application/x-cpio" };
        if (this.check([96, 234])) return { ext: "arj", mime: "application/x-arj" };
        if (this.check([239, 187, 191])) return this.tokenizer.ignore(3), this.detectConfident(t2);
        if (this.check([71, 73, 70])) return { ext: "gif", mime: "image/gif" };
        if (this.check([73, 73, 188])) return { ext: "jxr", mime: "image/vnd.ms-photo" };
        if (this.check([31, 139, 8])) {
          let r2 = new Or(t2).inflate(), s2 = true;
          try {
            let i2;
            try {
              i2 = await this.fromStream(r2);
            } catch {
              s2 = false;
            }
            if (i2 && i2.ext === "tar") return { ext: "tar.gz", mime: "application/gzip" };
          } finally {
            s2 && await r2.cancel();
          }
          return { ext: "gz", mime: "application/gzip" };
        }
        if (this.check([66, 90, 104])) return { ext: "bz2", mime: "application/x-bzip2" };
        if (this.checkString("ID3")) {
          await t2.ignore(6);
          let n2 = await t2.readToken(uh);
          return t2.position + n2 > t2.fileInfo.size ? { ext: "mp3", mime: "audio/mpeg" } : (await t2.ignore(n2), this.fromTokenizer(t2));
        }
        if (this.checkString("MP+")) return { ext: "mpc", mime: "audio/x-musepack" };
        if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) return { ext: "swf", mime: "application/x-shockwave-flash" };
        if (this.check([255, 216, 255])) return this.check([247], { offset: 3 }) ? { ext: "jls", mime: "image/jls" } : { ext: "jpg", mime: "image/jpeg" };
        if (this.check([79, 98, 106, 1])) return { ext: "avro", mime: "application/avro" };
        if (this.checkString("FLIF")) return { ext: "flif", mime: "image/flif" };
        if (this.checkString("8BPS")) return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
        if (this.checkString("MPCK")) return { ext: "mpc", mime: "audio/x-musepack" };
        if (this.checkString("FORM")) return { ext: "aif", mime: "audio/aiff" };
        if (this.checkString("icns", { offset: 0 })) return { ext: "icns", mime: "image/icns" };
        if (this.check([80, 75, 3, 4])) {
          let n2;
          return await new Tr(t2).unzip((r2) => {
            switch (r2.filename) {
              case "META-INF/mozilla.rsa":
                return n2 = { ext: "xpi", mime: "application/x-xpinstall" }, { stop: true };
              case "META-INF/MANIFEST.MF":
                return n2 = { ext: "jar", mime: "application/java-archive" }, { stop: true };
              case "mimetype":
                return { async handler(s2) {
                  let i2 = new TextDecoder("utf-8").decode(s2).trim();
                  n2 = Xo(i2);
                }, stop: true };
              case "[Content_Types].xml":
                return { async handler(s2) {
                  let i2 = new TextDecoder("utf-8").decode(s2), o2 = i2.indexOf('.main+xml"');
                  if (o2 === -1) {
                    let a = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                    i2.includes(`ContentType="${a}"`) && (n2 = Xo(a));
                  } else {
                    i2 = i2.slice(0, Math.max(0, o2));
                    let a = i2.lastIndexOf('"'), l = i2.slice(Math.max(0, a + 1));
                    n2 = Xo(l);
                  }
                }, stop: true };
              default:
                return /classes\d*\.dex/.test(r2.filename) ? (n2 = { ext: "apk", mime: "application/vnd.android.package-archive" }, { stop: true }) : {};
            }
          }).catch((r2) => {
            if (!(r2 instanceof ke)) throw r2;
          }), n2 ?? { ext: "zip", mime: "application/zip" };
        }
        if (this.checkString("OggS")) {
          await t2.ignore(28);
          let n2 = new Uint8Array(8);
          return await t2.readBuffer(n2), Wt(n2, [79, 112, 117, 115, 72, 101, 97, 100]) ? { ext: "opus", mime: "audio/ogg; codecs=opus" } : Wt(n2, [128, 116, 104, 101, 111, 114, 97]) ? { ext: "ogv", mime: "video/ogg" } : Wt(n2, [1, 118, 105, 100, 101, 111, 0]) ? { ext: "ogm", mime: "video/ogg" } : Wt(n2, [127, 70, 76, 65, 67]) ? { ext: "oga", mime: "audio/ogg" } : Wt(n2, [83, 112, 101, 101, 120, 32, 32]) ? { ext: "spx", mime: "audio/ogg" } : Wt(n2, [1, 118, 111, 114, 98, 105, 115]) ? { ext: "ogg", mime: "audio/ogg" } : { ext: "ogx", mime: "application/ogg" };
        }
        if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) return { ext: "zip", mime: "application/zip" };
        if (this.checkString("MThd")) return { ext: "mid", mime: "audio/midi" };
        if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) return { ext: "woff", mime: "font/woff" };
        if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) return { ext: "woff2", mime: "font/woff2" };
        if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
        if (this.checkString("DSD ")) return { ext: "dsf", mime: "audio/x-dsf" };
        if (this.checkString("LZIP")) return { ext: "lz", mime: "application/x-lzip" };
        if (this.checkString("fLaC")) return { ext: "flac", mime: "audio/flac" };
        if (this.check([66, 80, 71, 251])) return { ext: "bpg", mime: "image/bpg" };
        if (this.checkString("wvpk")) return { ext: "wv", mime: "audio/wavpack" };
        if (this.checkString("%PDF")) return { ext: "pdf", mime: "application/pdf" };
        if (this.check([0, 97, 115, 109])) return { ext: "wasm", mime: "application/wasm" };
        if (this.check([73, 73])) {
          let n2 = await this.readTiffHeader(false);
          if (n2) return n2;
        }
        if (this.check([77, 77])) {
          let n2 = await this.readTiffHeader(true);
          if (n2) return n2;
        }
        if (this.checkString("MAC ")) return { ext: "ape", mime: "audio/ape" };
        if (this.check([26, 69, 223, 163])) {
          async function n2() {
            let a = await t2.peekNumber(Td), l = 128, c = 0;
            for (; (a & l) === 0 && l !== 0; ) ++c, l >>= 1;
            let u = new Uint8Array(c + 1);
            return await t2.readBuffer(u), u;
          }
          async function r2() {
            let a = await n2(), l = await n2();
            l[0] ^= 128 >> l.length - 1;
            let c = Math.min(6, l.length), u = new DataView(a.buffer), f2 = new DataView(l.buffer, l.length - c, c);
            return { id: Qo(u), len: Qo(f2) };
          }
          async function s2(a) {
            for (; a > 0; ) {
              let l = await r2();
              if (l.id === 17026) return (await t2.readToken(new ut(l.len))).replaceAll(/\00.*$/g, "");
              await t2.ignore(l.len), --a;
            }
          }
          let i2 = await r2();
          switch (await s2(i2.len)) {
            case "webm":
              return { ext: "webm", mime: "video/webm" };
            case "matroska":
              return { ext: "mkv", mime: "video/matroska" };
            default:
              return;
          }
        }
        if (this.checkString("SQLi")) return { ext: "sqlite", mime: "application/x-sqlite3" };
        if (this.check([78, 69, 83, 26])) return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
        if (this.checkString("Cr24")) return { ext: "crx", mime: "application/x-google-chrome-extension" };
        if (this.checkString("MSCF") || this.checkString("ISc(")) return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
        if (this.check([237, 171, 238, 219])) return { ext: "rpm", mime: "application/x-rpm" };
        if (this.check([197, 208, 211, 198])) return { ext: "eps", mime: "application/eps" };
        if (this.check([40, 181, 47, 253])) return { ext: "zst", mime: "application/zstd" };
        if (this.check([127, 69, 76, 70])) return { ext: "elf", mime: "application/x-elf" };
        if (this.check([33, 66, 68, 78])) return { ext: "pst", mime: "application/vnd.ms-outlook" };
        if (this.checkString("PAR1") || this.checkString("PARE")) return { ext: "parquet", mime: "application/vnd.apache.parquet" };
        if (this.checkString("ttcf")) return { ext: "ttc", mime: "font/collection" };
        if (this.check([207, 250, 237, 254])) return { ext: "macho", mime: "application/x-mach-binary" };
        if (this.check([4, 34, 77, 24])) return { ext: "lz4", mime: "application/x-lz4" };
        if (this.checkString("regf")) return { ext: "dat", mime: "application/x-ft-windows-registry-hive" };
        if (this.checkString("$FL2") || this.checkString("$FL3")) return { ext: "sav", mime: "application/x-spss-sav" };
        if (this.check([79, 84, 84, 79, 0])) return { ext: "otf", mime: "font/otf" };
        if (this.checkString("#!AMR")) return { ext: "amr", mime: "audio/amr" };
        if (this.checkString("{\\rtf")) return { ext: "rtf", mime: "application/rtf" };
        if (this.check([70, 76, 86, 1])) return { ext: "flv", mime: "video/x-flv" };
        if (this.checkString("IMPM")) return { ext: "it", mime: "audio/x-it" };
        if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) return { ext: "lzh", mime: "application/x-lzh-compressed" };
        if (this.check([0, 0, 1, 186])) {
          if (this.check([33], { offset: 4, mask: [241] })) return { ext: "mpg", mime: "video/MP1S" };
          if (this.check([68], { offset: 4, mask: [196] })) return { ext: "mpg", mime: "video/MP2P" };
        }
        if (this.checkString("ITSF")) return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
        if (this.check([202, 254, 186, 190])) return { ext: "class", mime: "application/java-vm" };
        if (this.checkString(".RMF")) return { ext: "rm", mime: "application/vnd.rn-realmedia" };
        if (this.checkString("DRACO")) return { ext: "drc", mime: "application/vnd.google.draco" };
        if (this.check([253, 55, 122, 88, 90, 0])) return { ext: "xz", mime: "application/x-xz" };
        if (this.checkString("<?xml ")) return { ext: "xml", mime: "application/xml" };
        if (this.check([55, 122, 188, 175, 39, 28])) return { ext: "7z", mime: "application/x-7z-compressed" };
        if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) return { ext: "rar", mime: "application/x-rar-compressed" };
        if (this.checkString("solid ")) return { ext: "stl", mime: "model/stl" };
        if (this.checkString("AC")) {
          let n2 = new ut(4, "latin1").get(this.buffer, 2);
          if (n2.match("^d*") && n2 >= 1e3 && n2 <= 1050) return { ext: "dwg", mime: "image/vnd.dwg" };
        }
        if (this.checkString("070707")) return { ext: "cpio", mime: "application/x-cpio" };
        if (this.checkString("BLENDER")) return { ext: "blend", mime: "application/x-blender" };
        if (this.checkString("!<arch>")) return await t2.ignore(8), await t2.readToken(new ut(13, "ascii")) === "debian-binary" ? { ext: "deb", mime: "application/x-deb" } : { ext: "ar", mime: "application/x-unix-archive" };
        if (this.checkString("WEBVTT") && [`
`, "\r", "	", " ", "\0"].some((n2) => this.checkString(n2, { offset: 6 }))) return { ext: "vtt", mime: "text/vtt" };
        if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
          await t2.ignore(8);
          async function n2() {
            return { length: await t2.readToken(Dd), type: await t2.readToken(new ut(4, "latin1")) };
          }
          do {
            let r2 = await n2();
            if (r2.length < 0) return;
            switch (r2.type) {
              case "IDAT":
                return { ext: "png", mime: "image/png" };
              case "acTL":
                return { ext: "apng", mime: "image/apng" };
              default:
                await t2.ignore(r2.length + 4);
            }
          } while (t2.position + 8 < t2.fileInfo.size);
          return { ext: "png", mime: "image/png" };
        }
        if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) return { ext: "arrow", mime: "application/vnd.apache.arrow.file" };
        if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) return { ext: "glb", mime: "model/gltf-binary" };
        if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) return { ext: "mov", mime: "video/quicktime" };
        if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) return { ext: "orf", mime: "image/x-olympus-orf" };
        if (this.checkString("gimp xcf ")) return { ext: "xcf", mime: "image/x-xcf" };
        if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
          let n2 = new ut(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
          switch (n2) {
            case "avif":
            case "avis":
              return { ext: "avif", mime: "image/avif" };
            case "mif1":
              return { ext: "heic", mime: "image/heif" };
            case "msf1":
              return { ext: "heic", mime: "image/heif-sequence" };
            case "heic":
            case "heix":
              return { ext: "heic", mime: "image/heic" };
            case "hevc":
            case "hevx":
              return { ext: "heic", mime: "image/heic-sequence" };
            case "qt":
              return { ext: "mov", mime: "video/quicktime" };
            case "M4V":
            case "M4VH":
            case "M4VP":
              return { ext: "m4v", mime: "video/x-m4v" };
            case "M4P":
              return { ext: "m4p", mime: "video/mp4" };
            case "M4B":
              return { ext: "m4b", mime: "audio/mp4" };
            case "M4A":
              return { ext: "m4a", mime: "audio/x-m4a" };
            case "F4V":
              return { ext: "f4v", mime: "video/mp4" };
            case "F4P":
              return { ext: "f4p", mime: "video/mp4" };
            case "F4A":
              return { ext: "f4a", mime: "audio/mp4" };
            case "F4B":
              return { ext: "f4b", mime: "audio/mp4" };
            case "crx":
              return { ext: "cr3", mime: "image/x-canon-cr3" };
            default:
              return n2.startsWith("3g") ? n2.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
          }
        }
        if (this.checkString(`REGEDIT4\r
`)) return { ext: "reg", mime: "application/x-ms-regedit" };
        if (this.check([82, 73, 70, 70])) {
          if (this.checkString("WEBP", { offset: 8 })) return { ext: "webp", mime: "image/webp" };
          if (this.check([65, 86, 73], { offset: 8 })) return { ext: "avi", mime: "video/vnd.avi" };
          if (this.check([87, 65, 86, 69], { offset: 8 })) return { ext: "wav", mime: "audio/wav" };
          if (this.check([81, 76, 67, 77], { offset: 8 })) return { ext: "qcp", mime: "audio/qcelp" };
        }
        if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) return { ext: "rw2", mime: "image/x-panasonic-rw2" };
        if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
          async function n2() {
            let r2 = new Uint8Array(16);
            return await t2.readBuffer(r2), { id: r2, size: Number(await t2.readToken(Fd)) };
          }
          for (await t2.ignore(30); t2.position + 24 < t2.fileInfo.size; ) {
            let r2 = await n2(), s2 = r2.size - 24;
            if (Wt(r2.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
              let i2 = new Uint8Array(16);
              if (s2 -= await t2.readBuffer(i2), Wt(i2, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) return { ext: "asf", mime: "audio/x-ms-asf" };
              if (Wt(i2, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) return { ext: "asf", mime: "video/x-ms-asf" };
              break;
            }
            await t2.ignore(s2);
          }
          return { ext: "asf", mime: "application/vnd.ms-asf" };
        }
        if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) return { ext: "ktx", mime: "image/ktx" };
        if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) return { ext: "mie", mime: "application/x-mie" };
        if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) return { ext: "shp", mime: "application/x-esri-shape" };
        if (this.check([255, 79, 255, 81])) return { ext: "j2c", mime: "image/j2c" };
        if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) switch (await t2.ignore(20), await t2.readToken(new ut(4, "ascii"))) {
          case "jp2 ":
            return { ext: "jp2", mime: "image/jp2" };
          case "jpx ":
            return { ext: "jpx", mime: "image/jpx" };
          case "jpm ":
            return { ext: "jpm", mime: "image/jpm" };
          case "mjp2":
            return { ext: "mj2", mime: "image/mj2" };
          default:
            return;
        }
        if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) return { ext: "jxl", mime: "image/jxl" };
        if (this.check([254, 255])) return this.checkString("<?xml ", { offset: 2, encoding: "utf-16be" }) ? { ext: "xml", mime: "application/xml" } : void 0;
        if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) return { ext: "cfb", mime: "application/x-cfb" };
        if (await t2.peekBuffer(this.buffer, { length: Math.min(256, t2.fileInfo.size), mayBeLess: true }), this.check([97, 99, 115, 112], { offset: 36 })) return { ext: "icc", mime: "application/vnd.iccprofile" };
        if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) return { ext: "ace", mime: "application/x-ace-compressed" };
        if (this.checkString("BEGIN:")) {
          if (this.checkString("VCARD", { offset: 6 })) return { ext: "vcf", mime: "text/vcard" };
          if (this.checkString("VCALENDAR", { offset: 6 })) return { ext: "ics", mime: "text/calendar" };
        }
        if (this.checkString("FUJIFILMCCD-RAW")) return { ext: "raf", mime: "image/x-fujifilm-raf" };
        if (this.checkString("Extended Module:")) return { ext: "xm", mime: "audio/x-xm" };
        if (this.checkString("Creative Voice File")) return { ext: "voc", mime: "audio/x-voc" };
        if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
          let n2 = new DataView(this.buffer.buffer).getUint32(12, true);
          if (n2 > 12 && this.buffer.length >= n2 + 16) try {
            let r2 = new TextDecoder().decode(this.buffer.subarray(16, n2 + 16));
            if (JSON.parse(r2).files) return { ext: "asar", mime: "application/x-asar" };
          } catch {
          }
        }
        if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) return { ext: "mxf", mime: "application/mxf" };
        if (this.checkString("SCRM", { offset: 44 })) return { ext: "s3m", mime: "audio/x-s3m" };
        if (this.check([71]) && this.check([71], { offset: 188 })) return { ext: "mts", mime: "video/mp2t" };
        if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) return { ext: "mts", mime: "video/mp2t" };
        if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
        if (this.check([68, 73, 67, 77], { offset: 128 })) return { ext: "dcm", mime: "application/dicom" };
        if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) return { ext: "lnk", mime: "application/x.ms.shortcut" };
        if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) return { ext: "alias", mime: "application/x.apple.alias" };
        if (this.checkString("Kaydara FBX Binary  \0")) return { ext: "fbx", mime: "application/x.autodesk.fbx" };
        if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) return { ext: "eot", mime: "application/vnd.ms-fontobject" };
        if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) return { ext: "indd", mime: "application/x-indesign" };
        if (this.check([255, 255, 0, 0, 7, 0, 0, 0, 4, 0, 0, 0, 1, 0, 1, 0]) || this.check([0, 0, 255, 255, 0, 0, 0, 7, 0, 0, 0, 4, 0, 1, 0, 1])) return { ext: "jmp", mime: "application/x-jmp-data" };
        if (await t2.peekBuffer(this.buffer, { length: Math.min(512, t2.fileInfo.size), mayBeLess: true }), this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && ch(this.buffer)) return { ext: "tar", mime: "application/x-tar" };
        if (this.check([255, 254])) {
          let n2 = "utf-16le";
          return this.checkString("<?xml ", { offset: 2, encoding: n2 }) ? { ext: "xml", mime: "application/xml" } : this.check([255, 14], { offset: 2 }) && this.checkString("SketchUp Model", { offset: 4, encoding: n2 }) ? { ext: "skp", mime: "application/vnd.sketchup.skp" } : this.checkString(`Windows Registry Editor Version 5.00\r
`, { offset: 2, encoding: n2 }) ? { ext: "reg", mime: "application/x-ms-regedit" } : void 0;
        }
        if (this.checkString("-----BEGIN PGP MESSAGE-----")) return { ext: "pgp", mime: "application/pgp-encrypted" };
      });
      __publicField(this, "detectImprecise", async (t2) => {
        if (this.buffer = new Uint8Array(Ko), await t2.peekBuffer(this.buffer, { length: Math.min(8, t2.fileInfo.size), mayBeLess: true }), this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) return { ext: "mpg", mime: "video/mpeg" };
        if (this.check([0, 1, 0, 0, 0])) return { ext: "ttf", mime: "font/ttf" };
        if (this.check([0, 0, 1, 0])) return { ext: "ico", mime: "image/x-icon" };
        if (this.check([0, 0, 2, 0])) return { ext: "cur", mime: "image/x-icon" };
        if (await t2.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, t2.fileInfo.size), mayBeLess: true }), this.buffer.length >= 2 + this.options.mpegOffsetTolerance) for (let n2 = 0; n2 <= this.options.mpegOffsetTolerance; ++n2) {
          let r2 = this.scanMpeg(n2);
          if (r2) return r2;
        }
      });
      this.options = { mpegOffsetTolerance: 0, ...t2 }, this.detectors = [...(t2 == null ? void 0 : t2.customDetectors) ?? [], { id: "core", detect: this.detectConfident }, { id: "core.imprecise", detect: this.detectImprecise }], this.tokenizerOptions = { abortSignal: t2 == null ? void 0 : t2.signal };
    }
    async fromTokenizer(t2) {
      let n2 = t2.position;
      for (let r2 of this.detectors) {
        let s2 = await r2.detect(t2);
        if (s2) return s2;
        if (n2 !== t2.position) return;
      }
    }
    async fromBuffer(t2) {
      if (!(t2 instanceof Uint8Array || t2 instanceof ArrayBuffer)) throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof t2}\``);
      let n2 = t2 instanceof Uint8Array ? t2 : new Uint8Array(t2);
      if ((n2 == null ? void 0 : n2.length) > 1) return this.fromTokenizer(Hd(n2, this.tokenizerOptions));
    }
    async fromBlob(t2) {
      let n2 = Vd(t2, this.tokenizerOptions);
      try {
        return await this.fromTokenizer(n2);
      } finally {
        await n2.close();
      }
    }
    async fromStream(t2) {
      let n2 = jd(t2, this.tokenizerOptions);
      try {
        return await this.fromTokenizer(n2);
      } finally {
        await n2.close();
      }
    }
    async toDetectionStream(t2, n2) {
      let { sampleSize: r2 = Ko } = n2, s2, i2, o2 = t2.getReader({ mode: "byob" });
      try {
        let { value: c, done: u } = await o2.read(new Uint8Array(r2));
        if (i2 = c, !u && c) try {
          s2 = await this.fromBuffer(c.subarray(0, r2));
        } catch (f2) {
          if (!(f2 instanceof ke)) throw f2;
          s2 = void 0;
        }
        i2 = c;
      } finally {
        o2.releaseLock();
      }
      let a = new TransformStream({ async start(c) {
        c.enqueue(i2);
      }, transform(c, u) {
        u.enqueue(c);
      } }), l = t2.pipeThrough(a);
      return l.fileType = s2, l;
    }
    check(t2, n2) {
      return Wt(this.buffer, t2, n2);
    }
    checkString(t2, n2) {
      return this.check(lh(t2, n2 == null ? void 0 : n2.encoding), n2);
    }
    async readTiffTag(t2) {
      let n2 = await this.tokenizer.readToken(t2 ? Gn : Pe);
      switch (this.tokenizer.ignore(10), n2) {
        case 50341:
          return { ext: "arw", mime: "image/x-sony-arw" };
        case 50706:
          return { ext: "dng", mime: "image/x-adobe-dng" };
      }
    }
    async readTiffIFD(t2) {
      let n2 = await this.tokenizer.readToken(t2 ? Gn : Pe);
      for (let r2 = 0; r2 < n2; ++r2) {
        let s2 = await this.readTiffTag(t2);
        if (s2) return s2;
      }
    }
    async readTiffHeader(t2) {
      let n2 = (t2 ? Gn : Pe).get(this.buffer, 2), r2 = (t2 ? Od : De).get(this.buffer, 4);
      if (n2 === 42) {
        if (r2 >= 6) {
          if (this.checkString("CR", { offset: 8 })) return { ext: "cr2", mime: "image/x-canon-cr2" };
          if (r2 >= 8) {
            let i2 = (t2 ? Gn : Pe).get(this.buffer, 8), o2 = (t2 ? Gn : Pe).get(this.buffer, 10);
            if (i2 === 28 && o2 === 254 || i2 === 31 && o2 === 11) return { ext: "nef", mime: "image/x-nikon-nef" };
          }
        }
        return await this.tokenizer.ignore(r2), await this.readTiffIFD(t2) ?? { ext: "tif", mime: "image/tiff" };
      }
      if (n2 === 43) return { ext: "tif", mime: "image/tiff" };
    }
    scanMpeg(t2) {
      if (this.check([255, 224], { offset: t2, mask: [255, 224] })) {
        if (this.check([16], { offset: t2 + 1, mask: [22] })) return this.check([8], { offset: t2 + 1, mask: [8] }) ? { ext: "aac", mime: "audio/aac" } : { ext: "aac", mime: "audio/aac" };
        if (this.check([2], { offset: t2 + 1, mask: [6] })) return { ext: "mp3", mime: "audio/mpeg" };
        if (this.check([4], { offset: t2 + 1, mask: [6] })) return { ext: "mp2", mime: "audio/mpeg" };
        if (this.check([6], { offset: t2 + 1, mask: [6] })) return { ext: "mp1", mime: "audio/mpeg" };
      }
    }
  }, new Set(ph), new Set(dh);
});
var wh = {};
V(wh, { fileCommand: () => pA });
function lA(e2, t2) {
  var _a3;
  if (bh[e2]) return bh[e2];
  let [n2, r2] = t2.split("/"), s2 = ((_a3 = r2 == null ? void 0 : r2.split("+")[0]) == null ? void 0 : _a3.replace(/-/g, " ")) || e2;
  switch (n2) {
    case "image":
      return `${s2.toUpperCase()} image data`;
    case "audio":
      return `${s2.toUpperCase()} audio`;
    case "video":
      return `${s2.toUpperCase()} video`;
    case "font":
      return `${s2} font`;
    case "model":
      return `${s2} 3D model`;
    case "application":
      return (r2 == null ? void 0 : r2.includes("zip")) || (r2 == null ? void 0 : r2.includes("compressed")) ? `${s2} archive data` : (r2 == null ? void 0 : r2.includes("executable")) ? `${s2} executable` : `${e2.toUpperCase()} data`;
    default:
      return `${e2.toUpperCase()} data`;
  }
}
function cA(e2) {
  let t2 = e2.split("/").pop() || e2;
  if (t2.startsWith(".") && !t2.includes(".", 1)) return t2;
  let n2 = t2.lastIndexOf(".");
  return n2 === -1 || n2 === 0 ? "" : t2.slice(n2).toLowerCase();
}
function uA(e2, t2) {
  if (e2.startsWith("#!")) {
    let l = e2.split(`
`)[0];
    return l.includes("python") ? { description: "Python script, ASCII text executable", mime: "text/x-python" } : l.includes("node") || l.includes("bun") || l.includes("deno") ? { description: "JavaScript script, ASCII text executable", mime: "text/javascript" } : l.includes("bash") ? { description: "Bourne-Again shell script, ASCII text executable", mime: "text/x-shellscript" } : l.includes("sh") ? { description: "POSIX shell script, ASCII text executable", mime: "text/x-shellscript" } : l.includes("ruby") ? { description: "Ruby script, ASCII text executable", mime: "text/x-ruby" } : l.includes("perl") ? { description: "Perl script, ASCII text executable", mime: "text/x-perl" } : { description: "script, ASCII text executable", mime: "text/plain" };
  }
  let n2 = e2.trimStart();
  if (n2.startsWith("<?xml")) return { description: "XML document", mime: "application/xml" };
  if (n2.startsWith("<!DOCTYPE html") || n2.toLowerCase().startsWith("<html")) return { description: "HTML document", mime: "text/html" };
  let r2 = e2.includes(`\r
`), s2 = e2.includes("\r") && !r2, i2 = "";
  r2 ? i2 = ", with CRLF line terminators" : s2 && (i2 = ", with CR line terminators");
  let o2 = cA(t2);
  if (o2 && yh[o2]) {
    let l = yh[o2];
    return l.mime.startsWith("text/") && i2 ? { description: `${l.description}${i2}`, mime: l.mime } : l;
  }
  let a = false;
  for (let l = 0; l < Math.min(e2.length, 8192); l++) if (e2.charCodeAt(l) > 127) {
    a = true;
    break;
  }
  return a ? { description: `UTF-8 Unicode text${i2}`, mime: "text/plain; charset=utf-8" } : { description: `ASCII text${i2}`, mime: "text/plain" };
}
async function fA(e2, t2) {
  if (t2.length === 0) return { description: "empty", mime: "inode/x-empty" };
  let n2 = await mh(t2);
  if (n2) return { description: lA(n2.ext, n2.mime), mime: n2.mime };
  let r2 = new TextDecoder("utf-8", { fatal: false }).decode(t2);
  return uA(r2, e2);
}
var aA, yh, bh, pA, xh = v(() => {
  gh();
  X();
  aA = { name: "file", summary: "determine file type", usage: "file [OPTION]... FILE...", options: ["-b, --brief          do not prepend filenames to output", "-i, --mime           output MIME type strings", "-L, --dereference    follow symlinks", "    --help           display this help and exit"] }, yh = { ".js": { description: "JavaScript source", mime: "text/javascript" }, ".mjs": { description: "JavaScript module", mime: "text/javascript" }, ".cjs": { description: "CommonJS module", mime: "text/javascript" }, ".ts": { description: "TypeScript source", mime: "text/typescript" }, ".tsx": { description: "TypeScript JSX source", mime: "text/typescript" }, ".jsx": { description: "JavaScript JSX source", mime: "text/javascript" }, ".py": { description: "Python script", mime: "text/x-python" }, ".rb": { description: "Ruby script", mime: "text/x-ruby" }, ".go": { description: "Go source", mime: "text/x-go" }, ".rs": { description: "Rust source", mime: "text/x-rust" }, ".c": { description: "C source", mime: "text/x-c" }, ".h": { description: "C header", mime: "text/x-c" }, ".cpp": { description: "C++ source", mime: "text/x-c++" }, ".hpp": { description: "C++ header", mime: "text/x-c++" }, ".java": { description: "Java source", mime: "text/x-java" }, ".sh": { description: "Bourne-Again shell script", mime: "text/x-shellscript" }, ".bash": { description: "Bourne-Again shell script", mime: "text/x-shellscript" }, ".zsh": { description: "Zsh shell script", mime: "text/x-shellscript" }, ".json": { description: "JSON data", mime: "application/json" }, ".yaml": { description: "YAML data", mime: "text/yaml" }, ".yml": { description: "YAML data", mime: "text/yaml" }, ".xml": { description: "XML document", mime: "application/xml" }, ".csv": { description: "CSV text", mime: "text/csv" }, ".toml": { description: "TOML data", mime: "text/toml" }, ".html": { description: "HTML document", mime: "text/html" }, ".htm": { description: "HTML document", mime: "text/html" }, ".css": { description: "CSS stylesheet", mime: "text/css" }, ".svg": { description: "SVG image", mime: "image/svg+xml" }, ".md": { description: "Markdown document", mime: "text/markdown" }, ".markdown": { description: "Markdown document", mime: "text/markdown" }, ".txt": { description: "ASCII text", mime: "text/plain" }, ".rst": { description: "reStructuredText", mime: "text/x-rst" }, ".env": { description: "ASCII text", mime: "text/plain" }, ".gitignore": { description: "ASCII text", mime: "text/plain" }, ".dockerignore": { description: "ASCII text", mime: "text/plain" } }, bh = { jpg: "JPEG image data", jpeg: "JPEG image data", png: "PNG image data", gif: "GIF image data", webp: "WebP image data", bmp: "PC bitmap", ico: "MS Windows icon resource", tif: "TIFF image data", tiff: "TIFF image data", psd: "Adobe Photoshop Document", avif: "AVIF image", heic: "HEIC image", heif: "HEIF image", jxl: "JPEG XL image", icns: "Mac OS X icon", svg: "SVG Scalable Vector Graphics image", pdf: "PDF document", epub: "EPUB document", mobi: "Mobipocket E-book", djvu: "DjVu document", zip: "Zip archive data", gz: "gzip compressed data", gzip: "gzip compressed data", bz2: "bzip2 compressed data", xz: "XZ compressed data", tar: "POSIX tar archive", rar: "RAR archive data", "7z": "7-zip archive data", lz: "lzip compressed data", lzma: "LZMA compressed data", zst: "Zstandard compressed data", cab: "Microsoft Cabinet archive", ar: "Unix ar archive", rpm: "RPM package", deb: "Debian binary package", apk: "Android Package", dmg: "Apple disk image", iso: "ISO 9660 CD-ROM filesystem data", vhd: "Microsoft Virtual Hard Disk", vhdx: "Microsoft Virtual Hard Disk (new format)", qcow2: "QEMU QCOW Image", mp3: "Audio file with ID3", m4a: "MPEG-4 audio", aac: "AAC audio", wav: "RIFF (little-endian) data, WAVE audio", flac: "FLAC audio bitstream data", ogg: "Ogg data", oga: "Ogg audio", opus: "Ogg Opus audio", aiff: "AIFF audio", wma: "Windows Media Audio", amr: "AMR audio", mid: "MIDI audio", midi: "MIDI audio", ape: "Monkey's Audio", mp4: "ISO Media, MPEG-4", m4v: "MPEG-4 video", webm: "WebM", avi: "RIFF (little-endian) data, AVI", mov: "ISO Media, Apple QuickTime movie", mkv: "Matroska data", wmv: "Windows Media Video", flv: "Flash Video", "3gp": "3GPP multimedia", "3g2": "3GPP2 multimedia", ogv: "Ogg video", mts: "MPEG transport stream", m2ts: "MPEG transport stream", ts: "MPEG transport stream", mpg: "MPEG video", mpeg: "MPEG video", exe: "PE32 executable", dll: "PE32 DLL", elf: "ELF executable", mach: "Mach-O executable", wasm: "WebAssembly (wasm) binary module", dex: "Android Dalvik executable", class: "Java class file", swf: "Adobe Flash", doc: "Microsoft Word Document", docx: "Microsoft Word 2007+ Document", xls: "Microsoft Excel Spreadsheet", xlsx: "Microsoft Excel 2007+ Spreadsheet", ppt: "Microsoft PowerPoint Presentation", pptx: "Microsoft PowerPoint 2007+ Presentation", odt: "OpenDocument Text", ods: "OpenDocument Spreadsheet", odp: "OpenDocument Presentation", ttf: "TrueType Font", otf: "OpenType Font", woff: "Web Open Font Format", woff2: "Web Open Font Format 2", eot: "Embedded OpenType font", stl: "Stereolithography CAD", obj: "Wavefront 3D Object", gltf: "GL Transmission Format", glb: "GL Transmission Format (binary)", sqlite: "SQLite 3.x database", mdb: "Microsoft Access Database", xml: "XML document", json: "JSON data", macho: "Mach-O binary", ics: "iCalendar data", vcf: "vCard data", msi: "Microsoft Installer", ps: "PostScript", ai: "Adobe Illustrator", indd: "Adobe InDesign", sketch: "Sketch design file", fig: "Figma design file", xd: "Adobe XD", blend: "Blender", fbx: "Autodesk FBX", lnk: "MS Windows shortcut", alias: "Mac OS alias", torrent: "BitTorrent file", pcap: "pcap capture file", arrow: "Apache Arrow", parquet: "Apache Parquet" };
  pA = { name: "file", async execute(e2, t2) {
    if (_(e2)) return F$3(aA);
    let n2 = false, r2 = false, s2 = [];
    for (let a of e2) if (a.startsWith("--")) {
      if (a === "--brief") n2 = true;
      else if (a === "--mime" || a === "--mime-type") r2 = true;
      else if (a !== "--dereference") return G("file", a);
    } else if (a.startsWith("-") && a !== "-") {
      for (let l of a.slice(1)) if (l === "b") n2 = true;
      else if (l === "i") r2 = true;
      else if (l !== "L") return G("file", `-${l}`);
    } else s2.push(a);
    if (s2.length === 0) return { stdout: "", stderr: `Usage: file [-bLi] FILE...
`, exitCode: 1 };
    let i2 = "", o2 = 0;
    for (let a of s2) try {
      let l = t2.fs.resolvePath(t2.cwd, a);
      if ((await t2.fs.stat(l)).isDirectory) {
        let d = r2 ? "inode/directory" : "directory";
        i2 += n2 ? `${d}
` : `${a}: ${d}
`;
        continue;
      }
      let u = await t2.fs.readFileBuffer(l), f2 = await fA(a, u), p = r2 ? f2.mime : f2.description;
      i2 += n2 ? `${p}
` : `${a}: ${p}
`;
    } catch {
      i2 += n2 ? `cannot open
` : `${a}: cannot open (No such file or directory)
`, o2 = 1;
    }
    return { stdout: i2, stderr: "", exitCode: o2 };
  } };
});
var Eh = {};
V(Eh, { htmlToMarkdownCommand: () => mA });
var hA, mA, Sh = v(() => {
  X();
  hA = { name: "html-to-markdown", summary: "convert HTML to Markdown (BashEnv extension)", usage: "html-to-markdown [OPTION]... [FILE]", description: ["Convert HTML content to Markdown format using the turndown library.", "This is a non-standard BashEnv extension command, not available in regular bash.", "", "Read HTML from FILE or standard input and output Markdown to standard output.", "Commonly used with curl to convert web pages:", "  curl -s https://example.com | html-to-markdown", "", "Supported HTML elements:", "  - Headings (h1-h6)  # Markdown headings", "  - Paragraphs (p)  Plain text with blank lines", "  - Links (a)  [text](url)", "  - Images (img)  ![alt](src)", "  - Bold/Strong  **text**", "  - Italic/Em  _text_", "  - Code (code, pre)  `inline` or fenced blocks", "  - Lists (ul, ol, li)  - or 1. items", "  - Blockquotes  > quoted text", "  - Horizontal rules (hr)  ---"], options: ["-b, --bullet=CHAR     bullet character for unordered lists (-, +, or *)", "-c, --code=FENCE      fence style for code blocks (``` or ~~~)", "-r, --hr=STRING       string for horizontal rules (default: ---)", "    --heading-style=STYLE", "                      heading style: 'atx' for # headings (default),", "                      'setext' for underlined headings (h1/h2 only)", "    --help            display this help and exit"], examples: ["echo '<h1>Hello</h1><p>World</p>' | html-to-markdown", "html-to-markdown page.html", "curl -s https://example.com | html-to-markdown > page.md"] }, mA = { name: "html-to-markdown", async execute(e2, t2) {
    if (_(e2)) return F$3(hA);
    let n2 = "-", r2 = "```", s2 = "---", i2 = "atx", o2 = [];
    for (let l = 0; l < e2.length; l++) {
      let c = e2[l];
      if (c === "-b" || c === "--bullet") n2 = e2[++l] ?? "-";
      else if (c.startsWith("--bullet=")) n2 = c.slice(9);
      else if (c === "-c" || c === "--code") r2 = e2[++l] ?? "```";
      else if (c.startsWith("--code=")) r2 = c.slice(7);
      else if (c === "-r" || c === "--hr") s2 = e2[++l] ?? "---";
      else if (c.startsWith("--hr=")) s2 = c.slice(5);
      else if (c.startsWith("--heading-style=")) {
        let u = c.slice(16);
        (u === "setext" || u === "atx") && (i2 = u);
      } else if (c === "-") o2.push("-");
      else {
        if (c.startsWith("--")) return G("html-to-markdown", c);
        if (c.startsWith("-")) return G("html-to-markdown", c);
        o2.push(c);
      }
    }
    let a;
    if (o2.length === 0 || o2.length === 1 && o2[0] === "-") a = t2.stdin;
    else try {
      let l = t2.fs.resolvePath(t2.cwd, o2[0]);
      a = await t2.fs.readFile(l);
    } catch {
      return { stdout: "", stderr: `html-to-markdown: ${o2[0]}: No such file or directory
`, exitCode: 1 };
    }
    if (!a.trim()) return { stdout: "", stderr: "", exitCode: 0 };
    try {
      let l = new TurndownService({ bulletListMarker: n2, codeBlockStyle: "fenced", fence: r2, hr: s2, headingStyle: i2 });
      return l.remove(["script", "style", "footer"]), { stdout: `${l.turndown(a).trim()}
`, stderr: "", exitCode: 0 };
    } catch (l) {
      return { stdout: "", stderr: `html-to-markdown: conversion error: ${l.message}
`, exitCode: 1 };
    }
  } };
});
var Ah = {};
V(Ah, { helpCommand: () => bA });
function yA(e2) {
  let t2 = [], n2 = new Set(e2);
  t2.push(`Available commands:
`);
  let r2 = [];
  for (let [s2, i2] of Object.entries(gA)) {
    let o2 = i2.filter((a) => n2.has(a));
    if (o2.length > 0) {
      t2.push(`  ${s2}:`), t2.push(`    ${o2.join(", ")}
`);
      for (let a of o2) n2.delete(a);
    }
  }
  for (let s2 of n2) r2.push(s2);
  return r2.length > 0 && (t2.push("  Other:"), t2.push(`    ${r2.sort().join(", ")}
`)), t2.push("Use '<command> --help' for details on a specific command."), `${t2.join(`
`)}
`;
}
var gA, bA, Ch = v(() => {
  gA = { "File operations": ["ls", "cat", "head", "tail", "wc", "touch", "mkdir", "rm", "cp", "mv", "ln", "chmod", "stat", "readlink"], "Text processing": ["grep", "sed", "awk", "sort", "uniq", "cut", "tr", "tee", "diff"], Search: ["find"], "Navigation & paths": ["pwd", "basename", "dirname", "tree", "du"], "Environment & shell": ["echo", "printf", "env", "printenv", "export", "alias", "unalias", "history", "clear", "true", "false", "bash", "sh"], "Data processing": ["xargs", "jq", "base64", "date"], Network: ["curl", "html-to-markdown"] };
  bA = { name: "help", async execute(e2, t2) {
    var _a3;
    if (e2.includes("--help") || e2.includes("-h")) return { stdout: `help - display available commands

Usage: help [command]

Options:
  -h, --help    Show this help message

If a command name is provided, shows help for that command.
Otherwise, lists all available commands.
`, stderr: "", exitCode: 0 };
    if (e2.length > 0 && t2.exec) {
      let r2 = e2[0];
      return t2.exec(`${r2} --help`, { cwd: t2.cwd });
    }
    let n2 = ((_a3 = t2.getRegisteredCommands) == null ? void 0 : _a3.call(t2)) ?? [];
    return { stdout: yA(n2), stderr: "", exitCode: 0 };
  } };
});
var Nh = {};
V(Nh, { whichCommand: () => EA });
var wA, xA, EA, kh = v(() => {
  Oe();
  X();
  wA = { name: "which", summary: "locate a command", usage: "which [-as] program ...", options: ["-a         List all instances of executables found", "-s         No output, just return 0 if found, 1 if not", "--help     display this help and exit"] }, xA = { showAll: { short: "a", type: "boolean" }, silent: { short: "s", type: "boolean" } }, EA = { name: "which", async execute(e2, t2) {
    if (_(e2)) return F$3(wA);
    let n2 = fe("which", e2, xA);
    if (!n2.ok) return n2.error;
    let r2 = n2.result.flags.showAll, s2 = n2.result.flags.silent, i2 = n2.result.positional;
    if (i2.length === 0) return { stdout: "", stderr: "", exitCode: 1 };
    let a = (t2.env.PATH || "/usr/bin:/bin").split(":"), l = "", c = true;
    for (let u of i2) {
      let f2 = false;
      for (let p of a) {
        if (!p) continue;
        let d = `${p}/${u}`;
        if (await t2.fs.exists(d) && (f2 = true, s2 || (l += `${d}
`), !r2)) break;
      }
      f2 || (c = false);
    }
    return { stdout: l, stderr: "", exitCode: c ? 0 : 1 };
  } };
});
var vh = {};
V(vh, { tac: () => AA });
async function SA(e2, t2) {
  if (e2.length > 0 && e2[0] !== "-") {
    let s2 = e2[0].startsWith("/") ? e2[0] : `${t2.cwd}/${e2[0]}`;
    try {
      let o2 = (await t2.fs.readFile(s2)).split(`
`);
      o2[o2.length - 1] === "" && o2.pop();
      let a = o2.reverse();
      return { stdout: a.length > 0 ? `${a.join(`
`)}
` : "", stderr: "", exitCode: 0 };
    } catch {
      return { stdout: "", stderr: `tac: ${e2[0]}: No such file or directory
`, exitCode: 1 };
    }
  }
  let n2 = t2.stdin.split(`
`);
  n2[n2.length - 1] === "" && n2.pop();
  let r2 = n2.reverse();
  return { stdout: r2.length > 0 ? `${r2.join(`
`)}
` : "", stderr: "", exitCode: 0 };
}
var AA, $h = v(() => {
  AA = { name: "tac", execute: SA };
});
var Ih = {};
V(Ih, { hostname: () => NA });
async function CA(e2, t2) {
  return { stdout: `localhost
`, stderr: "", exitCode: 0 };
}
var NA, Rh = v(() => {
  NA = { name: "hostname", execute: CA };
});
var Ph = {};
V(Ph, { whoami: () => vA });
async function kA(e2, t2) {
  return { stdout: `user
`, stderr: "", exitCode: 0 };
}
var vA, Th = v(() => {
  vA = { name: "whoami", execute: kA };
});
var Oh = {};
V(Oh, { od: () => IA });
async function $A(e2, t2) {
  let n2 = "octal", r2 = [], s2 = [];
  for (let d = 0; d < e2.length; d++) {
    let m = e2[d];
    if (m === "-c") r2.push("char");
    else if (m === "-An" || m === "-A" && e2[d + 1] === "n") n2 = "none", m === "-A" && d++;
    else if (m === "-t" && e2[d + 1]) {
      let h = e2[++d];
      h === "x1" ? r2.push("hex") : h === "c" ? r2.push("char") : h.startsWith("o") && r2.push("octal");
    } else (!m.startsWith("-") || m === "-") && s2.push(m);
  }
  r2.length === 0 && r2.push("octal");
  let i2 = t2.stdin;
  if (s2.length > 0 && s2[0] !== "-") {
    let d = s2[0].startsWith("/") ? s2[0] : `${t2.cwd}/${s2[0]}`;
    try {
      i2 = await t2.fs.readFile(d);
    } catch {
      return { stdout: "", stderr: `od: ${s2[0]}: No such file or directory
`, exitCode: 1 };
    }
  }
  let o2 = r2.includes("char");
  function a(d) {
    return d === 0 ? "  \\0" : d === 7 ? "  \\a" : d === 8 ? "  \\b" : d === 9 ? "  \\t" : d === 10 ? "  \\n" : d === 11 ? "  \\v" : d === 12 ? "  \\f" : d === 13 ? "  \\r" : d >= 32 && d < 127 ? `   ${String.fromCharCode(d)}` : ` ${d.toString(8).padStart(3, "0")}`;
  }
  function l(d) {
    return o2 ? `  ${d.toString(16).padStart(2, "0")}` : ` ${d.toString(16).padStart(2, "0")}`;
  }
  function c(d) {
    return ` ${d.toString(8).padStart(3, "0")}`;
  }
  let u = [];
  for (let d of i2) u.push(d.charCodeAt(0));
  let f2 = 16, p = [];
  for (let d = 0; d < u.length; d += f2) {
    let m = u.slice(d, d + f2);
    for (let h = 0; h < r2.length; h++) {
      let g = r2[h], b;
      g === "char" ? b = m.map(a) : g === "hex" ? b = m.map(l) : b = m.map(c);
      let y = "";
      h === 0 && n2 !== "none" ? y = `${d.toString(8).padStart(7, "0")} ` : (h > 0 || n2 === "none") && (y = n2 === "none" ? "" : "        "), p.push(y + b.join(""));
    }
  }
  return n2 !== "none" && u.length > 0 && p.push(u.length.toString(8).padStart(7, "0")), { stdout: p.length > 0 ? `${p.join(`
`)}
` : "", stderr: "", exitCode: 0 };
}
var IA, Dh = v(() => {
  IA = { name: "od", execute: $A };
});
var js = {};
V(js, { gunzipCommand: () => MA, gzipCommand: () => LA, zcatCommand: () => WA });
function _h(e2) {
  return e2.best ? constants$3.Z_BEST_COMPRESSION : e2.level8 ? 8 : e2.level7 ? 7 : e2.level6 ? 6 : e2.level5 ? 5 : e2.level4 ? 4 : e2.level3 ? 3 : e2.level2 ? 2 : e2.fast ? constants$3.Z_BEST_SPEED : constants$3.Z_DEFAULT_COMPRESSION;
}
function Lh(e2) {
  if (e2.length < 10) return { originalName: null, mtime: null, headerSize: 0 };
  if (e2[0] !== 31 || e2[1] !== 139) return { originalName: null, mtime: null, headerSize: 0 };
  let t2 = e2[3], n2 = e2[4] | e2[5] << 8 | e2[6] << 16 | e2[7] << 24, r2 = 10;
  if (t2 & 4) {
    if (r2 + 2 > e2.length) return { originalName: null, mtime: null, headerSize: 0 };
    let i2 = e2[r2] | e2[r2 + 1] << 8;
    r2 += 2 + i2;
  }
  let s2 = null;
  if (t2 & 8) {
    let i2 = r2;
    for (; r2 < e2.length && e2[r2] !== 0; ) r2++;
    r2 < e2.length && (s2 = new TextDecoder().decode(e2.slice(i2, r2)), r2++);
  }
  if (t2 & 16) {
    for (; r2 < e2.length && e2[r2] !== 0; ) r2++;
    r2++;
  }
  return t2 & 2 && (r2 += 2), { originalName: s2, mtime: n2 > 0 ? new Date(n2 * 1e3) : null, headerSize: r2 };
}
function DA(e2) {
  if (e2.length < 4) return 0;
  let t2 = e2.length;
  return e2[t2 - 4] | e2[t2 - 3] << 8 | e2[t2 - 2] << 16 | e2[t2 - 1] << 24;
}
function zs(e2) {
  return e2.length >= 2 && e2[0] === 31 && e2[1] === 139;
}
async function Mh(e2, t2, n2, r2, s2, i2) {
  let o2 = n2.suffix, a, l, c;
  if (t2 === "-" || t2 === "") if (c = Uint8Array.from(e2.stdin, (u) => u.charCodeAt(0)), s2) {
    if (!zs(c)) return n2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: stdin: not in gzip format
`, exitCode: 1 };
    try {
      let u = gunzipSync(c);
      return { stdout: String.fromCharCode(...u), stderr: "", exitCode: 0 };
    } catch (u) {
      let f2 = u instanceof Error ? u.message : "unknown error";
      return { stdout: "", stderr: `${r2}: stdin: ${f2}
`, exitCode: 1 };
    }
  } else {
    _h(n2);
    let f2 = gzipSync(c);
    return { stdout: String.fromCharCode(...f2), stderr: "", exitCode: 0 };
  }
  a = e2.fs.resolvePath(e2.cwd, t2);
  try {
    if ((await e2.fs.stat(a)).isDirectory) return n2.recursive ? await Wh(e2, a, n2, r2, s2, i2) : n2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t2}: is a directory -- ignored
`, exitCode: 1 };
  } catch {
    return { stdout: "", stderr: `${r2}: ${t2}: No such file or directory
`, exitCode: 1 };
  }
  try {
    c = await e2.fs.readFileBuffer(a);
  } catch {
    return { stdout: "", stderr: `${r2}: ${t2}: No such file or directory
`, exitCode: 1 };
  }
  if (s2) {
    if (!t2.endsWith(o2)) return n2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t2}: unknown suffix -- ignored
`, exitCode: 1 };
    if (!zs(c)) return n2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t2}: not in gzip format
`, exitCode: 1 };
    let u;
    try {
      u = gunzipSync(c);
    } catch (f2) {
      let p = f2 instanceof Error ? f2.message : "unknown error";
      return { stdout: "", stderr: `${r2}: ${t2}: ${p}
`, exitCode: 1 };
    }
    if (i2) return { stdout: String.fromCharCode(...u), stderr: "", exitCode: 0 };
    if (n2.name) {
      let f2 = Lh(c);
      f2.originalName ? l = e2.fs.resolvePath(e2.cwd, f2.originalName) : l = a.slice(0, -o2.length);
    } else l = a.slice(0, -o2.length);
    if (!n2.force) try {
      return await e2.fs.stat(l), { stdout: "", stderr: `${r2}: ${l} already exists; not overwritten
`, exitCode: 1 };
    } catch {
    }
    if (await e2.fs.writeFile(l, u), !n2.keep && !i2 && await e2.fs.rm(a), n2.verbose) {
      let f2 = c.length > 0 ? ((1 - c.length / u.length) * 100).toFixed(1) : "0.0";
      return { stdout: "", stderr: `${t2}:	${f2}% -- replaced with ${l.split("/").pop()}
`, exitCode: 0 };
    }
    return { stdout: "", stderr: "", exitCode: 0 };
  } else {
    if (t2.endsWith(o2)) return n2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t2} already has ${o2} suffix -- unchanged
`, exitCode: 1 };
    let u = _h(n2), f2;
    try {
      f2 = gzipSync(c, { level: u });
    } catch (p) {
      let d = p instanceof Error ? p.message : "unknown error";
      return { stdout: "", stderr: `${r2}: ${t2}: ${d}
`, exitCode: 1 };
    }
    if (i2) return { stdout: String.fromCharCode(...f2), stderr: "", exitCode: 0 };
    if (l = a + o2, !n2.force) try {
      return await e2.fs.stat(l), { stdout: "", stderr: `${r2}: ${l} already exists; not overwritten
`, exitCode: 1 };
    } catch {
    }
    if (await e2.fs.writeFile(l, f2), !n2.keep && !i2 && await e2.fs.rm(a), n2.verbose) {
      let p = c.length > 0 ? ((1 - f2.length / c.length) * 100).toFixed(1) : "0.0";
      return { stdout: "", stderr: `${t2}:	${p}% -- replaced with ${l.split("/").pop()}
`, exitCode: 0 };
    }
    return { stdout: "", stderr: "", exitCode: 0 };
  }
}
async function Wh(e2, t2, n2, r2, s2, i2) {
  let o2 = await e2.fs.readdir(t2), a = "", l = "", c = 0;
  for (let u of o2) {
    let f2 = e2.fs.resolvePath(t2, u), p = await e2.fs.stat(f2);
    if (p.isDirectory) {
      let d = await Wh(e2, f2, n2, r2, s2, i2);
      a += d.stdout, l += d.stderr, d.exitCode !== 0 && (c = d.exitCode);
    } else if (p.isFile) {
      let d = n2.suffix;
      if (s2 && !u.endsWith(d) || !s2 && u.endsWith(d)) continue;
      let m = f2.startsWith(`${e2.cwd}/`) ? f2.slice(e2.cwd.length + 1) : f2, h = await Mh(e2, m, n2, r2, s2, i2);
      a += h.stdout, l += h.stderr, h.exitCode !== 0 && (c = h.exitCode);
    }
  }
  return { stdout: a, stderr: l, exitCode: c };
}
async function FA(e2, t2, n2, r2) {
  let s2;
  if (t2 === "-" || t2 === "") s2 = Uint8Array.from(e2.stdin, (f2) => f2.charCodeAt(0));
  else {
    let f2 = e2.fs.resolvePath(e2.cwd, t2);
    try {
      s2 = await e2.fs.readFileBuffer(f2);
    } catch {
      return { stdout: "", stderr: `${r2}: ${t2}: No such file or directory
`, exitCode: 1 };
    }
  }
  if (!zs(s2)) return n2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t2}: not in gzip format
`, exitCode: 1 };
  let i2 = s2.length, o2 = DA(s2), a = o2 > 0 ? ((1 - i2 / o2) * 100).toFixed(1) : "0.0", c = Lh(s2).originalName || (t2 === "-" ? "" : t2.replace(/\.gz$/, ""));
  return { stdout: `${i2.toString().padStart(10)} ${o2.toString().padStart(10)} ${a.padStart(5)}% ${c}
`, stderr: "", exitCode: 0 };
}
async function _A(e2, t2, n2, r2) {
  let s2;
  if (t2 === "-" || t2 === "") s2 = Uint8Array.from(e2.stdin, (i2) => i2.charCodeAt(0));
  else {
    let i2 = e2.fs.resolvePath(e2.cwd, t2);
    try {
      s2 = await e2.fs.readFileBuffer(i2);
    } catch {
      return { stdout: "", stderr: `${r2}: ${t2}: No such file or directory
`, exitCode: 1 };
    }
  }
  if (!zs(s2)) return n2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t2}: not in gzip format
`, exitCode: 1 };
  try {
    return gunzipSync(s2), n2.verbose ? { stdout: "", stderr: `${t2}:	OK
`, exitCode: 0 } : { stdout: "", stderr: "", exitCode: 0 };
  } catch (i2) {
    let o2 = i2 instanceof Error ? i2.message : "invalid";
    return { stdout: "", stderr: `${r2}: ${t2}: ${o2}
`, exitCode: 1 };
  }
}
async function ta(e2, t2, n2) {
  let r2 = n2 === "zcat" ? TA : n2 === "gunzip" ? PA : RA;
  if (_(e2)) return F$3(r2);
  let s2 = fe(n2, e2, OA);
  if (!s2.ok) return s2.error.stderr.includes("unrecognized option"), s2.error;
  let i2 = s2.result.flags, o2 = s2.result.positional, a = n2 === "gunzip" || n2 === "zcat" || i2.decompress || i2.uncompress, l = n2 === "zcat" || i2.stdout || i2.toStdout;
  if (i2.list) {
    o2.length === 0 && (o2 = ["-"]);
    let p = `  compressed uncompressed  ratio uncompressed_name
`, d = "", m = 0;
    for (let h of o2) {
      let g = await FA(t2, h, i2, n2);
      p += g.stdout, d += g.stderr, g.exitCode !== 0 && (m = g.exitCode);
    }
    return { stdout: p, stderr: d, exitCode: m };
  }
  if (i2.test) {
    o2.length === 0 && (o2 = ["-"]);
    let p = "", d = "", m = 0;
    for (let h of o2) {
      let g = await _A(t2, h, i2, n2);
      p += g.stdout, d += g.stderr, g.exitCode !== 0 && (m = g.exitCode);
    }
    return { stdout: p, stderr: d, exitCode: m };
  }
  o2.length === 0 && (o2 = ["-"]);
  let c = "", u = "", f2 = 0;
  for (let p of o2) {
    let d = await Mh(t2, p, i2, n2, a, l);
    c += d.stdout, u += d.stderr, d.exitCode !== 0 && (f2 = d.exitCode);
  }
  return { stdout: c, stderr: u, exitCode: f2 };
}
var RA, PA, TA, OA, LA, MA, WA, Hs = v(() => {
  Oe();
  X();
  RA = { name: "gzip", summary: "compress or expand files", usage: "gzip [OPTION]... [FILE]...", description: `Compress FILEs (by default, in-place).

When no FILE is given, or when FILE is -, read from standard input.

With -d, decompress instead.`, options: ["-c, --stdout      write to standard output, keep original files", "-d, --decompress  decompress", "-f, --force       force overwrite of output file", "-k, --keep        keep (don't delete) input files", "-l, --list        list compressed file contents", "-n, --no-name     do not save or restore the original name and timestamp", "-N, --name        save or restore the original file name and timestamp", "-q, --quiet       suppress all warnings", "-r, --recursive   operate recursively on directories", "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)", "-t, --test        test compressed file integrity", "-v, --verbose     verbose mode", "-1, --fast        compress faster", "-9, --best        compress better", "    --help        display this help and exit"] }, PA = { name: "gunzip", summary: "decompress files", usage: "gunzip [OPTION]... [FILE]...", description: `Decompress FILEs (by default, in-place).

When no FILE is given, or when FILE is -, read from standard input.`, options: ["-c, --stdout      write to standard output, keep original files", "-f, --force       force overwrite of output file", "-k, --keep        keep (don't delete) input files", "-l, --list        list compressed file contents", "-n, --no-name     do not restore the original name and timestamp", "-N, --name        restore the original file name and timestamp", "-q, --quiet       suppress all warnings", "-r, --recursive   operate recursively on directories", "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)", "-t, --test        test compressed file integrity", "-v, --verbose     verbose mode", "    --help        display this help and exit"] }, TA = { name: "zcat", summary: "decompress files to stdout", usage: "zcat [OPTION]... [FILE]...", description: `Decompress FILEs to standard output.

When no FILE is given, or when FILE is -, read from standard input.`, options: ["-f, --force       force; read compressed data even from a terminal", "-l, --list        list compressed file contents", "-q, --quiet       suppress all warnings", "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)", "-t, --test        test compressed file integrity", "-v, --verbose     verbose mode", "    --help        display this help and exit"] }, OA = { stdout: { short: "c", long: "stdout", type: "boolean" }, toStdout: { long: "to-stdout", type: "boolean" }, decompress: { short: "d", long: "decompress", type: "boolean" }, uncompress: { long: "uncompress", type: "boolean" }, force: { short: "f", long: "force", type: "boolean" }, keep: { short: "k", long: "keep", type: "boolean" }, list: { short: "l", long: "list", type: "boolean" }, noName: { short: "n", long: "no-name", type: "boolean" }, name: { short: "N", long: "name", type: "boolean" }, quiet: { short: "q", long: "quiet", type: "boolean" }, recursive: { short: "r", long: "recursive", type: "boolean" }, suffix: { short: "S", long: "suffix", type: "string", default: ".gz" }, test: { short: "t", long: "test", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" }, fast: { short: "1", long: "fast", type: "boolean" }, level2: { short: "2", type: "boolean" }, level3: { short: "3", type: "boolean" }, level4: { short: "4", type: "boolean" }, level5: { short: "5", type: "boolean" }, level6: { short: "6", type: "boolean" }, level7: { short: "7", type: "boolean" }, level8: { short: "8", type: "boolean" }, best: { short: "9", long: "best", type: "boolean" } };
  LA = { name: "gzip", async execute(e2, t2) {
    return ta(e2, t2, "gzip");
  } }, MA = { name: "gunzip", async execute(e2, t2) {
    return ta(e2, t2, "gunzip");
  } }, WA = { name: "zcat", async execute(e2, t2) {
    return ta(e2, t2, "zcat");
  } };
});
function na(e2) {
  let t2 = e2.indexOf("=");
  if (t2 >= 0) {
    let n2 = e2.slice(0, t2), r2 = e2.slice(t2 + 1);
    return n2 ? `${encodeURIComponent(n2)}=${encodeURIComponent(r2)}` : encodeURIComponent(r2);
  }
  return encodeURIComponent(e2);
}
function ra(e2) {
  let t2 = e2.indexOf("=");
  if (t2 < 0) return null;
  let n2 = e2.slice(0, t2), r2 = e2.slice(t2 + 1), s2, i2, o2 = r2.match(/;type=([^;]+)$/);
  o2 && (i2 = o2[1], r2 = r2.slice(0, -o2[0].length));
  let a = r2.match(/;filename=([^;]+)/);
  return a && (s2 = a[1], r2 = r2.replace(a[0], "")), (r2.startsWith("@") || r2.startsWith("<")) && (s2 = s2 ?? r2.slice(1).split("/").pop()), { name: n2, value: r2, filename: s2, contentType: i2 };
}
function Bh(e2, t2) {
  let n2 = `----CurlFormBoundary${Date.now().toString(36)}`, r2 = [];
  for (let s2 of e2) {
    let i2 = s2.value;
    if (i2.startsWith("@") || i2.startsWith("<")) {
      let a = i2.slice(1);
      i2 = t2.get(a) ?? "";
    }
    let o2 = `--${n2}\r
`;
    s2.filename ? (o2 += `Content-Disposition: form-data; name="${s2.name}"; filename="${s2.filename}"\r
`, s2.contentType && (o2 += `Content-Type: ${s2.contentType}\r
`)) : o2 += `Content-Disposition: form-data; name="${s2.name}"\r
`, o2 += `\r
${i2}\r
`, r2.push(o2);
  }
  return r2.push(`--${n2}--\r
`), { body: r2.join(""), boundary: n2 };
}
var sa = v(() => {
});
var Uh, zh = v(() => {
  Uh = { name: "curl", summary: "transfer a URL", usage: "curl [OPTIONS] URL", options: ["-X, --request METHOD  HTTP method (GET, POST, PUT, DELETE, etc.)", "-H, --header HEADER   Add header (can be used multiple times)", "-d, --data DATA       HTTP POST data", "    --data-raw DATA   HTTP POST data (no @ interpretation)", "    --data-binary DATA  HTTP POST binary data", "    --data-urlencode DATA  URL-encode and POST data", "-F, --form NAME=VALUE  Multipart form data", "-u, --user USER:PASS  HTTP authentication", "-A, --user-agent STR  Set User-Agent header", "-e, --referer URL     Set Referer header", "-b, --cookie DATA     Send cookies (name=value or @file)", "-c, --cookie-jar FILE Save cookies to file", "-T, --upload-file FILE  Upload file (PUT)", "-o, --output FILE     Write output to file", "-O, --remote-name     Write to file named from URL", "-I, --head            Show headers only (HEAD request)", "-i, --include         Include response headers in output", "-s, --silent          Silent mode (no progress)", "-S, --show-error      Show errors even when silent", "-f, --fail            Fail silently on HTTP errors (no output)", "-L, --location        Follow redirects (default)", "    --max-redirs NUM  Maximum redirects (default: 20)", "-m, --max-time SECS   Maximum time for request", "    --connect-timeout SECS  Connection timeout", "-w, --write-out FMT   Output format after completion", "-v, --verbose         Verbose output", "    --help            Display this help and exit", "", "Note: Network access must be configured via BashEnv network option.", "      curl is not available by default for security reasons."] };
});
function jh(e2) {
  let t2 = { method: "GET", headers: {}, dataBinary: false, formFields: [], useRemoteName: false, headOnly: false, includeHeaders: false, silent: false, showError: false, failSilently: false, followRedirects: true, verbose: false };
  for (let n2 = 0; n2 < e2.length; n2++) {
    let r2 = e2[n2];
    if (r2 === "-X" || r2 === "--request") t2.method = e2[++n2] ?? "GET";
    else if (r2.startsWith("-X")) t2.method = r2.slice(2);
    else if (r2.startsWith("--request=")) t2.method = r2.slice(10);
    else if (r2 === "-H" || r2 === "--header") {
      let s2 = e2[++n2];
      if (s2) {
        let i2 = s2.indexOf(":");
        if (i2 > 0) {
          let o2 = s2.slice(0, i2).trim(), a = s2.slice(i2 + 1).trim();
          t2.headers[o2] = a;
        }
      }
    } else if (r2.startsWith("--header=")) {
      let s2 = r2.slice(9), i2 = s2.indexOf(":");
      if (i2 > 0) {
        let o2 = s2.slice(0, i2).trim(), a = s2.slice(i2 + 1).trim();
        t2.headers[o2] = a;
      }
    } else if (r2 === "-d" || r2 === "--data" || r2 === "--data-raw") t2.data = e2[++n2] ?? "", t2.method === "GET" && (t2.method = "POST");
    else if (r2.startsWith("-d")) t2.data = r2.slice(2), t2.method === "GET" && (t2.method = "POST");
    else if (r2.startsWith("--data=")) t2.data = r2.slice(7), t2.method === "GET" && (t2.method = "POST");
    else if (r2.startsWith("--data-raw=")) t2.data = r2.slice(11), t2.method === "GET" && (t2.method = "POST");
    else if (r2 === "--data-binary") t2.data = e2[++n2] ?? "", t2.dataBinary = true, t2.method === "GET" && (t2.method = "POST");
    else if (r2.startsWith("--data-binary=")) t2.data = r2.slice(14), t2.dataBinary = true, t2.method === "GET" && (t2.method = "POST");
    else if (r2 === "--data-urlencode") {
      let s2 = e2[++n2] ?? "";
      t2.data = (t2.data ? `${t2.data}&` : "") + na(s2), t2.method === "GET" && (t2.method = "POST");
    } else if (r2.startsWith("--data-urlencode=")) {
      let s2 = r2.slice(17);
      t2.data = (t2.data ? `${t2.data}&` : "") + na(s2), t2.method === "GET" && (t2.method = "POST");
    } else if (r2 === "-F" || r2 === "--form") {
      let s2 = e2[++n2] ?? "", i2 = ra(s2);
      i2 && t2.formFields.push(i2), t2.method === "GET" && (t2.method = "POST");
    } else if (r2.startsWith("--form=")) {
      let s2 = r2.slice(7), i2 = ra(s2);
      i2 && t2.formFields.push(i2), t2.method === "GET" && (t2.method = "POST");
    } else if (r2 === "-u" || r2 === "--user") t2.user = e2[++n2];
    else if (r2.startsWith("-u")) t2.user = r2.slice(2);
    else if (r2.startsWith("--user=")) t2.user = r2.slice(7);
    else if (r2 === "-A" || r2 === "--user-agent") t2.headers["User-Agent"] = e2[++n2] ?? "";
    else if (r2.startsWith("-A")) t2.headers["User-Agent"] = r2.slice(2);
    else if (r2.startsWith("--user-agent=")) t2.headers["User-Agent"] = r2.slice(13);
    else if (r2 === "-e" || r2 === "--referer") t2.headers.Referer = e2[++n2] ?? "";
    else if (r2.startsWith("-e")) t2.headers.Referer = r2.slice(2);
    else if (r2.startsWith("--referer=")) t2.headers.Referer = r2.slice(10);
    else if (r2 === "-b" || r2 === "--cookie") t2.headers.Cookie = e2[++n2] ?? "";
    else if (r2.startsWith("-b")) t2.headers.Cookie = r2.slice(2);
    else if (r2.startsWith("--cookie=")) t2.headers.Cookie = r2.slice(9);
    else if (r2 === "-c" || r2 === "--cookie-jar") t2.cookieJar = e2[++n2];
    else if (r2.startsWith("--cookie-jar=")) t2.cookieJar = r2.slice(13);
    else if (r2 === "-T" || r2 === "--upload-file") t2.uploadFile = e2[++n2], t2.method === "GET" && (t2.method = "PUT");
    else if (r2.startsWith("--upload-file=")) t2.uploadFile = r2.slice(14), t2.method === "GET" && (t2.method = "PUT");
    else if (r2 === "-m" || r2 === "--max-time") {
      let s2 = parseFloat(e2[++n2] ?? "0");
      !Number.isNaN(s2) && s2 > 0 && (t2.timeoutMs = s2 * 1e3);
    } else if (r2.startsWith("--max-time=")) {
      let s2 = parseFloat(r2.slice(11));
      !Number.isNaN(s2) && s2 > 0 && (t2.timeoutMs = s2 * 1e3);
    } else if (r2 === "--connect-timeout") {
      let s2 = parseFloat(e2[++n2] ?? "0");
      !Number.isNaN(s2) && s2 > 0 && t2.timeoutMs === void 0 && (t2.timeoutMs = s2 * 1e3);
    } else if (r2.startsWith("--connect-timeout=")) {
      let s2 = parseFloat(r2.slice(18));
      !Number.isNaN(s2) && s2 > 0 && t2.timeoutMs === void 0 && (t2.timeoutMs = s2 * 1e3);
    } else if (r2 === "-o" || r2 === "--output") t2.outputFile = e2[++n2];
    else if (r2.startsWith("--output=")) t2.outputFile = r2.slice(9);
    else if (r2 === "-O" || r2 === "--remote-name") t2.useRemoteName = true;
    else if (r2 === "-I" || r2 === "--head") t2.headOnly = true, t2.method = "HEAD";
    else if (r2 === "-i" || r2 === "--include") t2.includeHeaders = true;
    else if (r2 === "-s" || r2 === "--silent") t2.silent = true;
    else if (r2 === "-S" || r2 === "--show-error") t2.showError = true;
    else if (r2 === "-f" || r2 === "--fail") t2.failSilently = true;
    else if (r2 === "-L" || r2 === "--location") t2.followRedirects = true;
    else if (r2 === "--max-redirs") n2++;
    else if (!r2.startsWith("--max-redirs=")) if (r2 === "-w" || r2 === "--write-out") t2.writeOut = e2[++n2];
    else if (r2.startsWith("--write-out=")) t2.writeOut = r2.slice(12);
    else if (r2 === "-v" || r2 === "--verbose") t2.verbose = true;
    else {
      if (r2.startsWith("--") && r2 !== "--") return G("curl", r2);
      if (r2.startsWith("-") && r2 !== "-") for (let s2 of r2.slice(1)) switch (s2) {
        case "s":
          t2.silent = true;
          break;
        case "S":
          t2.showError = true;
          break;
        case "f":
          t2.failSilently = true;
          break;
        case "L":
          t2.followRedirects = true;
          break;
        case "I":
          t2.headOnly = true, t2.method = "HEAD";
          break;
        case "i":
          t2.includeHeaders = true;
          break;
        case "O":
          t2.useRemoteName = true;
          break;
        case "v":
          t2.verbose = true;
          break;
        default:
          return G("curl", `-${s2}`);
      }
      else r2.startsWith("-") || (t2.url = r2);
    }
  }
  return t2;
}
var Hh = v(() => {
  X();
  sa();
});
function ia(e2) {
  return Object.entries(e2).map(([t2, n2]) => `${t2}: ${n2}`).join(`\r
`);
}
function Vh(e2) {
  try {
    return new URL(e2).pathname.split("/").pop() || "index.html";
  } catch {
    return "index.html";
  }
}
function oa(e2, t2) {
  let n2 = e2;
  return n2 = n2.replace(/%\{http_code\}/g, String(t2.status)), n2 = n2.replace(/%\{content_type\}/g, t2.headers["content-type"] || ""), n2 = n2.replace(/%\{url_effective\}/g, t2.url), n2 = n2.replace(/%\{size_download\}/g, String(t2.bodyLength)), n2 = n2.replace(/\\n/g, `
`), n2;
}
var qh = v(() => {
});
var Gh = {};
V(Gh, { curlCommand: () => HA });
async function BA(e2, t2) {
  if (e2.uploadFile) {
    let n2 = t2.fs.resolvePath(t2.cwd, e2.uploadFile);
    return { body: await t2.fs.readFile(n2) };
  }
  if (e2.formFields.length > 0) {
    let n2 = /* @__PURE__ */ new Map();
    for (let i2 of e2.formFields) if (i2.value.startsWith("@") || i2.value.startsWith("<")) {
      let o2 = t2.fs.resolvePath(t2.cwd, i2.value.slice(1));
      try {
        let a = await t2.fs.readFile(o2);
        n2.set(i2.value.slice(1), a);
      } catch {
        n2.set(i2.value.slice(1), "");
      }
    }
    let { body: r2, boundary: s2 } = Bh(e2.formFields, n2);
    return { body: r2, contentType: `multipart/form-data; boundary=${s2}` };
  }
  return e2.data !== void 0 ? { body: e2.data } : {};
}
function UA(e2, t2) {
  let n2 = { ...e2.headers };
  if (e2.user) {
    let r2 = Buffer.from(e2.user).toString("base64");
    n2.Authorization = `Basic ${r2}`;
  }
  return t2 && !n2["Content-Type"] && (n2["Content-Type"] = t2), n2;
}
async function zA(e2, t2, n2) {
  if (!e2.cookieJar) return;
  let r2 = t2["set-cookie"];
  if (!r2) return;
  let s2 = n2.fs.resolvePath(n2.cwd, e2.cookieJar);
  await n2.fs.writeFile(s2, r2);
}
function jA(e2, t2, n2) {
  let r2 = "";
  if (e2.verbose) {
    r2 += `> ${e2.method} ${n2}
`;
    for (let [s2, i2] of Object.entries(e2.headers)) r2 += `> ${s2}: ${i2}
`;
    r2 += `>
`, r2 += `< HTTP/1.1 ${t2.status} ${t2.statusText}
`;
    for (let [s2, i2] of Object.entries(t2.headers)) r2 += `< ${s2}: ${i2}
`;
    r2 += `<
`;
  }
  return e2.includeHeaders && !e2.verbose && (r2 += `HTTP/1.1 ${t2.status} ${t2.statusText}\r
`, r2 += ia(t2.headers), r2 += `\r
\r
`), e2.headOnly ? e2.includeHeaders || e2.verbose || (r2 += `HTTP/1.1 ${t2.status} ${t2.statusText}\r
`, r2 += ia(t2.headers), r2 += `\r
`) : r2 += t2.body, e2.writeOut && (r2 += oa(e2.writeOut, { status: t2.status, headers: t2.headers, url: t2.url, bodyLength: t2.body.length })), r2;
}
var HA, Zh = v(() => {
  wt();
  X();
  sa();
  zh();
  Hh();
  qh();
  HA = { name: "curl", async execute(e2, t2) {
    if (_(e2)) return F$3(Uh);
    let n2 = jh(e2);
    if ("exitCode" in n2) return n2;
    let r2 = n2;
    if (!r2.url) return { stdout: "", stderr: `curl: no URL specified
`, exitCode: 2 };
    if (!t2.fetch) return { stdout: "", stderr: `curl: internal error: fetch not available
`, exitCode: 1 };
    let s2 = r2.url;
    s2.match(/^https?:\/\//) || (s2 = `https://${s2}`);
    try {
      let { body: i2, contentType: o2 } = await BA(r2, t2), a = UA(r2, o2), l = await t2.fetch(s2, { method: r2.method, headers: Object.keys(a).length > 0 ? a : void 0, body: i2, followRedirects: r2.followRedirects, timeoutMs: r2.timeoutMs });
      if (await zA(r2, l.headers, t2), r2.failSilently && l.status >= 400) return { stdout: "", stderr: r2.showError || !r2.silent ? `curl: (22) The requested URL returned error: ${l.status}
` : "", exitCode: 22 };
      let c = jA(r2, l, s2);
      if (r2.outputFile || r2.useRemoteName) {
        let u = r2.outputFile || Vh(s2), f2 = t2.fs.resolvePath(t2.cwd, u);
        await t2.fs.writeFile(f2, r2.headOnly ? "" : l.body), r2.verbose || (c = ""), r2.writeOut && (c = oa(r2.writeOut, { status: l.status, headers: l.headers, url: l.url, bodyLength: l.body.length }));
      }
      return { stdout: c, stderr: "", exitCode: 0 };
    } catch (i2) {
      let o2 = Ne(i2), a = 1;
      return o2.includes("Network access denied") ? a = 7 : o2.includes("HTTP method") && o2.includes("not allowed") ? a = 3 : o2.includes("Redirect target not in allow-list") || o2.includes("Too many redirects") ? a = 47 : o2.includes("aborted") && (a = 28), { stdout: "", stderr: !r2.silent || r2.showError ? `curl: (${a}) ${o2}
` : "", exitCode: a };
    }
  } };
});
function Dr() {
  var _a3, _b3;
  return { pid: process.pid, ppid: process.ppid, uid: ((_a3 = process.getuid) == null ? void 0 : _a3.call(process)) ?? 1e3, gid: ((_b3 = process.getgid) == null ? void 0 : _b3.call(process)) ?? 1e3 };
}
function im() {
  let { pid: e2, ppid: t2, uid: n2, gid: r2 } = Dr();
  return `Name:	bash
State:	R (running)
Pid:	${e2}
PPid:	${t2}
Uid:	${n2}	${n2}	${n2}	${n2}
Gid:	${r2}	${r2}	${r2}	${r2}
`;
}
var rm, sm, ca = v(() => {
  rm = "5.1.0(1)-release", sm = "Linux version 5.15.0-generic (just-bash) #1 SMP PREEMPT";
});
function am(e2) {
  let t2 = e2.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  if (!t2) return false;
  let n2 = e2.slice(t2[0].length);
  if (n2 === "" || n2 === "+") return true;
  if (n2[0] === "[") {
    let r2 = 0, s2 = 0;
    for (; s2 < n2.length; s2++) if (n2[s2] === "[") r2++;
    else if (n2[s2] === "]" && (r2--, r2 === 0)) break;
    if (r2 !== 0 || s2 >= n2.length) return false;
    let i2 = n2.slice(s2 + 1);
    return i2 === "" || i2 === "+";
  }
  return false;
}
function lm(e2) {
  let t2 = 0;
  for (let n2 = 0; n2 < e2.length; n2++) {
    let r2 = e2[n2];
    if (r2 === "[") t2++;
    else if (r2 === "]") t2--;
    else {
      if (t2 === 0 && r2 === "=") return n2;
      if (t2 === 0 && r2 === "+" && e2[n2 + 1] === "=") return n2 + 1;
    }
  }
  return -1;
}
function aC(e2) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e2);
}
function cm(e2) {
  return e2 === " " || e2 === "	" || e2 === `
` || e2 === ";" || e2 === "&" || e2 === "|" || e2 === "(" || e2 === ")" || e2 === "<" || e2 === ">";
}
var x, Sn, Gs, sC, iC, oC, Zs, tn = v(() => {
  (function(e2) {
    e2.EOF = "EOF", e2.NEWLINE = "NEWLINE", e2.SEMICOLON = "SEMICOLON", e2.AMP = "AMP", e2.PIPE = "PIPE", e2.PIPE_AMP = "PIPE_AMP", e2.AND_AND = "AND_AND", e2.OR_OR = "OR_OR", e2.BANG = "BANG", e2.LESS = "LESS", e2.GREAT = "GREAT", e2.DLESS = "DLESS", e2.DGREAT = "DGREAT", e2.LESSAND = "LESSAND", e2.GREATAND = "GREATAND", e2.LESSGREAT = "LESSGREAT", e2.DLESSDASH = "DLESSDASH", e2.CLOBBER = "CLOBBER", e2.TLESS = "TLESS", e2.AND_GREAT = "AND_GREAT", e2.AND_DGREAT = "AND_DGREAT", e2.LPAREN = "LPAREN", e2.RPAREN = "RPAREN", e2.LBRACE = "LBRACE", e2.RBRACE = "RBRACE", e2.DSEMI = "DSEMI", e2.SEMI_AND = "SEMI_AND", e2.SEMI_SEMI_AND = "SEMI_SEMI_AND", e2.DBRACK_START = "DBRACK_START", e2.DBRACK_END = "DBRACK_END", e2.DPAREN_START = "DPAREN_START", e2.DPAREN_END = "DPAREN_END", e2.IF = "IF", e2.THEN = "THEN", e2.ELSE = "ELSE", e2.ELIF = "ELIF", e2.FI = "FI", e2.FOR = "FOR", e2.WHILE = "WHILE", e2.UNTIL = "UNTIL", e2.DO = "DO", e2.DONE = "DONE", e2.CASE = "CASE", e2.ESAC = "ESAC", e2.IN = "IN", e2.FUNCTION = "FUNCTION", e2.SELECT = "SELECT", e2.TIME = "TIME", e2.COPROC = "COPROC", e2.WORD = "WORD", e2.NAME = "NAME", e2.NUMBER = "NUMBER", e2.ASSIGNMENT_WORD = "ASSIGNMENT_WORD", e2.FD_VARIABLE = "FD_VARIABLE", e2.COMMENT = "COMMENT", e2.HEREDOC_CONTENT = "HEREDOC_CONTENT";
  })(x || (x = {}));
  Sn = class extends Error {
    constructor(t2, n2, r2) {
      super(`line ${n2}: ${t2}`);
      __publicField(this, "line");
      __publicField(this, "column");
      this.line = n2, this.column = r2, this.name = "LexerError";
    }
  }, Gs = { if: x.IF, then: x.THEN, else: x.ELSE, elif: x.ELIF, fi: x.FI, for: x.FOR, while: x.WHILE, until: x.UNTIL, do: x.DO, done: x.DONE, case: x.CASE, esac: x.ESAC, in: x.IN, function: x.FUNCTION, select: x.SELECT, time: x.TIME, coproc: x.COPROC };
  sC = [[";", ";", "&", x.SEMI_SEMI_AND], ["<", "<", "<", x.TLESS], ["&", ">", ">", x.AND_DGREAT]], iC = [["[", "[", x.DBRACK_START], ["]", "]", x.DBRACK_END], ["(", "(", x.DPAREN_START], [")", ")", x.DPAREN_END], ["&", "&", x.AND_AND], ["|", "|", x.OR_OR], [";", ";", x.DSEMI], [";", "&", x.SEMI_AND], ["|", "&", x.PIPE_AMP], [">", ">", x.DGREAT], ["<", "&", x.LESSAND], [">", "&", x.GREATAND], ["<", ">", x.LESSGREAT], [">", "|", x.CLOBBER], ["&", ">", x.AND_GREAT]], oC = { "|": x.PIPE, "&": x.AMP, ";": x.SEMICOLON, "(": x.LPAREN, ")": x.RPAREN, "<": x.LESS, ">": x.GREAT };
  Zs = class {
    constructor(t2) {
      __publicField(this, "input");
      __publicField(this, "pos", 0);
      __publicField(this, "line", 1);
      __publicField(this, "column", 1);
      __publicField(this, "tokens", []);
      __publicField(this, "pendingHeredocs", []);
      __publicField(this, "dparenDepth", 0);
      this.input = t2;
    }
    tokenize() {
      let n2 = this.input.length, r2 = this.tokens, s2 = this.pendingHeredocs;
      for (; this.pos < n2; ) {
        if (s2.length > 0 && r2.length > 0 && r2[r2.length - 1].type === x.NEWLINE) {
          this.readHeredocContent();
          continue;
        }
        if (this.skipWhitespace(), this.pos >= n2) break;
        let i2 = this.nextToken();
        i2 && r2.push(i2);
      }
      return r2.push({ type: x.EOF, value: "", start: this.pos, end: this.pos, line: this.line, column: this.column }), r2;
    }
    skipWhitespace() {
      let t2 = this.input, n2 = t2.length, r2 = this.pos, s2 = this.column, i2 = this.line;
      for (; r2 < n2; ) {
        let o2 = t2[r2];
        if (o2 === " " || o2 === "	") r2++, s2++;
        else if (o2 === "\\" && t2[r2 + 1] === `
`) r2 += 2, i2++, s2 = 1;
        else break;
      }
      this.pos = r2, this.column = s2, this.line = i2;
    }
    nextToken() {
      let t2 = this.input, n2 = this.pos, r2 = this.line, s2 = this.column, i2 = t2[n2], o2 = t2[n2 + 1], a = t2[n2 + 2];
      if (i2 === "#" && this.dparenDepth === 0) return this.readComment(n2, r2, s2);
      if (i2 === `
`) return this.pos = n2 + 1, this.line++, this.column = 1, { type: x.NEWLINE, value: `
`, start: n2, end: n2 + 1, line: r2, column: s2 };
      if (i2 === "<" && o2 === "<" && a === "-") return this.pos = n2 + 3, this.column = s2 + 3, this.registerHeredocFromLookahead(true), this.makeToken(x.DLESSDASH, "<<-", n2, r2, s2);
      for (let [c, u, f2, p] of sC) if (i2 === c && o2 === u && a === f2) return this.pos = n2 + 3, this.column = s2 + 3, this.makeToken(p, c + u + f2, n2, r2, s2);
      if (i2 === "<" && o2 === "<") return this.pos = n2 + 2, this.column = s2 + 2, this.registerHeredocFromLookahead(false), this.makeToken(x.DLESS, "<<", n2, r2, s2);
      if (i2 === "(" && o2 === "(") return this.dparenDepth > 0 ? (this.pos = n2 + 1, this.column = s2 + 1, this.dparenDepth++, this.makeToken(x.LPAREN, "(", n2, r2, s2)) : this.looksLikeNestedSubshells(n2 + 2) || this.dparenClosesWithSpacedParens(n2 + 2) ? (this.pos = n2 + 1, this.column = s2 + 1, this.makeToken(x.LPAREN, "(", n2, r2, s2)) : (this.pos = n2 + 2, this.column = s2 + 2, this.dparenDepth = 1, this.makeToken(x.DPAREN_START, "((", n2, r2, s2));
      if (i2 === ")" && o2 === ")") return this.dparenDepth === 1 ? (this.pos = n2 + 2, this.column = s2 + 2, this.dparenDepth = 0, this.makeToken(x.DPAREN_END, "))", n2, r2, s2)) : this.dparenDepth > 1 ? (this.pos = n2 + 1, this.column = s2 + 1, this.dparenDepth--, this.makeToken(x.RPAREN, ")", n2, r2, s2)) : (this.pos = n2 + 1, this.column = s2 + 1, this.makeToken(x.RPAREN, ")", n2, r2, s2));
      for (let [c, u, f2] of iC) if (!(c === "(" && u === "(" || c === ")" && u === ")") && !(this.dparenDepth > 0 && c === ";" && (f2 === x.DSEMI || f2 === x.SEMI_AND || f2 === x.SEMI_SEMI_AND)) && i2 === c && o2 === u) {
        if (f2 === x.DBRACK_START || f2 === x.DBRACK_END) {
          let p = t2[n2 + 2];
          if (p !== void 0 && p !== " " && p !== "	" && p !== `
` && p !== ";" && p !== "&" && p !== "|" && p !== "(" && p !== ")" && p !== "<" && p !== ">") break;
        }
        return this.pos = n2 + 2, this.column = s2 + 2, this.makeToken(f2, c + u, n2, r2, s2);
      }
      if (i2 === "(" && this.dparenDepth > 0) return this.pos = n2 + 1, this.column = s2 + 1, this.dparenDepth++, this.makeToken(x.LPAREN, "(", n2, r2, s2);
      if (i2 === ")" && this.dparenDepth > 1) return this.pos = n2 + 1, this.column = s2 + 1, this.dparenDepth--, this.makeToken(x.RPAREN, ")", n2, r2, s2);
      let l = oC[i2];
      if (l) return this.pos = n2 + 1, this.column = s2 + 1, this.makeToken(l, i2, n2, r2, s2);
      if (i2 === "{") {
        let c = this.scanFdVariable(n2);
        return c !== null ? (this.pos = c.end, this.column = s2 + (c.end - n2), { type: x.FD_VARIABLE, value: c.varname, start: n2, end: c.end, line: r2, column: s2 }) : o2 === "}" ? (this.pos = n2 + 2, this.column = s2 + 2, { type: x.WORD, value: "{}", start: n2, end: n2 + 2, line: r2, column: s2, quoted: false, singleQuoted: false }) : this.scanBraceExpansion(n2) !== null ? this.readWordWithBraceExpansion(n2, r2, s2) : this.scanLiteralBraceWord(n2) !== null ? this.readWordWithBraceExpansion(n2, r2, s2) : o2 !== void 0 && o2 !== " " && o2 !== "	" && o2 !== `
` ? this.readWord(n2, r2, s2) : (this.pos = n2 + 1, this.column = s2 + 1, this.makeToken(x.LBRACE, "{", n2, r2, s2));
      }
      return i2 === "}" ? this.isWordCharFollowing(n2 + 1) ? this.readWord(n2, r2, s2) : (this.pos = n2 + 1, this.column = s2 + 1, this.makeToken(x.RBRACE, "}", n2, r2, s2)) : i2 === "!" ? o2 === "=" ? (this.pos = n2 + 2, this.column = s2 + 2, this.makeToken(x.WORD, "!=", n2, r2, s2)) : (this.pos = n2 + 1, this.column = s2 + 1, this.makeToken(x.BANG, "!", n2, r2, s2)) : this.readWord(n2, r2, s2);
    }
    looksLikeNestedSubshells(t2) {
      let n2 = this.input, r2 = n2.length, s2 = t2;
      for (; s2 < r2 && (n2[s2] === " " || n2[s2] === "	"); ) s2++;
      if (s2 >= r2) return false;
      let i2 = n2[s2];
      if (i2 === "(") return this.looksLikeNestedSubshells(s2 + 1);
      let o2 = /[a-zA-Z_]/.test(i2), a = i2 === "!" || i2 === "[";
      if (!o2 && !a) return false;
      let l = s2;
      for (; l < r2 && /[a-zA-Z0-9_\-.]/.test(n2[l]); ) l++;
      if (l === s2) return a;
      let c = l;
      for (; c < r2 && (n2[c] === " " || n2[c] === "	"); ) c++;
      if (c >= r2) return false;
      let u = n2[c];
      if (u === "=" && n2[c + 1] !== "=" || u === `
` || l === c && /[+\-*/%<>&|^!~?:]/.test(u) && u !== "-" || u === ")" && n2[c + 1] === ")") return false;
      if (c > l && (u === "-" || u === '"' || u === "'" || u === "$" || /[a-zA-Z_/.]/.test(u))) {
        let f2 = c;
        for (; f2 < r2 && n2[f2] !== `
`; ) {
          if (n2[f2] === ")") return true;
          f2++;
        }
        return false;
      }
      if (u === ")") {
        let f2 = c + 1;
        for (; f2 < r2 && (n2[f2] === " " || n2[f2] === "	"); ) f2++;
        if (n2[f2] === "|" && n2[f2 + 1] === "|" || n2[f2] === "&" && n2[f2 + 1] === "&" || n2[f2] === ";" || n2[f2] === "|" && n2[f2 + 1] !== "|") return true;
      }
      return false;
    }
    makeToken(t2, n2, r2, s2, i2) {
      return { type: t2, value: n2, start: r2, end: this.pos, line: s2, column: i2 };
    }
    readComment(t2, n2, r2) {
      let s2 = this.input, i2 = s2.length, o2 = this.pos;
      for (; o2 < i2 && s2[o2] !== `
`; ) o2++;
      let a = s2.slice(t2, o2);
      return this.pos = o2, this.column = r2 + (o2 - t2), { type: x.COMMENT, value: a, start: t2, end: o2, line: n2, column: r2 };
    }
    readWord(t2, n2, r2) {
      let s2 = this.input, i2 = s2.length, o2 = this.pos, a = o2;
      for (; o2 < i2; ) {
        let y = s2[o2];
        if (y === " " || y === "	" || y === `
` || y === ";" || y === "&" || y === "|" || y === "(" || y === ")" || y === "<" || y === ">" || y === "'" || y === '"' || y === "\\" || y === "$" || y === "`" || y === "{" || y === "}" || y === "~" || y === "*" || y === "?" || y === "[") break;
        o2++;
      }
      if (o2 > a) {
        let y = s2[o2];
        if (!(y === "(" && o2 > a && "@*+?!".includes(s2[o2 - 1]))) {
          if (o2 >= i2 || y === " " || y === "	" || y === `
` || y === ";" || y === "&" || y === "|" || y === "(" || y === ")" || y === "<" || y === ">") {
            let w = s2.slice(a, o2);
            if (this.pos = o2, this.column = r2 + (o2 - a), Gs[w]) return { type: Gs[w], value: w, start: t2, end: o2, line: n2, column: r2 };
            let E = lm(w);
            return E > 0 && am(w.slice(0, E)) ? { type: x.ASSIGNMENT_WORD, value: w, start: t2, end: o2, line: n2, column: r2 } : /^[0-9]+$/.test(w) ? { type: x.NUMBER, value: w, start: t2, end: o2, line: n2, column: r2 } : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(w) ? { type: x.NAME, value: w, start: t2, end: o2, line: n2, column: r2, quoted: false, singleQuoted: false } : { type: x.WORD, value: w, start: t2, end: o2, line: n2, column: r2, quoted: false, singleQuoted: false };
          }
        }
      }
      o2 = this.pos;
      let l = this.column, c = this.line, u = "", f2 = false, p = false, d = false, m = false, h = s2[o2] === '"' || s2[o2] === "'", g = false, b = 0;
      for (; o2 < i2; ) {
        let y = s2[o2];
        if (!d && !m) {
          if (y === "(" && u.length > 0 && "@*+?!".includes(u[u.length - 1])) {
            let w = this.scanExtglobPattern(o2);
            if (w !== null) {
              u += w.content, o2 = w.end, l += w.content.length;
              continue;
            }
          }
          if (y === "[" && b === 0) {
            if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u)) {
              let w = o2 + 1 < i2 ? s2[o2 + 1] : "";
              if (w === "^" || w === "!") {
                u += y, o2++, l++;
                continue;
              }
              b = 1, u += y, o2++, l++;
              continue;
            }
          } else if (y === "[" && b > 0) {
            u.length > 0 && u[u.length - 1] !== "\\" && b++, u += y, o2++, l++;
            continue;
          } else if (y === "]" && b > 0) {
            u.length > 0 && u[u.length - 1] !== "\\" && b--, u += y, o2++, l++;
            continue;
          }
          if (b > 0) {
            if (y === `
`) break;
            u += y, o2++, l++;
            continue;
          }
          if (y === " " || y === "	" || y === `
` || y === ";" || y === "&" || y === "|" || y === "(" || y === ")" || y === "<" || y === ">") break;
        }
        if (y === "$" && o2 + 1 < i2 && s2[o2 + 1] === "'" && !d && !m) {
          for (u += "$'", o2 += 2, l += 2; o2 < i2 && s2[o2] !== "'"; ) s2[o2] === "\\" && o2 + 1 < i2 ? (u += s2[o2] + s2[o2 + 1], o2 += 2, l += 2) : (u += s2[o2], o2++, l++);
          o2 < i2 && (u += "'", o2++, l++);
          continue;
        }
        if (y === "$" && o2 + 1 < i2 && s2[o2 + 1] === '"' && !d && !m) {
          o2++, l++, m = true, f2 = true, u === "" && (h = true), o2++, l++;
          continue;
        }
        if (y === "'" && !m) {
          if (d) if (d = false, !h || g) u += y;
          else {
            let w = o2 + 1 < i2 ? s2[o2 + 1] : "";
            w && !cm(w) && w !== "'" && (w === '"' ? (g = true, u += y, p = false, f2 = false) : (g = true, u += y));
          }
          else d = true, h && !g ? (p = true, f2 = true) : u += y;
          o2++, l++;
          continue;
        }
        if (y === '"' && !d) {
          if (m) if (m = false, !h || g) u += y;
          else {
            let w = o2 + 1 < i2 ? s2[o2 + 1] : "";
            w && !cm(w) && w !== '"' && (w === "'" ? (g = true, u += y, p = false, f2 = false) : (g = true, u += y));
          }
          else m = true, h && !g ? f2 = true : u += y;
          o2++, l++;
          continue;
        }
        if (y === "\\" && !d && o2 + 1 < i2) {
          let w = s2[o2 + 1];
          if (w === `
`) {
            o2 += 2, c++, l = 1;
            continue;
          }
          if (m) {
            if (w === '"' || w === "\\" || w === "$" || w === "`" || w === `
`) {
              if (w === `
`) {
                o2 += 2, l = 1, c++;
                continue;
              }
              u += y + w, o2 += 2, l += 2;
              continue;
            }
          } else {
            w === "\\" || w === '"' || w === "'" || w === "`" || w === "*" || w === "?" || w === "[" || w === "]" || w === "(" || w === ")" || w === "$" || w === "-" || w === "." || w === "^" || w === "+" || w === "{" || w === "}" ? u += y + w : u += w, o2 += 2, l += 2;
            continue;
          }
        }
        if (y === "$" && o2 + 1 < i2 && s2[o2 + 1] === "(" && !d) {
          u += y, o2++, l++, u += s2[o2], o2++, l++;
          let w = 1, E = false, C = false, A = 0, I = false, O = "", L = s2[o2] === "(" && !this.dollarDparenIsSubshell(o2);
          for (; w > 0 && o2 < i2; ) {
            let D = s2[o2];
            if (u += D, E) D === "'" && (E = false);
            else if (C) D === "\\" && o2 + 1 < i2 ? (u += s2[o2 + 1], o2++, l++) : D === '"' && (C = false);
            else if (D === "'") E = true, O = "";
            else if (D === '"') C = true, O = "";
            else if (D === "\\" && o2 + 1 < i2) u += s2[o2 + 1], o2++, l++, O = "";
            else if (D === "$" && o2 + 1 < i2 && s2[o2 + 1] === "{") {
              o2++, l++, u += s2[o2], o2++, l++;
              let $ = 1, N2 = false, P = false;
              for (; $ > 0 && o2 < i2; ) {
                let k = s2[o2];
                if (k === "\\" && o2 + 1 < i2 && !N2) {
                  u += k, o2++, l++, u += s2[o2], o2++, l++;
                  continue;
                }
                u += k, N2 ? k === "'" && (N2 = false) : P ? k === '"' && (P = false) : k === "'" ? N2 = true : k === '"' ? P = true : k === "{" ? $++ : k === "}" && $--, k === `
` ? (c++, l = 0) : l++, o2++;
              }
              O = "";
              continue;
            } else if (D === "#" && !L && (O === "" || /\s/.test(s2[o2 - 1] || ""))) {
              for (; o2 + 1 < i2 && s2[o2 + 1] !== `
`; ) o2++, l++, u += s2[o2];
              O = "";
            } else /[a-zA-Z_]/.test(D) ? O += D : (O === "case" ? (A++, I = false) : O === "in" && A > 0 ? I = true : O === "esac" && A > 0 && (A--, I = false), O = "", D === "(" ? o2 > 0 && s2[o2 - 1] === "$" ? w++ : I || w++ : D === ")" ? I ? I = false : w-- : D === ";" && A > 0 && o2 + 1 < i2 && s2[o2 + 1] === ";" && (I = true));
            D === `
` && (c++, l = 0, O = ""), o2++, l++;
          }
          continue;
        }
        if (y === "$" && o2 + 1 < i2 && s2[o2 + 1] === "[" && !d) {
          u += y, o2++, l++, u += s2[o2], o2++, l++;
          let w = 1;
          for (; w > 0 && o2 < i2; ) {
            let E = s2[o2];
            u += E, E === "[" ? w++ : E === "]" ? w-- : E === `
` && (c++, l = 0), o2++, l++;
          }
          continue;
        }
        if (y === "$" && o2 + 1 < i2 && s2[o2 + 1] === "{" && !d) {
          u += y, o2++, l++, u += s2[o2], o2++, l++;
          let w = 1, E = false, C = false, A = c, I = l, O = c, L = l;
          for (; w > 0 && o2 < i2; ) {
            let D = s2[o2];
            if (D === "\\" && o2 + 1 < i2 && s2[o2 + 1] === `
`) {
              o2 += 2, c++, l = 1;
              continue;
            }
            if (D === "\\" && o2 + 1 < i2 && !E) {
              u += D, o2++, l++, u += s2[o2], o2++, l++;
              continue;
            }
            u += D, E ? D === "'" && (E = false) : C ? D === '"' && (C = false) : D === "'" ? (E = true, A = c, I = l) : D === '"' ? (C = true, O = c, L = l) : D === "{" ? w++ : D === "}" && w--, D === `
` && (c++, l = 0), o2++, l++;
          }
          if (E) throw new Sn("unexpected EOF while looking for matching `''", A, I);
          if (C) throw new Sn("unexpected EOF while looking for matching `\"'", O, L);
          continue;
        }
        if (y === "$" && o2 + 1 < i2 && !d) {
          let w = s2[o2 + 1];
          if (w === "#" || w === "?" || w === "$" || w === "!" || w === "@" || w === "*" || w === "-" || w >= "0" && w <= "9") {
            u += y + w, o2 += 2, l += 2;
            continue;
          }
        }
        if (y === "`" && !d) {
          for (u += y, o2++, l++; o2 < i2 && s2[o2] !== "`"; ) {
            let w = s2[o2];
            u += w, w === "\\" && o2 + 1 < i2 && (u += s2[o2 + 1], o2++, l++), w === `
` && (c++, l = 0), o2++, l++;
          }
          o2 < i2 && (u += s2[o2], o2++, l++);
          continue;
        }
        u += y, o2++, y === `
` ? (c++, l = 1) : l++;
      }
      if (this.pos = o2, this.column = l, this.line = c, g && h && (u = s2[t2] + u, f2 = false, p = false), d || m) {
        let y = d ? "'" : '"';
        throw new Sn(`unexpected EOF while looking for matching \`${y}'`, n2, r2);
      }
      if (!h && u.length >= 2) {
        if (u[0] === "'" && u[u.length - 1] === "'") {
          let y = u.slice(1, -1);
          !y.includes("'") && !y.includes('"') && (u = y, f2 = true, p = true);
        } else if (u[0] === '"' && u[u.length - 1] === '"') {
          let y = u.slice(1, -1), w = false;
          for (let E = 0; E < y.length; E++) {
            if (y[E] === '"') {
              w = true;
              break;
            }
            y[E] === "\\" && E + 1 < y.length && E++;
          }
          w || (u = y, f2 = true, p = false);
        }
      }
      if (u === "") return { type: x.WORD, value: "", start: t2, end: o2, line: n2, column: r2, quoted: f2, singleQuoted: p };
      if (!f2 && Gs[u]) return { type: Gs[u], value: u, start: t2, end: o2, line: n2, column: r2 };
      if (!h) {
        let y = lm(u);
        if (y > 0 && am(u.slice(0, y))) return { type: x.ASSIGNMENT_WORD, value: u, start: t2, end: o2, line: n2, column: r2, quoted: f2, singleQuoted: p };
      }
      return /^[0-9]+$/.test(u) ? { type: x.NUMBER, value: u, start: t2, end: o2, line: n2, column: r2 } : aC(u) ? { type: x.NAME, value: u, start: t2, end: o2, line: n2, column: r2, quoted: f2, singleQuoted: p } : { type: x.WORD, value: u, start: t2, end: o2, line: n2, column: r2, quoted: f2, singleQuoted: p };
    }
    readHeredocContent() {
      for (; this.pendingHeredocs.length > 0; ) {
        let t2 = this.pendingHeredocs.shift();
        if (!t2) break;
        let n2 = this.pos, r2 = this.line, s2 = this.column, i2 = "";
        for (; this.pos < this.input.length; ) {
          this.pos;
          let a = "";
          for (; this.pos < this.input.length && this.input[this.pos] !== `
`; ) a += this.input[this.pos], this.pos++, this.column++;
          if ((t2.stripTabs ? a.replace(/^\t+/, "") : a) === t2.delimiter) {
            this.pos < this.input.length && this.input[this.pos] === `
` && (this.pos++, this.line++, this.column = 1);
            break;
          }
          i2 += a, this.pos < this.input.length && this.input[this.pos] === `
` && (i2 += `
`, this.pos++, this.line++, this.column = 1);
        }
        this.tokens.push({ type: x.HEREDOC_CONTENT, value: i2, start: n2, end: this.pos, line: r2, column: s2 });
      }
    }
    addPendingHeredoc(t2, n2, r2) {
      this.pendingHeredocs.push({ delimiter: t2, stripTabs: n2, quoted: r2 });
    }
    registerHeredocFromLookahead(t2) {
      let n2 = this.pos, r2 = this.column;
      for (; this.pos < this.input.length && (this.input[this.pos] === " " || this.input[this.pos] === "	"); ) this.pos++, this.column++;
      let s2 = "", i2 = false;
      for (; this.pos < this.input.length; ) {
        let o2 = this.input[this.pos];
        if (/[\s;<>&|()]/.test(o2)) break;
        if (o2 === "'" || o2 === '"') {
          i2 = true;
          let a = o2;
          for (this.pos++, this.column++; this.pos < this.input.length && this.input[this.pos] !== a; ) s2 += this.input[this.pos], this.pos++, this.column++;
          this.pos < this.input.length && this.input[this.pos] === a && (this.pos++, this.column++);
        } else o2 === "\\" ? (i2 = true, this.pos++, this.column++, this.pos < this.input.length && (s2 += this.input[this.pos], this.pos++, this.column++)) : (s2 += o2, this.pos++, this.column++);
      }
      this.pos = n2, this.column = r2, s2 && this.pendingHeredocs.push({ delimiter: s2, stripTabs: t2, quoted: i2 });
    }
    isWordCharFollowing(t2) {
      if (t2 >= this.input.length) return false;
      let n2 = this.input[t2];
      return !(n2 === " " || n2 === "	" || n2 === `
` || n2 === ";" || n2 === "&" || n2 === "|" || n2 === "(" || n2 === ")" || n2 === "<" || n2 === ">");
    }
    readWordWithBraceExpansion(t2, n2, r2) {
      let s2 = this.input, i2 = s2.length, o2 = t2, a = r2;
      for (; o2 < i2; ) {
        let c = s2[o2];
        if (c === " " || c === "	" || c === `
` || c === ";" || c === "&" || c === "|" || c === "(" || c === ")" || c === "<" || c === ">") break;
        if (c === "{") {
          if (this.scanBraceExpansion(o2) !== null) {
            let f2 = 1;
            for (o2++, a++; o2 < i2 && f2 > 0; ) s2[o2] === "{" ? f2++ : s2[o2] === "}" && f2--, o2++, a++;
            continue;
          }
          o2++, a++;
          continue;
        }
        if (c === "}") {
          o2++, a++;
          continue;
        }
        if (c === "$" && o2 + 1 < i2 && s2[o2 + 1] === "(") {
          o2++, a++, o2++, a++;
          let u = 1;
          for (; u > 0 && o2 < i2; ) s2[o2] === "(" ? u++ : s2[o2] === ")" && u--, o2++, a++;
          continue;
        }
        if (c === "$" && o2 + 1 < i2 && s2[o2 + 1] === "{") {
          o2++, a++, o2++, a++;
          let u = 1;
          for (; u > 0 && o2 < i2; ) s2[o2] === "{" ? u++ : s2[o2] === "}" && u--, o2++, a++;
          continue;
        }
        if (c === "`") {
          for (o2++, a++; o2 < i2 && s2[o2] !== "`"; ) s2[o2] === "\\" && o2 + 1 < i2 ? (o2 += 2, a += 2) : (o2++, a++);
          o2 < i2 && (o2++, a++);
          continue;
        }
        o2++, a++;
      }
      let l = s2.slice(t2, o2);
      return this.pos = o2, this.column = a, { type: x.WORD, value: l, start: t2, end: o2, line: n2, column: r2, quoted: false, singleQuoted: false };
    }
    scanBraceExpansion(t2) {
      let n2 = this.input, r2 = n2.length, s2 = t2 + 1, i2 = 1, o2 = false, a = false;
      for (; s2 < r2 && i2 > 0; ) {
        let l = n2[s2];
        if (l === "{") i2++, s2++;
        else if (l === "}") i2--, s2++;
        else if (l === "," && i2 === 1) o2 = true, s2++;
        else if (l === "." && s2 + 1 < r2 && n2[s2 + 1] === ".") a = true, s2 += 2;
        else {
          if (l === " " || l === "	" || l === `
` || l === ";" || l === "&" || l === "|") return null;
          s2++;
        }
      }
      return i2 === 0 && (o2 || a) ? n2.slice(t2, s2) : null;
    }
    scanLiteralBraceWord(t2) {
      let n2 = this.input, r2 = n2.length, s2 = t2 + 1, i2 = 1;
      for (; s2 < r2 && i2 > 0; ) {
        let o2 = n2[s2];
        if (o2 === "{") i2++, s2++;
        else if (o2 === "}") {
          if (i2--, i2 === 0) return n2.slice(t2, s2 + 1);
          s2++;
        } else {
          if (o2 === " " || o2 === "	" || o2 === `
` || o2 === ";" || o2 === "&" || o2 === "|") return null;
          s2++;
        }
      }
      return null;
    }
    scanExtglobPattern(t2) {
      let n2 = this.input, r2 = n2.length, s2 = t2 + 1, i2 = 1;
      for (; s2 < r2 && i2 > 0; ) {
        let o2 = n2[s2];
        if (o2 === "\\" && s2 + 1 < r2) {
          s2 += 2;
          continue;
        }
        if ("@*+?!".includes(o2) && s2 + 1 < r2 && n2[s2 + 1] === "(") {
          s2++, i2++, s2++;
          continue;
        }
        if (o2 === "(") i2++, s2++;
        else if (o2 === ")") i2--, s2++;
        else {
          if (o2 === `
`) return null;
          s2++;
        }
      }
      return i2 === 0 ? { content: n2.slice(t2, s2), end: s2 } : null;
    }
    scanFdVariable(t2) {
      let n2 = this.input, r2 = n2.length, s2 = t2 + 1, i2 = s2;
      for (; s2 < r2; ) {
        let u = n2[s2];
        if (s2 === i2) {
          if (!(u >= "a" && u <= "z" || u >= "A" && u <= "Z" || u === "_")) return null;
        } else if (!(u >= "a" && u <= "z" || u >= "A" && u <= "Z" || u >= "0" && u <= "9" || u === "_")) break;
        s2++;
      }
      if (s2 === i2) return null;
      let o2 = n2.slice(i2, s2);
      if (s2 >= r2 || n2[s2] !== "}" || (s2++, s2 >= r2)) return null;
      let a = n2[s2], l = s2 + 1 < r2 ? n2[s2 + 1] : "";
      return a === ">" || a === "<" || a === "&" && (l === ">" || l === "<") ? { varname: o2, end: s2 } : null;
    }
    dollarDparenIsSubshell(t2) {
      let n2 = this.input, r2 = n2.length, s2 = t2 + 1, i2 = 2, o2 = false, a = false, l = false;
      for (; s2 < r2 && i2 > 0; ) {
        let c = n2[s2];
        if (o2) {
          c === "'" && (o2 = false), c === `
` && (l = true), s2++;
          continue;
        }
        if (a) {
          if (c === "\\") {
            s2 += 2;
            continue;
          }
          c === '"' && (a = false), c === `
` && (l = true), s2++;
          continue;
        }
        if (c === "'") {
          o2 = true, s2++;
          continue;
        }
        if (c === '"') {
          a = true, s2++;
          continue;
        }
        if (c === "\\") {
          s2 += 2;
          continue;
        }
        if (c === `
` && (l = true), c === "(") {
          i2++, s2++;
          continue;
        }
        if (c === ")") {
          if (i2--, i2 === 1) {
            let u = s2 + 1;
            if (u < r2 && n2[u] === ")") return false;
            let f2 = u, p = false;
            for (; f2 < r2 && (n2[f2] === " " || n2[f2] === "	" || n2[f2] === `
`); ) p = true, f2++;
            if (p && f2 < r2 && n2[f2] === ")" || l) return true;
          }
          if (i2 === 0) return false;
          s2++;
          continue;
        }
        s2++;
      }
      return false;
    }
    dparenClosesWithSpacedParens(t2) {
      let n2 = this.input, r2 = n2.length, s2 = t2, i2 = 2, o2 = false, a = false;
      for (; s2 < r2 && i2 > 0; ) {
        let l = n2[s2];
        if (o2) {
          l === "'" && (o2 = false), s2++;
          continue;
        }
        if (a) {
          if (l === "\\") {
            s2 += 2;
            continue;
          }
          l === '"' && (a = false), s2++;
          continue;
        }
        if (l === "'") {
          o2 = true, s2++;
          continue;
        }
        if (l === '"') {
          a = true, s2++;
          continue;
        }
        if (l === "\\") {
          s2 += 2;
          continue;
        }
        if (l === "(") {
          i2++, s2++;
          continue;
        }
        if (l === ")") {
          if (i2--, i2 === 1) {
            let c = s2 + 1;
            if (c < r2 && n2[c] === ")") return false;
            let u = c, f2 = false;
            for (; u < r2 && (n2[u] === " " || n2[u] === "	" || n2[u] === `
`); ) f2 = true, u++;
            if (f2 && u < r2 && n2[u] === ")") return true;
          }
          if (i2 === 0) return false;
          s2++;
          continue;
        }
        if (i2 === 1 && (l === "|" && s2 + 1 < r2 && n2[s2 + 1] === "|" || l === "&" && s2 + 1 < r2 && n2[s2 + 1] === "&" || l === "|" && s2 + 1 < r2 && n2[s2 + 1] !== "|")) return true;
        s2++;
      }
      return false;
    }
  };
});
var da, ha, um, fm, pm, dm, Ge, An = v(() => {
  tn();
  da = 1e6, ha = 1e5, um = 1e6, fm = /* @__PURE__ */ new Set([x.LESS, x.GREAT, x.DLESS, x.DGREAT, x.LESSAND, x.GREATAND, x.LESSGREAT, x.DLESSDASH, x.CLOBBER, x.TLESS, x.AND_GREAT, x.AND_DGREAT]), pm = /* @__PURE__ */ new Set([x.LESS, x.GREAT, x.DLESS, x.DGREAT, x.LESSAND, x.GREATAND, x.LESSGREAT, x.DLESSDASH, x.CLOBBER, x.TLESS]), dm = /* @__PURE__ */ new Set([x.LESS, x.GREAT, x.DLESS, x.DGREAT, x.LESSAND, x.GREATAND, x.LESSGREAT, x.DLESSDASH, x.CLOBBER, x.TLESS, x.AND_GREAT, x.AND_DGREAT]), Ge = class extends Error {
    constructor(t2, n2, r2, s2 = void 0) {
      super(`Parse error at ${n2}:${r2}: ${t2}`);
      __publicField(this, "line");
      __publicField(this, "column");
      __publicField(this, "token");
      this.line = n2, this.column = r2, this.token = s2, this.name = "ParseException";
    }
  };
});
var j, Cn = v(() => {
  j = { script(e2) {
    return { type: "Script", statements: e2 };
  }, statement(e2, t2 = [], n2 = false, r2, s2) {
    let i2 = { type: "Statement", pipelines: e2, operators: t2, background: n2 };
    return r2 && (i2.deferredError = r2), s2 !== void 0 && (i2.sourceText = s2), i2;
  }, pipeline(e2, t2 = false, n2 = false, r2 = false, s2) {
    return { type: "Pipeline", commands: e2, negated: t2, timed: n2, timePosix: r2, pipeStderr: s2 };
  }, simpleCommand(e2, t2 = [], n2 = [], r2 = []) {
    return { type: "SimpleCommand", name: e2, args: t2, assignments: n2, redirections: r2 };
  }, word(e2) {
    return { type: "Word", parts: e2 };
  }, literal(e2) {
    return { type: "Literal", value: e2 };
  }, singleQuoted(e2) {
    return { type: "SingleQuoted", value: e2 };
  }, doubleQuoted(e2) {
    return { type: "DoubleQuoted", parts: e2 };
  }, escaped(e2) {
    return { type: "Escaped", value: e2 };
  }, parameterExpansion(e2, t2 = null) {
    return { type: "ParameterExpansion", parameter: e2, operation: t2 };
  }, commandSubstitution(e2, t2 = false) {
    return { type: "CommandSubstitution", body: e2, legacy: t2 };
  }, arithmeticExpansion(e2) {
    return { type: "ArithmeticExpansion", expression: e2 };
  }, assignment(e2, t2, n2 = false, r2 = null) {
    return { type: "Assignment", name: e2, value: t2, append: n2, array: r2 };
  }, redirection(e2, t2, n2 = null, r2) {
    let s2 = { type: "Redirection", fd: n2, operator: e2, target: t2 };
    return r2 && (s2.fdVariable = r2), s2;
  }, hereDoc(e2, t2, n2 = false, r2 = false) {
    return { type: "HereDoc", delimiter: e2, content: t2, stripTabs: n2, quoted: r2 };
  }, ifNode(e2, t2 = null, n2 = []) {
    return { type: "If", clauses: e2, elseBody: t2, redirections: n2 };
  }, forNode(e2, t2, n2, r2 = []) {
    return { type: "For", variable: e2, words: t2, body: n2, redirections: r2 };
  }, whileNode(e2, t2, n2 = []) {
    return { type: "While", condition: e2, body: t2, redirections: n2 };
  }, untilNode(e2, t2, n2 = []) {
    return { type: "Until", condition: e2, body: t2, redirections: n2 };
  }, caseNode(e2, t2, n2 = []) {
    return { type: "Case", word: e2, items: t2, redirections: n2 };
  }, caseItem(e2, t2, n2 = ";;") {
    return { type: "CaseItem", patterns: e2, body: t2, terminator: n2 };
  }, subshell(e2, t2 = []) {
    return { type: "Subshell", body: e2, redirections: t2 };
  }, group(e2, t2 = []) {
    return { type: "Group", body: e2, redirections: t2 };
  }, functionDef(e2, t2, n2 = [], r2) {
    return { type: "FunctionDef", name: e2, body: t2, redirections: n2, sourceFile: r2 };
  }, conditionalCommand(e2, t2 = [], n2) {
    return { type: "ConditionalCommand", expression: e2, redirections: t2, line: n2 };
  }, arithmeticCommand(e2, t2 = [], n2) {
    return { type: "ArithmeticCommand", expression: e2, redirections: t2, line: n2 };
  } };
});
function ve(e2, t2) {
  for (; t2 < e2.length; ) {
    if (e2[t2] === "\\" && e2[t2 + 1] === `
`) {
      t2 += 2;
      continue;
    }
    if (/\s/.test(e2[t2])) {
      t2++;
      continue;
    }
    break;
  }
  return t2;
}
function Fr(e2) {
  if (e2.includes("#")) {
    let [t2, n2] = e2.split("#"), r2 = Number.parseInt(t2, 10);
    if (r2 < 2 || r2 > 64) return Number.NaN;
    if (r2 <= 36) return Number.parseInt(n2, r2);
    let s2 = 0;
    for (let i2 of n2) {
      let o2;
      if (/[0-9]/.test(i2)) o2 = i2.charCodeAt(0) - 48;
      else if (/[a-z]/.test(i2)) o2 = i2.charCodeAt(0) - 97 + 10;
      else if (/[A-Z]/.test(i2)) o2 = i2.charCodeAt(0) - 65 + 36;
      else if (i2 === "@") o2 = 62;
      else if (i2 === "_") o2 = 63;
      else return Number.NaN;
      if (o2 >= r2) return Number.NaN;
      s2 = s2 * r2 + o2;
    }
    return s2;
  }
  return e2.startsWith("0x") || e2.startsWith("0X") ? Number.parseInt(e2.slice(2), 16) : e2.startsWith("0") && e2.length > 1 && /^[0-9]+$/.test(e2) ? /[89]/.test(e2) ? Number.NaN : Number.parseInt(e2, 8) : Number.parseInt(e2, 10);
}
function hm(e2, t2, n2, r2) {
  if (n2.slice(r2, r2 + 3) !== "$((") return null;
  let s2 = r2 + 3, i2 = 1, o2 = s2;
  for (; s2 < n2.length - 1 && i2 > 0; ) n2[s2] === "(" && n2[s2 + 1] === "(" ? (i2++, s2 += 2) : n2[s2] === ")" && n2[s2 + 1] === ")" ? (i2--, i2 > 0 && (s2 += 2)) : s2++;
  let a = n2.slice(o2, s2), { expr: l } = e2(t2, a, 0);
  return s2 += 2, { expr: { type: "ArithNested", expression: l }, pos: s2 };
}
function mm(e2, t2) {
  if (e2.slice(t2, t2 + 2) !== "$'") return null;
  let n2 = t2 + 2, r2 = "";
  for (; n2 < e2.length && e2[n2] !== "'"; ) if (e2[n2] === "\\" && n2 + 1 < e2.length) {
    let i2 = e2[n2 + 1];
    switch (i2) {
      case "n":
        r2 += `
`;
        break;
      case "t":
        r2 += "	";
        break;
      case "r":
        r2 += "\r";
        break;
      case "\\":
        r2 += "\\";
        break;
      case "'":
        r2 += "'";
        break;
      default:
        r2 += i2;
    }
    n2 += 2;
  } else r2 += e2[n2], n2++;
  e2[n2] === "'" && n2++;
  let s2 = Number.parseInt(r2, 10);
  return { expr: { type: "ArithNumber", value: Number.isNaN(s2) ? 0 : s2 }, pos: n2 };
}
function gm(e2, t2) {
  if (e2.slice(t2, t2 + 2) !== '$"') return null;
  let n2 = t2 + 2, r2 = "";
  for (; n2 < e2.length && e2[n2] !== '"'; ) e2[n2] === "\\" && n2 + 1 < e2.length ? (r2 += e2[n2 + 1], n2 += 2) : (r2 += e2[n2], n2++);
  e2[n2] === '"' && n2++;
  let s2 = Number.parseInt(r2, 10);
  return { expr: { type: "ArithNumber", value: Number.isNaN(s2) ? 0 : s2 }, pos: n2 };
}
var Qs, ym = v(() => {
  Qs = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", "&=", "|=", "^="];
});
function lC(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) if (e2[n2] === '"') {
    for (n2++; n2 < e2.length && e2[n2] !== '"'; ) e2[n2] === "\\" && n2 + 1 < e2.length ? (t2 += e2[n2 + 1], n2 += 2) : (t2 += e2[n2], n2++);
    n2 < e2.length && n2++;
  } else t2 += e2[n2], n2++;
  return t2;
}
function he(e2, t2) {
  let n2 = lC(t2), { expr: r2, pos: s2 } = Et(e2, n2, 0), i2 = ve(n2, s2);
  if (i2 < n2.length) {
    let o2 = t2.slice(i2).trim();
    if (o2) return { type: "ArithmeticExpression", originalText: t2, expression: { type: "ArithSyntaxError", errorToken: o2, message: `${o2}: syntax error: invalid arithmetic operator (error token is "${o2}")` } };
  }
  return { type: "ArithmeticExpression", expression: r2, originalText: t2 };
}
function pt(e2, t2) {
  return { expr: { type: "ArithSyntaxError", errorToken: e2, message: `syntax error: operand expected (error token is "${e2}")` }, pos: t2 };
}
function dt(e2, t2) {
  return ve(e2, t2) >= e2.length;
}
function Et(e2, t2, n2) {
  return cC(e2, t2, n2);
}
function cC(e2, t2, n2) {
  let { expr: r2, pos: s2 } = _r(e2, t2, n2);
  for (s2 = ve(t2, s2); t2[s2] === ","; ) {
    if (s2++, dt(t2, s2)) return pt(",", s2);
    let { expr: o2, pos: a } = _r(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: ",", left: r2, right: o2 }, s2 = ve(t2, a);
  }
  return { expr: r2, pos: s2 };
}
function _r(e2, t2, n2) {
  let { expr: r2, pos: s2 } = uC(e2, t2, n2);
  if (s2 = ve(t2, s2), t2[s2] === "?") {
    s2++;
    let { expr: i2, pos: o2 } = Et(e2, t2, s2);
    if (s2 = ve(t2, o2), t2[s2] === ":") {
      s2++;
      let { expr: a, pos: l } = Et(e2, t2, s2);
      return { expr: { type: "ArithTernary", condition: r2, consequent: i2, alternate: a }, pos: l };
    }
  }
  return { expr: r2, pos: s2 };
}
function uC(e2, t2, n2) {
  let { expr: r2, pos: s2 } = bm(e2, t2, n2);
  for (; s2 = ve(t2, s2), t2.slice(s2, s2 + 2) === "||"; ) {
    if (s2 += 2, dt(t2, s2)) return pt("||", s2);
    let { expr: o2, pos: a } = bm(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: "||", left: r2, right: o2 }, s2 = a;
  }
  return { expr: r2, pos: s2 };
}
function bm(e2, t2, n2) {
  let { expr: r2, pos: s2 } = wm(e2, t2, n2);
  for (; s2 = ve(t2, s2), t2.slice(s2, s2 + 2) === "&&"; ) {
    if (s2 += 2, dt(t2, s2)) return pt("&&", s2);
    let { expr: o2, pos: a } = wm(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: "&&", left: r2, right: o2 }, s2 = a;
  }
  return { expr: r2, pos: s2 };
}
function wm(e2, t2, n2) {
  let { expr: r2, pos: s2 } = xm(e2, t2, n2);
  for (; s2 = ve(t2, s2), t2[s2] === "|" && t2[s2 + 1] !== "|"; ) {
    if (s2++, dt(t2, s2)) return pt("|", s2);
    let { expr: o2, pos: a } = xm(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: "|", left: r2, right: o2 }, s2 = a;
  }
  return { expr: r2, pos: s2 };
}
function xm(e2, t2, n2) {
  let { expr: r2, pos: s2 } = Em(e2, t2, n2);
  for (; s2 = ve(t2, s2), t2[s2] === "^"; ) {
    if (s2++, dt(t2, s2)) return pt("^", s2);
    let { expr: o2, pos: a } = Em(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: "^", left: r2, right: o2 }, s2 = a;
  }
  return { expr: r2, pos: s2 };
}
function Em(e2, t2, n2) {
  let { expr: r2, pos: s2 } = Sm(e2, t2, n2);
  for (; s2 = ve(t2, s2), t2[s2] === "&" && t2[s2 + 1] !== "&"; ) {
    if (s2++, dt(t2, s2)) return pt("&", s2);
    let { expr: o2, pos: a } = Sm(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: "&", left: r2, right: o2 }, s2 = a;
  }
  return { expr: r2, pos: s2 };
}
function Sm(e2, t2, n2) {
  let { expr: r2, pos: s2 } = Am(e2, t2, n2);
  for (; s2 = ve(t2, s2), t2.slice(s2, s2 + 2) === "==" || t2.slice(s2, s2 + 2) === "!="; ) {
    let i2 = t2.slice(s2, s2 + 2);
    if (s2 += 2, dt(t2, s2)) return pt(i2, s2);
    let { expr: o2, pos: a } = Am(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: i2, left: r2, right: o2 }, s2 = a;
  }
  return { expr: r2, pos: s2 };
}
function Am(e2, t2, n2) {
  let { expr: r2, pos: s2 } = ma(e2, t2, n2);
  for (; ; ) if (s2 = ve(t2, s2), t2.slice(s2, s2 + 2) === "<=" || t2.slice(s2, s2 + 2) === ">=") {
    let i2 = t2.slice(s2, s2 + 2);
    if (s2 += 2, dt(t2, s2)) return pt(i2, s2);
    let { expr: o2, pos: a } = ma(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: i2, left: r2, right: o2 }, s2 = a;
  } else if (t2[s2] === "<" || t2[s2] === ">") {
    let i2 = t2[s2];
    if (s2++, dt(t2, s2)) return pt(i2, s2);
    let { expr: o2, pos: a } = ma(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: i2, left: r2, right: o2 }, s2 = a;
  } else break;
  return { expr: r2, pos: s2 };
}
function ma(e2, t2, n2) {
  let { expr: r2, pos: s2 } = Cm(e2, t2, n2);
  for (; s2 = ve(t2, s2), t2.slice(s2, s2 + 2) === "<<" || t2.slice(s2, s2 + 2) === ">>"; ) {
    let i2 = t2.slice(s2, s2 + 2);
    if (s2 += 2, dt(t2, s2)) return pt(i2, s2);
    let { expr: o2, pos: a } = Cm(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: i2, left: r2, right: o2 }, s2 = a;
  }
  return { expr: r2, pos: s2 };
}
function Cm(e2, t2, n2) {
  let { expr: r2, pos: s2 } = Nm(e2, t2, n2);
  for (; s2 = ve(t2, s2), (t2[s2] === "+" || t2[s2] === "-") && t2[s2 + 1] !== t2[s2]; ) {
    let i2 = t2[s2];
    if (s2++, dt(t2, s2)) return pt(i2, s2);
    let { expr: o2, pos: a } = Nm(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: i2, left: r2, right: o2 }, s2 = a;
  }
  return { expr: r2, pos: s2 };
}
function Nm(e2, t2, n2) {
  let { expr: r2, pos: s2 } = Ks(e2, t2, n2);
  for (; ; ) if (s2 = ve(t2, s2), t2[s2] === "*" && t2[s2 + 1] !== "*") {
    if (s2++, dt(t2, s2)) return pt("*", s2);
    let { expr: o2, pos: a } = Ks(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: "*", left: r2, right: o2 }, s2 = a;
  } else if (t2[s2] === "/" || t2[s2] === "%") {
    let i2 = t2[s2];
    if (s2++, dt(t2, s2)) return pt(i2, s2);
    let { expr: o2, pos: a } = Ks(e2, t2, s2);
    r2 = { type: "ArithBinary", operator: i2, left: r2, right: o2 }, s2 = a;
  } else break;
  return { expr: r2, pos: s2 };
}
function Ks(e2, t2, n2) {
  let { expr: r2, pos: s2 } = ga(e2, t2, n2), i2 = ve(t2, s2);
  if (t2.slice(i2, i2 + 2) === "**") {
    if (i2 += 2, dt(t2, i2)) return pt("**", i2);
    let { expr: a, pos: l } = Ks(e2, t2, i2);
    return { expr: { type: "ArithBinary", operator: "**", left: r2, right: a }, pos: l };
  }
  return { expr: r2, pos: s2 };
}
function ga(e2, t2, n2) {
  let r2 = ve(t2, n2);
  if (t2.slice(r2, r2 + 2) === "++" || t2.slice(r2, r2 + 2) === "--") {
    let s2 = t2.slice(r2, r2 + 2);
    r2 += 2;
    let { expr: i2, pos: o2 } = ga(e2, t2, r2);
    return { expr: { type: "ArithUnary", operator: s2, operand: i2, prefix: true }, pos: o2 };
  }
  if (t2[r2] === "+" || t2[r2] === "-" || t2[r2] === "!" || t2[r2] === "~") {
    let s2 = t2[r2];
    r2++;
    let { expr: i2, pos: o2 } = ga(e2, t2, r2);
    return { expr: { type: "ArithUnary", operator: s2, operand: i2, prefix: true }, pos: o2 };
  }
  return pC(e2, t2, r2);
}
function fC(e2, t2) {
  let n2 = e2[t2];
  return n2 === "$" || n2 === "`";
}
function pC(e2, t2, n2) {
  let { expr: r2, pos: s2 } = km(e2, t2, n2, false), i2 = [r2];
  for (; fC(t2, s2); ) {
    let { expr: a, pos: l } = km(e2, t2, s2, true);
    i2.push(a), s2 = l;
  }
  i2.length > 1 && (r2 = { type: "ArithConcat", parts: i2 });
  let o2;
  if (t2[s2] === "[" && r2.type === "ArithConcat") {
    s2++;
    let { expr: a, pos: l } = Et(e2, t2, s2);
    o2 = a, s2 = l, t2[s2] === "]" && s2++;
  }
  if (o2 && r2.type === "ArithConcat" && (r2 = { type: "ArithDynamicElement", nameExpr: r2, subscript: o2 }, o2 = void 0), s2 = ve(t2, s2), r2.type === "ArithConcat" || r2.type === "ArithVariable" || r2.type === "ArithDynamicElement") {
    for (let a of Qs) if (t2.slice(s2, s2 + a.length) === a && t2.slice(s2, s2 + a.length + 1) !== "==") {
      s2 += a.length;
      let { expr: l, pos: c } = _r(e2, t2, s2);
      return r2.type === "ArithDynamicElement" ? { expr: { type: "ArithDynamicAssignment", operator: a, target: r2.nameExpr, subscript: r2.subscript, value: l }, pos: c } : r2.type === "ArithConcat" ? { expr: { type: "ArithDynamicAssignment", operator: a, target: r2, value: l }, pos: c } : { expr: { type: "ArithAssignment", operator: a, variable: r2.name, value: l }, pos: c };
    }
  }
  if (t2.slice(s2, s2 + 2) === "++" || t2.slice(s2, s2 + 2) === "--") {
    let a = t2.slice(s2, s2 + 2);
    return s2 += 2, { expr: { type: "ArithUnary", operator: a, operand: r2, prefix: false }, pos: s2 };
  }
  return { expr: r2, pos: s2 };
}
function km(e2, t2, n2, r2 = false) {
  let s2 = ve(t2, n2), i2 = hm(Et, e2, t2, s2);
  if (i2) return i2;
  let o2 = mm(t2, s2);
  if (o2) return o2;
  let a = gm(t2, s2);
  if (a) return a;
  if (t2.slice(s2, s2 + 2) === "$(" && t2[s2 + 2] !== "(") {
    s2 += 2;
    let c = 1, u = s2;
    for (; s2 < t2.length && c > 0; ) t2[s2] === "(" ? c++ : t2[s2] === ")" && c--, c > 0 && s2++;
    let f2 = t2.slice(u, s2);
    return s2++, { expr: { type: "ArithCommandSubst", command: f2 }, pos: s2 };
  }
  if (t2[s2] === "`") {
    s2++;
    let c = s2;
    for (; s2 < t2.length && t2[s2] !== "`"; ) s2++;
    let u = t2.slice(c, s2);
    return t2[s2] === "`" && s2++, { expr: { type: "ArithCommandSubst", command: u }, pos: s2 };
  }
  if (t2[s2] === "(") {
    s2++;
    let { expr: c, pos: u } = Et(e2, t2, s2);
    return s2 = ve(t2, u), t2[s2] === ")" && s2++, { expr: { type: "ArithGroup", expression: c }, pos: s2 };
  }
  if (t2[s2] === "'") {
    s2++;
    let c = "";
    for (; s2 < t2.length && t2[s2] !== "'"; ) c += t2[s2], s2++;
    t2[s2] === "'" && s2++;
    let u = Number.parseInt(c, 10);
    return { expr: { type: "ArithSingleQuote", content: c, value: Number.isNaN(u) ? 0 : u }, pos: s2 };
  }
  if (t2[s2] === '"') {
    s2++;
    let c = "";
    for (; s2 < t2.length && t2[s2] !== '"'; ) t2[s2] === "\\" && s2 + 1 < t2.length ? (c += t2[s2 + 1], s2 += 2) : (c += t2[s2], s2++);
    t2[s2] === '"' && s2++;
    let u = c.trim();
    if (!u) return { expr: { type: "ArithNumber", value: 0 }, pos: s2 };
    let { expr: f2 } = Et(e2, u, 0);
    return { expr: f2, pos: s2 };
  }
  if (/[0-9]/.test(t2[s2])) {
    let c = "", u = false, f2 = false;
    for (; s2 < t2.length; ) {
      let d = t2[s2];
      if (u) if (/[0-9a-zA-Z@_]/.test(d)) c += d, s2++;
      else break;
      else if (d === "#") u = true, c += d, s2++;
      else if (c === "0" && (d === "x" || d === "X") && s2 + 1 < t2.length && /[0-9a-fA-F]/.test(t2[s2 + 1])) f2 = true, c += d, s2++;
      else if (f2 && /[0-9a-fA-F]/.test(d)) c += d, s2++;
      else if (!f2 && /[0-9]/.test(d)) c += d, s2++;
      else break;
    }
    if (s2 < t2.length && /[a-zA-Z_]/.test(t2[s2])) {
      let d = c;
      for (; s2 < t2.length && /[a-zA-Z0-9_]/.test(t2[s2]); ) d += t2[s2], s2++;
      return { expr: { type: "ArithSyntaxError", errorToken: d, message: `${d}: value too great for base (error token is "${d}")` }, pos: s2 };
    }
    if (t2[s2] === "." && /[0-9]/.test(t2[s2 + 1])) throw new Ee(`${c}.${t2[s2 + 1]}...: syntax error: invalid arithmetic operator`);
    if (t2[s2] === "[") {
      let d = t2.slice(s2).trim();
      return { expr: { type: "ArithNumberSubscript", number: c, errorToken: d }, pos: t2.length };
    }
    return { expr: { type: "ArithNumber", value: Fr(c) }, pos: s2 };
  }
  if (t2[s2] === "$" && t2[s2 + 1] === "{") {
    let c = s2 + 2, u = 1, f2 = c;
    for (; f2 < t2.length && u > 0; ) t2[f2] === "{" ? u++ : t2[f2] === "}" && u--, u > 0 && f2++;
    let p = t2.slice(c, f2), d = f2 + 1;
    if (t2[d] === "#") {
      let m = d + 1;
      for (; m < t2.length && /[0-9a-zA-Z@_]/.test(t2[m]); ) m++;
      let h = t2.slice(d + 1, m);
      return { expr: { type: "ArithDynamicBase", baseExpr: p, value: h }, pos: m };
    }
    if (/[0-9]/.test(t2[d]) || t2[d] === "x" || t2[d] === "X") {
      let m = d;
      if (t2[d] === "x" || t2[d] === "X") for (m++; m < t2.length && /[0-9a-fA-F]/.test(t2[m]); ) m++;
      else for (; m < t2.length && /[0-9]/.test(t2[m]); ) m++;
      let h = t2.slice(d, m);
      return { expr: { type: "ArithDynamicNumber", prefix: p, suffix: h }, pos: m };
    }
    return s2 = d, { expr: { type: "ArithBracedExpansion", content: p }, pos: s2 };
  }
  if (t2[s2] === "$" && s2 + 1 < t2.length && /[0-9]/.test(t2[s2 + 1])) {
    s2++;
    let c = "";
    for (; s2 < t2.length && /[0-9]/.test(t2[s2]); ) c += t2[s2], s2++;
    return { expr: { type: "ArithVariable", name: c, hasDollarPrefix: true }, pos: s2 };
  }
  if (t2[s2] === "$" && s2 + 1 < t2.length && /[*@#?\-!$]/.test(t2[s2 + 1])) {
    let c = t2[s2 + 1];
    return s2 += 2, { expr: { type: "ArithSpecialVar", name: c }, pos: s2 };
  }
  let l = false;
  if (t2[s2] === "$" && s2 + 1 < t2.length && /[a-zA-Z_]/.test(t2[s2 + 1]) && (l = true, s2++), s2 < t2.length && /[a-zA-Z_]/.test(t2[s2])) {
    let c = "";
    for (; s2 < t2.length && /[a-zA-Z0-9_]/.test(t2[s2]); ) c += t2[s2], s2++;
    if (t2[s2] === "[" && !r2) {
      s2++;
      let u;
      if (t2[s2] === "'" || t2[s2] === '"') {
        let p = t2[s2];
        for (s2++, u = ""; s2 < t2.length && t2[s2] !== p; ) u += t2[s2], s2++;
        t2[s2] === p && s2++, s2 = ve(t2, s2), t2[s2] === "]" && s2++;
      }
      let f2;
      if (u === void 0) {
        let { expr: p, pos: d } = Et(e2, t2, s2);
        f2 = p, s2 = d, t2[s2] === "]" && s2++;
      }
      if (s2 = ve(t2, s2), t2[s2] === "[" && f2) return { expr: { type: "ArithDoubleSubscript", array: c, index: f2 }, pos: s2 };
      if (!r2) {
        for (let p of Qs) if (t2.slice(s2, s2 + p.length) === p && t2.slice(s2, s2 + p.length + 1) !== "==") {
          s2 += p.length;
          let { expr: d, pos: m } = _r(e2, t2, s2);
          return { expr: { type: "ArithAssignment", operator: p, variable: c, subscript: f2, stringKey: u, value: d }, pos: m };
        }
      }
      return { expr: { type: "ArithArrayElement", array: c, index: f2, stringKey: u }, pos: s2 };
    }
    if (s2 = ve(t2, s2), !r2) {
      for (let u of Qs) if (t2.slice(s2, s2 + u.length) === u && t2.slice(s2, s2 + u.length + 1) !== "==") {
        s2 += u.length;
        let { expr: f2, pos: p } = _r(e2, t2, s2);
        return { expr: { type: "ArithAssignment", operator: u, variable: c, value: f2 }, pos: p };
      }
    }
    return { expr: { type: "ArithVariable", name: c, hasDollarPrefix: l }, pos: s2 };
  }
  if (t2[s2] === "#") {
    let c = s2 + 1;
    for (; c < t2.length && t2[c] !== `
`; ) c++;
    let u = t2.slice(s2, c).trim() || "#";
    return { expr: { type: "ArithSyntaxError", errorToken: u, message: `${u}: syntax error: invalid arithmetic operator (error token is "${u}")` }, pos: t2.length };
  }
  return { expr: { type: "ArithNumber", value: 0 }, pos: s2 };
}
var Je = v(() => {
  de();
  ym();
});
function dC(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) {
    let r2 = e2[n2];
    if (r2 < 128) {
      t2 += String.fromCharCode(r2), n2++;
      continue;
    }
    if ((r2 & 224) === 192) {
      if (n2 + 1 < e2.length && (e2[n2 + 1] & 192) === 128 && r2 >= 194) {
        let s2 = (r2 & 31) << 6 | e2[n2 + 1] & 63;
        t2 += String.fromCharCode(s2), n2 += 2;
        continue;
      }
      t2 += String.fromCharCode(r2), n2++;
      continue;
    }
    if ((r2 & 240) === 224) {
      if (n2 + 2 < e2.length && (e2[n2 + 1] & 192) === 128 && (e2[n2 + 2] & 192) === 128) {
        if (r2 === 224 && e2[n2 + 1] < 160) {
          t2 += String.fromCharCode(r2), n2++;
          continue;
        }
        let s2 = (r2 & 15) << 12 | (e2[n2 + 1] & 63) << 6 | e2[n2 + 2] & 63;
        if (s2 >= 55296 && s2 <= 57343) {
          t2 += String.fromCharCode(r2), n2++;
          continue;
        }
        t2 += String.fromCharCode(s2), n2 += 3;
        continue;
      }
      t2 += String.fromCharCode(r2), n2++;
      continue;
    }
    if ((r2 & 248) === 240 && r2 <= 244) {
      if (n2 + 3 < e2.length && (e2[n2 + 1] & 192) === 128 && (e2[n2 + 2] & 192) === 128 && (e2[n2 + 3] & 192) === 128) {
        if (r2 === 240 && e2[n2 + 1] < 144) {
          t2 += String.fromCharCode(r2), n2++;
          continue;
        }
        let s2 = (r2 & 7) << 18 | (e2[n2 + 1] & 63) << 12 | (e2[n2 + 2] & 63) << 6 | e2[n2 + 3] & 63;
        if (s2 > 1114111) {
          t2 += String.fromCharCode(r2), n2++;
          continue;
        }
        t2 += String.fromCodePoint(s2), n2 += 4;
        continue;
      }
      t2 += String.fromCharCode(r2), n2++;
      continue;
    }
    t2 += String.fromCharCode(r2), n2++;
  }
  return t2;
}
function Im(e2, t2, n2) {
  let r2 = n2 + 1;
  for (; r2 < t2.length && /[a-zA-Z0-9_-]/.test(t2[r2]); ) r2++;
  return r2;
}
function ya(e2, t2, n2, r2, s2) {
  let i2 = 1, o2 = n2 + 1;
  for (; o2 < t2.length && i2 > 0; ) t2[o2] === r2 ? i2++ : t2[o2] === s2 && i2--, i2 > 0 && o2++;
  return i2 === 0 ? o2 : -1;
}
function Nn(e2, t2, n2) {
  let r2 = n2, s2 = 1;
  for (; r2 < t2.length && s2 > 0; ) {
    let i2 = t2[r2];
    if (i2 === "\\" && r2 + 1 < t2.length) {
      r2 += 2;
      continue;
    }
    if (i2 === "'") {
      let o2 = t2.indexOf("'", r2 + 1);
      if (o2 !== -1) {
        r2 = o2 + 1;
        continue;
      }
    }
    if (i2 === '"') {
      for (r2++; r2 < t2.length && t2[r2] !== '"'; ) t2[r2] === "\\" && r2 + 1 < t2.length ? r2 += 2 : r2++;
      r2 < t2.length && r2++;
      continue;
    }
    i2 === "{" ? s2++ : i2 === "}" && s2--, s2 > 0 && r2++;
  }
  return r2;
}
function Rm(e2, t2, n2) {
  let r2 = n2, s2 = false;
  for (; r2 < t2.length; ) {
    let i2 = t2[r2];
    if (i2 === "/" && s2 || i2 === "}") break;
    if (i2 === "'") {
      let o2 = t2.indexOf("'", r2 + 1);
      if (o2 !== -1) {
        r2 = o2 + 1, s2 = true;
        continue;
      }
    }
    if (i2 === '"') {
      for (r2++; r2 < t2.length && t2[r2] !== '"'; ) t2[r2] === "\\" && r2 + 1 < t2.length ? r2 += 2 : r2++;
      r2 < t2.length && r2++, s2 = true;
      continue;
    }
    i2 === "\\" ? (r2 += 2, s2 = true) : (r2++, s2 = true);
  }
  return r2;
}
function Pm(e2, t2, n2) {
  let r2 = n2, s2 = "";
  for (; r2 < t2.length; ) {
    let i2 = t2[r2];
    if (i2 === "*" || i2 === "?") s2 += i2, r2++;
    else if (i2 === "[") {
      let o2 = hC(t2, r2);
      o2 === -1 ? (s2 += i2, r2++) : (s2 += t2.slice(r2, o2 + 1), r2 = o2 + 1);
    } else break;
  }
  return { pattern: s2, endIndex: r2 };
}
function hC(e2, t2) {
  let n2 = t2 + 1;
  for (n2 < e2.length && e2[n2] === "^" && n2++, n2 < e2.length && e2[n2] === "]" && n2++; n2 < e2.length; ) {
    let r2 = e2[n2];
    if (r2 === "\\" && n2 + 1 < e2.length) {
      let s2 = e2[n2 + 1];
      if (s2 === '"' || s2 === "'") return -1;
      n2 += 2;
      continue;
    }
    if (r2 === "]") return n2;
    if (r2 === '"' || r2 === "$" || r2 === "`") return -1;
    if (r2 === "'") {
      let s2 = e2.indexOf("'", n2 + 1);
      if (s2 !== -1) {
        n2 = s2 + 1;
        continue;
      }
    }
    if (r2 === "[" && n2 + 1 < e2.length && e2[n2 + 1] === ":") {
      let s2 = e2.indexOf(":]", n2 + 2);
      if (s2 !== -1) {
        n2 = s2 + 2;
        continue;
      }
    }
    if (r2 === "[" && n2 + 1 < e2.length && (e2[n2 + 1] === "." || e2[n2 + 1] === "=")) {
      let i2 = `${e2[n2 + 1]}]`, o2 = e2.indexOf(i2, n2 + 2);
      if (o2 !== -1) {
        n2 = o2 + 2;
        continue;
      }
    }
    n2++;
  }
  return -1;
}
function Tm(e2, t2, n2) {
  let r2 = "", s2 = n2;
  for (; s2 < t2.length && t2[s2] !== "'"; ) {
    let i2 = t2[s2];
    if (i2 === "\\" && s2 + 1 < t2.length) switch (t2[s2 + 1]) {
      case "n":
        r2 += `
`, s2 += 2;
        break;
      case "t":
        r2 += "	", s2 += 2;
        break;
      case "r":
        r2 += "\r", s2 += 2;
        break;
      case "\\":
        r2 += "\\", s2 += 2;
        break;
      case "'":
        r2 += "'", s2 += 2;
        break;
      case '"':
        r2 += '"', s2 += 2;
        break;
      case "a":
        r2 += "\x07", s2 += 2;
        break;
      case "b":
        r2 += "\b", s2 += 2;
        break;
      case "e":
      case "E":
        r2 += "\x1B", s2 += 2;
        break;
      case "f":
        r2 += "\f", s2 += 2;
        break;
      case "v":
        r2 += "\v", s2 += 2;
        break;
      case "x": {
        let a = [], l = s2;
        for (; l + 1 < t2.length && t2[l] === "\\" && t2[l + 1] === "x"; ) {
          let c = t2.slice(l + 2, l + 4), u = parseInt(c, 16);
          if (!Number.isNaN(u) && c.length > 0) a.push(u), l += 2 + c.length;
          else break;
        }
        a.length > 0 ? (r2 += dC(a), s2 = l) : (r2 += "\\x", s2 += 2);
        break;
      }
      case "u": {
        let a = t2.slice(s2 + 2, s2 + 6), l = parseInt(a, 16);
        Number.isNaN(l) ? (r2 += "\\u", s2 += 2) : (r2 += String.fromCharCode(l), s2 += 6);
        break;
      }
      case "c": {
        if (s2 + 2 < t2.length) {
          let l = t2[s2 + 2].charCodeAt(0) & 31;
          r2 += String.fromCharCode(l), s2 += 3;
        } else r2 += "\\c", s2 += 2;
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7": {
        let a = "", l = s2 + 1;
        for (; l < t2.length && l < s2 + 4 && /[0-7]/.test(t2[l]); ) a += t2[l], l++;
        let c = parseInt(a, 8);
        r2 += String.fromCharCode(c), s2 = l;
        break;
      }
      default:
        r2 += i2, s2++;
    }
    else r2 += i2, s2++;
  }
  return s2 < t2.length && t2[s2] === "'" && s2++, { part: j.literal(r2), endIndex: s2 };
}
function ba(e2, t2) {
  let n2 = t2.trim();
  return n2 === "" ? { type: "ArithmeticExpression", expression: { type: "ArithNumber", value: 0 } } : he(e2, n2);
}
function $m(e2) {
  let t2 = [], n2 = "", r2 = 0;
  for (let s2 = 0; s2 < e2.length; s2++) {
    let i2 = e2[s2];
    i2 === "{" ? (r2++, n2 += i2) : i2 === "}" ? (r2--, n2 += i2) : i2 === "," && r2 === 0 ? (t2.push(n2), n2 = "") : n2 += i2;
  }
  return t2.push(n2), t2;
}
function Om(e2, t2, n2, r2) {
  let s2 = ya(e2, t2, n2, "{", "}");
  if (s2 === -1) return null;
  let i2 = t2.slice(n2 + 1, s2), o2 = i2.match(/^(-?\d+)\.\.(-?\d+)(?:\.\.(-?\d+))?$/);
  if (o2) return { part: { type: "BraceExpansion", items: [{ type: "Range", start: Number.parseInt(o2[1], 10), end: Number.parseInt(o2[2], 10), step: o2[3] ? Number.parseInt(o2[3], 10) : void 0, startStr: o2[1], endStr: o2[2] }] }, endIndex: s2 + 1 };
  let a = i2.match(/^([a-zA-Z])\.\.([a-zA-Z])(?:\.\.(-?\d+))?$/);
  return a ? { part: { type: "BraceExpansion", items: [{ type: "Range", start: a[1], end: a[2], step: a[3] ? Number.parseInt(a[3], 10) : void 0 }] }, endIndex: s2 + 1 } : i2.includes(",") && r2 ? { part: { type: "BraceExpansion", items: $m(i2).map((u) => ({ type: "Word", word: j.word(r2(e2, u, false, false, false)) })) }, endIndex: s2 + 1 } : i2.includes(",") ? { part: { type: "BraceExpansion", items: $m(i2).map((u) => ({ type: "Word", word: j.word([j.literal(u)]) })) }, endIndex: s2 + 1 } : null;
}
function wa(e2, t2) {
  let n2 = "";
  for (let r2 of t2.parts) switch (r2.type) {
    case "Literal":
      n2 += r2.value;
      break;
    case "SingleQuoted":
      n2 += `'${r2.value}'`;
      break;
    case "Escaped":
      n2 += r2.value;
      break;
    case "DoubleQuoted":
      n2 += '"';
      for (let s2 of r2.parts) s2.type === "Literal" || s2.type === "Escaped" ? n2 += s2.value : s2.type === "ParameterExpansion" && (n2 += `\${${s2.parameter}}`);
      n2 += '"';
      break;
    case "ParameterExpansion":
      n2 += `\${${r2.parameter}}`;
      break;
    case "Glob":
      n2 += r2.pattern;
      break;
    case "TildeExpansion":
      n2 += "~", r2.user && (n2 += r2.user);
      break;
    case "BraceExpansion": {
      n2 += "{";
      let s2 = [];
      for (let i2 of r2.items) if (i2.type === "Range") {
        let o2 = i2.startStr ?? String(i2.start), a = i2.endStr ?? String(i2.end);
        i2.step !== void 0 ? s2.push(`${o2}..${a}..${i2.step}`) : s2.push(`${o2}..${a}`);
      } else s2.push(wa(e2, i2.word));
      s2.length === 1 && r2.items[0].type === "Range" ? n2 += s2[0] : n2 += s2.join(","), n2 += "}";
      break;
    }
    default:
      n2 += r2.type;
  }
  return n2;
}
function Dm(e2, t2) {
  return { [x.LESS]: "<", [x.GREAT]: ">", [x.DGREAT]: ">>", [x.LESSAND]: "<&", [x.GREATAND]: ">&", [x.LESSGREAT]: "<>", [x.CLOBBER]: ">|", [x.TLESS]: "<<<", [x.AND_GREAT]: "&>", [x.AND_DGREAT]: "&>>", [x.DLESS]: "<", [x.DLESSDASH]: "<" }[t2] || ">";
}
var xa = v(() => {
  Cn();
  Je();
  tn();
});
function Xs(e2) {
  let t2 = e2.current(), n2 = t2.type;
  if (n2 === x.NUMBER) {
    let r2 = e2.peek(1);
    return t2.end !== r2.start ? false : pm.has(r2.type);
  }
  if (n2 === x.FD_VARIABLE) {
    let r2 = e2.peek(1);
    return dm.has(r2.type);
  }
  return fm.has(n2);
}
function Js(e2) {
  let t2 = null, n2;
  e2.check(x.NUMBER) ? t2 = Number.parseInt(e2.advance().value, 10) : e2.check(x.FD_VARIABLE) && (n2 = e2.advance().value);
  let r2 = e2.advance(), s2 = Dm(e2, r2.type);
  if (r2.type === x.DLESS || r2.type === x.DLESSDASH) return mC(e2, s2, t2, r2.type === x.DLESSDASH);
  e2.isWord() || e2.error("Expected redirection target");
  let i2 = e2.parseWord();
  return j.redirection(s2, i2, t2, n2);
}
function mC(e2, t2, n2, r2) {
  e2.isWord() || e2.error("Expected here-document delimiter");
  let s2 = e2.advance(), i2 = s2.value, o2 = s2.quoted || false;
  (i2.startsWith("'") && i2.endsWith("'") || i2.startsWith('"') && i2.endsWith('"')) && (i2 = i2.slice(1, -1));
  let a = j.redirection(r2 ? "<<-" : "<<", j.hereDoc(i2, j.word([]), r2, o2), n2);
  return e2.addPendingHeredoc(a, i2, r2, o2), a;
}
function _m(e2) {
  let t2 = e2.current().line, n2 = [], r2 = null, s2 = [], i2 = [];
  for (; e2.check(x.ASSIGNMENT_WORD) || Xs(e2); ) e2.checkIterationLimit(), e2.check(x.ASSIGNMENT_WORD) ? n2.push(gC(e2)) : i2.push(Js(e2));
  if (e2.isWord()) r2 = e2.parseWord();
  else if (n2.length > 0 && (e2.check(x.DBRACK_START) || e2.check(x.DPAREN_START))) {
    let a = e2.advance();
    r2 = j.word([j.literal(a.value)]);
  }
  for (; (!e2.isStatementEnd() || e2.check(x.RBRACE)) && !e2.check(x.PIPE, x.PIPE_AMP); ) if (e2.checkIterationLimit(), Xs(e2)) i2.push(Js(e2));
  else if (e2.check(x.RBRACE)) {
    let a = e2.advance();
    s2.push(e2.parseWordFromString(a.value, false, false));
  } else if (e2.check(x.LBRACE)) {
    let a = e2.advance();
    s2.push(e2.parseWordFromString(a.value, false, false));
  } else if (e2.check(x.DBRACK_END)) {
    let a = e2.advance();
    s2.push(e2.parseWordFromString(a.value, false, false));
  } else if (e2.isWord()) s2.push(e2.parseWord());
  else if (e2.check(x.ASSIGNMENT_WORD)) {
    let a = e2.advance(), l = a.value, c = l.endsWith("="), u = l.endsWith("=(");
    if ((c || u) && (u || e2.check(x.LPAREN))) {
      let f2 = u ? l.slice(0, -2) : l.slice(0, -1);
      u || e2.expect(x.LPAREN);
      let p = Ea(e2);
      e2.expect(x.RPAREN);
      let d = p.map((h) => wa(e2, h)), m = `${f2}=(${d.join(" ")})`;
      s2.push(e2.parseWordFromString(m, false, false));
    } else s2.push(e2.parseWordFromString(l, a.quoted, a.singleQuoted));
  } else if (e2.check(x.LPAREN)) e2.error("syntax error near unexpected token `('");
  else break;
  let o2 = j.simpleCommand(r2, s2, n2, i2);
  return o2.line = t2, o2;
}
function gC(e2) {
  let t2 = e2.expect(x.ASSIGNMENT_WORD), n2 = t2.value, r2 = n2.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  r2 || e2.error(`Invalid assignment: ${n2}`);
  let s2 = r2[0], i2, o2 = s2.length;
  if (n2[o2] === "[") {
    let f2 = 0, p = o2 + 1;
    for (; o2 < n2.length; o2++) if (n2[o2] === "[") f2++;
    else if (n2[o2] === "]" && (f2--, f2 === 0)) break;
    f2 !== 0 && e2.error(`Invalid assignment: ${n2}`), i2 = n2.slice(p, o2), o2++;
  }
  let a = n2[o2] === "+";
  a && o2++, n2[o2] !== "=" && e2.error(`Invalid assignment: ${n2}`), o2++;
  let l = n2.slice(o2);
  if (l === "(") {
    let f2 = Ea(e2);
    e2.expect(x.RPAREN);
    let p = i2 !== void 0 ? `${s2}[${i2}]` : s2;
    return j.assignment(p, null, a, f2);
  }
  if (l === "" && e2.check(x.LPAREN)) {
    let f2 = e2.current();
    if (t2.end === f2.start) {
      e2.advance();
      let p = Ea(e2);
      e2.expect(x.RPAREN);
      let d = i2 !== void 0 ? `${s2}[${i2}]` : s2;
      return j.assignment(d, null, a, p);
    }
  }
  let c = l ? e2.parseWordFromString(l, t2.quoted, t2.singleQuoted, true) : null, u = i2 !== void 0 ? `${s2}[${i2}]` : s2;
  return j.assignment(u, c, a, null);
}
function Ea(e2) {
  let t2 = [];
  for (e2.skipNewlines(); !e2.check(x.RPAREN, x.EOF); ) e2.checkIterationLimit(), e2.isWord() ? t2.push(e2.parseWord()) : yC.has(e2.current().type) ? e2.error(`syntax error near unexpected token \`${e2.current().value}'`) : e2.advance(), e2.skipNewlines();
  return t2;
}
var yC, Lm = v(() => {
  Cn();
  tn();
  An();
  xa();
  yC = /* @__PURE__ */ new Set([x.AMP, x.PIPE, x.PIPE_AMP, x.SEMICOLON, x.AND_AND, x.OR_OR, x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND]);
});
function Sa(e2, t2) {
  e2.expect(x.IF);
  let n2 = [], r2 = e2.parseCompoundList();
  e2.expect(x.THEN);
  let s2 = e2.parseCompoundList();
  if (s2.length === 0) {
    let a = e2.check(x.FI) ? "fi" : e2.check(x.ELSE) ? "else" : e2.check(x.ELIF) ? "elif" : "fi";
    e2.error(`syntax error near unexpected token \`${a}'`);
  }
  for (n2.push({ condition: r2, body: s2 }); e2.check(x.ELIF); ) {
    e2.advance();
    let a = e2.parseCompoundList();
    e2.expect(x.THEN);
    let l = e2.parseCompoundList();
    if (l.length === 0) {
      let c = e2.check(x.FI) ? "fi" : e2.check(x.ELSE) ? "else" : e2.check(x.ELIF) ? "elif" : "fi";
      e2.error(`syntax error near unexpected token \`${c}'`);
    }
    n2.push({ condition: a, body: l });
  }
  let i2 = null;
  e2.check(x.ELSE) && (e2.advance(), i2 = e2.parseCompoundList(), i2.length === 0 && e2.error("syntax error near unexpected token `fi'")), e2.expect(x.FI);
  let o2 = (t2 == null ? void 0 : t2.skipRedirections) ? [] : e2.parseOptionalRedirections();
  return j.ifNode(n2, i2, o2);
}
function Aa(e2, t2) {
  let n2 = e2.expect(x.FOR);
  if (e2.check(x.DPAREN_START)) return wC(e2, t2, n2.line);
  e2.isWord() || e2.error("Expected variable name in for loop");
  let s2 = e2.advance().value, i2 = null;
  if (e2.skipNewlines(), e2.check(x.IN)) for (e2.advance(), i2 = []; !e2.check(x.SEMICOLON, x.NEWLINE, x.DO, x.EOF) && e2.isWord(); ) i2.push(e2.parseWord());
  e2.check(x.SEMICOLON) && e2.advance(), e2.skipNewlines(), e2.expect(x.DO);
  let o2 = e2.parseCompoundList();
  e2.expect(x.DONE);
  let a = (t2 == null ? void 0 : t2.skipRedirections) ? [] : e2.parseOptionalRedirections();
  return j.forNode(s2, i2, o2, a);
}
function wC(e2, t2, n2) {
  e2.expect(x.DPAREN_START);
  let r2 = null, s2 = null, i2 = null, o2 = ["", "", ""], a = 0, l = 0;
  for (; !e2.check(x.DPAREN_END, x.EOF); ) {
    let f2 = e2.advance();
    if (f2.type === x.SEMICOLON && l === 0) {
      if (a++, a > 2) break;
    } else f2.value === "(" && l++, f2.value === ")" && l--, o2[a] += f2.value;
  }
  e2.expect(x.DPAREN_END), o2[0].trim() && (r2 = he(e2, o2[0].trim())), o2[1].trim() && (s2 = he(e2, o2[1].trim())), o2[2].trim() && (i2 = he(e2, o2[2].trim())), e2.skipNewlines(), e2.check(x.SEMICOLON) && e2.advance(), e2.skipNewlines();
  let c;
  e2.check(x.LBRACE) ? (e2.advance(), c = e2.parseCompoundList(), e2.expect(x.RBRACE)) : (e2.expect(x.DO), c = e2.parseCompoundList(), e2.expect(x.DONE));
  let u = (t2 == null ? void 0 : t2.skipRedirections) ? [] : e2.parseOptionalRedirections();
  return { type: "CStyleFor", init: r2, condition: s2, update: i2, body: c, redirections: u, line: n2 };
}
function Ca(e2, t2) {
  e2.expect(x.WHILE);
  let n2 = e2.parseCompoundList();
  e2.expect(x.DO);
  let r2 = e2.parseCompoundList();
  r2.length === 0 && e2.error("syntax error near unexpected token `done'"), e2.expect(x.DONE);
  let s2 = (t2 == null ? void 0 : t2.skipRedirections) ? [] : e2.parseOptionalRedirections();
  return j.whileNode(n2, r2, s2);
}
function Na(e2, t2) {
  e2.expect(x.UNTIL);
  let n2 = e2.parseCompoundList();
  e2.expect(x.DO);
  let r2 = e2.parseCompoundList();
  r2.length === 0 && e2.error("syntax error near unexpected token `done'"), e2.expect(x.DONE);
  let s2 = (t2 == null ? void 0 : t2.skipRedirections) ? [] : e2.parseOptionalRedirections();
  return j.untilNode(n2, r2, s2);
}
function ka(e2, t2) {
  e2.expect(x.CASE), e2.isWord() || e2.error("Expected word after 'case'");
  let n2 = e2.parseWord();
  e2.skipNewlines(), e2.expect(x.IN), e2.skipNewlines();
  let r2 = [];
  for (; !e2.check(x.ESAC, x.EOF); ) {
    e2.checkIterationLimit();
    let i2 = e2.getPos(), o2 = xC(e2);
    if (o2 && r2.push(o2), e2.skipNewlines(), e2.getPos() === i2 && !o2) break;
  }
  e2.expect(x.ESAC);
  let s2 = (t2 == null ? void 0 : t2.skipRedirections) ? [] : e2.parseOptionalRedirections();
  return j.caseNode(n2, r2, s2);
}
function xC(e2) {
  e2.check(x.LPAREN) && e2.advance();
  let t2 = [];
  for (; e2.isWord() && (t2.push(e2.parseWord()), e2.check(x.PIPE)); ) e2.advance();
  if (t2.length === 0) return null;
  e2.expect(x.RPAREN), e2.skipNewlines();
  let n2 = [];
  for (; !e2.check(x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND, x.ESAC, x.EOF); ) {
    e2.checkIterationLimit(), e2.isWord() && e2.peek(1).type === x.RPAREN && e2.error("syntax error near unexpected token `)'"), e2.check(x.LPAREN) && e2.peek(1).type === x.WORD && e2.error(`syntax error near unexpected token \`${e2.peek(1).value}'`);
    let s2 = e2.getPos(), i2 = e2.parseStatement();
    if (i2 && n2.push(i2), e2.skipSeparators(false), e2.getPos() === s2 && !i2) break;
  }
  let r2 = ";;";
  return e2.check(x.DSEMI) ? (e2.advance(), r2 = ";;") : e2.check(x.SEMI_AND) ? (e2.advance(), r2 = ";&") : e2.check(x.SEMI_SEMI_AND) && (e2.advance(), r2 = ";;&"), j.caseItem(t2, n2, r2);
}
function va(e2, t2) {
  e2.expect(x.LPAREN);
  let n2 = e2.parseCompoundList();
  e2.expect(x.RPAREN);
  let r2 = (t2 == null ? void 0 : t2.skipRedirections) ? [] : e2.parseOptionalRedirections();
  return j.subshell(n2, r2);
}
function $a(e2, t2) {
  e2.expect(x.LBRACE);
  let n2 = e2.parseCompoundList();
  e2.expect(x.RBRACE);
  let r2 = (t2 == null ? void 0 : t2.skipRedirections) ? [] : e2.parseOptionalRedirections();
  return j.group(n2, r2);
}
var Mm = v(() => {
  Cn();
  Je();
  tn();
});
function Wm(e2) {
  return e2.isWord() || e2.check(x.LBRACE) || e2.check(x.RBRACE) || e2.check(x.ASSIGNMENT_WORD);
}
function Bm(e2) {
  if (e2.check(x.BANG) && e2.peek(1).type === x.LPAREN) {
    e2.advance(), e2.advance();
    let t2 = 1, n2 = "!(";
    for (; t2 > 0 && !e2.check(x.EOF); ) if (e2.check(x.LPAREN)) t2++, n2 += "(", e2.advance();
    else if (e2.check(x.RPAREN)) t2--, t2 > 0 && (n2 += ")"), e2.advance();
    else if (e2.isWord()) n2 += e2.advance().value;
    else if (e2.check(x.PIPE)) n2 += "|", e2.advance();
    else break;
    return n2 += ")", e2.parseWordFromString(n2, false, false, false, false, true);
  }
  return e2.parseWordNoBraceExpansion();
}
function Ra(e2) {
  return e2.skipNewlines(), CC(e2);
}
function CC(e2) {
  let t2 = Um(e2);
  for (e2.skipNewlines(); e2.check(x.OR_OR); ) {
    e2.advance(), e2.skipNewlines();
    let n2 = Um(e2);
    t2 = { type: "CondOr", left: t2, right: n2 }, e2.skipNewlines();
  }
  return t2;
}
function Um(e2) {
  let t2 = Ia(e2);
  for (e2.skipNewlines(); e2.check(x.AND_AND); ) {
    e2.advance(), e2.skipNewlines();
    let n2 = Ia(e2);
    t2 = { type: "CondAnd", left: t2, right: n2 }, e2.skipNewlines();
  }
  return t2;
}
function Ia(e2) {
  return e2.skipNewlines(), e2.check(x.BANG) ? (e2.advance(), e2.skipNewlines(), { type: "CondNot", operand: Ia(e2) }) : NC(e2);
}
function NC(e2) {
  if (e2.check(x.LPAREN)) {
    e2.advance();
    let t2 = Ra(e2);
    return e2.expect(x.RPAREN), { type: "CondGroup", expression: t2 };
  }
  if (Wm(e2)) {
    let t2 = e2.current(), n2 = t2.value;
    if (SC.includes(n2) && !t2.quoted) {
      if (e2.advance(), e2.check(x.DBRACK_END) && e2.error(`Expected operand after ${n2}`), Wm(e2)) {
        let i2 = e2.parseWordNoBraceExpansion();
        return { type: "CondUnary", operator: n2, operand: i2 };
      }
      let s2 = e2.current();
      e2.error(`unexpected argument \`${s2.value}' to conditional unary operator`);
    }
    let r2 = e2.parseWordNoBraceExpansion();
    if (e2.isWord() && AC.includes(e2.current().value)) {
      let s2 = e2.advance().value, i2;
      return s2 === "=~" ? i2 = kC(e2) : s2 === "==" || s2 === "!=" ? i2 = Bm(e2) : i2 = e2.parseWordNoBraceExpansion(), { type: "CondBinary", operator: s2, left: r2, right: i2 };
    }
    if (e2.check(x.LESS)) {
      e2.advance();
      let s2 = e2.parseWordNoBraceExpansion();
      return { type: "CondBinary", operator: "<", left: r2, right: s2 };
    }
    if (e2.check(x.GREAT)) {
      e2.advance();
      let s2 = e2.parseWordNoBraceExpansion();
      return { type: "CondBinary", operator: ">", left: r2, right: s2 };
    }
    if (e2.isWord() && e2.current().value === "=") {
      e2.advance();
      let s2 = Bm(e2);
      return { type: "CondBinary", operator: "==", left: r2, right: s2 };
    }
    return { type: "CondWord", word: r2 };
  }
  e2.error("Expected conditional expression");
}
function kC(e2) {
  let t2 = [], n2 = 0, r2 = -1, s2 = e2.getInput(), i2 = () => e2.check(x.DBRACK_END) || e2.check(x.AND_AND) || e2.check(x.OR_OR) || e2.check(x.NEWLINE) || e2.check(x.EOF);
  for (; !i2(); ) {
    let o2 = e2.current(), a = r2 >= 0 && o2.start > r2;
    if (n2 === 0 && a) break;
    if (n2 > 0 && a) {
      let l = s2.slice(r2, o2.start);
      t2.push({ type: "Literal", value: l });
    }
    if (e2.isWord() || e2.check(x.ASSIGNMENT_WORD)) {
      let l = e2.parseWordForRegex();
      t2.push(...l.parts), r2 = e2.peek(-1).end;
    } else if (e2.check(x.LPAREN)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "(" }), n2++, r2 = l.end;
    } else if (e2.check(x.DPAREN_START)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "((" }), n2 += 2, r2 = l.end;
    } else if (e2.check(x.DPAREN_END)) if (n2 >= 2) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "))" }), n2 -= 2, r2 = l.end;
    } else {
      if (n2 === 1) break;
      break;
    }
    else if (e2.check(x.RPAREN)) if (n2 > 0) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: ")" }), n2--, r2 = l.end;
    } else break;
    else if (e2.check(x.PIPE)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "|" }), r2 = l.end;
    } else if (e2.check(x.SEMICOLON)) if (n2 > 0) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: ";" }), r2 = l.end;
    } else break;
    else if (n2 > 0 && e2.check(x.LESS)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "<" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.GREAT)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: ">" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.DGREAT)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: ">>" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.DLESS)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "<<" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.LESSAND)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "<&" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.GREATAND)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: ">&" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.LESSGREAT)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "<>" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.CLOBBER)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: ">|" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.TLESS)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "<<<" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.AMP)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "&" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.LBRACE)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "{" }), r2 = l.end;
    } else if (n2 > 0 && e2.check(x.RBRACE)) {
      let l = e2.advance();
      t2.push({ type: "Literal", value: "}" }), r2 = l.end;
    } else break;
  }
  return t2.length === 0 && e2.error("Expected regex pattern after =~"), { type: "Word", parts: t2 };
}
var SC, AC, zm = v(() => {
  tn();
  SC = ["-a", "-b", "-c", "-d", "-e", "-f", "-g", "-h", "-k", "-p", "-r", "-s", "-t", "-u", "-w", "-x", "-G", "-L", "-N", "-O", "-S", "-z", "-n", "-o", "-v", "-R"], AC = ["==", "!=", "=~", "<", ">", "-eq", "-ne", "-lt", "-le", "-gt", "-ge", "-nt", "-ot", "-ef"];
});
function $C(e2, t2) {
  let n2 = 1, r2 = t2 + 1;
  for (; r2 < e2.length && n2 > 0; ) {
    let s2 = e2[r2];
    if (s2 === "\\") {
      r2 += 2;
      continue;
    }
    if ("@*+?!".includes(s2) && r2 + 1 < e2.length && e2[r2 + 1] === "(") {
      r2++, n2++, r2++;
      continue;
    }
    if (s2 === "(") n2++;
    else if (s2 === ")" && (n2--, n2 === 0)) return r2;
    r2++;
  }
  return -1;
}
function IC(e2, t2, n2) {
  let r2 = n2 + 1, s2 = t2[r2];
  if ("@*#?$!-0123456789".includes(s2)) return { part: j.parameterExpansion(s2), endIndex: r2 + 1 };
  let i2 = "";
  for (; r2 < t2.length && /[a-zA-Z0-9_]/.test(t2[r2]); ) i2 += t2[r2], r2++;
  return { part: j.parameterExpansion(i2), endIndex: r2 };
}
function RC(e2, t2, n2, r2 = false) {
  let s2 = n2 + 2, i2 = false;
  t2[s2] === "!" && (i2 = true, s2++);
  let o2 = false;
  t2[s2] === "#" && !/[}:#%/^,]/.test(t2[s2 + 1] || "}") && (o2 = true, s2++);
  let a = "", l = t2[s2];
  if (/[@*#?$!-]/.test(l) && !/[a-zA-Z0-9_]/.test(t2[s2 + 1] || "")) a = l, s2++;
  else for (; s2 < t2.length && /[a-zA-Z0-9_]/.test(t2[s2]); ) a += t2[s2], s2++;
  if (t2[s2] === "[") {
    let u = ya(e2, t2, s2, "[", "]");
    if (a += t2.slice(s2, u + 1), s2 = u + 1, t2[s2] === "[") {
      let f2 = 1, p = s2;
      for (; p < t2.length && f2 > 0; ) t2[p] === "{" ? f2++ : t2[p] === "}" && f2--, f2 > 0 && p++;
      let d = t2.slice(n2 + 2, p);
      return { part: j.parameterExpansion("", { type: "BadSubstitution", text: d }), endIndex: p + 1 };
    }
  }
  if (a === "" && !i2 && !o2 && t2[s2] !== "}") {
    let u = 1, f2 = s2;
    for (; f2 < t2.length && u > 0; ) t2[f2] === "{" ? u++ : t2[f2] === "}" && u--, u > 0 && f2++;
    if (u > 0) throw new Ge("unexpected EOF while looking for matching '}'", 0, 0);
    let p = t2.slice(n2 + 2, f2);
    return { part: j.parameterExpansion("", { type: "BadSubstitution", text: p }), endIndex: f2 + 1 };
  }
  let c = null;
  if (i2) {
    let u = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
    if (u) if (s2 < t2.length && t2[s2] !== "}" && /[:=\-+?#%/^,@]/.test(t2[s2])) {
      let f2 = Pa(e2, t2, s2, a, r2);
      f2.operation ? (c = { type: "Indirection", innerOp: f2.operation }, s2 = f2.endIndex) : (c = { type: "ArrayKeys", array: u[1], star: u[2] === "*" }, a = "");
    } else c = { type: "ArrayKeys", array: u[1], star: u[2] === "*" }, a = "";
    else if (t2[s2] === "*" || t2[s2] === "@" && !/[QPaAEKkuUL]/.test(t2[s2 + 1] || "")) {
      let f2 = t2[s2];
      s2++, c = { type: "VarNamePrefix", prefix: a, star: f2 === "*" }, a = "";
    } else if (s2 < t2.length && t2[s2] !== "}" && /[:=\-+?#%/^,@]/.test(t2[s2])) {
      let f2 = Pa(e2, t2, s2, a, r2);
      f2.operation ? (c = { type: "Indirection", innerOp: f2.operation }, s2 = f2.endIndex) : c = { type: "Indirection" };
    } else c = { type: "Indirection" };
  } else if (o2) if (t2[s2] === ":") for (c = { type: "LengthSliceError" }; s2 < t2.length && t2[s2] !== "}"; ) s2++;
  else t2[s2] !== "}" && /[-+=?]/.test(t2[s2]) ? e2.error(`\${#${a}${t2.slice(s2, t2.indexOf("}", s2))}}: bad substitution`) : t2[s2] === "/" ? e2.error(`\${#${a}${t2.slice(s2, t2.indexOf("}", s2))}}: bad substitution`) : c = { type: "Length" };
  if (!c && s2 < t2.length && t2[s2] !== "}") {
    let u = Pa(e2, t2, s2, a, r2);
    c = u.operation, s2 = u.endIndex;
  }
  if (s2 < t2.length && t2[s2] !== "}") {
    let u = t2[s2];
    if (!/[:\-+=?#%/^,@[]/.test(u)) {
      let f2 = s2;
      for (; f2 < t2.length && t2[f2] !== "}"; ) f2++;
      let p = t2.slice(n2, f2 + 1);
      e2.error(`\${${p.slice(2, -1)}}: bad substitution`);
    }
  }
  for (; s2 < t2.length && t2[s2] !== "}"; ) s2++;
  if (s2 >= t2.length) throw new Ge("unexpected EOF while looking for matching '}'", 0, 0);
  return { part: j.parameterExpansion(a, c), endIndex: s2 + 1 };
}
function Pa(e2, t2, n2, r2, s2 = false) {
  let i2 = n2, o2 = t2[i2], a = t2[i2 + 1] || "";
  if (o2 === ":") {
    let l = a;
    if ("-=?+".includes(l)) {
      i2 += 2;
      let b = Nn(e2, t2, i2), y = t2.slice(i2, b), w = nn(e2, y, false, false, true, false, s2, false, false, true), E = j.word(w.length > 0 ? w : [j.literal("")]);
      if (l === "-") return { operation: { type: "DefaultValue", word: E, checkEmpty: true }, endIndex: b };
      if (l === "=") return { operation: { type: "AssignDefault", word: E, checkEmpty: true }, endIndex: b };
      if (l === "?") return { operation: { type: "ErrorIfUnset", word: E, checkEmpty: true }, endIndex: b };
      if (l === "+") return { operation: { type: "UseAlternative", word: E, checkEmpty: true }, endIndex: b };
    }
    i2++;
    let c = Nn(e2, t2, i2), u = t2.slice(i2, c), f2 = -1, p = 0, d = 0;
    for (let g = 0; g < u.length; g++) {
      let b = u[g];
      if (b === "(" || b === "[") p++;
      else if (b === ")" || b === "]") p--;
      else if (b === "?" && p === 0) d++;
      else if (b === ":" && p === 0) if (d > 0) d--;
      else {
        f2 = g;
        break;
      }
    }
    let m = f2 >= 0 ? u.slice(0, f2) : u, h = f2 >= 0 ? u.slice(f2 + 1) : null;
    return { operation: { type: "Substring", offset: ba(e2, m), length: h !== null ? ba(e2, h) : null }, endIndex: c };
  }
  if ("-=?+".includes(o2)) {
    i2++;
    let l = Nn(e2, t2, i2), c = t2.slice(i2, l), u = nn(e2, c, false, false, true, false, s2, false, false, true), f2 = j.word(u.length > 0 ? u : [j.literal("")]);
    if (o2 === "-") return { operation: { type: "DefaultValue", word: f2, checkEmpty: false }, endIndex: l };
    if (o2 === "=") return { operation: { type: "AssignDefault", word: f2, checkEmpty: false }, endIndex: l };
    if (o2 === "?") return { operation: { type: "ErrorIfUnset", word: c ? f2 : null, checkEmpty: false }, endIndex: l };
    if (o2 === "+") return { operation: { type: "UseAlternative", word: f2, checkEmpty: false }, endIndex: l };
  }
  if (o2 === "#" || o2 === "%") {
    let l = a === o2, c = o2 === "#" ? "prefix" : "suffix";
    i2 += l ? 2 : 1;
    let u = Nn(e2, t2, i2), f2 = t2.slice(i2, u), p = nn(e2, f2, false, false, false);
    return { operation: { type: "PatternRemoval", pattern: j.word(p.length > 0 ? p : [j.literal("")]), side: c, greedy: l }, endIndex: u };
  }
  if (o2 === "/") {
    let l = a === "/";
    i2 += l ? 2 : 1;
    let c = null;
    t2[i2] === "#" ? (c = "start", i2++) : t2[i2] === "%" && (c = "end", i2++);
    let u;
    c !== null && (t2[i2] === "/" || t2[i2] === "}") ? u = i2 : u = Rm(e2, t2, i2);
    let f2 = t2.slice(i2, u), p = nn(e2, f2, false, false, false), d = j.word(p.length > 0 ? p : [j.literal("")]), m = null, h = u;
    if (t2[u] === "/") {
      let g = u + 1, b = Nn(e2, t2, g), y = t2.slice(g, b), w = nn(e2, y, false, false, false);
      m = j.word(w.length > 0 ? w : [j.literal("")]), h = b;
    }
    return { operation: { type: "PatternReplacement", pattern: d, replacement: m, all: l, anchor: c }, endIndex: h };
  }
  if (o2 === "^" || o2 === ",") {
    let l = a === o2, c = o2 === "^" ? "upper" : "lower";
    i2 += l ? 2 : 1;
    let u = Nn(e2, t2, i2), f2 = t2.slice(i2, u), p = f2 ? j.word([j.literal(f2)]) : null;
    return { operation: { type: "CaseModification", direction: c, all: l, pattern: p }, endIndex: u };
  }
  return o2 === "@" && /[QPaAEKkuUL]/.test(a) ? { operation: { type: "Transform", operator: a }, endIndex: i2 + 2 } : { operation: null, endIndex: i2 };
}
function Ta(e2, t2, n2, r2 = false) {
  let s2 = n2 + 1;
  if (s2 >= t2.length) return { part: j.literal("$"), endIndex: s2 };
  let i2 = t2[s2];
  if (i2 === "(" && t2[s2 + 1] === "(") return e2.isDollarDparenSubshell(t2, n2) ? e2.parseCommandSubstitution(t2, n2) : e2.parseArithmeticExpansion(t2, n2);
  if (i2 === "[") {
    let o2 = 1, a = s2 + 1;
    for (; a < t2.length && o2 > 0; ) t2[a] === "[" ? o2++ : t2[a] === "]" && o2--, o2 > 0 && a++;
    if (o2 === 0) {
      let l = t2.slice(s2 + 1, a), c = he(e2, l);
      return { part: j.arithmeticExpansion(c), endIndex: a + 1 };
    }
  }
  return i2 === "(" ? e2.parseCommandSubstitution(t2, n2) : i2 === "{" ? RC(e2, t2, n2, r2) : /[a-zA-Z_0-9@*#?$!-]/.test(i2) ? IC(e2, t2, n2) : { part: j.literal("$"), endIndex: s2 };
}
function jm(e2, t2) {
  let n2 = [], r2 = 0, s2 = "", i2 = () => {
    s2 && (n2.push(j.literal(s2)), s2 = "");
  };
  for (; r2 < t2.length; ) {
    let o2 = t2[r2];
    if (o2 === "\\" && r2 + 1 < t2.length) {
      let a = t2[r2 + 1];
      if (a === "$" || a === "`" || a === '"' || a === "\\") {
        s2 += a, r2 += 2;
        continue;
      }
      s2 += o2, r2++;
      continue;
    }
    if (o2 === "$") {
      i2();
      let { part: a, endIndex: l } = Ta(e2, t2, r2, true);
      a && n2.push(a), r2 = l;
      continue;
    }
    if (o2 === "`") {
      i2();
      let { part: a, endIndex: l } = e2.parseBacktickSubstitution(t2, r2, true);
      n2.push(a), r2 = l;
      continue;
    }
    s2 += o2, r2++;
  }
  return i2(), n2;
}
function PC(e2, t2, n2) {
  let r2 = [], s2 = n2, i2 = "", o2 = () => {
    i2 && (r2.push(j.literal(i2)), i2 = "");
  };
  for (; s2 < t2.length && t2[s2] !== '"'; ) {
    let a = t2[s2];
    if (a === "\\" && s2 + 1 < t2.length) {
      let l = t2[s2 + 1];
      if ('"\\$`\n'.includes(l)) {
        i2 += l, s2 += 2;
        continue;
      }
      i2 += a, s2++;
      continue;
    }
    if (a === "$") {
      o2();
      let { part: l, endIndex: c } = Ta(e2, t2, s2, true);
      l && r2.push(l), s2 = c;
      continue;
    }
    if (a === "`") {
      o2();
      let { part: l, endIndex: c } = e2.parseBacktickSubstitution(t2, s2, true);
      r2.push(l), s2 = c;
      continue;
    }
    i2 += a, s2++;
  }
  return o2(), { part: j.doubleQuoted(r2), endIndex: s2 };
}
function nn(e2, t2, n2 = false, r2 = false, s2 = false, i2 = false, o2 = false, a = false, l = false, c = false) {
  if (r2) return [j.singleQuoted(t2)];
  if (n2) {
    let m = jm(e2, t2);
    return [j.doubleQuoted(m)];
  }
  if (t2.length >= 2 && t2[0] === '"' && t2[t2.length - 1] === '"') {
    let m = t2.slice(1, -1), h = false;
    for (let g = 0; g < m.length; g++) {
      if (m[g] === '"') {
        h = true;
        break;
      }
      m[g] === "\\" && g + 1 < m.length && g++;
    }
    if (!h) {
      let g = jm(e2, m);
      return [j.doubleQuoted(g)];
    }
  }
  let u = [], f2 = 0, p = "", d = () => {
    p && (u.push(j.literal(p)), p = "");
  };
  for (; f2 < t2.length; ) {
    let m = t2[f2];
    if (m === "\\" && f2 + 1 < t2.length) {
      let h = t2[f2 + 1];
      if (l) {
        d(), u.push(j.escaped(h)), f2 += 2;
        continue;
      }
      let g = i2 ? h === "$" || h === "`" || h === `
` : h === "$" || h === "`" || h === '"' || h === "'" || h === `
` || c && h === "}", b = o2 ? "*?[]\\".includes(h) : "*?[]\\(){}.^+".includes(h);
      g ? p += h : b ? (d(), u.push(j.escaped(h))) : p += `\\${h}`, f2 += 2;
      continue;
    }
    if (m === "'" && !o2 && !i2) {
      d();
      let h = t2.indexOf("'", f2 + 1);
      if (h === -1) {
        p += t2.slice(f2);
        break;
      }
      u.push(j.singleQuoted(t2.slice(f2 + 1, h))), f2 = h + 1;
      continue;
    }
    if (m === '"' && !i2) {
      d();
      let { part: h, endIndex: g } = PC(e2, t2, f2 + 1);
      u.push(h), f2 = g + 1;
      continue;
    }
    if (m === "$" && t2[f2 + 1] === "'") {
      d();
      let { part: h, endIndex: g } = Tm(e2, t2, f2 + 2);
      u.push(h), f2 = g;
      continue;
    }
    if (m === "$") {
      d();
      let { part: h, endIndex: g } = Ta(e2, t2, f2);
      h && u.push(h), f2 = g;
      continue;
    }
    if (m === "`") {
      d();
      let { part: h, endIndex: g } = e2.parseBacktickSubstitution(t2, f2);
      u.push(h), f2 = g;
      continue;
    }
    if (m === "~") {
      let h = f2 > 0 ? t2[f2 - 1] : "";
      if (f2 === 0 || h === "=" || s2 && h === ":") {
        let b = Im(e2, t2, f2), y = t2[b];
        if (y === void 0 || y === "/" || y === ":") {
          d();
          let w = t2.slice(f2 + 1, b) || null;
          u.push({ type: "TildeExpansion", user: w }), f2 = b;
          continue;
        }
      }
    }
    if ("@*+?!".includes(m) && f2 + 1 < t2.length && t2[f2 + 1] === "(") {
      let h = $C(t2, f2 + 1);
      if (h !== -1) {
        d();
        let g = t2.slice(f2, h + 1);
        u.push({ type: "Glob", pattern: g }), f2 = h + 1;
        continue;
      }
    }
    if (m === "*" || m === "?" || m === "[") {
      d();
      let { pattern: h, endIndex: g } = Pm(e2, t2, f2);
      u.push({ type: "Glob", pattern: h }), f2 = g;
      continue;
    }
    if (m === "{" && !s2 && !a) {
      let h = Om(e2, t2, f2, nn);
      if (h) {
        d(), u.push(h.part), f2 = h.endIndex;
        continue;
      }
    }
    p += m, f2++;
  }
  return d(), u;
}
var Hm = v(() => {
  Cn();
  Je();
  An();
  xa();
});
function Vm(e2, t2) {
  let n2 = e2.length, r2 = t2 + 3, s2 = 2, i2 = false, o2 = false;
  for (; r2 < n2 && s2 > 0; ) {
    let a = e2[r2];
    if (i2) {
      a === "'" && (i2 = false), r2++;
      continue;
    }
    if (o2) {
      if (a === "\\") {
        r2 += 2;
        continue;
      }
      a === '"' && (o2 = false), r2++;
      continue;
    }
    if (a === "'") {
      i2 = true, r2++;
      continue;
    }
    if (a === '"') {
      o2 = true, r2++;
      continue;
    }
    if (a === "\\") {
      r2 += 2;
      continue;
    }
    if (a === "(") {
      s2++, r2++;
      continue;
    }
    if (a === ")") {
      if (s2--, s2 === 1) {
        let l = r2 + 1;
        return !(l < n2 && e2[l] === ")");
      }
      if (s2 === 0) return false;
      r2++;
      continue;
    }
    if (s2 === 1 && (a === "|" && r2 + 1 < n2 && e2[r2 + 1] === "|" || a === "&" && r2 + 1 < n2 && e2[r2 + 1] === "&" || a === "|" && r2 + 1 < n2 && e2[r2 + 1] !== "|")) return true;
    r2++;
  }
  return false;
}
function qm(e2, t2, n2, r2) {
  let s2 = t2 + 2, i2 = 1, o2 = s2, a = false, l = false, c = 0, u = false, f2 = "";
  for (; o2 < e2.length && i2 > 0; ) {
    let h = e2[o2];
    a ? h === "'" && (a = false) : l ? h === "\\" && o2 + 1 < e2.length ? o2++ : h === '"' && (l = false) : h === "'" ? (a = true, f2 = "") : h === '"' ? (l = true, f2 = "") : h === "\\" && o2 + 1 < e2.length ? (o2++, f2 = "") : /[a-zA-Z_]/.test(h) ? f2 += h : (f2 === "case" ? (c++, u = false) : f2 === "in" && c > 0 ? u = true : f2 === "esac" && c > 0 && (c--, u = false), f2 = "", h === "(" ? o2 > 0 && e2[o2 - 1] === "$" ? i2++ : u || i2++ : h === ")" ? u ? u = false : i2-- : h === ";" && c > 0 && o2 + 1 < e2.length && e2[o2 + 1] === ";" && (u = true)), i2 > 0 && o2++;
  }
  i2 > 0 && r2("unexpected EOF while looking for matching `)'");
  let p = e2.slice(s2, o2), m = n2().parse(p);
  return { part: j.commandSubstitution(m, false), endIndex: o2 + 1 };
}
function Gm(e2, t2, n2, r2, s2) {
  let o2 = t2 + 1, a = "";
  for (; o2 < e2.length && e2[o2] !== "`"; ) if (e2[o2] === "\\") {
    let u = e2[o2 + 1];
    u === "$" || u === "`" || u === "\\" || u === `
` || n2 && u === '"' ? (u !== `
` && (a += u), o2 += 2) : (a += e2[o2], o2++);
  } else a += e2[o2], o2++;
  o2 >= e2.length && s2("unexpected EOF while looking for matching ``'");
  let c = r2().parse(a);
  return { part: j.commandSubstitution(c, true), endIndex: o2 + 1 };
}
var Zm = v(() => {
  Cn();
});
function Bt(e2) {
  return new se().parse(e2);
}
var se, Fe = v(() => {
  Cn();
  Je();
  Lm();
  Mm();
  zm();
  Hm();
  tn();
  Zm();
  An();
  An();
  se = class e2 {
    constructor() {
      __publicField(this, "tokens", []);
      __publicField(this, "pos", 0);
      __publicField(this, "pendingHeredocs", []);
      __publicField(this, "parseIterations", 0);
      __publicField(this, "_input", "");
    }
    getInput() {
      return this._input;
    }
    checkIterationLimit() {
      if (this.parseIterations++, this.parseIterations > um) throw new Ge("Maximum parse iterations exceeded (possible infinite loop)", this.current().line, this.current().column);
    }
    parse(t2) {
      if (t2.length > da) throw new Ge(`Input too large: ${t2.length} bytes exceeds limit of ${da}`, 1, 1);
      this._input = t2;
      let n2 = new Zs(t2);
      if (this.tokens = n2.tokenize(), this.tokens.length > ha) throw new Ge(`Too many tokens: ${this.tokens.length} exceeds limit of ${ha}`, 1, 1);
      return this.pos = 0, this.pendingHeredocs = [], this.parseIterations = 0, this.parseScript();
    }
    parseTokens(t2) {
      return this.tokens = t2, this.pos = 0, this.pendingHeredocs = [], this.parseScript();
    }
    current() {
      return this.tokens[this.pos] || this.tokens[this.tokens.length - 1];
    }
    peek(t2 = 0) {
      return this.tokens[this.pos + t2] || this.tokens[this.tokens.length - 1];
    }
    advance() {
      let t2 = this.current();
      return this.pos < this.tokens.length - 1 && this.pos++, t2;
    }
    getPos() {
      return this.pos;
    }
    check(t2, n2, r2, s2, ...i2) {
      var _a3;
      let o2 = (_a3 = this.tokens[this.pos]) == null ? void 0 : _a3.type;
      return o2 === t2 || n2 !== void 0 && o2 === n2 || r2 !== void 0 && o2 === r2 || s2 !== void 0 && o2 === s2 ? true : i2.length > 0 ? i2.includes(o2) : false;
    }
    expect(t2, n2) {
      if (this.check(t2)) return this.advance();
      let r2 = this.current();
      throw new Ge(n2 || `Expected ${t2}, got ${r2.type}`, r2.line, r2.column, r2);
    }
    error(t2) {
      let n2 = this.current();
      throw new Ge(t2, n2.line, n2.column, n2);
    }
    skipNewlines() {
      for (; this.check(x.NEWLINE, x.COMMENT); ) this.check(x.NEWLINE) ? (this.advance(), this.processHeredocs()) : this.advance();
    }
    skipSeparators(t2 = true) {
      for (; ; ) {
        if (this.check(x.NEWLINE)) {
          this.advance(), this.processHeredocs();
          continue;
        }
        if (this.check(x.SEMICOLON, x.COMMENT)) {
          this.advance();
          continue;
        }
        if (t2 && this.check(x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND)) {
          this.advance();
          continue;
        }
        break;
      }
    }
    addPendingHeredoc(t2, n2, r2, s2) {
      this.pendingHeredocs.push({ redirect: t2, delimiter: n2, stripTabs: r2, quoted: s2 });
    }
    processHeredocs() {
      for (let t2 of this.pendingHeredocs) if (this.check(x.HEREDOC_CONTENT)) {
        let n2 = this.advance(), r2;
        t2.quoted ? r2 = j.word([j.literal(n2.value)]) : r2 = this.parseWordFromString(n2.value, false, false, false, true), t2.redirect.target = j.hereDoc(t2.delimiter, r2, t2.stripTabs, t2.quoted);
      }
      this.pendingHeredocs = [];
    }
    isStatementEnd() {
      return this.check(x.EOF, x.NEWLINE, x.SEMICOLON, x.AMP, x.AND_AND, x.OR_OR, x.RPAREN, x.RBRACE, x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND);
    }
    isCommandStart() {
      let t2 = this.current().type;
      return t2 === x.WORD || t2 === x.NAME || t2 === x.NUMBER || t2 === x.ASSIGNMENT_WORD || t2 === x.IF || t2 === x.FOR || t2 === x.WHILE || t2 === x.UNTIL || t2 === x.CASE || t2 === x.LPAREN || t2 === x.LBRACE || t2 === x.DPAREN_START || t2 === x.DBRACK_START || t2 === x.FUNCTION || t2 === x.BANG || t2 === x.TIME || t2 === x.IN || t2 === x.LESS || t2 === x.GREAT || t2 === x.DLESS || t2 === x.DGREAT || t2 === x.LESSAND || t2 === x.GREATAND || t2 === x.LESSGREAT || t2 === x.DLESSDASH || t2 === x.CLOBBER || t2 === x.TLESS || t2 === x.AND_GREAT || t2 === x.AND_DGREAT;
    }
    parseScript() {
      let t2 = [], r2 = 0;
      for (this.skipNewlines(); !this.check(x.EOF); ) {
        r2++, r2 > 1e4 && this.error("Parser stuck: too many iterations (>10000)");
        let s2 = this.checkUnexpectedToken();
        if (s2) {
          t2.push(s2), this.skipSeparators(false);
          continue;
        }
        let i2 = this.pos, o2 = this.parseStatement();
        o2 && t2.push(o2), this.skipSeparators(false), this.check(x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND) && this.error(`syntax error near unexpected token \`${this.current().value}'`), this.pos === i2 && !this.check(x.EOF) && this.advance();
      }
      return j.script(t2);
    }
    checkUnexpectedToken() {
      let t2 = this.current().type, n2 = this.current().value;
      if ((t2 === x.DO || t2 === x.DONE || t2 === x.THEN || t2 === x.ELSE || t2 === x.ELIF || t2 === x.FI || t2 === x.ESAC) && this.error(`syntax error near unexpected token \`${n2}'`), t2 === x.RBRACE || t2 === x.RPAREN) {
        let r2 = `syntax error near unexpected token \`${n2}'`;
        return this.advance(), j.statement([j.pipeline([j.simpleCommand(null, [], [], [])])], [], false, { message: r2, token: n2 });
      }
      return (t2 === x.DSEMI || t2 === x.SEMI_AND || t2 === x.SEMI_SEMI_AND) && this.error(`syntax error near unexpected token \`${n2}'`), t2 === x.SEMICOLON && this.error(`syntax error near unexpected token \`${n2}'`), (t2 === x.PIPE || t2 === x.PIPE_AMP) && this.error(`syntax error near unexpected token \`${n2}'`), null;
    }
    parseStatement() {
      if (this.skipNewlines(), !this.isCommandStart()) return null;
      let t2 = this.current().start, n2 = [], r2 = [], s2 = false, i2 = this.parsePipeline();
      for (n2.push(i2); this.check(x.AND_AND, x.OR_OR); ) {
        let l = this.advance();
        r2.push(l.type === x.AND_AND ? "&&" : "||"), this.skipNewlines();
        let c = this.parsePipeline();
        n2.push(c);
      }
      this.check(x.AMP) && (this.advance(), s2 = true);
      let o2 = this.pos > 0 ? this.tokens[this.pos - 1].end : t2, a = this._input.slice(t2, o2);
      return j.statement(n2, r2, s2, void 0, a);
    }
    parsePipeline() {
      let t2 = false, n2 = false;
      this.check(x.TIME) && (this.advance(), t2 = true, this.check(x.WORD, x.NAME) && this.current().value === "-p" && (this.advance(), n2 = true));
      let r2 = 0;
      for (; this.check(x.BANG); ) this.advance(), r2++;
      let s2 = r2 % 2 === 1, i2 = [], o2 = [], a = this.parseCommand();
      for (i2.push(a); this.check(x.PIPE, x.PIPE_AMP); ) {
        let l = this.advance();
        this.skipNewlines(), o2.push(l.type === x.PIPE_AMP);
        let c = this.parseCommand();
        i2.push(c);
      }
      return j.pipeline(i2, s2, t2, n2, o2.length > 0 ? o2 : void 0);
    }
    parseCommand() {
      return this.check(x.IF) ? Sa(this) : this.check(x.FOR) ? Aa(this) : this.check(x.WHILE) ? Ca(this) : this.check(x.UNTIL) ? Na(this) : this.check(x.CASE) ? ka(this) : this.check(x.LPAREN) ? va(this) : this.check(x.LBRACE) ? $a(this) : this.check(x.DPAREN_START) ? this.dparenClosesWithSpacedParens() ? this.parseNestedSubshellsFromDparen() : this.parseArithmeticCommand() : this.check(x.DBRACK_START) ? this.parseConditionalCommand() : this.check(x.FUNCTION) ? this.parseFunctionDef() : this.check(x.NAME, x.WORD) && this.peek(1).type === x.LPAREN && this.peek(2).type === x.RPAREN ? this.parseFunctionDef() : _m(this);
    }
    dparenClosesWithSpacedParens() {
      let t2 = 1, n2 = 1;
      for (; n2 < this.tokens.length - this.pos; ) {
        let r2 = this.peek(n2);
        if (r2.type === x.EOF) return false;
        if (r2.type === x.DPAREN_START || r2.type === x.LPAREN) t2++;
        else if (r2.type === x.DPAREN_END) {
          if (t2 -= 2, t2 <= 0) return false;
        } else if (r2.type === x.RPAREN && (t2--, t2 === 0 && this.peek(n2 + 1).type === x.RPAREN)) return true;
        n2++;
      }
      return false;
    }
    parseNestedSubshellsFromDparen() {
      this.advance();
      let t2 = this.parseCompoundList();
      this.expect(x.RPAREN), this.expect(x.RPAREN);
      let n2 = this.parseOptionalRedirections(), r2 = j.subshell(t2, []);
      return j.subshell([j.statement([j.pipeline([r2], false, false, false)])], n2);
    }
    isWord() {
      let t2 = this.current().type;
      return t2 === x.WORD || t2 === x.NAME || t2 === x.NUMBER || t2 === x.IF || t2 === x.FOR || t2 === x.WHILE || t2 === x.UNTIL || t2 === x.CASE || t2 === x.FUNCTION || t2 === x.ELSE || t2 === x.ELIF || t2 === x.FI || t2 === x.THEN || t2 === x.DO || t2 === x.DONE || t2 === x.ESAC || t2 === x.IN || t2 === x.SELECT || t2 === x.TIME || t2 === x.COPROC || t2 === x.BANG;
    }
    parseWord() {
      let t2 = this.advance();
      return this.parseWordFromString(t2.value, t2.quoted, t2.singleQuoted);
    }
    parseWordNoBraceExpansion() {
      let t2 = this.advance();
      return this.parseWordFromString(t2.value, t2.quoted, t2.singleQuoted, false, false, true);
    }
    parseWordForRegex() {
      let t2 = this.advance();
      return this.parseWordFromString(t2.value, t2.quoted, t2.singleQuoted, false, false, true, true);
    }
    parseWordFromString(t2, n2 = false, r2 = false, s2 = false, i2 = false, o2 = false, a = false) {
      let l = nn(this, t2, n2, r2, s2, i2, false, o2, a);
      return j.word(l);
    }
    parseCommandSubstitution(t2, n2) {
      return qm(t2, n2, () => new e2(), (r2) => this.error(r2));
    }
    parseBacktickSubstitution(t2, n2, r2 = false) {
      return Gm(t2, n2, r2, () => new e2(), (s2) => this.error(s2));
    }
    isDollarDparenSubshell(t2, n2) {
      return Vm(t2, n2);
    }
    parseArithmeticExpansion(t2, n2) {
      let r2 = n2 + 3, s2 = 1, i2 = 0, o2 = r2;
      for (; o2 < t2.length - 1 && s2 > 0; ) t2[o2] === "$" && t2[o2 + 1] === "(" ? t2[o2 + 2] === "(" ? (s2++, o2 += 3) : (i2++, o2 += 2) : t2[o2] === "(" && t2[o2 + 1] === "(" ? (s2++, o2 += 2) : t2[o2] === ")" && t2[o2 + 1] === ")" ? i2 > 0 ? (i2--, o2++) : (s2--, s2 > 0 && (o2 += 2)) : t2[o2] === "(" ? (i2++, o2++) : (t2[o2] === ")" && i2 > 0 && i2--, o2++);
      let a = t2.slice(r2, o2), l = this.parseArithmeticExpression(a);
      return { part: j.arithmeticExpansion(l), endIndex: o2 + 2 };
    }
    parseArithmeticCommand() {
      let t2 = this.expect(x.DPAREN_START), n2 = "", r2 = 1, s2 = 0, i2 = false, o2 = false;
      for (; r2 > 0 && !this.check(x.EOF); ) {
        if (i2) {
          if (i2 = false, s2 > 0) {
            s2--, n2 += ")";
            continue;
          }
          if (this.check(x.RPAREN)) {
            r2--, o2 = true, this.advance();
            continue;
          }
          if (this.check(x.DPAREN_END)) {
            r2--, o2 = true;
            continue;
          }
          n2 += ")";
          continue;
        }
        if (this.check(x.DPAREN_START)) r2++, n2 += "((", this.advance();
        else if (this.check(x.DPAREN_END)) s2 >= 2 ? (s2 -= 2, n2 += "))", this.advance()) : s2 === 1 ? (s2--, n2 += ")", i2 = true, this.advance()) : (r2--, o2 = true, r2 > 0 && (n2 += "))"), this.advance());
        else if (this.check(x.LPAREN)) s2++, n2 += "(", this.advance();
        else if (this.check(x.RPAREN)) s2 > 0 && s2--, n2 += ")", this.advance();
        else {
          let c = this.current().value, u = n2.length > 0 ? n2[n2.length - 1] : "";
          n2.length > 0 && !n2.endsWith(" ") && !(c === "=" && /[|&^+\-*/%<>]$/.test(n2)) && !(c === "<" && u === "<") && !(c === ">" && u === ">") && (n2 += " "), n2 += c, this.advance();
        }
      }
      o2 || this.expect(x.DPAREN_END);
      let a = this.parseArithmeticExpression(n2.trim()), l = this.parseOptionalRedirections();
      return j.arithmeticCommand(a, l, t2.line);
    }
    parseConditionalCommand() {
      let t2 = this.expect(x.DBRACK_START), n2 = Ra(this);
      this.expect(x.DBRACK_END);
      let r2 = this.parseOptionalRedirections();
      return j.conditionalCommand(n2, r2, t2.line);
    }
    parseFunctionDef() {
      let t2;
      if (this.check(x.FUNCTION)) {
        if (this.advance(), this.check(x.NAME) || this.check(x.WORD)) t2 = this.advance().value;
        else {
          let s2 = this.current();
          throw new Ge("Expected function name", s2.line, s2.column, s2);
        }
        this.check(x.LPAREN) && (this.advance(), this.expect(x.RPAREN));
      } else t2 = this.advance().value, t2.includes("$") && this.error(`\`${t2}': not a valid identifier`), this.expect(x.LPAREN), this.expect(x.RPAREN);
      this.skipNewlines();
      let n2 = this.parseCompoundCommandBody({ forFunctionBody: true }), r2 = this.parseOptionalRedirections();
      return j.functionDef(t2, n2, r2);
    }
    parseCompoundCommandBody(t2) {
      let n2 = t2 == null ? void 0 : t2.forFunctionBody;
      if (this.check(x.LBRACE)) return $a(this, { skipRedirections: n2 });
      if (this.check(x.LPAREN)) return va(this, { skipRedirections: n2 });
      if (this.check(x.IF)) return Sa(this, { skipRedirections: n2 });
      if (this.check(x.FOR)) return Aa(this, { skipRedirections: n2 });
      if (this.check(x.WHILE)) return Ca(this, { skipRedirections: n2 });
      if (this.check(x.UNTIL)) return Na(this, { skipRedirections: n2 });
      if (this.check(x.CASE)) return ka(this, { skipRedirections: n2 });
      this.error("Expected compound command for function body");
    }
    parseCompoundList() {
      let t2 = [];
      for (this.skipNewlines(); !this.check(x.EOF, x.FI, x.ELSE, x.ELIF, x.THEN, x.DO, x.DONE, x.ESAC, x.RPAREN, x.RBRACE, x.DSEMI, x.SEMI_AND, x.SEMI_SEMI_AND) && this.isCommandStart(); ) {
        this.checkIterationLimit();
        let n2 = this.pos, r2 = this.parseStatement();
        if (r2 && t2.push(r2), this.skipSeparators(), this.pos === n2 && !r2) break;
      }
      return t2;
    }
    parseOptionalRedirections() {
      let t2 = [];
      for (; Xs(this); ) {
        this.checkIterationLimit();
        let n2 = this.pos;
        if (t2.push(Js(this)), this.pos === n2) break;
      }
      return t2;
    }
    parseArithmeticExpression(t2) {
      return he(this, t2);
    }
  };
});
function Da(e2) {
  return DC[e2] || "";
}
function eg(e2) {
  let t2 = [], n2 = "", r2 = 0;
  for (; r2 < e2.length; ) {
    let s2 = e2[r2];
    if (s2 === "[") {
      for (n2 += s2, r2++, r2 < e2.length && (e2[r2] === "!" || e2[r2] === "^") && (n2 += e2[r2], r2++), r2 < e2.length && e2[r2] === "]" && (n2 += e2[r2], r2++); r2 < e2.length && e2[r2] !== "]"; ) {
        if (e2[r2] === "[" && r2 + 1 < e2.length && e2[r2 + 1] === ":") {
          let i2 = e2.indexOf(":]", r2 + 2);
          if (i2 !== -1) {
            n2 += e2.slice(r2, i2 + 2), r2 = i2 + 2;
            continue;
          }
        }
        if (e2[r2] === "\\" && r2 + 1 < e2.length) {
          n2 += e2[r2] + e2[r2 + 1], r2 += 2;
          continue;
        }
        n2 += e2[r2], r2++;
      }
      r2 < e2.length && e2[r2] === "]" && (n2 += e2[r2], r2++);
    } else s2 === ":" ? (n2 !== "" && t2.push(n2), n2 = "", r2++) : s2 === "\\" && r2 + 1 < e2.length ? (n2 += s2 + e2[r2 + 1], r2 += 2) : (n2 += s2, r2++);
  }
  return n2 !== "" && t2.push(n2), t2;
}
function tg(e2) {
  let t2 = "^";
  for (let n2 = 0; n2 < e2.length; n2++) {
    let r2 = e2[n2];
    if (r2 === "*") t2 += "[^/]*";
    else if (r2 === "?") t2 += "[^/]";
    else if (r2 === "[") {
      let s2 = n2 + 1, i2 = "[";
      s2 < e2.length && (e2[s2] === "^" || e2[s2] === "!") && (i2 += "^", s2++), s2 < e2.length && e2[s2] === "]" && (i2 += "\\]", s2++);
      let o2 = s2;
      for (; o2 < e2.length; ) {
        if (e2[o2] === "\\" && o2 + 1 < e2.length) {
          o2 += 2;
          continue;
        }
        if (e2[o2] === "[" && o2 + 1 < e2.length && e2[o2 + 1] === ":") {
          let l = e2.indexOf(":]", o2 + 2);
          if (l !== -1) {
            o2 = l + 2;
            continue;
          }
        }
        if (e2[o2] === "]") break;
        o2++;
      }
      let a = s2;
      for (; s2 < e2.length && e2[s2] !== "]"; ) {
        if (e2[s2] === "[" && s2 + 1 < e2.length && e2[s2 + 1] === ":") {
          let l = e2.indexOf(":]", s2 + 2);
          if (l !== -1) {
            let c = e2.slice(s2 + 2, l), u = Da(c);
            i2 += u, s2 = l + 2;
            continue;
          }
        }
        if (e2[s2] === "\\" && s2 + 1 < e2.length) {
          i2 += `\\${e2[s2 + 1]}`, s2 += 2;
          continue;
        }
        if (e2[s2] === "-") {
          let l = s2 === a, c = s2 + 1 === o2;
          l || c ? i2 += "\\-" : i2 += "-";
        } else i2 += e2[s2];
        s2++;
      }
      i2 += "]", t2 += i2, n2 = s2;
    } else if (r2 === "\\" && n2 + 1 < e2.length) {
      let s2 = e2[n2 + 1];
      /[.+^${}()|\\*?[\]]/.test(s2) ? t2 += `\\${s2}` : t2 += s2, n2++;
    } else /[.+^${}()|]/.test(r2) ? t2 += `\\${r2}` : t2 += r2;
  }
  return t2 += "$", new RegExp(t2);
}
function Fa(e2, t2) {
  let n2 = 1, r2 = t2 + 1;
  for (; r2 < e2.length && n2 > 0; ) {
    let s2 = e2[r2];
    if (s2 === "\\") {
      r2 += 2;
      continue;
    }
    if (s2 === "(") n2++;
    else if (s2 === ")" && (n2--, n2 === 0)) return r2;
    r2++;
  }
  return -1;
}
function _a(e2) {
  let t2 = [], n2 = "", r2 = 0, s2 = false, i2 = 0;
  for (; i2 < e2.length; ) {
    let o2 = e2[i2];
    if (o2 === "'" && !s2) {
      s2 = true, n2 += "\0QUOTE_START\0", i2++;
      continue;
    }
    if (o2 === "'" && s2) {
      s2 = false, n2 += "\0QUOTE_END\0", i2++;
      continue;
    }
    if (s2) {
      n2 += o2, i2++;
      continue;
    }
    if (o2 === "\\") {
      n2 += o2, i2 + 1 < e2.length ? (n2 += e2[i2 + 1], i2 += 2) : i2++;
      continue;
    }
    o2 === "(" ? (r2++, n2 += o2) : o2 === ")" ? (r2--, n2 += o2) : o2 === "|" && r2 === 0 ? (t2.push(n2), n2 = "") : n2 += o2, i2++;
  }
  return t2.push(n2), t2;
}
var DC, ng = v(() => {
  DC = { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "!-~", lower: "a-z", print: " -~", punct: "!-/:-@\\[-`{-~", space: " \\t\\n\\r\\f\\v", upper: "A-Z", word: "a-zA-Z0-9_", xdigit: "0-9a-fA-F" };
});
var rn, Ys = v(() => {
  Pn();
  ng();
  rn = class {
    constructor(t2, n2, r2, s2) {
      __publicField(this, "fs");
      __publicField(this, "cwd");
      __publicField(this, "globignorePatterns", []);
      __publicField(this, "hasGlobignore", false);
      __publicField(this, "globstar", false);
      __publicField(this, "nullglob", false);
      __publicField(this, "failglob", false);
      __publicField(this, "dotglob", false);
      __publicField(this, "extglob", false);
      __publicField(this, "globskipdots", true);
      this.fs = t2, this.cwd = n2, typeof s2 == "boolean" ? this.globstar = s2 : s2 && (this.globstar = s2.globstar ?? false, this.nullglob = s2.nullglob ?? false, this.failglob = s2.failglob ?? false, this.dotglob = s2.dotglob ?? false, this.extglob = s2.extglob ?? false, this.globskipdots = s2.globskipdots ?? true);
      let i2 = r2 == null ? void 0 : r2.GLOBIGNORE;
      i2 !== void 0 && i2 !== "" && (this.hasGlobignore = true, this.globignorePatterns = eg(i2));
    }
    hasNullglob() {
      return this.nullglob;
    }
    hasFailglob() {
      return this.failglob;
    }
    filterGlobignore(t2) {
      return !this.hasGlobignore && !this.globskipdots ? t2 : t2.filter((n2) => {
        let r2 = n2.split("/").pop() || n2;
        if ((this.hasGlobignore || this.globskipdots) && (r2 === "." || r2 === "..")) return false;
        if (this.hasGlobignore) {
          for (let s2 of this.globignorePatterns) if (this.matchGlobignorePattern(n2, s2)) return false;
        }
        return true;
      });
    }
    matchGlobignorePattern(t2, n2) {
      return tg(n2).test(t2);
    }
    isGlobPattern(t2) {
      return !!(t2.includes("*") || t2.includes("?") || /\[.*\]/.test(t2) || this.extglob && /[@*+?!]\(/.test(t2));
    }
    async expandArgs(t2, n2) {
      let r2 = t2.map((o2, a) => ((n2 == null ? void 0 : n2[a]) ?? false) || !this.isGlobPattern(o2) ? null : this.expand(o2)), s2 = await Promise.all(r2.map((o2) => o2 || Promise.resolve(null))), i2 = [];
      for (let o2 = 0; o2 < t2.length; o2++) {
        let a = s2[o2];
        a === null ? i2.push(t2[o2]) : a.length > 0 ? i2.push(...a) : i2.push(t2[o2]);
      }
      return i2;
    }
    async expand(t2) {
      let n2;
      if (t2.includes("**") && this.globstar && this.isGlobstarValid(t2)) n2 = await this.expandRecursive(t2);
      else {
        let r2 = t2.replace(/\*\*+/g, "*");
        n2 = await this.expandSimple(r2);
      }
      return this.filterGlobignore(n2);
    }
    isGlobstarValid(t2) {
      let n2 = t2.split("/");
      for (let r2 of n2) if (r2.includes("**") && r2 !== "**") return false;
      return true;
    }
    hasGlobChars(t2) {
      return !!(t2.includes("*") || t2.includes("?") || /\[.*\]/.test(t2) || this.extglob && /[@*+?!]\(/.test(t2));
    }
    async expandSimple(t2) {
      let n2 = t2.startsWith("/"), r2 = t2.split("/").filter((c) => c !== ""), s2 = -1;
      for (let c = 0; c < r2.length; c++) if (this.hasGlobChars(r2[c])) {
        s2 = c;
        break;
      }
      if (s2 === -1) return [t2];
      let i2, o2;
      if (s2 === 0) n2 ? (i2 = "/", o2 = "/") : (i2 = this.cwd, o2 = "");
      else {
        let c = r2.slice(0, s2);
        n2 ? (i2 = `/${c.join("/")}`, o2 = `/${c.join("/")}`) : (i2 = this.fs.resolvePath(this.cwd, c.join("/")), o2 = c.join("/"));
      }
      let a = r2.slice(s2);
      return (await this.expandSegments(i2, o2, a)).sort();
    }
    async expandSegments(t2, n2, r2) {
      if (r2.length === 0) return [n2];
      let [s2, ...i2] = r2, o2 = [];
      try {
        if (this.fs.readdirWithFileTypes) {
          let a = await this.fs.readdirWithFileTypes(t2), l = [], c = [...a], u = this.dotglob || this.hasGlobignore;
          if (s2.startsWith(".") || this.dotglob) {
            let p = a.some((m) => m.name === "."), d = a.some((m) => m.name === "..");
            p || c.push({ name: ".", isFile: false, isDirectory: true, isSymbolicLink: false }), d || c.push({ name: "..", isFile: false, isDirectory: true, isSymbolicLink: false });
          }
          for (let p of c) if (!(p.name.startsWith(".") && !s2.startsWith(".") && !u) && this.matchPattern(p.name, s2)) {
            let d = t2 === "/" ? `/${p.name}` : `${t2}/${p.name}`, m;
            n2 === "" ? m = p.name : n2 === "/" ? m = `/${p.name}` : m = `${n2}/${p.name}`, i2.length === 0 ? l.push(Promise.resolve([m])) : p.isDirectory && l.push(this.expandSegments(d, m, i2));
          }
          let f2 = await Promise.all(l);
          for (let p of f2) o2.push(...p);
        } else {
          let a = await this.fs.readdir(t2), l = [], c = [...a], u = this.dotglob || this.hasGlobignore;
          (s2.startsWith(".") || this.dotglob) && (a.includes(".") || c.push("."), a.includes("..") || c.push(".."));
          for (let p of c) if (!(p.startsWith(".") && !s2.startsWith(".") && !u) && this.matchPattern(p, s2)) {
            let d = t2 === "/" ? `/${p}` : `${t2}/${p}`, m;
            n2 === "" ? m = p : n2 === "/" ? m = `/${p}` : m = `${n2}/${p}`, i2.length === 0 ? l.push(Promise.resolve([m])) : l.push((async () => {
              try {
                if ((await this.fs.stat(d)).isDirectory) return this.expandSegments(d, m, i2);
              } catch {
              }
              return [];
            })());
          }
          let f2 = await Promise.all(l);
          for (let p of f2) o2.push(...p);
        }
      } catch {
      }
      return o2;
    }
    async expandRecursive(t2) {
      let n2 = [], r2 = t2.indexOf("**"), s2 = t2.slice(0, r2).replace(/\/$/, "") || ".", o2 = t2.slice(r2 + 2).replace(/^\//, "");
      return o2.includes("**") && this.isGlobstarValid(o2) ? (await this.walkDirectoryMultiGlobstar(s2, o2, n2), [...new Set(n2)].sort()) : (await this.walkDirectory(s2, o2, n2), n2.sort());
    }
    async walkDirectoryMultiGlobstar(t2, n2, r2) {
      let s2 = this.fs.resolvePath(this.cwd, t2);
      try {
        let i2 = this.fs.readdirWithFileTypes ? await this.fs.readdirWithFileTypes(s2) : null;
        if (i2) {
          let o2 = [];
          for (let c of i2) {
            let u = t2 === "." ? c.name : `${t2}/${c.name}`;
            c.isDirectory && o2.push(u);
          }
          let a = t2 === "." ? n2 : `${t2}/${n2}`, l = await this.expandRecursive(a);
          r2.push(...l);
          for (let c = 0; c < o2.length; c += 100) {
            let u = o2.slice(c, c + 100);
            await Promise.all(u.map((f2) => this.walkDirectoryMultiGlobstar(f2, n2, r2)));
          }
        } else {
          let o2 = await this.fs.readdir(s2), a = [];
          for (let u of o2) {
            let f2 = t2 === "." ? u : `${t2}/${u}`, p = this.fs.resolvePath(this.cwd, f2);
            try {
              (await this.fs.stat(p)).isDirectory && a.push(f2);
            } catch {
            }
          }
          let l = t2 === "." ? n2 : `${t2}/${n2}`, c = await this.expandRecursive(l);
          r2.push(...c);
          for (let u = 0; u < a.length; u += 100) {
            let f2 = a.slice(u, u + 100);
            await Promise.all(f2.map((p) => this.walkDirectoryMultiGlobstar(p, n2, r2)));
          }
        }
      } catch {
      }
    }
    async walkDirectory(t2, n2, r2) {
      let s2 = this.fs.resolvePath(this.cwd, t2);
      try {
        if (this.fs.readdirWithFileTypes) {
          let i2 = await this.fs.readdirWithFileTypes(s2), o2 = [], a = [];
          for (let l of i2) {
            let c = t2 === "." ? l.name : `${t2}/${l.name}`;
            l.isDirectory ? a.push(c) : n2 && this.matchPattern(l.name, n2) && o2.push(c);
          }
          r2.push(...o2);
          for (let l = 0; l < a.length; l += 100) {
            let c = a.slice(l, l + 100);
            await Promise.all(c.map((u) => this.walkDirectory(u, n2, r2)));
          }
        } else {
          let i2 = await this.fs.readdir(s2), o2 = [];
          for (let l = 0; l < i2.length; l += 100) {
            let c = i2.slice(l, l + 100), u = await Promise.all(c.map(async (f2) => {
              let p = t2 === "." ? f2 : `${t2}/${f2}`, d = this.fs.resolvePath(this.cwd, p);
              try {
                let m = await this.fs.stat(d);
                return { name: f2, path: p, isDirectory: m.isDirectory };
              } catch {
                return null;
              }
            }));
            o2.push(...u.filter((f2) => f2 !== null));
          }
          for (let l of o2) !l.isDirectory && n2 && this.matchPattern(l.name, n2) && r2.push(l.path);
          let a = o2.filter((l) => l.isDirectory);
          for (let l = 0; l < a.length; l += 100) {
            let c = a.slice(l, l + 100);
            await Promise.all(c.map((u) => this.walkDirectory(u.path, n2, r2)));
          }
        }
      } catch {
      }
    }
    matchPattern(t2, n2) {
      return this.patternToRegex(n2).test(t2);
    }
    patternToRegex(t2) {
      let n2 = this.patternToRegexStr(t2);
      return new RegExp(`^${n2}$`);
    }
    patternToRegexStr(t2) {
      let n2 = "", r2 = false;
      for (let s2 = 0; s2 < t2.length; s2++) {
        if (t2.slice(s2, s2 + 13) === "\0QUOTE_START\0") {
          r2 = true, s2 += 12;
          continue;
        }
        if (t2.slice(s2, s2 + 11) === "\0QUOTE_END\0") {
          r2 = false, s2 += 10;
          continue;
        }
        let i2 = t2[s2];
        if (r2) {
          /[.+^${}()|\\*?[\]]/.test(i2) ? n2 += `\\${i2}` : n2 += i2;
          continue;
        }
        if (this.extglob && (i2 === "@" || i2 === "*" || i2 === "+" || i2 === "?" || i2 === "!") && s2 + 1 < t2.length && t2[s2 + 1] === "(") {
          let o2 = Fa(t2, s2 + 1);
          if (o2 !== -1) {
            let a = t2.slice(s2 + 2, o2), l = _a(a), c = l.map((f2) => this.patternToRegexStr(f2)), u = c.length > 0 ? c.join("|") : "(?:)";
            if (i2 === "@") n2 += `(?:${u})`;
            else if (i2 === "*") n2 += `(?:${u})*`;
            else if (i2 === "+") n2 += `(?:${u})+`;
            else if (i2 === "?") n2 += `(?:${u})?`;
            else if (i2 === "!") if (o2 < t2.length - 1) {
              let p = l.map((m) => this.computePatternLength(m));
              if (p.every((m) => m !== null) && p.every((m) => m === p[0]) && p[0] !== null) {
                let m = p[0];
                if (m === 0) n2 += "(?:.+)";
                else {
                  let h = [];
                  m > 0 && h.push(`.{0,${m - 1}}`), h.push(`.{${m + 1},}`), h.push(`(?!(?:${u})).{${m}}`), n2 += `(?:${h.join("|")})`;
                }
              } else n2 += `(?:(?!(?:${u})).)*?`;
            } else n2 += `(?!(?:${u})$).*`;
            s2 = o2;
            continue;
          }
        }
        if (i2 === "*") n2 += ".*";
        else if (i2 === "?") n2 += ".";
        else if (i2 === "[") {
          let o2 = s2 + 1, a = "[";
          o2 < t2.length && (t2[o2] === "^" || t2[o2] === "!") && (a += "^", o2++), o2 < t2.length && t2[o2] === "]" && (a += "\\]", o2++);
          let l = o2;
          for (; l < t2.length; ) {
            if (t2[l] === "\\" && l + 1 < t2.length) {
              l += 2;
              continue;
            }
            if (t2[l] === "[" && l + 1 < t2.length && t2[l + 1] === ":") {
              let u = t2.indexOf(":]", l + 2);
              if (u !== -1) {
                l = u + 2;
                continue;
              }
            }
            if (t2[l] === "]") break;
            l++;
          }
          let c = o2;
          for (; o2 < t2.length && t2[o2] !== "]"; ) {
            if (t2[o2] === "[" && o2 + 1 < t2.length && t2[o2 + 1] === ":") {
              let u = t2.indexOf(":]", o2 + 2);
              if (u !== -1) {
                let f2 = t2.slice(o2 + 2, u), p = Da(f2);
                a += p, o2 = u + 2;
                continue;
              }
            }
            if (t2[o2] === "\\" && o2 + 1 < t2.length) {
              a += `\\${t2[o2 + 1]}`, o2 += 2;
              continue;
            }
            if (t2[o2] === "-") {
              let u = o2 === c, f2 = o2 + 1 === l;
              u || f2 ? a += "\\-" : a += "-";
            } else a += t2[o2];
            o2++;
          }
          a += "]", n2 += a, s2 = o2;
        } else if (i2 === "\\" && s2 + 1 < t2.length) {
          let o2 = t2[s2 + 1];
          /[.+^${}()|\\*?[\]]/.test(o2) ? n2 += `\\${o2}` : n2 += o2, s2++;
        } else /[.+^${}()|]/.test(i2) ? n2 += `\\${i2}` : n2 += i2;
      }
      return n2;
    }
    computePatternLength(t2) {
      let n2 = 0, r2 = 0, s2 = false;
      for (; r2 < t2.length; ) {
        if (t2.slice(r2, r2 + 13) === "\0QUOTE_START\0") {
          s2 = true, r2 += 13;
          continue;
        }
        if (t2.slice(r2, r2 + 11) === "\0QUOTE_END\0") {
          s2 = false, r2 += 11;
          continue;
        }
        let i2 = t2[r2];
        if (s2) {
          n2 += 1, r2++;
          continue;
        }
        if ((i2 === "@" || i2 === "*" || i2 === "+" || i2 === "?" || i2 === "!") && r2 + 1 < t2.length && t2[r2 + 1] === "(") {
          let o2 = Fa(t2, r2 + 1);
          if (o2 !== -1) {
            if (i2 === "@") {
              let a = t2.slice(r2 + 2, o2), c = _a(a).map((u) => this.computePatternLength(u));
              if (c.every((u) => u !== null) && c.every((u) => u === c[0])) {
                n2 += c[0], r2 = o2 + 1;
                continue;
              }
              return null;
            }
            return null;
          }
        }
        if (i2 === "*") return null;
        if (i2 === "?") {
          n2 += 1, r2++;
          continue;
        }
        if (i2 === "[") {
          let o2 = t2.indexOf("]", r2 + 1);
          if (o2 !== -1) {
            n2 += 1, r2 = o2 + 1;
            continue;
          }
          n2 += 1, r2++;
          continue;
        }
        if (i2 === "\\") {
          n2 += 1, r2 += 2;
          continue;
        }
        n2 += 1, r2++;
      }
      return n2;
    }
  };
});
function La(e2) {
  for (let t2 = 0; t2 < e2.length; t2++) {
    if (e2[t2] === "\\") {
      t2++;
      continue;
    }
    if (e2[t2] === "$") {
      let n2 = e2[t2 + 1];
      if (n2 === "{" || n2 && /[a-zA-Z_]/.test(n2)) return true;
    }
  }
  return false;
}
function FC(e2) {
  var _a3;
  if (!e2.operation) return false;
  let t2 = e2.operation, n2;
  if ((t2.type === "DefaultValue" || t2.type === "AssignDefault" || t2.type === "UseAlternative" || t2.type === "ErrorIfUnset") && (n2 = (_a3 = t2.word) == null ? void 0 : _a3.parts), !n2) return false;
  for (let r2 of n2) if (r2.type === "DoubleQuoted" || r2.type === "SingleQuoted") return true;
  return false;
}
function rg(e2) {
  var _a3;
  if (!e2.operation) return false;
  let t2 = e2.operation, n2;
  if ((t2.type === "DefaultValue" || t2.type === "AssignDefault" || t2.type === "UseAlternative" || t2.type === "ErrorIfUnset") && (n2 = (_a3 = t2.word) == null ? void 0 : _a3.parts), !n2 || n2.length === 0) return false;
  for (let r2 of n2) if (r2.type !== "DoubleQuoted" && r2.type !== "SingleQuoted") return false;
  return true;
}
function Lr(e2) {
  var _a3, _b3, _c2, _d2, _e2, _f2;
  let t2 = false, n2 = false, r2 = false, s2 = false, i2 = false, o2 = false, a = false;
  for (let l of e2) {
    if ((l.type === "SingleQuoted" || l.type === "DoubleQuoted") && (t2 = true, l.type === "DoubleQuoted")) for (let c of l.parts) c.type === "ParameterExpansion" && (c.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/) && (!c.operation || c.operation.type === "PatternRemoval" || c.operation.type === "PatternReplacement") && (s2 = true), (((_a3 = c.operation) == null ? void 0 : _a3.type) === "VarNamePrefix" || ((_b3 = c.operation) == null ? void 0 : _b3.type) === "ArrayKeys") && (o2 = true), ((_c2 = c.operation) == null ? void 0 : _c2.type) === "Indirection" && (a = true));
    l.type === "CommandSubstitution" && (n2 = true), l.type === "ParameterExpansion" && (i2 = true, (l.parameter === "@" || l.parameter === "*") && (r2 = true), FC(l) && (t2 = true), (((_d2 = l.operation) == null ? void 0 : _d2.type) === "VarNamePrefix" || ((_e2 = l.operation) == null ? void 0 : _e2.type) === "ArrayKeys") && (o2 = true), ((_f2 = l.operation) == null ? void 0 : _f2.type) === "Indirection" && (a = true)), l.type === "Glob" && La(l.pattern) && (i2 = true);
  }
  return { hasQuoted: t2, hasCommandSub: n2, hasArrayVar: r2, hasArrayAtExpansion: s2, hasParamExpansion: i2, hasVarNamePrefixExpansion: o2, hasIndirection: a };
}
var ei = v(() => {
});
function _e(e2, t2) {
  let n2 = `${t2}_`, r2 = [];
  for (let s2 of Object.keys(e2.state.env)) if (s2.startsWith(n2)) {
    let i2 = s2.slice(n2.length), o2 = Number.parseInt(i2, 10);
    !Number.isNaN(o2) && String(o2) === i2 && r2.push(o2);
  }
  return r2.sort((s2, i2) => s2 - i2);
}
function Ut(e2, t2) {
  let n2 = `${t2}_`;
  for (let r2 of Object.keys(e2.state.env)) r2.startsWith(n2) && delete e2.state.env[r2];
}
function Pt(e2, t2) {
  let n2 = `${t2}_`, r2 = `${t2}__length`, s2 = [];
  for (let i2 of Object.keys(e2.state.env)) if (i2 !== r2 && i2.startsWith(n2)) {
    let o2 = i2.slice(n2.length);
    if (o2.startsWith("_length")) continue;
    s2.push(o2);
  }
  return s2.sort();
}
function ti(e2) {
  return e2.startsWith("'") && e2.endsWith("'") || e2.startsWith('"') && e2.endsWith('"') ? e2.slice(1, -1) : e2;
}
function Ma(e2) {
  if (e2.parts.length < 2) return null;
  let t2 = e2.parts[0], n2 = e2.parts[1];
  if (t2.type !== "Glob" || !t2.pattern.startsWith("[")) return null;
  let r2, s2 = n2, i2 = 1;
  if (n2.type === "Literal" && n2.value.startsWith("]")) {
    let f2 = n2.value.slice(1);
    if (f2.startsWith("+=") || f2.startsWith("=")) r2 = t2.pattern.slice(1);
    else if (f2 === "") {
      if (e2.parts.length < 3) return null;
      let p = e2.parts[2];
      if (p.type !== "Literal" || !p.value.startsWith("=") && !p.value.startsWith("+=")) return null;
      r2 = t2.pattern.slice(1), s2 = p, i2 = 2;
    } else return null;
  } else if (t2.pattern === "[" && (n2.type === "DoubleQuoted" || n2.type === "SingleQuoted")) {
    if (e2.parts.length < 3) return null;
    let f2 = e2.parts[2];
    if (f2.type !== "Literal" || !f2.value.startsWith("]=") && !f2.value.startsWith("]+=")) return null;
    if (n2.type === "SingleQuoted") r2 = n2.value;
    else {
      r2 = "";
      for (let p of n2.parts) (p.type === "Literal" || p.type === "Escaped") && (r2 += p.value);
    }
    s2 = f2, i2 = 2;
  } else if (t2.pattern.endsWith("]")) {
    if (n2.type !== "Literal" || !n2.value.startsWith("=") && !n2.value.startsWith("+=")) return null;
    r2 = t2.pattern.slice(1, -1);
  } else return null;
  r2 = ti(r2);
  let o2;
  if (s2.type !== "Literal") return null;
  s2.value.startsWith("]=") || s2.value.startsWith("]+=") ? o2 = s2.value.slice(1) : o2 = s2.value;
  let a = o2.startsWith("+=");
  if (!a && !o2.startsWith("=")) return null;
  let l = [], c = a ? 2 : 1, u = o2.slice(c);
  u && l.push({ type: "Literal", value: u });
  for (let f2 = i2 + 1; f2 < e2.parts.length; f2++) {
    let p = e2.parts[f2];
    p.type === "BraceExpansion" ? l.push({ type: "Literal", value: _C(p) }) : l.push(p);
  }
  return { key: r2, valueParts: l, append: a };
}
function _C(e2) {
  return `{${e2.items.map((n2) => {
    if (n2.type === "Range") {
      let r2 = n2.startStr ?? String(n2.start), s2 = n2.endStr ?? String(n2.end), i2 = `${r2}..${s2}`;
      return n2.step && (i2 += `..${n2.step}`), i2;
    }
    return Yn(n2.word);
  }).join(",")}}`;
}
function Yn(e2) {
  let t2 = "";
  for (let n2 of e2.parts) switch (n2.type) {
    case "Literal":
      t2 += n2.value;
      break;
    case "Glob":
      t2 += n2.pattern;
      break;
    case "SingleQuoted":
      t2 += n2.value;
      break;
    case "DoubleQuoted":
      for (let r2 of n2.parts) (r2.type === "Literal" || r2.type === "Escaped") && (t2 += r2.value);
      break;
    case "Escaped":
      t2 += n2.value;
      break;
    case "BraceExpansion":
      t2 += "{", t2 += n2.items.map((r2) => r2.type === "Range" ? `${r2.startStr}..${r2.endStr}${r2.step ? `..${r2.step}` : ""}` : Yn(r2.word)).join(","), t2 += "}";
      break;
    case "TildeExpansion":
      t2 += "~", n2.user && (t2 += n2.user);
      break;
  }
  return t2;
}
var $t = v(() => {
});
function Ue(e2) {
  return e2.IFS ?? ` 	
`;
}
function Ze(e2) {
  return e2.IFS === "";
}
function ni(e2) {
  let t2 = Ue(e2);
  if (t2 === "") return true;
  for (let n2 of t2) if (n2 !== " " && n2 !== "	" && n2 !== `
`) return false;
  return true;
}
function sg(e2) {
  return e2.split("").map((t2) => /[\\^$.*+?()[\]{}|-]/.test(t2) ? `\\${t2}` : t2 === "	" ? "\\t" : t2 === `
` ? "\\n" : t2).join("");
}
function oe(e2) {
  let t2 = e2.IFS;
  return t2 === void 0 ? " " : t2[0] || "";
}
function MC(e2) {
  return LC.includes(e2);
}
function Wa(e2) {
  let t2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set();
  for (let r2 of e2) MC(r2) ? t2.add(r2) : n2.add(r2);
  return { whitespace: t2, nonWhitespace: n2 };
}
function Ba(e2, t2, n2, r2) {
  if (t2 === "") return e2 === "" ? { words: [], wordStarts: [] } : { words: [e2], wordStarts: [0] };
  let { whitespace: s2, nonWhitespace: i2 } = Wa(t2), o2 = [], a = [], l = 0;
  for (; l < e2.length && s2.has(e2[l]); ) l++;
  if (l >= e2.length) return { words: [], wordStarts: [] };
  if (i2.has(e2[l])) for (o2.push(""), a.push(l), l++; l < e2.length && s2.has(e2[l]); ) l++;
  for (; l < e2.length && !(n2 !== void 0 && o2.length >= n2); ) {
    let c = l;
    for (a.push(c); l < e2.length; ) {
      let u = e2[l];
      if (!r2 && u === "\\") {
        l++, l < e2.length && l++;
        continue;
      }
      if (s2.has(u) || i2.has(u)) break;
      l++;
    }
    if (o2.push(e2.substring(c, l)), l >= e2.length) break;
    for (; l < e2.length && s2.has(e2[l]); ) l++;
    if (l < e2.length && i2.has(e2[l])) {
      for (l++; l < e2.length && s2.has(e2[l]); ) l++;
      for (; l < e2.length && i2.has(e2[l]) && !(n2 !== void 0 && o2.length >= n2); ) for (o2.push(""), a.push(l), l++; l < e2.length && s2.has(e2[l]); ) l++;
    }
  }
  return { words: o2, wordStarts: a };
}
function ri(e2, t2) {
  if (t2 === "") return { words: e2 ? [e2] : [], hadLeadingDelimiter: false, hadTrailingDelimiter: false };
  if (e2 === "") return { words: [], hadLeadingDelimiter: false, hadTrailingDelimiter: false };
  let { whitespace: n2, nonWhitespace: r2 } = Wa(t2), s2 = [], i2 = 0, o2 = false, a = false, l = i2;
  for (; i2 < e2.length && n2.has(e2[i2]); ) i2++;
  if (i2 > l && (o2 = true), i2 >= e2.length) return { words: [], hadLeadingDelimiter: true, hadTrailingDelimiter: true };
  if (r2.has(e2[i2])) for (s2.push(""), i2++; i2 < e2.length && n2.has(e2[i2]); ) i2++;
  for (; i2 < e2.length; ) {
    let c = i2;
    for (; i2 < e2.length; ) {
      let f2 = e2[i2];
      if (n2.has(f2) || r2.has(f2)) break;
      i2++;
    }
    if (s2.push(e2.substring(c, i2)), i2 >= e2.length) {
      a = false;
      break;
    }
    let u = i2;
    for (; i2 < e2.length && n2.has(e2[i2]); ) i2++;
    if (i2 < e2.length && r2.has(e2[i2])) {
      for (i2++; i2 < e2.length && n2.has(e2[i2]); ) i2++;
      for (; i2 < e2.length && r2.has(e2[i2]); ) for (s2.push(""), i2++; i2 < e2.length && n2.has(e2[i2]); ) i2++;
    }
    i2 >= e2.length && i2 > u && (a = true);
  }
  return { words: s2, hadLeadingDelimiter: o2, hadTrailingDelimiter: a };
}
function Ae(e2, t2) {
  return ri(e2, t2).words;
}
function WC(e2, t2) {
  for (let n2 of e2) if (t2.has(n2)) return true;
  return false;
}
function ig(e2, t2, n2) {
  if (t2 === "") return e2;
  let { whitespace: r2, nonWhitespace: s2 } = Wa(t2), i2 = e2.length;
  for (; i2 > 0 && r2.has(e2[i2 - 1]); ) {
    if (!n2 && i2 >= 2) {
      let a = 0, l = i2 - 2;
      for (; l >= 0 && e2[l] === "\\"; ) a++, l--;
      if (a % 2 === 1) break;
    }
    i2--;
  }
  let o2 = e2.substring(0, i2);
  if (o2.length >= 1 && s2.has(o2[o2.length - 1])) {
    if (!n2 && o2.length >= 2) {
      let l = 0, c = o2.length - 2;
      for (; c >= 0 && o2[c] === "\\"; ) l++, c--;
      if (l % 2 === 1) return o2;
    }
    let a = o2.substring(0, o2.length - 1);
    if (!WC(a, s2)) return a;
  }
  return o2;
}
var LC, St = v(() => {
  LC = ` 	
`;
});
function Se(e2, t2) {
  var _a3;
  return ((_a3 = e2.state.namerefs) == null ? void 0 : _a3.has(t2)) ?? false;
}
function Zt(e2, t2) {
  var _a3;
  (_a3 = e2.state).namerefs ?? (_a3.namerefs = /* @__PURE__ */ new Set()), e2.state.namerefs.add(t2);
}
function og(e2, t2) {
  var _a3, _b3, _c2;
  (_a3 = e2.state.namerefs) == null ? void 0 : _a3.delete(t2), (_b3 = e2.state.boundNamerefs) == null ? void 0 : _b3.delete(t2), (_c2 = e2.state.invalidNamerefs) == null ? void 0 : _c2.delete(t2);
}
function ag(e2, t2) {
  var _a3;
  (_a3 = e2.state).invalidNamerefs ?? (_a3.invalidNamerefs = /* @__PURE__ */ new Set()), e2.state.invalidNamerefs.add(t2);
}
function lg(e2, t2) {
  var _a3;
  return ((_a3 = e2.state.invalidNamerefs) == null ? void 0 : _a3.has(t2)) ?? false;
}
function Ua(e2, t2) {
  var _a3;
  (_a3 = e2.state).boundNamerefs ?? (_a3.boundNamerefs = /* @__PURE__ */ new Set()), e2.state.boundNamerefs.add(t2);
}
function si(e2, t2) {
  var _a3;
  let n2 = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (n2) {
    let s2 = n2[1], i2 = Object.keys(e2.state.env).some((a) => a.startsWith(`${s2}_`) && !a.includes("__")), o2 = ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(s2)) ?? false;
    return i2 || o2;
  }
  return Object.keys(e2.state.env).some((s2) => s2.startsWith(`${t2}_`) && !s2.includes("__")) ? true : e2.state.env[t2] !== void 0;
}
function st(e2, t2, n2 = 100) {
  if (!Se(e2, t2) || lg(e2, t2)) return t2;
  let r2 = /* @__PURE__ */ new Set(), s2 = t2;
  for (; n2-- > 0; ) {
    if (r2.has(s2)) return;
    if (r2.add(s2), !Se(e2, s2)) return s2;
    let i2 = e2.state.env[s2];
    if (i2 === void 0 || i2 === "" || !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(i2)) return s2;
    s2 = i2;
  }
}
function kn(e2, t2) {
  if (Se(e2, t2)) return e2.state.env[t2];
}
function cg(e2, t2, n2, r2 = 100) {
  if (!Se(e2, t2) || lg(e2, t2)) return t2;
  let s2 = /* @__PURE__ */ new Set(), i2 = t2;
  for (; r2-- > 0; ) {
    if (s2.has(i2)) return;
    if (s2.add(i2), !Se(e2, i2)) return i2;
    let o2 = e2.state.env[i2];
    if (o2 === void 0 || o2 === "") return n2 !== void 0 ? /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(n2) && si(e2, n2) ? i2 : null : i2;
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(o2)) return i2;
    i2 = o2;
  }
}
var Tt = v(() => {
});
function BC(e2, t2) {
  let n2 = t2.replace(/\$\{([a-zA-Z_][a-zA-Z0-9_]*)\}/g, (r2, s2) => e2.state.env[s2] ?? "");
  return n2 = n2.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (r2, s2) => e2.state.env[s2] ?? ""), n2;
}
function te(e2, t2) {
  var _a3;
  return t2 === "FUNCNAME" ? (e2.state.funcNameStack ?? []).map((i2, o2) => [o2, i2]) : t2 === "BASH_LINENO" ? (e2.state.callLineStack ?? []).map((i2, o2) => [o2, String(i2)]) : t2 === "BASH_SOURCE" ? (e2.state.sourceStack ?? []).map((i2, o2) => [o2, i2]) : ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(t2)) ? Pt(e2, t2).map((i2) => [i2, e2.state.env[`${t2}_${i2}`]]) : _e(e2, t2).map((s2) => [s2, e2.state.env[`${t2}_${s2}`]]);
}
function Qt(e2, t2) {
  var _a3, _b3, _c2, _d2;
  return t2 === "FUNCNAME" ? (((_a3 = e2.state.funcNameStack) == null ? void 0 : _a3.length) ?? 0) > 0 : t2 === "BASH_LINENO" ? (((_b3 = e2.state.callLineStack) == null ? void 0 : _b3.length) ?? 0) > 0 : t2 === "BASH_SOURCE" ? (((_c2 = e2.state.sourceStack) == null ? void 0 : _c2.length) ?? 0) > 0 : ((_d2 = e2.state.associativeArrays) == null ? void 0 : _d2.has(t2)) ? Pt(e2, t2).length > 0 : _e(e2, t2).length > 0;
}
async function me(e2, t2, n2 = true, r2 = false) {
  var _a3, _b3, _c2, _d2, _e2, _f2, _g2, _h2, _i2;
  switch (t2) {
    case "?":
      return String(e2.state.lastExitCode);
    case "$":
      return String(process.pid);
    case "#":
      return e2.state.env["#"] || "0";
    case "@":
      return e2.state.env["@"] || "";
    case "_":
      return e2.state.lastArg;
    case "-": {
      let o2 = "";
      return o2 += "h", e2.state.options.errexit && (o2 += "e"), e2.state.options.noglob && (o2 += "f"), e2.state.options.nounset && (o2 += "u"), e2.state.options.verbose && (o2 += "v"), e2.state.options.xtrace && (o2 += "x"), o2 += "B", e2.state.options.noclobber && (o2 += "C"), o2 += "s", o2;
    }
    case "*": {
      let o2 = Number.parseInt(e2.state.env["#"] || "0", 10);
      if (o2 === 0) return "";
      let a = [];
      for (let l = 1; l <= o2; l++) a.push(e2.state.env[String(l)] || "");
      return a.join(oe(e2.state.env));
    }
    case "0":
      return e2.state.env[0] || "bash";
    case "PWD":
      return e2.state.env.PWD !== void 0 ? e2.state.env.PWD : "";
    case "OLDPWD":
      return e2.state.env.OLDPWD !== void 0 ? e2.state.env.OLDPWD : "";
    case "PPID": {
      let { ppid: o2 } = Dr();
      return String(o2);
    }
    case "UID": {
      let { uid: o2 } = Dr();
      return String(o2);
    }
    case "EUID":
      return String(((_a3 = process.geteuid) == null ? void 0 : _a3.call(process)) ?? Dr().uid);
    case "RANDOM":
      return String(Math.floor(Math.random() * 32768));
    case "SECONDS":
      return String(Math.floor((Date.now() - e2.state.startTime) / 1e3));
    case "BASH_VERSION":
      return rm;
    case "!":
      return String(e2.state.lastBackgroundPid);
    case "BASHPID":
      return String(e2.state.bashPid);
    case "LINENO":
      return String(e2.state.currentLine);
    case "FUNCNAME": {
      let o2 = (_b3 = e2.state.funcNameStack) == null ? void 0 : _b3[0];
      if (o2 !== void 0) return o2;
      if (n2 && e2.state.options.nounset) throw new tt("FUNCNAME");
      return "";
    }
    case "BASH_LINENO": {
      let o2 = (_c2 = e2.state.callLineStack) == null ? void 0 : _c2[0];
      if (o2 !== void 0) return String(o2);
      if (n2 && e2.state.options.nounset) throw new tt("BASH_LINENO");
      return "";
    }
    case "BASH_SOURCE": {
      let o2 = (_d2 = e2.state.sourceStack) == null ? void 0 : _d2[0];
      if (o2 !== void 0) return o2;
      if (n2 && e2.state.options.nounset) throw new tt("BASH_SOURCE");
      return "";
    }
  }
  if (/^[a-zA-Z_][a-zA-Z0-9_]*\[\]$/.test(t2)) throw new nt(`\${${t2}}`);
  let s2 = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (s2) {
    let o2 = s2[1], a = s2[2];
    if (Se(e2, o2)) {
      let f2 = st(e2, o2);
      if (f2 && f2 !== o2) {
        if (f2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/)) return "";
        o2 = f2;
      }
    }
    if (a === "@" || a === "*") {
      let f2 = te(e2, o2);
      if (f2.length > 0) return f2.map(([, d]) => d).join(" ");
      let p = e2.state.env[o2];
      return p !== void 0 ? p : "";
    }
    if (o2 === "FUNCNAME") {
      let f2 = Number.parseInt(a, 10);
      return !Number.isNaN(f2) && f2 >= 0 ? ((_e2 = e2.state.funcNameStack) == null ? void 0 : _e2[f2]) ?? "" : "";
    }
    if (o2 === "BASH_LINENO") {
      let f2 = Number.parseInt(a, 10);
      if (!Number.isNaN(f2) && f2 >= 0) {
        let p = (_f2 = e2.state.callLineStack) == null ? void 0 : _f2[f2];
        return p !== void 0 ? String(p) : "";
      }
      return "";
    }
    if (o2 === "BASH_SOURCE") {
      let f2 = Number.parseInt(a, 10);
      return !Number.isNaN(f2) && f2 >= 0 ? ((_g2 = e2.state.sourceStack) == null ? void 0 : _g2[f2]) ?? "" : "";
    }
    if ((_h2 = e2.state.associativeArrays) == null ? void 0 : _h2.has(o2)) {
      let f2 = ti(a);
      f2 = BC(e2, f2);
      let p = e2.state.env[`${o2}_${f2}`];
      if (p === void 0 && n2 && e2.state.options.nounset) throw new tt(`${o2}[${a}]`);
      return p || "";
    }
    let c;
    if (/^-?\d+$/.test(a)) c = Number.parseInt(a, 10);
    else try {
      let f2 = new se(), p = he(f2, a);
      c = await Q(e2, p.expression);
    } catch {
      let f2 = e2.state.env[a];
      c = f2 ? Number.parseInt(f2, 10) : 0, Number.isNaN(c) && (c = 0);
    }
    if (c < 0) {
      let f2 = te(e2, o2), p = e2.state.currentLine;
      if (f2.length === 0) return e2.state.expansionStderr = (e2.state.expansionStderr || "") + `bash: line ${p}: ${o2}: bad array subscript
`, "";
      let m = Math.max(...f2.map(([g]) => typeof g == "number" ? g : 0)) + 1 + c;
      return m < 0 ? (e2.state.expansionStderr = (e2.state.expansionStderr || "") + `bash: line ${p}: ${o2}: bad array subscript
`, "") : e2.state.env[`${o2}_${m}`] || "";
    }
    let u = e2.state.env[`${o2}_${c}`];
    if (u !== void 0) return u;
    if (c === 0) {
      let f2 = e2.state.env[o2];
      if (f2 !== void 0) return f2;
    }
    if (n2 && e2.state.options.nounset) throw new tt(`${o2}[${c}]`);
    return "";
  }
  if (/^[1-9][0-9]*$/.test(t2)) {
    let o2 = e2.state.env[t2];
    if (o2 === void 0 && n2 && e2.state.options.nounset) throw new tt(t2);
    return o2 || "";
  }
  if (Se(e2, t2)) {
    let o2 = st(e2, t2);
    if (o2 === void 0) return "";
    if (o2 !== t2) return await me(e2, o2, n2, r2);
    let a = e2.state.env[t2];
    if ((a === void 0 || a === "") && n2 && e2.state.options.nounset) throw new tt(t2);
    return a || "";
  }
  let i2 = e2.state.env[t2];
  if (i2 !== void 0) return ((_i2 = e2.state.tempEnvBindings) == null ? void 0 : _i2.some((o2) => o2.has(t2))) && (e2.state.accessedTempEnvVars = e2.state.accessedTempEnvVars || /* @__PURE__ */ new Set(), e2.state.accessedTempEnvVars.add(t2)), i2;
  if (Qt(e2, t2)) {
    let o2 = e2.state.env[`${t2}_0`];
    return o2 !== void 0 ? o2 : "";
  }
  if (n2 && e2.state.options.nounset) throw new tt(t2);
  return "";
}
async function zt(e2, t2) {
  var _a3;
  if ((/* @__PURE__ */ new Set(["?", "$", "#", "_", "-", "0", "PPID", "UID", "EUID", "RANDOM", "SECONDS", "BASH_VERSION", "!", "BASHPID", "LINENO"])).has(t2)) return true;
  if (t2 === "@" || t2 === "*") return Number.parseInt(e2.state.env["#"] || "0", 10) > 0;
  if (t2 === "PWD" || t2 === "OLDPWD") return t2 in e2.state.env;
  let r2 = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (r2) {
    let s2 = r2[1], i2 = r2[2];
    if (Se(e2, s2)) {
      let l = st(e2, s2);
      if (l && l !== s2) {
        if (l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/)) return false;
        s2 = l;
      }
    }
    if (i2 === "@" || i2 === "*") return te(e2, s2).length > 0 ? true : s2 in e2.state.env;
    if ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(s2)) {
      let l = ti(i2);
      return `${s2}_${l}` in e2.state.env;
    }
    let a;
    if (/^-?\d+$/.test(i2)) a = Number.parseInt(i2, 10);
    else try {
      let l = new se(), c = he(l, i2);
      a = await Q(e2, c.expression);
    } catch {
      let l = e2.state.env[i2];
      a = l ? Number.parseInt(l, 10) : 0, Number.isNaN(a) && (a = 0);
    }
    if (a < 0) {
      let l = te(e2, s2);
      if (l.length === 0) return false;
      let u = Math.max(...l.map(([f2]) => typeof f2 == "number" ? f2 : 0)) + 1 + a;
      return u < 0 ? false : `${s2}_${u}` in e2.state.env;
    }
    return `${s2}_${a}` in e2.state.env;
  }
  if (Se(e2, t2)) {
    let s2 = st(e2, t2);
    return s2 === void 0 || s2 === t2 ? t2 in e2.state.env : zt(e2, s2);
  }
  return !!(t2 in e2.state.env || Qt(e2, t2));
}
var ht = v(() => {
  Je();
  Fe();
  ca();
  it();
  de();
  $t();
  St();
  Tt();
});
async function ug(e2, t2) {
  let n2 = "", r2 = 0;
  for (; r2 < t2.length; ) {
    if (t2[r2] === "$") {
      if (t2[r2 + 1] === "{") {
        let s2 = 1, i2 = r2 + 2;
        for (; i2 < t2.length && s2 > 0; ) t2[i2] === "{" ? s2++ : t2[i2] === "}" && s2--, i2++;
        n2 += t2.slice(r2, i2), r2 = i2;
        continue;
      }
      if (t2[r2 + 1] === "(") {
        let s2 = 1, i2 = r2 + 2;
        for (; i2 < t2.length && s2 > 0; ) t2[i2] === "(" ? s2++ : t2[i2] === ")" && s2--, i2++;
        n2 += t2.slice(r2, i2), r2 = i2;
        continue;
      }
      if (/[a-zA-Z_]/.test(t2[r2 + 1] || "")) {
        let s2 = r2 + 1;
        for (; s2 < t2.length && /[a-zA-Z0-9_]/.test(t2[s2]); ) s2++;
        let i2 = t2.slice(r2 + 1, s2), o2 = await me(e2, i2);
        n2 += o2, r2 = s2;
        continue;
      }
      if (/[0-9]/.test(t2[r2 + 1] || "")) {
        let s2 = r2 + 1;
        for (; s2 < t2.length && /[0-9]/.test(t2[s2]); ) s2++;
        let i2 = t2.slice(r2 + 1, s2), o2 = await me(e2, i2);
        n2 += o2, r2 = s2;
        continue;
      }
      if (/[*@#?\-!$]/.test(t2[r2 + 1] || "")) {
        let s2 = t2[r2 + 1], i2 = await me(e2, s2);
        n2 += i2, r2 += 2;
        continue;
      }
    }
    if (t2[r2] === '"') {
      for (n2 += '"', r2++; r2 < t2.length && t2[r2] !== '"'; ) if (t2[r2] === "$" && /[a-zA-Z_]/.test(t2[r2 + 1] || "")) {
        let s2 = r2 + 1;
        for (; s2 < t2.length && /[a-zA-Z0-9_]/.test(t2[s2]); ) s2++;
        let i2 = t2.slice(r2 + 1, s2), o2 = await me(e2, i2);
        n2 += o2, r2 = s2;
      } else t2[r2] === "\\" ? (n2 += t2[r2], r2++, r2 < t2.length && (n2 += t2[r2], r2++)) : (n2 += t2[r2], r2++);
      r2 < t2.length && (n2 += '"', r2++);
      continue;
    }
    n2 += t2[r2], r2++;
  }
  return n2;
}
async function za(e2, t2) {
  let n2 = t2, r2 = t2.startsWith('"') && t2.endsWith('"'), s2 = t2.startsWith("'") && t2.endsWith("'");
  if ((r2 || s2) && (n2 = t2.slice(1, -1)), s2) return n2;
  let i2 = "", o2 = 0;
  for (; o2 < n2.length; ) if (n2[o2] === "$") if (n2[o2 + 1] === "(") {
    let a = 1, l = o2 + 2;
    for (; l < n2.length && a > 0; ) n2[l] === "(" && n2[l - 1] === "$" || n2[l] === "(" ? a++ : n2[l] === ")" && a--, l++;
    let c = n2.slice(o2 + 2, l - 1);
    if (e2.execFn) {
      let u = await e2.execFn(c);
      i2 += u.stdout.replace(/\n+$/, ""), u.stderr && (e2.state.expansionStderr = (e2.state.expansionStderr || "") + u.stderr);
    }
    o2 = l;
  } else if (n2[o2 + 1] === "{") {
    let a = 1, l = o2 + 2;
    for (; l < n2.length && a > 0; ) n2[l] === "{" ? a++ : n2[l] === "}" && a--, l++;
    let c = n2.slice(o2 + 2, l - 1), u = await me(e2, c);
    i2 += u, o2 = l;
  } else if (/[a-zA-Z_]/.test(n2[o2 + 1] || "")) {
    let a = o2 + 1;
    for (; a < n2.length && /[a-zA-Z0-9_]/.test(n2[a]); ) a++;
    let l = n2.slice(o2 + 1, a), c = await me(e2, l);
    i2 += c, o2 = a;
  } else i2 += n2[o2], o2++;
  else if (n2[o2] === "`") {
    let a = o2 + 1;
    for (; a < n2.length && n2[a] !== "`"; ) a++;
    let l = n2.slice(o2 + 1, a);
    if (e2.execFn) {
      let c = await e2.execFn(l);
      i2 += c.stdout.replace(/\n+$/, ""), c.stderr && (e2.state.expansionStderr = (e2.state.expansionStderr || "") + c.stderr);
    }
    o2 = a + 1;
  } else i2 += n2[o2], o2++;
  return i2;
}
var fg = v(() => {
  ht();
});
function UC(e2, t2, n2, r2, s2) {
  let i2 = n2 ?? 1;
  i2 === 0 && (i2 = 1);
  let o2 = Math.abs(i2), a = [], l = 0;
  (r2 == null ? void 0 : r2.match(/^-?0\d/)) && (l = Math.max(l, r2.replace(/^-/, "").length)), (s2 == null ? void 0 : s2.match(/^-?0\d/)) && (l = Math.max(l, s2.replace(/^-/, "").length));
  let c = (u) => {
    if (l > 0) {
      let f2 = u < 0, p = String(Math.abs(u)).padStart(l, "0");
      return f2 ? `-${p}` : p;
    }
    return String(u);
  };
  if (e2 <= t2) for (let u = e2, f2 = 0; u <= t2 && f2 < ii; u += o2, f2++) a.push(c(u));
  else for (let u = e2, f2 = 0; u >= t2 && f2 < ii; u -= o2, f2++) a.push(c(u));
  return a;
}
function zC(e2, t2, n2) {
  let r2 = n2 ?? 1;
  r2 === 0 && (r2 = 1);
  let s2 = e2.charCodeAt(0), i2 = t2.charCodeAt(0), o2 = Math.abs(r2), a = e2 >= "A" && e2 <= "Z", l = e2 >= "a" && e2 <= "z", c = t2 >= "A" && t2 <= "Z", u = t2 >= "a" && t2 <= "z";
  if (a && u || l && c) {
    let p = n2 !== void 0 ? `..${n2}` : "";
    throw new Fn(`{${e2}..${t2}${p}}: invalid sequence`);
  }
  let f2 = [];
  if (s2 <= i2) for (let p = s2, d = 0; p <= i2 && d < ii; p += o2, d++) f2.push(String.fromCharCode(p));
  else for (let p = s2, d = 0; p >= i2 && d < ii; p -= o2, d++) f2.push(String.fromCharCode(p));
  return f2;
}
function ja(e2, t2, n2, r2, s2) {
  let i2 = n2 !== void 0 ? `..${n2}` : "";
  return typeof e2 == "number" && typeof t2 == "number" ? { expanded: UC(e2, t2, n2, r2, s2), literal: `{${e2}..${t2}${i2}}` } : typeof e2 == "string" && typeof t2 == "string" ? { expanded: zC(e2, t2, n2), literal: `{${e2}..${t2}${i2}}` } : { expanded: null, literal: `{${e2}..${t2}${i2}}` };
}
var ii, pg = v(() => {
  de();
  ii = 1e4;
});
function dg(e2) {
  if (e2.statements.length !== 1) return null;
  let t2 = e2.statements[0];
  if (t2.operators.length !== 0 || t2.pipelines.length !== 1) return null;
  let n2 = t2.pipelines[0];
  if (n2.negated || n2.commands.length !== 1) return null;
  let r2 = n2.commands[0];
  if (r2.type !== "SimpleCommand") return null;
  let s2 = r2;
  if (s2.name !== null || s2.args.length !== 0 || s2.assignments.length !== 0 || s2.redirections.length !== 1) return null;
  let i2 = s2.redirections[0];
  return i2.operator !== "<" || i2.target.type !== "Word" ? null : { target: i2.target };
}
var hg = v(() => {
});
function jt(e2, t2) {
  return !!(/[*?[]/.test(e2) || t2 && /[@*+?!]\(/.test(e2));
}
function Ha(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) e2[n2] === "\\" && n2 + 1 < e2.length ? (t2 += e2[n2 + 1], n2 += 2) : (t2 += e2[n2], n2++);
  return t2;
}
function mt(e2) {
  return e2.replace(/([*?[\]\\()|])/g, "\\$1");
}
function er(e2) {
  return e2.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
}
var tr = v(() => {
});
function pe(e2) {
  return e2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var nr = v(() => {
});
function ce(e2, t2, n2 = false) {
  let r2 = "", s2 = 0;
  for (; s2 < e2.length; ) {
    let i2 = e2[s2];
    if (n2 && (i2 === "@" || i2 === "*" || i2 === "+" || i2 === "?" || i2 === "!") && s2 + 1 < e2.length && e2[s2 + 1] === "(") {
      let o2 = jC(e2, s2 + 1);
      if (o2 !== -1) {
        let a = e2.slice(s2 + 2, o2), c = HC(a).map((f2) => ce(f2, t2, n2)), u = c.length > 0 ? c.join("|") : "(?:)";
        i2 === "@" ? r2 += `(?:${u})` : i2 === "*" ? r2 += `(?:${u})*` : i2 === "+" ? r2 += `(?:${u})+` : i2 === "?" ? r2 += `(?:${u})?` : i2 === "!" && (r2 += `(?!(?:${u})$).*`), s2 = o2 + 1;
        continue;
      }
    }
    if (i2 === "\\") if (s2 + 1 < e2.length) {
      let o2 = e2[s2 + 1];
      /[\\^$.|+(){}[\]*?]/.test(o2) ? r2 += `\\${o2}` : r2 += o2, s2 += 2;
    } else r2 += "\\\\", s2++;
    else if (i2 === "*") r2 += t2 ? ".*" : ".*?", s2++;
    else if (i2 === "?") r2 += ".", s2++;
    else if (i2 === "[") {
      let o2 = VC(e2, s2);
      if (o2 === -1) r2 += "\\[", s2++;
      else {
        let a = e2.slice(s2 + 1, o2);
        r2 += qC(a), s2 = o2 + 1;
      }
    } else /[\^$.|+(){}]/.test(i2) ? (r2 += `\\${i2}`, s2++) : (r2 += i2, s2++);
  }
  return r2;
}
function jC(e2, t2) {
  let n2 = 1, r2 = t2 + 1;
  for (; r2 < e2.length && n2 > 0; ) {
    let s2 = e2[r2];
    if (s2 === "\\") {
      r2 += 2;
      continue;
    }
    if (s2 === "(") n2++;
    else if (s2 === ")" && (n2--, n2 === 0)) return r2;
    r2++;
  }
  return -1;
}
function HC(e2) {
  let t2 = [], n2 = "", r2 = 0, s2 = 0;
  for (; s2 < e2.length; ) {
    let i2 = e2[s2];
    if (i2 === "\\") {
      n2 += i2, s2 + 1 < e2.length ? (n2 += e2[s2 + 1], s2 += 2) : s2++;
      continue;
    }
    i2 === "(" ? (r2++, n2 += i2) : i2 === ")" ? (r2--, n2 += i2) : i2 === "|" && r2 === 0 ? (t2.push(n2), n2 = "") : n2 += i2, s2++;
  }
  return t2.push(n2), t2;
}
function VC(e2, t2) {
  let n2 = t2 + 1;
  for (n2 < e2.length && e2[n2] === "^" && n2++, n2 < e2.length && e2[n2] === "]" && n2++; n2 < e2.length; ) {
    if (e2[n2] === "\\" && n2 + 1 < e2.length) {
      n2 += 2;
      continue;
    }
    if (e2[n2] === "]") return n2;
    if (e2[n2] === "'") {
      let r2 = e2.indexOf("'", n2 + 1);
      if (r2 !== -1) {
        n2 = r2 + 1;
        continue;
      }
    }
    if (e2[n2] === "[" && n2 + 1 < e2.length && e2[n2 + 1] === ":") {
      let r2 = e2.indexOf(":]", n2 + 2);
      if (r2 !== -1) {
        n2 = r2 + 2;
        continue;
      }
    }
    n2++;
  }
  return -1;
}
function qC(e2) {
  let t2 = "[", n2 = 0;
  for ((e2[0] === "^" || e2[0] === "!") && (t2 += "^", n2++); n2 < e2.length; ) {
    if (e2[n2] === "'") {
      let s2 = e2.indexOf("'", n2 + 1);
      if (s2 !== -1) {
        let i2 = e2.slice(n2 + 1, s2);
        for (let o2 of i2) o2 === "\\" ? t2 += "\\\\" : o2 === "]" ? t2 += "\\]" : o2 === "^" && t2 === "[" ? t2 += "\\^" : t2 += o2;
        n2 = s2 + 1;
        continue;
      }
    }
    if (e2[n2] === "[" && n2 + 1 < e2.length && e2[n2 + 1] === ":") {
      let s2 = e2.indexOf(":]", n2 + 2);
      if (s2 !== -1) {
        let i2 = e2.slice(n2 + 2, s2);
        t2 += ZC(i2), n2 = s2 + 2;
        continue;
      }
    }
    let r2 = e2[n2];
    r2 === "\\" ? n2 + 1 < e2.length ? (t2 += `\\${e2[n2 + 1]}`, n2 += 2) : (t2 += "\\\\", n2++) : r2 === "-" && n2 > 0 && n2 < e2.length - 1 ? (t2 += "-", n2++) : r2 === "^" && n2 === 0 ? (t2 += "^", n2++) : (r2 === "]" && n2 === 0 ? t2 += "\\]" : t2 += r2, n2++);
  }
  return t2 += "]", t2;
}
function ZC(e2) {
  return GC[e2] ?? "";
}
var GC, rr = v(() => {
  GC = { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "!-~", lower: "a-z", print: " -~", punct: "!-/:-@\\[-`{-~", space: " \\t\\n\\r\\f\\v", upper: "A-Z", word: "a-zA-Z0-9_", xdigit: "0-9A-Fa-f" };
});
function Kt(e2, t2, n2, r2) {
  if (n2 === "prefix") return e2.replace(new RegExp(`^${t2}`, "s"), "");
  let s2 = new RegExp(`${t2}$`, "s");
  if (r2) return e2.replace(s2, "");
  for (let i2 = e2.length; i2 >= 0; i2--) {
    let o2 = e2.slice(i2);
    if (s2.test(o2)) return e2.slice(0, i2);
  }
  return e2;
}
function sr(e2, t2) {
  let n2 = Object.keys(e2.state.env), r2 = /* @__PURE__ */ new Set(), s2 = e2.state.associativeArrays ?? /* @__PURE__ */ new Set(), i2 = /* @__PURE__ */ new Set();
  for (let a of n2) {
    let l = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_\d+$/);
    l && i2.add(l[1]);
    let c = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
    c && i2.add(c[1]);
  }
  let o2 = (a) => {
    for (let l of s2) {
      let c = `${l}_`;
      if (a.startsWith(c) && a !== l) return true;
    }
    return false;
  };
  for (let a of n2) if (a.startsWith(t2)) if (a.includes("__")) {
    let l = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
    (l == null ? void 0 : l[1].startsWith(t2)) && r2.add(l[1]);
  } else if (/_\d+$/.test(a)) {
    let l = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_\d+$/);
    (l == null ? void 0 : l[1].startsWith(t2)) && r2.add(l[1]);
  } else o2(a) || r2.add(a);
  return [...r2].sort();
}
var vn = v(() => {
});
function QC(e2, t2) {
  let n2 = (i2, o2 = 2) => String(i2).padStart(o2, "0");
  if (e2 === "") {
    let i2 = n2(t2.getHours()), o2 = n2(t2.getMinutes()), a = n2(t2.getSeconds());
    return `${i2}:${o2}:${a}`;
  }
  let r2 = "", s2 = 0;
  for (; s2 < e2.length; ) if (e2[s2] === "%") {
    if (s2 + 1 >= e2.length) {
      r2 += "%", s2++;
      continue;
    }
    let i2 = e2[s2 + 1];
    switch (i2) {
      case "H":
        r2 += n2(t2.getHours());
        break;
      case "M":
        r2 += n2(t2.getMinutes());
        break;
      case "S":
        r2 += n2(t2.getSeconds());
        break;
      case "d":
        r2 += n2(t2.getDate());
        break;
      case "m":
        r2 += n2(t2.getMonth() + 1);
        break;
      case "Y":
        r2 += t2.getFullYear();
        break;
      case "y":
        r2 += n2(t2.getFullYear() % 100);
        break;
      case "I": {
        let o2 = t2.getHours() % 12;
        o2 === 0 && (o2 = 12), r2 += n2(o2);
        break;
      }
      case "p":
        r2 += t2.getHours() < 12 ? "AM" : "PM";
        break;
      case "P":
        r2 += t2.getHours() < 12 ? "am" : "pm";
        break;
      case "%":
        r2 += "%";
        break;
      case "a": {
        r2 += ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][t2.getDay()];
        break;
      }
      case "b": {
        r2 += ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][t2.getMonth()];
        break;
      }
      default:
        r2 += `%${i2}`;
    }
    s2 += 2;
  } else r2 += e2[s2], s2++;
  return r2;
}
function Mr(e2, t2) {
  let n2 = "", r2 = 0, s2 = e2.state.env.USER || e2.state.env.LOGNAME || "user", i2 = e2.state.env.HOSTNAME || "localhost", o2 = i2.split(".")[0], a = e2.state.env.PWD || "/", l = e2.state.env.HOME || "/", c = a.startsWith(l) ? `~${a.slice(l.length)}` : a, u = a.split("/").pop() || a, f2 = /* @__PURE__ */ new Date(), p = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], d = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], m = e2.state.env.__COMMAND_NUMBER || "1";
  for (; r2 < t2.length; ) {
    let h = t2[r2];
    if (h === "\\") {
      if (r2 + 1 >= t2.length) {
        n2 += "\\", r2++;
        continue;
      }
      let g = t2[r2 + 1];
      if (g >= "0" && g <= "7") {
        let b = "", y = r2 + 1;
        for (; y < t2.length && y < r2 + 4 && t2[y] >= "0" && t2[y] <= "7"; ) b += t2[y], y++;
        let w = Number.parseInt(b, 8) % 256;
        n2 += String.fromCharCode(w), r2 = y;
        continue;
      }
      switch (g) {
        case "\\":
          n2 += "\\", r2 += 2;
          break;
        case "a":
          n2 += "\x07", r2 += 2;
          break;
        case "e":
          n2 += "\x1B", r2 += 2;
          break;
        case "n":
          n2 += `
`, r2 += 2;
          break;
        case "r":
          n2 += "\r", r2 += 2;
          break;
        case "$":
          n2 += "$", r2 += 2;
          break;
        case "[":
        case "]":
          r2 += 2;
          break;
        case "u":
          n2 += s2, r2 += 2;
          break;
        case "h":
          n2 += o2, r2 += 2;
          break;
        case "H":
          n2 += i2, r2 += 2;
          break;
        case "w":
          n2 += c, r2 += 2;
          break;
        case "W":
          n2 += u, r2 += 2;
          break;
        case "d": {
          let b = String(f2.getDate()).padStart(2, " ");
          n2 += `${p[f2.getDay()]} ${d[f2.getMonth()]} ${b}`, r2 += 2;
          break;
        }
        case "t": {
          let b = String(f2.getHours()).padStart(2, "0"), y = String(f2.getMinutes()).padStart(2, "0"), w = String(f2.getSeconds()).padStart(2, "0");
          n2 += `${b}:${y}:${w}`, r2 += 2;
          break;
        }
        case "T": {
          let b = f2.getHours() % 12;
          b === 0 && (b = 12);
          let y = String(b).padStart(2, "0"), w = String(f2.getMinutes()).padStart(2, "0"), E = String(f2.getSeconds()).padStart(2, "0");
          n2 += `${y}:${w}:${E}`, r2 += 2;
          break;
        }
        case "@": {
          let b = f2.getHours() % 12;
          b === 0 && (b = 12);
          let y = String(b).padStart(2, "0"), w = String(f2.getMinutes()).padStart(2, "0"), E = f2.getHours() < 12 ? "AM" : "PM";
          n2 += `${y}:${w} ${E}`, r2 += 2;
          break;
        }
        case "A": {
          let b = String(f2.getHours()).padStart(2, "0"), y = String(f2.getMinutes()).padStart(2, "0");
          n2 += `${b}:${y}`, r2 += 2;
          break;
        }
        case "D":
          if (r2 + 2 < t2.length && t2[r2 + 2] === "{") {
            let b = t2.indexOf("}", r2 + 3);
            if (b !== -1) {
              let y = t2.slice(r2 + 3, b);
              n2 += QC(y, f2), r2 = b + 1;
            } else n2 += "\\D", r2 += 2;
          } else n2 += "\\D", r2 += 2;
          break;
        case "s":
          n2 += "bash", r2 += 2;
          break;
        case "v":
          n2 += "5.0", r2 += 2;
          break;
        case "V":
          n2 += "5.0.0", r2 += 2;
          break;
        case "j":
          n2 += "0", r2 += 2;
          break;
        case "l":
          n2 += "tty", r2 += 2;
          break;
        case "#":
          n2 += m, r2 += 2;
          break;
        case "!":
          n2 += m, r2 += 2;
          break;
        case "x":
          n2 += "\\x", r2 += 2;
          break;
        default:
          n2 += `\\${g}`, r2 += 2;
      }
    } else n2 += h, r2++;
  }
  return n2;
}
var Va = v(() => {
});
function sn(e2) {
  if (e2 === "") return "''";
  if (/[\n\r\t\x00-\x1f\x7f']/.test(e2)) {
    let n2 = "$'";
    for (let r2 of e2) switch (r2) {
      case "'":
        n2 += "\\'";
        break;
      case "\\":
        n2 += "\\\\";
        break;
      case `
`:
        n2 += "\\n";
        break;
      case "\r":
        n2 += "\\r";
        break;
      case "	":
        n2 += "\\t";
        break;
      default: {
        let s2 = r2.charCodeAt(0);
        s2 < 32 || s2 === 127 ? n2 += `\\${s2.toString(8).padStart(3, "0")}` : n2 += r2;
      }
    }
    return `${n2}'`;
  }
  return `'${e2}'`;
}
var qa = v(() => {
});
function gt(e2, t2) {
  e2.state.readonlyVars = e2.state.readonlyVars || /* @__PURE__ */ new Set(), e2.state.readonlyVars.add(t2);
}
function Ht(e2, t2) {
  var _a3;
  return ((_a3 = e2.state.readonlyVars) == null ? void 0 : _a3.has(t2)) ?? false;
}
function je(e2, t2, n2 = "bash") {
  if (Ht(e2, t2)) {
    let r2 = `${n2}: ${t2}: readonly variable
`;
    throw new ae(1, "", r2);
  }
  return null;
}
function Ot(e2, t2) {
  var _a3;
  let n2 = ((_a3 = e2.state.exportedVars) == null ? void 0 : _a3.has(t2)) ?? false;
  if (e2.state.exportedVars = e2.state.exportedVars || /* @__PURE__ */ new Set(), e2.state.exportedVars.add(t2), e2.state.localScopes.length > 0 && e2.state.localScopes[e2.state.localScopes.length - 1].has(t2) && !n2) {
    for (e2.state.localExportedVars || (e2.state.localExportedVars = []); e2.state.localExportedVars.length < e2.state.localScopes.length; ) e2.state.localExportedVars.push(/* @__PURE__ */ new Set());
    e2.state.localExportedVars[e2.state.localExportedVars.length - 1].add(t2);
  }
}
function oi(e2, t2) {
  var _a3;
  (_a3 = e2.state.exportedVars) == null ? void 0 : _a3.delete(t2);
}
var on$1 = v(() => {
  de();
});
function an(e2, t2) {
  var _a3, _b3, _c2;
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t2)) return "";
  let n2 = "", r2 = e2.state.env[`${t2}__length`] !== void 0 || Object.keys(e2.state.env).some((i2) => i2.startsWith(`${t2}_`) && /^[0-9]+$/.test(i2.slice(t2.length + 1))), s2 = ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(t2)) ?? false;
  return r2 && !s2 && (n2 += "a"), s2 && (n2 += "A"), ((_b3 = e2.state.integerVars) == null ? void 0 : _b3.has(t2)) && (n2 += "i"), Se(e2, t2) && (n2 += "n"), Ht(e2, t2) && (n2 += "r"), ((_c2 = e2.state.exportedVars) == null ? void 0 : _c2.has(t2)) && (n2 += "x"), n2;
}
var ai = v(() => {
  Tt();
  on$1();
});
async function mg(e2, t2, n2, r2) {
  return (n2.isUnset || t2.checkEmpty && n2.isEmpty) && t2.word ? r2(e2, t2.word.parts, n2.inDoubleQuotes) : n2.effectiveValue;
}
async function gg(e2, t2, n2, r2, s2) {
  if ((r2.isUnset || n2.checkEmpty && r2.isEmpty) && n2.word) {
    let o2 = await s2(e2, n2.word.parts, r2.inDoubleQuotes), a = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    if (a) {
      let [, l, c] = a, u;
      if (/^\d+$/.test(c)) u = Number.parseInt(c, 10);
      else {
        try {
          let p = new se(), d = he(p, c);
          u = await Q(e2, d.expression);
        } catch {
          let p = e2.state.env[c];
          u = p ? Number.parseInt(p, 10) : 0;
        }
        Number.isNaN(u) && (u = 0);
      }
      e2.state.env[`${l}_${u}`] = o2;
      let f2 = Number.parseInt(e2.state.env[`${l}__length`] || "0", 10);
      u >= f2 && (e2.state.env[`${l}__length`] = String(u + 1));
    } else e2.state.env[t2] = o2;
    return o2;
  }
  return r2.effectiveValue;
}
async function yg(e2, t2, n2, r2, s2) {
  if (r2.isUnset || n2.checkEmpty && r2.isEmpty) {
    let o2 = n2.word ? await s2(e2, n2.word.parts, r2.inDoubleQuotes) : `${t2}: parameter null or not set`;
    throw new ae(1, "", `bash: ${o2}
`);
  }
  return r2.effectiveValue;
}
async function bg(e2, t2, n2, r2) {
  return !(n2.isUnset || t2.checkEmpty && n2.isEmpty) && t2.word ? r2(e2, t2.word.parts, n2.inDoubleQuotes) : "";
}
async function wg(e2, t2, n2, r2, s2) {
  let i2 = "", o2 = e2.state.shoptOptions.extglob;
  if (n2.pattern) for (let l of n2.pattern.parts) if (l.type === "Glob") i2 += ce(l.pattern, n2.greedy, o2);
  else if (l.type === "Literal") i2 += ce(l.value, n2.greedy, o2);
  else if (l.type === "SingleQuoted" || l.type === "Escaped") i2 += pe(l.value);
  else if (l.type === "DoubleQuoted") {
    let c = await r2(e2, l.parts);
    i2 += pe(c);
  } else if (l.type === "ParameterExpansion") {
    let c = await s2(e2, l);
    i2 += ce(c, n2.greedy, o2);
  } else {
    let c = await s2(e2, l);
    i2 += pe(c);
  }
  if (n2.side === "prefix") return t2.replace(new RegExp(`^${i2}`, "s"), "");
  let a = new RegExp(`${i2}$`, "s");
  if (n2.greedy) return t2.replace(a, "");
  for (let l = t2.length; l >= 0; l--) {
    let c = t2.slice(l);
    if (a.test(c)) return t2.slice(0, l);
  }
  return t2;
}
async function xg(e2, t2, n2, r2, s2) {
  let i2 = "", o2 = e2.state.shoptOptions.extglob;
  if (n2.pattern) for (let c of n2.pattern.parts) if (c.type === "Glob") i2 += ce(c.pattern, true, o2);
  else if (c.type === "Literal") i2 += ce(c.value, true, o2);
  else if (c.type === "SingleQuoted" || c.type === "Escaped") i2 += pe(c.value);
  else if (c.type === "DoubleQuoted") {
    let u = await r2(e2, c.parts);
    i2 += pe(u);
  } else if (c.type === "ParameterExpansion") {
    let u = await s2(e2, c);
    i2 += ce(u, true, o2);
  } else {
    let u = await s2(e2, c);
    i2 += pe(u);
  }
  let a = n2.replacement ? await r2(e2, n2.replacement.parts) : "";
  if (n2.anchor === "start" ? i2 = `^${i2}` : n2.anchor === "end" && (i2 = `${i2}$`), i2 === "") return t2;
  let l = n2.all ? "gs" : "s";
  try {
    let c = new RegExp(i2, l);
    if (n2.all) {
      let u = "", f2 = 0, p = c.exec(t2);
      for (; p !== null && !(p[0].length === 0 && p.index === t2.length); ) u += t2.slice(f2, p.index) + a, f2 = p.index + p[0].length, p[0].length === 0 && f2++, p = c.exec(t2);
      return u += t2.slice(f2), u;
    }
    return t2.replace(c, a);
  } catch {
    return t2;
  }
}
function Eg(e2, t2, n2) {
  var _a3, _b3;
  let r2 = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
  if (r2) {
    let s2 = r2[1], i2 = te(e2, s2);
    return i2.length > 0 ? String(i2.length) : e2.state.env[s2] !== void 0 ? "1" : "0";
  }
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t2) && Qt(e2, t2)) {
    if (t2 === "FUNCNAME") {
      let i2 = ((_a3 = e2.state.funcNameStack) == null ? void 0 : _a3[0]) || "";
      return String([...i2].length);
    }
    if (t2 === "BASH_LINENO") {
      let i2 = (_b3 = e2.state.callLineStack) == null ? void 0 : _b3[0];
      return String(i2 !== void 0 ? [...String(i2)].length : 0);
    }
    let s2 = e2.state.env[`${t2}_0`] || "";
    return String([...s2].length);
  }
  return String([...n2].length);
}
async function Sg(e2, t2, n2, r2) {
  var _a3;
  let s2 = await Q(e2, r2.offset.expression), i2 = r2.length ? await Q(e2, r2.length.expression) : void 0;
  if (t2 === "@" || t2 === "*") {
    let c = Number.parseInt(e2.state.env["#"] || "0", 10), u = [];
    for (let m = 1; m <= c; m++) u.push(e2.state.env[String(m)] || "");
    let f2 = e2.state.env[0] || "bash", p, d;
    if (s2 <= 0) if (p = [f2, ...u], s2 < 0) {
      if (d = p.length + s2, d < 0) return "";
    } else d = 0;
    else p = u, d = s2 - 1;
    if (d < 0 || d >= p.length) return "";
    if (i2 !== void 0) {
      let m = i2 < 0 ? p.length + i2 : d + i2;
      return p.slice(d, Math.max(d, m)).join(" ");
    }
    return p.slice(d).join(" ");
  }
  let o2 = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
  if (o2) {
    let c = o2[1];
    if ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(c)) throw new ae(1, "", `bash: \${${c}[@]: 0: 3}: bad substitution
`);
    let u = te(e2, c), f2 = 0;
    if (s2 < 0) {
      if (u.length > 0) {
        let p = u[u.length - 1][0], m = (typeof p == "number" ? p : 0) + 1 + s2;
        if (m < 0 || (f2 = u.findIndex(([h]) => typeof h == "number" && h >= m), f2 < 0)) return "";
      }
    } else if (f2 = u.findIndex(([p]) => typeof p == "number" && p >= s2), f2 < 0) return "";
    if (i2 !== void 0) {
      if (i2 < 0) throw new Ee(`${o2[1]}[@]: substring expression < 0`);
      return u.slice(f2, f2 + i2).map(([, p]) => p).join(" ");
    }
    return u.slice(f2).map(([, p]) => p).join(" ");
  }
  let a = [...n2], l = s2;
  if (l < 0 && (l = Math.max(0, a.length + l)), i2 !== void 0) {
    if (i2 < 0) {
      let c = a.length + i2;
      return a.slice(l, Math.max(l, c)).join("");
    }
    return a.slice(l, l + i2).join("");
  }
  return a.slice(l).join("");
}
async function Ag(e2, t2, n2, r2, s2) {
  if (n2.pattern) {
    let i2 = e2.state.shoptOptions.extglob, o2 = "";
    for (let f2 of n2.pattern.parts) if (f2.type === "Glob") o2 += ce(f2.pattern, true, i2);
    else if (f2.type === "Literal") o2 += ce(f2.value, true, i2);
    else if (f2.type === "SingleQuoted" || f2.type === "Escaped") o2 += pe(f2.value);
    else if (f2.type === "DoubleQuoted") {
      let p = await r2(e2, f2.parts);
      o2 += pe(p);
    } else if (f2.type === "ParameterExpansion") {
      let p = await s2(e2, f2);
      o2 += ce(p, true, i2);
    }
    let a = new RegExp(`^(?:${o2})$`), l = n2.direction === "upper" ? (f2) => f2.toUpperCase() : (f2) => f2.toLowerCase(), c = "", u = false;
    for (let f2 of t2) !n2.all && u ? c += f2 : a.test(f2) ? (c += l(f2), u = true) : c += f2;
    return c;
  }
  return n2.direction === "upper" ? n2.all ? t2.toUpperCase() : t2.charAt(0).toUpperCase() + t2.slice(1) : n2.all ? t2.toLowerCase() : t2.charAt(0).toLowerCase() + t2.slice(1);
}
function Cg(e2, t2, n2, r2, s2) {
  let i2 = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
  if (i2 && s2.operator === "Q") return te(e2, i2[1]).map(([, c]) => sn(c)).join(" ");
  if (i2 && s2.operator === "a") return an(e2, i2[1]);
  let o2 = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[.+\]$/);
  if (o2 && s2.operator === "a") return an(e2, o2[1]);
  switch (s2.operator) {
    case "Q":
      return r2 ? "" : sn(n2);
    case "P":
      return Mr(e2, n2);
    case "a":
      return an(e2, t2);
    case "A":
      return r2 ? "" : `${t2}=${sn(n2)}`;
    case "E":
      return n2.replace(/\\([\\abefnrtv'"?])/g, (a, l) => {
        switch (l) {
          case "\\":
            return "\\";
          case "a":
            return "\x07";
          case "b":
            return "\b";
          case "e":
            return "\x1B";
          case "f":
            return "\f";
          case "n":
            return `
`;
          case "r":
            return "\r";
          case "t":
            return "	";
          case "v":
            return "\v";
          case "'":
            return "'";
          case '"':
            return '"';
          case "?":
            return "?";
          default:
            return l;
        }
      });
    case "K":
    case "k":
      return r2 ? "" : sn(n2);
    case "u":
      return n2.charAt(0).toUpperCase() + n2.slice(1);
    case "U":
      return n2.toUpperCase();
    case "L":
      return n2.toLowerCase();
    default:
      return n2;
  }
}
async function Ng(e2, t2, n2, r2, s2, i2, o2 = false) {
  var _a3;
  if (Se(e2, t2)) return kn(e2, t2) || "";
  let a = /^[a-zA-Z_][a-zA-Z0-9_]*\[([@*])\]$/.test(t2);
  if (r2) {
    if (((_a3 = s2.innerOp) == null ? void 0 : _a3.type) === "UseAlternative") return "";
    throw new nt(`\${!${t2}}`);
  }
  let l = n2;
  if (a && (l === "" || l.includes(" "))) throw new nt(`\${!${t2}}`);
  let c = l.match(/^[a-zA-Z_][a-zA-Z0-9_]*\[(.+)\]$/);
  if (c && c[1].includes("~")) throw new nt(`\${!${t2}}`);
  if (s2.innerOp) {
    let u = { type: "ParameterExpansion", parameter: l, operation: s2.innerOp };
    return i2(e2, u, o2);
  }
  return await me(e2, l);
}
function kg(e2, t2) {
  let r2 = te(e2, t2.array).map(([s2]) => String(s2));
  return t2.star ? r2.join(oe(e2.state.env)) : r2.join(" ");
}
function vg(e2, t2) {
  let n2 = sr(e2, t2.prefix);
  return t2.star ? n2.join(oe(e2.state.env)) : n2.join(" ");
}
function $g(e2, t2, n2, r2) {
  let s2 = Number.parseInt(e2.state.env["#"] || "0", 10), i2 = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (t2 === "*") return { isEmpty: s2 === 0, effectiveValue: n2 };
  if (t2 === "@") return { isEmpty: s2 === 0 || s2 === 1 && e2.state.env[1] === "", effectiveValue: n2 };
  if (i2) {
    let [, o2, a] = i2, l = te(e2, o2);
    if (l.length === 0) return { isEmpty: true, effectiveValue: "" };
    if (a === "*") {
      let c = oe(e2.state.env), u = l.map(([, f2]) => f2).join(c);
      return { isEmpty: r2 ? u === "" : false, effectiveValue: u };
    }
    return { isEmpty: l.length === 1 && l.every(([, c]) => c === ""), effectiveValue: l.map(([, c]) => c).join(" ") };
  }
  return { isEmpty: n2 === "", effectiveValue: n2 };
}
var Ig = v(() => {
  Je();
  Fe();
  it();
  de();
  St();
  Tt();
  nr();
  rr();
  vn();
  Va();
  qa();
  ht();
  ai();
});
function Rg(e2) {
  let t2 = 0;
  for (; t2 < e2.length; ) {
    let n2 = e2[t2];
    if (n2 === "\\" && t2 + 1 < e2.length) {
      t2 += 2;
      continue;
    }
    if (n2 === "'") {
      let r2 = e2.indexOf("'", t2 + 1);
      if (r2 !== -1) {
        t2 = r2 + 1;
        continue;
      }
    }
    if (n2 === "$" && t2 + 1 < e2.length && e2[t2 + 1] === "(" || n2 === "`") return true;
    t2++;
  }
  return false;
}
function Pg(e2, t2) {
  let n2 = 1, r2 = t2, s2 = false, i2 = false;
  for (; r2 < e2.length && n2 > 0; ) {
    let o2 = e2[r2];
    if (o2 === "\\" && !s2 && r2 + 1 < e2.length) {
      r2 += 2;
      continue;
    }
    if (o2 === "'" && !i2) {
      s2 = !s2, r2++;
      continue;
    }
    if (o2 === '"' && !s2) {
      i2 = !i2, r2++;
      continue;
    }
    if (!s2 && !i2) {
      if (o2 === "(") n2++;
      else if (o2 === ")" && (n2--, n2 === 0)) return r2;
    }
    r2++;
  }
  return -1;
}
async function li(e2, t2) {
  var _a3;
  let n2 = new se(), r2;
  try {
    r2 = n2.parse(t2);
  } catch {
    return "";
  }
  let s2 = e2.state.bashPid;
  e2.state.bashPid = e2.state.nextVirtualPid++;
  let i2 = { ...e2.state.env }, o2 = e2.state.cwd, a = e2.state.suppressVerbose;
  e2.state.suppressVerbose = true;
  try {
    let l = await e2.executeScript(r2), c = l.exitCode;
    return e2.state.env = i2, e2.state.cwd = o2, e2.state.suppressVerbose = a, e2.state.lastExitCode = c, e2.state.env["?"] = String(c), l.stderr && (e2.state.expansionStderr = (e2.state.expansionStderr || "") + l.stderr), e2.state.bashPid = s2, l.stdout.replace(/\n+$/, "");
  } catch (l) {
    if (e2.state.env = i2, e2.state.cwd = o2, e2.state.bashPid = s2, e2.state.suppressVerbose = a, l instanceof ne) throw l;
    return l instanceof ae ? (e2.state.lastExitCode = l.exitCode, e2.state.env["?"] = String(l.exitCode), ((_a3 = l.stdout) == null ? void 0 : _a3.replace(/\n+$/, "")) ?? "") : "";
  }
}
function Ga(e2, t2) {
  let n2 = "", r2 = 0;
  for (; r2 < t2.length; ) {
    let s2 = t2[r2];
    if (s2 === "'") {
      let i2 = t2.indexOf("'", r2 + 1);
      if (i2 !== -1) {
        let o2 = t2.slice(r2 + 1, i2);
        n2 += mt(o2), r2 = i2 + 1;
        continue;
      }
    }
    if (s2 === '"') {
      let i2 = -1, o2 = r2 + 1;
      for (; o2 < t2.length; ) {
        if (t2[o2] === "\\") {
          o2 += 2;
          continue;
        }
        if (t2[o2] === '"') {
          i2 = o2;
          break;
        }
        o2++;
      }
      if (i2 !== -1) {
        let a = t2.slice(r2 + 1, i2), l = KC(e2, a);
        n2 += mt(l), r2 = i2 + 1;
        continue;
      }
    }
    if (s2 === "$" && r2 + 1 < t2.length) {
      let i2 = t2[r2 + 1];
      if (i2 === "{") {
        let o2 = t2.indexOf("}", r2 + 2);
        if (o2 !== -1) {
          let a = t2.slice(r2 + 2, o2);
          n2 += e2.state.env[a] ?? "", r2 = o2 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(i2)) {
        let o2 = r2 + 1;
        for (; o2 < t2.length && /[a-zA-Z0-9_]/.test(t2[o2]); ) o2++;
        let a = t2.slice(r2 + 1, o2);
        n2 += e2.state.env[a] ?? "", r2 = o2;
        continue;
      }
    }
    if (s2 === "\\" && r2 + 1 < t2.length) {
      n2 += s2 + t2[r2 + 1], r2 += 2;
      continue;
    }
    n2 += s2, r2++;
  }
  return n2;
}
function KC(e2, t2) {
  let n2 = "", r2 = 0;
  for (; r2 < t2.length; ) {
    let s2 = t2[r2];
    if (s2 === "\\" && r2 + 1 < t2.length) {
      let i2 = t2[r2 + 1];
      if (i2 === "$" || i2 === "`" || i2 === "\\" || i2 === '"') {
        n2 += i2, r2 += 2;
        continue;
      }
      n2 += s2, r2++;
      continue;
    }
    if (s2 === "$" && r2 + 1 < t2.length) {
      let i2 = t2[r2 + 1];
      if (i2 === "{") {
        let o2 = t2.indexOf("}", r2 + 2);
        if (o2 !== -1) {
          let a = t2.slice(r2 + 2, o2);
          n2 += e2.state.env[a] ?? "", r2 = o2 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(i2)) {
        let o2 = r2 + 1;
        for (; o2 < t2.length && /[a-zA-Z0-9_]/.test(t2[o2]); ) o2++;
        let a = t2.slice(r2 + 1, o2);
        n2 += e2.state.env[a] ?? "", r2 = o2;
        continue;
      }
    }
    n2 += s2, r2++;
  }
  return n2;
}
async function Tg(e2, t2) {
  let n2 = "", r2 = 0;
  for (; r2 < t2.length; ) {
    let s2 = t2[r2];
    if (s2 === "'") {
      let i2 = t2.indexOf("'", r2 + 1);
      if (i2 !== -1) {
        let o2 = t2.slice(r2 + 1, i2);
        n2 += mt(o2), r2 = i2 + 1;
        continue;
      }
    }
    if (s2 === '"') {
      let i2 = -1, o2 = r2 + 1;
      for (; o2 < t2.length; ) {
        if (t2[o2] === "\\") {
          o2 += 2;
          continue;
        }
        if (t2[o2] === '"') {
          i2 = o2;
          break;
        }
        o2++;
      }
      if (i2 !== -1) {
        let a = t2.slice(r2 + 1, i2), l = await XC(e2, a);
        n2 += mt(l), r2 = i2 + 1;
        continue;
      }
    }
    if (s2 === "$" && r2 + 1 < t2.length && t2[r2 + 1] === "(") {
      let i2 = Pg(t2, r2 + 2);
      if (i2 !== -1) {
        let o2 = t2.slice(r2 + 2, i2), a = await li(e2, o2);
        n2 += a, r2 = i2 + 1;
        continue;
      }
    }
    if (s2 === "`") {
      let i2 = t2.indexOf("`", r2 + 1);
      if (i2 !== -1) {
        let o2 = t2.slice(r2 + 1, i2), a = await li(e2, o2);
        n2 += a, r2 = i2 + 1;
        continue;
      }
    }
    if (s2 === "$" && r2 + 1 < t2.length) {
      let i2 = t2[r2 + 1];
      if (i2 === "{") {
        let o2 = t2.indexOf("}", r2 + 2);
        if (o2 !== -1) {
          let a = t2.slice(r2 + 2, o2);
          n2 += e2.state.env[a] ?? "", r2 = o2 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(i2)) {
        let o2 = r2 + 1;
        for (; o2 < t2.length && /[a-zA-Z0-9_]/.test(t2[o2]); ) o2++;
        let a = t2.slice(r2 + 1, o2);
        n2 += e2.state.env[a] ?? "", r2 = o2;
        continue;
      }
    }
    if (s2 === "\\" && r2 + 1 < t2.length) {
      n2 += s2 + t2[r2 + 1], r2 += 2;
      continue;
    }
    n2 += s2, r2++;
  }
  return n2;
}
async function XC(e2, t2) {
  let n2 = "", r2 = 0;
  for (; r2 < t2.length; ) {
    let s2 = t2[r2];
    if (s2 === "\\" && r2 + 1 < t2.length) {
      let i2 = t2[r2 + 1];
      if (i2 === "$" || i2 === "`" || i2 === "\\" || i2 === '"') {
        n2 += i2, r2 += 2;
        continue;
      }
      n2 += s2, r2++;
      continue;
    }
    if (s2 === "$" && r2 + 1 < t2.length && t2[r2 + 1] === "(") {
      let i2 = Pg(t2, r2 + 2);
      if (i2 !== -1) {
        let o2 = t2.slice(r2 + 2, i2), a = await li(e2, o2);
        n2 += a, r2 = i2 + 1;
        continue;
      }
    }
    if (s2 === "`") {
      let i2 = t2.indexOf("`", r2 + 1);
      if (i2 !== -1) {
        let o2 = t2.slice(r2 + 1, i2), a = await li(e2, o2);
        n2 += a, r2 = i2 + 1;
        continue;
      }
    }
    if (s2 === "$" && r2 + 1 < t2.length) {
      let i2 = t2[r2 + 1];
      if (i2 === "{") {
        let o2 = t2.indexOf("}", r2 + 2);
        if (o2 !== -1) {
          let a = t2.slice(r2 + 2, o2);
          n2 += e2.state.env[a] ?? "", r2 = o2 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(i2)) {
        let o2 = r2 + 1;
        for (; o2 < t2.length && /[a-zA-Z0-9_]/.test(t2[o2]); ) o2++;
        let a = t2.slice(r2 + 1, o2);
        n2 += e2.state.env[a] ?? "", r2 = o2;
        continue;
      }
    }
    n2 += s2, r2++;
  }
  return n2;
}
var Og = v(() => {
  Fe();
  de();
  tr();
});
function Dg(e2, t2) {
  if (!t2.startsWith("~")) return t2;
  let n2 = e2.state.env.HOME !== void 0 ? e2.state.env.HOME : "/home/user";
  if (t2 === "~" || t2.startsWith("~/")) return n2 + t2.slice(1);
  let r2 = 1;
  for (; r2 < t2.length && /[a-zA-Z0-9_-]/.test(t2[r2]); ) r2++;
  let s2 = t2.slice(1, r2), i2 = t2.slice(r2);
  return i2 !== "" && !i2.startsWith("/") ? t2 : s2 === "root" ? `/root${i2}` : t2;
}
var Fg = v(() => {
});
async function JC(e2, t2, n2, r2) {
  let s2 = "";
  for (let i2 of t2.parts) if (i2.type === "Glob") s2 += ce(i2.pattern, true, e2.state.shoptOptions.extglob);
  else if (i2.type === "Literal") s2 += ce(i2.value, true, e2.state.shoptOptions.extglob);
  else if (i2.type === "SingleQuoted" || i2.type === "Escaped") s2 += pe(i2.value);
  else if (i2.type === "DoubleQuoted") {
    let o2 = await n2(e2, i2.parts);
    s2 += pe(o2);
  } else if (i2.type === "ParameterExpansion") {
    let o2 = await r2(e2, i2);
    s2 += ce(o2, true, e2.state.shoptOptions.extglob);
  } else {
    let o2 = await r2(e2, i2);
    s2 += pe(o2);
  }
  return s2;
}
async function _g(e2, t2, n2, r2) {
  var _a3;
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let s2 = t2[0];
  if (s2.parts.length !== 1 || s2.parts[0].type !== "ParameterExpansion" || ((_a3 = s2.parts[0].operation) == null ? void 0 : _a3.type) !== "PatternReplacement") return null;
  let i2 = s2.parts[0], o2 = i2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!o2) return null;
  let a = o2[1], l = o2[2] === "*", c = i2.operation, u = te(e2, a), f2 = u.map(([, g]) => g);
  if (u.length === 0) {
    let g = e2.state.env[a];
    g !== void 0 && f2.push(g);
  }
  if (f2.length === 0) return { values: [], quoted: true };
  let p = "";
  c.pattern && (p = await JC(e2, c.pattern, n2, r2));
  let d = c.replacement ? await n2(e2, c.replacement.parts) : "", m = p;
  c.anchor === "start" ? m = `^${p}` : c.anchor === "end" && (m = `${p}$`);
  let h = [];
  try {
    let g = new RegExp(m, c.all ? "g" : "");
    for (let b of f2) h.push(b.replace(g, d));
  } catch {
    h.push(...f2);
  }
  if (l) {
    let g = oe(e2.state.env);
    return { values: [h.join(g)], quoted: true };
  }
  return { values: h, quoted: true };
}
async function Lg(e2, t2, n2, r2) {
  var _a3;
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let s2 = t2[0];
  if (s2.parts.length !== 1 || s2.parts[0].type !== "ParameterExpansion" || ((_a3 = s2.parts[0].operation) == null ? void 0 : _a3.type) !== "PatternRemoval") return null;
  let i2 = s2.parts[0], o2 = i2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!o2) return null;
  let a = o2[1], l = o2[2] === "*", c = i2.operation, u = te(e2, a), f2 = u.map(([, h]) => h);
  if (u.length === 0) {
    let h = e2.state.env[a];
    h !== void 0 && f2.push(h);
  }
  if (f2.length === 0) return { values: [], quoted: true };
  let p = "", d = e2.state.shoptOptions.extglob;
  if (c.pattern) for (let h of c.pattern.parts) if (h.type === "Glob") p += ce(h.pattern, c.greedy, d);
  else if (h.type === "Literal") p += ce(h.value, c.greedy, d);
  else if (h.type === "SingleQuoted" || h.type === "Escaped") p += pe(h.value);
  else if (h.type === "DoubleQuoted") {
    let g = await n2(e2, h.parts);
    p += pe(g);
  } else if (h.type === "ParameterExpansion") {
    let g = await r2(e2, h);
    p += ce(g, c.greedy, d);
  } else {
    let g = await r2(e2, h);
    p += pe(g);
  }
  let m = [];
  for (let h of f2) m.push(Kt(h, p, c.side, c.greedy));
  if (l) {
    let h = oe(e2.state.env);
    return { values: [m.join(h)], quoted: true };
  }
  return { values: m, quoted: true };
}
var Mg = v(() => {
  St();
  nr();
  rr();
  vn();
  ht();
});
async function Wg(e2, t2) {
  var _a3, _b3, _c2;
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let n2 = t2[0];
  if (n2.parts.length !== 1 || n2.parts[0].type !== "ParameterExpansion" || ((_a3 = n2.parts[0].operation) == null ? void 0 : _a3.type) !== "DefaultValue" && ((_b3 = n2.parts[0].operation) == null ? void 0 : _b3.type) !== "UseAlternative" && ((_c2 = n2.parts[0].operation) == null ? void 0 : _c2.type) !== "AssignDefault") return null;
  let r2 = n2.parts[0], s2 = r2.operation, i2 = r2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/), o2, a = false;
  if (i2) {
    let l = i2[1];
    a = i2[2] === "*";
    let c = te(e2, l), u = c.length > 0 || e2.state.env[l] !== void 0, f2 = c.length === 0 || c.length === 1 && c.every(([, d]) => d === ""), p = s2.checkEmpty ?? false;
    if (s2.type === "UseAlternative" ? o2 = u && !(p && f2) : o2 = !u || p && f2, !o2) {
      if (c.length > 0) {
        let m = c.map(([, h]) => h);
        if (a) {
          let h = oe(e2.state.env);
          return { values: [m.join(h)], quoted: true };
        }
        return { values: m, quoted: true };
      }
      let d = e2.state.env[l];
      return d !== void 0 ? { values: [d], quoted: true } : { values: [], quoted: true };
    }
  } else {
    let l = r2.parameter, c = await zt(e2, l), u = await me(e2, l), f2 = u === "", p = s2.checkEmpty ?? false;
    if (s2.type === "UseAlternative" ? o2 = c && !(p && f2) : o2 = !c || p && f2, !o2) return { values: [u], quoted: true };
  }
  if (o2 && s2.word) {
    let l = s2.word.parts, c = null, u = false;
    for (let f2 of l) if (f2.type === "ParameterExpansion" && !f2.operation) {
      let p = f2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (p) {
        c = p[1], u = p[2] === "*";
        break;
      }
    }
    if (c) {
      let f2 = te(e2, c);
      if (f2.length > 0) {
        let d = f2.map(([, m]) => m);
        if (u || a) {
          let m = oe(e2.state.env);
          return { values: [d.join(m)], quoted: true };
        }
        return { values: d, quoted: true };
      }
      let p = e2.state.env[c];
      return p !== void 0 ? { values: [p], quoted: true } : { values: [], quoted: true };
    }
  }
  return null;
}
async function Bg(e2, t2, n2, r2, s2) {
  var _a3, _b3;
  if (!n2 || t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let i2 = t2[0], o2 = -1, a = "", l = false, c = null;
  for (let h = 0; h < i2.parts.length; h++) {
    let g = i2.parts[h];
    if (g.type === "ParameterExpansion" && (((_a3 = g.operation) == null ? void 0 : _a3.type) === "PatternRemoval" || ((_b3 = g.operation) == null ? void 0 : _b3.type) === "PatternReplacement")) {
      let b = g.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (b) {
        o2 = h, a = b[1], l = b[2] === "*", c = g.operation;
        break;
      }
    }
  }
  if (o2 === -1 || o2 === 0 && o2 === i2.parts.length - 1) return null;
  let u = "";
  for (let h = 0; h < o2; h++) u += await r2(e2, i2.parts[h]);
  let f2 = "";
  for (let h = o2 + 1; h < i2.parts.length; h++) f2 += await r2(e2, i2.parts[h]);
  let p = te(e2, a), d = p.map(([, h]) => h);
  if (p.length === 0) {
    let h = e2.state.env[a];
    if (h !== void 0) d = [h];
    else {
      if (l) return { values: [u + f2], quoted: true };
      let g = u + f2;
      return { values: g ? [g] : [], quoted: true };
    }
  }
  if ((c == null ? void 0 : c.type) === "PatternRemoval") {
    let h = c, g = "", b = e2.state.shoptOptions.extglob;
    if (h.pattern) for (let y of h.pattern.parts) if (y.type === "Glob") g += ce(y.pattern, h.greedy, b);
    else if (y.type === "Literal") g += ce(y.value, h.greedy, b);
    else if (y.type === "SingleQuoted" || y.type === "Escaped") g += pe(y.value);
    else if (y.type === "DoubleQuoted") {
      let w = await s2(e2, y.parts);
      g += pe(w);
    } else if (y.type === "ParameterExpansion") {
      let w = await r2(e2, y);
      g += ce(w, h.greedy, b);
    } else {
      let w = await r2(e2, y);
      g += pe(w);
    }
    d = d.map((y) => Kt(y, g, h.side, h.greedy));
  } else if ((c == null ? void 0 : c.type) === "PatternReplacement") {
    let h = c, g = "";
    if (h.pattern) for (let w of h.pattern.parts) if (w.type === "Glob") g += ce(w.pattern, true, e2.state.shoptOptions.extglob);
    else if (w.type === "Literal") g += ce(w.value, true, e2.state.shoptOptions.extglob);
    else if (w.type === "SingleQuoted" || w.type === "Escaped") g += pe(w.value);
    else if (w.type === "DoubleQuoted") {
      let E = await s2(e2, w.parts);
      g += pe(E);
    } else if (w.type === "ParameterExpansion") {
      let E = await r2(e2, w);
      g += ce(E, true, e2.state.shoptOptions.extglob);
    } else {
      let E = await r2(e2, w);
      g += pe(E);
    }
    let b = h.replacement ? await s2(e2, h.replacement.parts) : "", y = g;
    h.anchor === "start" ? y = `^${g}` : h.anchor === "end" && (y = `${g}$`);
    try {
      let w = new RegExp(y, h.all ? "g" : "");
      d = d.map((E) => E.replace(w, b));
    } catch {
    }
  }
  if (l) {
    let h = oe(e2.state.env);
    return { values: [u + d.join(h) + f2], quoted: true };
  }
  return d.length === 1 ? { values: [u + d[0] + f2], quoted: true } : { values: [u + d[0], ...d.slice(1, -1), d[d.length - 1] + f2], quoted: true };
}
async function Ug(e2, t2, n2, r2) {
  if (!n2 || t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let s2 = t2[0], i2 = -1, o2 = "", a = false;
  for (let d = 0; d < s2.parts.length; d++) {
    let m = s2.parts[d];
    if (m.type === "ParameterExpansion" && !m.operation) {
      let h = m.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (h) {
        i2 = d, o2 = h[1], a = h[2] === "*";
        break;
      }
    }
  }
  if (i2 === -1) return null;
  let l = "";
  for (let d = 0; d < i2; d++) l += await r2(e2, s2.parts[d]);
  let c = "";
  for (let d = i2 + 1; d < s2.parts.length; d++) c += await r2(e2, s2.parts[d]);
  let u = te(e2, o2), f2 = u.map(([, d]) => d);
  if (u.length === 0) {
    let d = e2.state.env[o2];
    if (d !== void 0) return { values: [l + d + c], quoted: true };
    if (a) return { values: [l + c], quoted: true };
    let m = l + c;
    return { values: m ? [m] : [], quoted: true };
  }
  if (a) {
    let d = oe(e2.state.env);
    return { values: [l + f2.join(d) + c], quoted: true };
  }
  return f2.length === 1 ? { values: [l + f2[0] + c], quoted: true } : { values: [l + f2[0], ...f2.slice(1, -1), f2[f2.length - 1] + c], quoted: true };
}
var zg = v(() => {
  St();
  nr();
  rr();
  vn();
  ht();
});
async function jg(e2, t2, n2) {
  var _a3, _b3;
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let r2 = t2[0];
  if (r2.parts.length !== 1 || r2.parts[0].type !== "ParameterExpansion" || ((_a3 = r2.parts[0].operation) == null ? void 0 : _a3.type) !== "Substring") return null;
  let s2 = r2.parts[0], i2 = s2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!i2) return null;
  let o2 = i2[1], a = i2[2] === "*", l = s2.operation;
  if ((_b3 = e2.state.associativeArrays) == null ? void 0 : _b3.has(o2)) throw new ae(1, "", `bash: \${${o2}[@]: 0: 3}: bad substitution
`);
  let c = l.offset ? await n2(e2, l.offset.expression) : 0, u = l.length ? await n2(e2, l.length.expression) : void 0, f2 = te(e2, o2), p = 0;
  if (c < 0) {
    if (f2.length > 0) {
      let m = f2[f2.length - 1][0], g = (typeof m == "number" ? m : 0) + 1 + c;
      if (g < 0) return { values: [], quoted: true };
      p = f2.findIndex(([b]) => typeof b == "number" && b >= g), p < 0 && (p = f2.length);
    }
  } else p = f2.findIndex(([m]) => typeof m == "number" && m >= c), p < 0 && (p = f2.length);
  let d;
  if (u !== void 0) {
    if (u < 0) throw new Ee(`${o2}[@]: substring expression < 0`);
    d = f2.slice(p, p + u).map(([, m]) => m);
  } else d = f2.slice(p).map(([, m]) => m);
  if (d.length === 0) return { values: [], quoted: true };
  if (a) {
    let m = oe(e2.state.env);
    return { values: [d.join(m)], quoted: true };
  }
  return { values: d, quoted: true };
}
function Hg(e2, t2) {
  var _a3;
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let n2 = t2[0];
  if (n2.parts.length !== 1 || n2.parts[0].type !== "ParameterExpansion" || ((_a3 = n2.parts[0].operation) == null ? void 0 : _a3.type) !== "Transform") return null;
  let r2 = n2.parts[0], s2 = r2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!s2) return null;
  let i2 = s2[1], o2 = s2[2] === "*", a = r2.operation, l = te(e2, i2);
  if (l.length === 0) {
    let f2 = e2.state.env[i2];
    if (f2 !== void 0) {
      let p;
      switch (a.operator) {
        case "a":
          p = "";
          break;
        case "P":
          p = Mr(e2, f2);
          break;
        case "Q":
          p = sn(f2);
          break;
        default:
          p = f2;
      }
      return { values: [p], quoted: true };
    }
    return o2 ? { values: [""], quoted: true } : { values: [], quoted: true };
  }
  let c = an(e2, i2), u;
  switch (a.operator) {
    case "a":
      u = l.map(() => c);
      break;
    case "P":
      u = l.map(([, f2]) => Mr(e2, f2));
      break;
    case "Q":
      u = l.map(([, f2]) => sn(f2));
      break;
    case "u":
      u = l.map(([, f2]) => f2.charAt(0).toUpperCase() + f2.slice(1));
      break;
    case "U":
      u = l.map(([, f2]) => f2.toUpperCase());
      break;
    case "L":
      u = l.map(([, f2]) => f2.toLowerCase());
      break;
    default:
      u = l.map(([, f2]) => f2);
  }
  if (o2) {
    let f2 = oe(e2.state.env);
    return { values: [u.join(f2)], quoted: true };
  }
  return { values: u, quoted: true };
}
var Vg = v(() => {
  de();
  St();
  Va();
  qa();
  ht();
  ai();
});
function qg(e2, t2) {
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let n2 = t2[0];
  if (n2.parts.length !== 1 || n2.parts[0].type !== "ParameterExpansion") return null;
  let r2 = n2.parts[0];
  if (r2.operation) return null;
  let s2 = r2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(@)\]$/);
  if (!s2) return null;
  let i2 = s2[1];
  if (Se(e2, i2)) {
    let l = kn(e2, i2);
    if ((l == null ? void 0 : l.endsWith("[@]")) || (l == null ? void 0 : l.endsWith("[*]"))) return { values: [], quoted: true };
  }
  let o2 = te(e2, i2);
  if (o2.length > 0) return { values: o2.map(([, l]) => l), quoted: true };
  let a = e2.state.env[i2];
  return a !== void 0 ? { values: [a], quoted: true } : { values: [], quoted: true };
}
function Gg(e2, t2) {
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let n2 = t2[0];
  if (n2.parts.length !== 1 || n2.parts[0].type !== "ParameterExpansion" || n2.parts[0].operation) return null;
  let s2 = n2.parts[0].parameter;
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s2) || !Se(e2, s2)) return null;
  let i2 = kn(e2, s2);
  if (!i2) return null;
  let o2 = i2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(@)\]$/);
  if (!o2) return null;
  let a = o2[1], l = te(e2, a);
  if (l.length > 0) return { values: l.map(([, u]) => u), quoted: true };
  let c = e2.state.env[a];
  return c !== void 0 ? { values: [c], quoted: true } : { values: [], quoted: true };
}
var Zg = v(() => {
  Tt();
  ht();
});
async function Qg(e2, t2, n2, r2, s2) {
  var _a3;
  if (!n2 || t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let i2 = t2[0];
  if (i2.parts.length !== 1 || i2.parts[0].type !== "ParameterExpansion" || ((_a3 = i2.parts[0].operation) == null ? void 0 : _a3.type) !== "Indirection") return null;
  let o2 = i2.parts[0], a = o2.operation, l = await me(e2, o2.parameter), c = l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!c) {
    if (!a.innerOp && (l === "@" || l === "*")) {
      let m = Number.parseInt(e2.state.env["#"] || "0", 10), h = [];
      for (let g = 1; g <= m; g++) h.push(e2.state.env[String(g)] || "");
      return l === "*" ? { values: [h.join(oe(e2.state.env))], quoted: true } : { values: h, quoted: true };
    }
    return null;
  }
  let u = c[1], f2 = c[2] === "*", p = te(e2, u);
  if (a.innerOp) {
    if (a.innerOp.type === "Substring") return YC(e2, p, u, f2, a.innerOp);
    if (a.innerOp.type === "DefaultValue" || a.innerOp.type === "UseAlternative" || a.innerOp.type === "AssignDefault" || a.innerOp.type === "ErrorIfUnset") return eN(e2, p, u, f2, a.innerOp, s2);
    if (a.innerOp.type === "Transform" && a.innerOp.operator === "a") {
      let h = an(e2, u), g = p.map(() => h);
      return f2 ? { values: [g.join(oe(e2.state.env))], quoted: true } : { values: g, quoted: true };
    }
    let m = [];
    for (let [, h] of p) {
      let g = { type: "ParameterExpansion", parameter: "_indirect_elem_", operation: a.innerOp }, b = e2.state.env._indirect_elem_;
      e2.state.env._indirect_elem_ = h;
      try {
        let y = await r2(e2, g, true);
        m.push(y);
      } finally {
        b !== void 0 ? e2.state.env._indirect_elem_ = b : delete e2.state.env._indirect_elem_;
      }
    }
    return f2 ? { values: [m.join(oe(e2.state.env))], quoted: true } : { values: m, quoted: true };
  }
  if (p.length > 0) {
    let m = p.map(([, h]) => h);
    return f2 ? { values: [m.join(oe(e2.state.env))], quoted: true } : { values: m, quoted: true };
  }
  let d = e2.state.env[u];
  return d !== void 0 ? { values: [d], quoted: true } : { values: [], quoted: true };
}
async function YC(e2, t2, n2, r2, s2) {
  let i2 = s2.offset ? await Q(e2, s2.offset.expression) : 0, o2 = s2.length ? await Q(e2, s2.length.expression) : void 0, a = 0;
  if (i2 < 0) {
    if (t2.length > 0) {
      let u = t2[t2.length - 1][0], p = (typeof u == "number" ? u : 0) + 1 + i2;
      if (p < 0) return { values: [], quoted: true };
      if (a = t2.findIndex(([d]) => typeof d == "number" && d >= p), a < 0) return { values: [], quoted: true };
    }
  } else if (a = t2.findIndex(([u]) => typeof u == "number" && u >= i2), a < 0) return { values: [], quoted: true };
  let l;
  if (o2 !== void 0) {
    if (o2 < 0) throw new Ee(`${n2}[@]: substring expression < 0`);
    l = t2.slice(a, a + o2);
  } else l = t2.slice(a);
  let c = l.map(([, u]) => u);
  return r2 ? { values: [c.join(oe(e2.state.env))], quoted: true } : { values: c, quoted: true };
}
async function eN(e2, t2, n2, r2, s2, i2) {
  let o2 = s2.checkEmpty ?? false, a = t2.map(([, u]) => u), l = t2.length === 0, c = t2.length === 0;
  if (s2.type === "UseAlternative") return !c && !(o2 && l) && s2.word ? { values: [await i2(e2, s2.word.parts, true)], quoted: true } : { values: [], quoted: true };
  if (s2.type === "DefaultValue") return (c || o2 && l) && s2.word ? { values: [await i2(e2, s2.word.parts, true)], quoted: true } : r2 ? { values: [a.join(oe(e2.state.env))], quoted: true } : { values: a, quoted: true };
  if (s2.type === "AssignDefault") {
    if ((c || o2 && l) && s2.word) {
      let f2 = await i2(e2, s2.word.parts, true);
      return e2.state.env[`${n2}_0`] = f2, e2.state.env[`${n2}__length`] = "1", { values: [f2], quoted: true };
    }
    return r2 ? { values: [a.join(oe(e2.state.env))], quoted: true } : { values: a, quoted: true };
  }
  return r2 ? { values: [a.join(oe(e2.state.env))], quoted: true } : { values: a, quoted: true };
}
async function Kg(e2, t2) {
  var _a3, _b3, _c2;
  if (t2.length !== 1 || t2[0].type !== "ParameterExpansion" || ((_a3 = t2[0].operation) == null ? void 0 : _a3.type) !== "UseAlternative" && ((_b3 = t2[0].operation) == null ? void 0 : _b3.type) !== "DefaultValue") return null;
  let n2 = t2[0], r2 = n2.operation, s2 = r2 == null ? void 0 : r2.word;
  if (!s2 || s2.parts.length !== 1 || s2.parts[0].type !== "DoubleQuoted") return null;
  let i2 = s2.parts[0];
  if (i2.parts.length !== 1 || i2.parts[0].type !== "ParameterExpansion" || ((_c2 = i2.parts[0].operation) == null ? void 0 : _c2.type) !== "Indirection") return null;
  let o2 = i2.parts[0], l = (await me(e2, o2.parameter)).match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!l) return null;
  let c = await zt(e2, n2.parameter), u = await me(e2, n2.parameter) === "", f2 = r2.checkEmpty ?? false, p;
  if (r2.type === "UseAlternative" ? p = c && !(f2 && u) : p = !c || f2 && u, p) {
    let d = l[1], m = l[2] === "*", h = te(e2, d);
    if (h.length > 0) {
      let b = h.map(([, y]) => y);
      return m ? { values: [b.join(oe(e2.state.env))], quoted: true } : { values: b, quoted: true };
    }
    let g = e2.state.env[d];
    return g !== void 0 ? { values: [g], quoted: true } : { values: [], quoted: true };
  }
  return { values: [], quoted: false };
}
async function Xg(e2, t2) {
  var _a3, _b3;
  if (t2.length !== 1 || t2[0].type !== "ParameterExpansion" || ((_a3 = t2[0].operation) == null ? void 0 : _a3.type) !== "Indirection") return null;
  let n2 = t2[0], s2 = n2.operation.innerOp;
  if (!s2 || s2.type !== "UseAlternative" && s2.type !== "DefaultValue") return null;
  let i2 = s2.word;
  if (!i2 || i2.parts.length !== 1 || i2.parts[0].type !== "DoubleQuoted") return null;
  let o2 = i2.parts[0];
  if (o2.parts.length !== 1 || o2.parts[0].type !== "ParameterExpansion" || ((_b3 = o2.parts[0].operation) == null ? void 0 : _b3.type) !== "Indirection") return null;
  let a = o2.parts[0], c = (await me(e2, a.parameter)).match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!c) return null;
  let u = await me(e2, n2.parameter), f2 = await zt(e2, n2.parameter), p = u === "", d = s2.checkEmpty ?? false, m;
  if (s2.type === "UseAlternative" ? m = f2 && !(d && p) : m = !f2 || d && p, m) {
    let h = c[1], g = c[2] === "*", b = te(e2, h);
    if (b.length > 0) {
      let w = b.map(([, E]) => E);
      return g ? { values: [w.join(oe(e2.state.env))], quoted: true } : { values: w, quoted: true };
    }
    let y = e2.state.env[h];
    return y !== void 0 ? { values: [y], quoted: true } : { values: [], quoted: true };
  }
  return { values: [], quoted: false };
}
var Jg = v(() => {
  it();
  de();
  St();
  ht();
  ai();
});
function Yg(e2) {
  let t2 = Number.parseInt(e2.state.env["#"] || "0", 10), n2 = [];
  for (let r2 = 1; r2 <= t2; r2++) n2.push(e2.state.env[String(r2)] || "");
  return n2;
}
async function e0(e2, t2, n2, r2) {
  var _a3;
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let s2 = t2[0], i2 = -1, o2 = false;
  for (let y = 0; y < s2.parts.length; y++) {
    let w = s2.parts[y];
    if (w.type === "ParameterExpansion" && (w.parameter === "@" || w.parameter === "*") && ((_a3 = w.operation) == null ? void 0 : _a3.type) === "Substring") {
      i2 = y, o2 = w.parameter === "*";
      break;
    }
  }
  if (i2 === -1) return null;
  let l = s2.parts[i2].operation, c = l.offset ? await n2(e2, l.offset.expression) : 0, u = l.length ? await n2(e2, l.length.expression) : void 0, f2 = Number.parseInt(e2.state.env["#"] || "0", 10), p = [];
  for (let y = 1; y <= f2; y++) p.push(e2.state.env[String(y)] || "");
  let d = e2.state.env[0] || "bash", m;
  if (c <= 0) {
    let y = [d, ...p], w = y.length + c;
    if (w < 0) m = [];
    else {
      let E = c < 0 ? w : 0;
      if (u !== void 0) {
        let C = u < 0 ? y.length + u : E + u;
        m = y.slice(E, Math.max(E, C));
      } else m = y.slice(E);
    }
  } else {
    let y = c - 1;
    if (y >= p.length) m = [];
    else if (u !== void 0) {
      let w = u < 0 ? p.length + u : y + u;
      m = p.slice(y, Math.max(y, w));
    } else m = p.slice(y);
  }
  let h = "";
  for (let y = 0; y < i2; y++) h += await r2(e2, s2.parts[y]);
  let g = "";
  for (let y = i2 + 1; y < s2.parts.length; y++) g += await r2(e2, s2.parts[y]);
  if (m.length === 0) {
    let y = h + g;
    return { values: y ? [y] : [], quoted: true };
  }
  if (o2) {
    let y = oe(e2.state.env);
    return { values: [h + m.join(y) + g], quoted: true };
  }
  return m.length === 1 ? { values: [h + m[0] + g], quoted: true } : { values: [h + m[0], ...m.slice(1, -1), m[m.length - 1] + g], quoted: true };
}
async function t0(e2, t2, n2, r2) {
  var _a3;
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let s2 = t2[0], i2 = -1, o2 = false;
  for (let b = 0; b < s2.parts.length; b++) {
    let y = s2.parts[b];
    if (y.type === "ParameterExpansion" && (y.parameter === "@" || y.parameter === "*") && ((_a3 = y.operation) == null ? void 0 : _a3.type) === "PatternReplacement") {
      i2 = b, o2 = y.parameter === "*";
      break;
    }
  }
  if (i2 === -1) return null;
  let l = s2.parts[i2].operation, c = Yg(e2), u = "";
  for (let b = 0; b < i2; b++) u += await n2(e2, s2.parts[b]);
  let f2 = "";
  for (let b = i2 + 1; b < s2.parts.length; b++) f2 += await n2(e2, s2.parts[b]);
  if (c.length === 0) {
    let b = u + f2;
    return { values: b ? [b] : [], quoted: true };
  }
  let p = "";
  if (l.pattern) for (let b of l.pattern.parts) if (b.type === "Glob") p += ce(b.pattern, true, e2.state.shoptOptions.extglob);
  else if (b.type === "Literal") p += ce(b.value, true, e2.state.shoptOptions.extglob);
  else if (b.type === "SingleQuoted" || b.type === "Escaped") p += pe(b.value);
  else if (b.type === "DoubleQuoted") {
    let y = await r2(e2, b.parts);
    p += pe(y);
  } else if (b.type === "ParameterExpansion") {
    let y = await n2(e2, b);
    p += ce(y, true, e2.state.shoptOptions.extglob);
  } else {
    let y = await n2(e2, b);
    p += pe(y);
  }
  let d = l.replacement ? await r2(e2, l.replacement.parts) : "", m = p;
  l.anchor === "start" ? m = `^${p}` : l.anchor === "end" && (m = `${p}$`);
  let h = [];
  try {
    let b = new RegExp(m, l.all ? "g" : "");
    for (let y of c) h.push(y.replace(b, d));
  } catch {
    h.push(...c);
  }
  if (o2) {
    let b = oe(e2.state.env);
    return { values: [u + h.join(b) + f2], quoted: true };
  }
  return h.length === 1 ? { values: [u + h[0] + f2], quoted: true } : { values: [u + h[0], ...h.slice(1, -1), h[h.length - 1] + f2], quoted: true };
}
async function n0(e2, t2, n2, r2) {
  var _a3;
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let s2 = t2[0], i2 = -1, o2 = false;
  for (let g = 0; g < s2.parts.length; g++) {
    let b = s2.parts[g];
    if (b.type === "ParameterExpansion" && (b.parameter === "@" || b.parameter === "*") && ((_a3 = b.operation) == null ? void 0 : _a3.type) === "PatternRemoval") {
      i2 = g, o2 = b.parameter === "*";
      break;
    }
  }
  if (i2 === -1) return null;
  let l = s2.parts[i2].operation, c = Yg(e2), u = "";
  for (let g = 0; g < i2; g++) u += await n2(e2, s2.parts[g]);
  let f2 = "";
  for (let g = i2 + 1; g < s2.parts.length; g++) f2 += await n2(e2, s2.parts[g]);
  if (c.length === 0) {
    let g = u + f2;
    return { values: g ? [g] : [], quoted: true };
  }
  let p = "", d = e2.state.shoptOptions.extglob;
  if (l.pattern) for (let g of l.pattern.parts) if (g.type === "Glob") p += ce(g.pattern, l.greedy, d);
  else if (g.type === "Literal") p += ce(g.value, l.greedy, d);
  else if (g.type === "SingleQuoted" || g.type === "Escaped") p += pe(g.value);
  else if (g.type === "DoubleQuoted") {
    let b = await r2(e2, g.parts);
    p += pe(b);
  } else if (g.type === "ParameterExpansion") {
    let b = await n2(e2, g);
    p += ce(b, l.greedy, d);
  } else {
    let b = await n2(e2, g);
    p += pe(b);
  }
  let m = [];
  for (let g of c) m.push(Kt(g, p, l.side, l.greedy));
  if (o2) {
    let g = oe(e2.state.env);
    return { values: [u + m.join(g) + f2], quoted: true };
  }
  return m.length === 1 ? { values: [u + m[0] + f2], quoted: true } : { values: [u + m[0], ...m.slice(1, -1), m[m.length - 1] + f2], quoted: true };
}
async function r0(e2, t2, n2) {
  if (t2.length !== 1 || t2[0].type !== "DoubleQuoted") return null;
  let r2 = t2[0], s2 = -1, i2 = false;
  for (let p = 0; p < r2.parts.length; p++) {
    let d = r2.parts[p];
    if (d.type === "ParameterExpansion" && (d.parameter === "@" || d.parameter === "*")) {
      s2 = p, i2 = d.parameter === "*";
      break;
    }
  }
  if (s2 === -1) return null;
  let o2 = r2.parts[s2];
  if (o2.type === "ParameterExpansion" && o2.operation) return null;
  let a = Number.parseInt(e2.state.env["#"] || "0", 10), l = "";
  for (let p = 0; p < s2; p++) l += await n2(e2, r2.parts[p]);
  let c = "";
  for (let p = s2 + 1; p < r2.parts.length; p++) c += await n2(e2, r2.parts[p]);
  if (a === 0) {
    if (i2) return { values: [l + c], quoted: true };
    let p = l + c;
    return { values: p ? [p] : [], quoted: true };
  }
  let u = [];
  for (let p = 1; p <= a; p++) u.push(e2.state.env[String(p)] || "");
  if (i2) {
    let p = oe(e2.state.env);
    return { values: [l + u.join(p) + c], quoted: true };
  }
  return u.length === 1 ? { values: [l + u[0] + c], quoted: true } : { values: [l + u[0], ...u.slice(1, -1), u[u.length - 1] + c], quoted: true };
}
var s0 = v(() => {
  St();
  nr();
  rr();
  vn();
});
function tN(e2) {
  return new rn(e2.fs, e2.state.cwd, e2.state.env, { globstar: e2.state.shoptOptions.globstar, nullglob: e2.state.shoptOptions.nullglob, failglob: e2.state.shoptOptions.failglob, dotglob: e2.state.shoptOptions.dotglob, extglob: e2.state.shoptOptions.extglob, globskipdots: e2.state.shoptOptions.globskipdots });
}
async function ci(e2, t2) {
  if (e2.state.options.noglob) return t2;
  let n2 = tN(e2), r2 = [];
  for (let s2 of t2) if (jt(s2, e2.state.shoptOptions.extglob)) {
    let i2 = await n2.expand(s2);
    if (i2.length > 0) r2.push(...i2);
    else {
      if (n2.hasFailglob()) throw new _t(s2);
      n2.hasNullglob() || r2.push(s2);
    }
  } else r2.push(s2);
  return r2;
}
async function i0(e2, t2, n2, r2) {
  var _a3;
  let s2 = -1, i2 = "", o2 = false;
  for (let y = 0; y < t2.length; y++) {
    let w = t2[y];
    if (w.type === "ParameterExpansion" && ((_a3 = w.operation) == null ? void 0 : _a3.type) === "PatternReplacement") {
      let E = w.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (E) {
        s2 = y, i2 = E[1], o2 = E[2] === "*";
        break;
      }
    }
  }
  if (s2 === -1) return null;
  let l = t2[s2].operation, c = te(e2, i2), u = c.map(([, y]) => y);
  if (c.length === 0) {
    let y = e2.state.env[i2];
    y !== void 0 && (u = [y]);
  }
  if (u.length === 0) return { values: [], quoted: false };
  let f2 = "";
  if (l.pattern) for (let y of l.pattern.parts) if (y.type === "Glob") f2 += ce(y.pattern, true, e2.state.shoptOptions.extglob);
  else if (y.type === "Literal") f2 += ce(y.value, true, e2.state.shoptOptions.extglob);
  else if (y.type === "SingleQuoted" || y.type === "Escaped") f2 += pe(y.value);
  else if (y.type === "DoubleQuoted") {
    let w = await n2(e2, y.parts);
    f2 += pe(w);
  } else if (y.type === "ParameterExpansion") {
    let w = await r2(e2, y);
    f2 += ce(w, true, e2.state.shoptOptions.extglob);
  } else {
    let w = await r2(e2, y);
    f2 += pe(w);
  }
  let p = l.replacement ? await n2(e2, l.replacement.parts) : "", d = f2;
  l.anchor === "start" ? d = `^${f2}` : l.anchor === "end" && (d = `${f2}$`);
  let m = [];
  try {
    let y = new RegExp(d, l.all ? "g" : "");
    for (let w of u) m.push(w.replace(y, p));
  } catch {
    m.push(...u);
  }
  let h = Ue(e2.state.env), g = Ze(e2.state.env);
  if (o2) {
    let y = oe(e2.state.env), w = m.join(y);
    return g ? { values: w ? [w] : [], quoted: false } : { values: Ae(w, h), quoted: false };
  }
  if (g) return { values: m, quoted: false };
  let b = [];
  for (let y of m) y === "" ? b.push("") : b.push(...Ae(y, h));
  return { values: b, quoted: false };
}
async function o0(e2, t2, n2, r2) {
  var _a3;
  let s2 = -1, i2 = "", o2 = false;
  for (let b = 0; b < t2.length; b++) {
    let y = t2[b];
    if (y.type === "ParameterExpansion" && ((_a3 = y.operation) == null ? void 0 : _a3.type) === "PatternRemoval") {
      let w = y.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (w) {
        s2 = b, i2 = w[1], o2 = w[2] === "*";
        break;
      }
    }
  }
  if (s2 === -1) return null;
  let l = t2[s2].operation, c = te(e2, i2), u = c.map(([, b]) => b);
  if (c.length === 0) {
    let b = e2.state.env[i2];
    b !== void 0 && (u = [b]);
  }
  if (u.length === 0) return { values: [], quoted: false };
  let f2 = "", p = e2.state.shoptOptions.extglob;
  if (l.pattern) for (let b of l.pattern.parts) if (b.type === "Glob") f2 += ce(b.pattern, l.greedy, p);
  else if (b.type === "Literal") f2 += ce(b.value, l.greedy, p);
  else if (b.type === "SingleQuoted" || b.type === "Escaped") f2 += pe(b.value);
  else if (b.type === "DoubleQuoted") {
    let y = await n2(e2, b.parts);
    f2 += pe(y);
  } else if (b.type === "ParameterExpansion") {
    let y = await r2(e2, b);
    f2 += ce(y, l.greedy, p);
  } else {
    let y = await r2(e2, b);
    f2 += pe(y);
  }
  let d = [];
  for (let b of u) d.push(Kt(b, f2, l.side, l.greedy));
  let m = Ue(e2.state.env), h = Ze(e2.state.env);
  if (o2) {
    let b = oe(e2.state.env), y = d.join(b);
    return h ? { values: y ? [y] : [], quoted: false } : { values: Ae(y, m), quoted: false };
  }
  if (h) return { values: d, quoted: false };
  let g = [];
  for (let b of d) b === "" ? g.push("") : g.push(...Ae(b, m));
  return { values: g, quoted: false };
}
async function a0(e2, t2, n2, r2) {
  var _a3;
  let s2 = -1, i2 = false;
  for (let g = 0; g < t2.length; g++) {
    let b = t2[g];
    if (b.type === "ParameterExpansion" && (b.parameter === "@" || b.parameter === "*") && ((_a3 = b.operation) == null ? void 0 : _a3.type) === "PatternRemoval") {
      s2 = g, i2 = b.parameter === "*";
      break;
    }
  }
  if (s2 === -1) return null;
  let a = t2[s2].operation, l = Number.parseInt(e2.state.env["#"] || "0", 10), c = [];
  for (let g = 1; g <= l; g++) c.push(e2.state.env[String(g)] || "");
  if (c.length === 0) return { values: [], quoted: false };
  let u = "", f2 = e2.state.shoptOptions.extglob;
  if (a.pattern) for (let g of a.pattern.parts) if (g.type === "Glob") u += ce(g.pattern, a.greedy, f2);
  else if (g.type === "Literal") u += ce(g.value, a.greedy, f2);
  else if (g.type === "SingleQuoted" || g.type === "Escaped") u += pe(g.value);
  else if (g.type === "DoubleQuoted") {
    let b = await n2(e2, g.parts);
    u += pe(b);
  } else if (g.type === "ParameterExpansion") {
    let b = await r2(e2, g);
    u += ce(b, a.greedy, f2);
  } else {
    let b = await r2(e2, g);
    u += pe(b);
  }
  let p = [];
  for (let g of c) p.push(Kt(g, u, a.side, a.greedy));
  let d = Ue(e2.state.env), m = Ze(e2.state.env);
  if (i2) {
    let g = oe(e2.state.env), b = p.join(g);
    return m ? { values: b ? [b] : [], quoted: false } : { values: Ae(b, d), quoted: false };
  }
  if (m) return { values: p, quoted: false };
  let h = [];
  for (let g of p) g === "" ? h.push("") : h.push(...Ae(g, d));
  return { values: h, quoted: false };
}
async function l0(e2, t2, n2, r2) {
  var _a3;
  let s2 = -1, i2 = false;
  for (let w = 0; w < t2.length; w++) {
    let E = t2[w];
    if (E.type === "ParameterExpansion" && (E.parameter === "@" || E.parameter === "*") && ((_a3 = E.operation) == null ? void 0 : _a3.type) === "Substring") {
      s2 = w, i2 = E.parameter === "*";
      break;
    }
  }
  if (s2 === -1) return null;
  let a = t2[s2].operation, l = a.offset ? await n2(e2, a.offset.expression) : 0, c = a.length ? await n2(e2, a.length.expression) : void 0, u = Number.parseInt(e2.state.env["#"] || "0", 10), f2 = [];
  for (let w = 1; w <= u; w++) f2.push(e2.state.env[String(w)] || "");
  let p = e2.state.env[0] || "bash", d;
  if (l <= 0) {
    let w = [p, ...f2], E = w.length + l;
    if (E < 0) d = [];
    else {
      let C = l < 0 ? E : 0;
      if (c !== void 0) {
        let A = c < 0 ? w.length + c : C + c;
        d = w.slice(C, Math.max(C, A));
      } else d = w.slice(C);
    }
  } else {
    let w = l - 1;
    if (w >= f2.length) d = [];
    else if (c !== void 0) {
      let E = c < 0 ? f2.length + c : w + c;
      d = f2.slice(w, Math.max(w, E));
    } else d = f2.slice(w);
  }
  let m = "";
  for (let w = 0; w < s2; w++) m += await r2(e2, t2[w]);
  let h = "";
  for (let w = s2 + 1; w < t2.length; w++) h += await r2(e2, t2[w]);
  let g = Ue(e2.state.env), b = Ze(e2.state.env);
  if (d.length === 0) {
    let w = m + h;
    return w ? b ? { values: [w], quoted: false } : { values: Ae(w, g), quoted: false } : { values: [], quoted: false };
  }
  let y;
  if (i2) {
    let w = oe(e2.state.env), E = m + d.join(w) + h;
    b ? y = E ? [E] : [] : y = Ae(E, g);
  } else if (b) d.length === 1 ? y = [m + d[0] + h] : y = [m + d[0], ...d.slice(1, -1), d[d.length - 1] + h];
  else {
    y = [];
    for (let w = 0; w < d.length; w++) {
      let E = d[w];
      if (w === 0 && (E = m + E), w === d.length - 1 && (E = E + h), E === "") y.push("");
      else {
        let C = Ae(E, g);
        y.push(...C);
      }
    }
  }
  return { values: await ci(e2, y), quoted: false };
}
async function c0(e2, t2) {
  if (t2.length !== 1 || t2[0].type !== "ParameterExpansion" || t2[0].parameter !== "@" && t2[0].parameter !== "*" || t2[0].operation) return null;
  let n2 = t2[0].parameter === "*", r2 = Number.parseInt(e2.state.env["#"] || "0", 10);
  if (r2 === 0) return { values: [], quoted: false };
  let s2 = [];
  for (let c = 1; c <= r2; c++) s2.push(e2.state.env[String(c)] || "");
  let i2 = Ue(e2.state.env), o2 = Ze(e2.state.env), a = ni(e2.state.env), l;
  if (n2) if (o2) l = s2.filter((c) => c !== "");
  else {
    let c = oe(e2.state.env), u = s2.join(c);
    l = Ae(u, i2);
  }
  else if (o2) l = s2.filter((c) => c !== "");
  else if (a) {
    l = [];
    for (let c of s2) {
      if (c === "") continue;
      let u = Ae(c, i2);
      l.push(...u);
    }
  } else {
    l = [];
    for (let c of s2) if (c === "") l.push("");
    else {
      let u = Ae(c, i2);
      l.push(...u);
    }
    for (; l.length > 0 && l[l.length - 1] === ""; ) l.pop();
  }
  return { values: await ci(e2, l), quoted: false };
}
async function u0(e2, t2) {
  if (t2.length !== 1 || t2[0].type !== "ParameterExpansion" || t2[0].operation) return null;
  let n2 = t2[0].parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!n2) return null;
  let r2 = n2[1], s2 = n2[2] === "*", i2 = te(e2, r2), o2;
  if (i2.length === 0) {
    let f2 = e2.state.env[r2];
    if (f2 !== void 0) o2 = [f2];
    else return { values: [], quoted: false };
  } else o2 = i2.map(([, f2]) => f2);
  let a = Ue(e2.state.env), l = Ze(e2.state.env), c = ni(e2.state.env), u;
  if (s2) if (l) u = o2.filter((f2) => f2 !== "");
  else {
    let f2 = oe(e2.state.env), p = o2.join(f2);
    u = Ae(p, a);
  }
  else if (l) u = o2.filter((f2) => f2 !== "");
  else if (c) {
    u = [];
    for (let f2 of o2) {
      if (f2 === "") continue;
      let p = Ae(f2, a);
      u.push(...p);
    }
  } else {
    u = [];
    for (let f2 of o2) if (f2 === "") u.push("");
    else {
      let p = Ae(f2, a);
      u.push(...p);
    }
    for (; u.length > 0 && u[u.length - 1] === ""; ) u.pop();
  }
  return { values: await ci(e2, u), quoted: false };
}
function f0(e2, t2) {
  var _a3;
  if (t2.length !== 1 || t2[0].type !== "ParameterExpansion" || ((_a3 = t2[0].operation) == null ? void 0 : _a3.type) !== "VarNamePrefix") return null;
  let n2 = t2[0].operation, r2 = sr(e2, n2.prefix);
  if (r2.length === 0) return { values: [], quoted: false };
  let s2 = Ue(e2.state.env), i2 = Ze(e2.state.env), o2;
  if (n2.star) if (i2) o2 = r2;
  else {
    let a = oe(e2.state.env), l = r2.join(a);
    o2 = Ae(l, s2);
  }
  else if (i2) o2 = r2;
  else {
    o2 = [];
    for (let a of r2) {
      let l = Ae(a, s2);
      o2.push(...l);
    }
  }
  return { values: o2, quoted: false };
}
function p0(e2, t2) {
  var _a3;
  if (t2.length !== 1 || t2[0].type !== "ParameterExpansion" || ((_a3 = t2[0].operation) == null ? void 0 : _a3.type) !== "ArrayKeys") return null;
  let n2 = t2[0].operation, s2 = te(e2, n2.array).map(([l]) => String(l));
  if (s2.length === 0) return { values: [], quoted: false };
  let i2 = Ue(e2.state.env), o2 = Ze(e2.state.env), a;
  if (n2.star) if (o2) a = s2;
  else {
    let l = oe(e2.state.env), c = s2.join(l);
    a = Ae(c, i2);
  }
  else if (o2) a = s2;
  else {
    a = [];
    for (let l of s2) {
      let c = Ae(l, i2);
      a.push(...c);
    }
  }
  return { values: a, quoted: false };
}
async function d0(e2, t2, n2) {
  let r2 = -1;
  for (let p = 0; p < t2.length; p++) {
    let d = t2[p];
    if (d.type === "ParameterExpansion" && (d.parameter === "@" || d.parameter === "*") && !d.operation) {
      r2 = p;
      break;
    }
  }
  if (r2 === -1 || t2.length <= 1) return null;
  let s2 = Number.parseInt(e2.state.env["#"] || "0", 10), i2 = [];
  for (let p = 1; p <= s2; p++) i2.push(e2.state.env[String(p)] || "");
  let o2 = "";
  for (let p = 0; p < r2; p++) o2 += await n2(e2, t2[p]);
  let a = "";
  for (let p = r2 + 1; p < t2.length; p++) a += await n2(e2, t2[p]);
  let l = Ue(e2.state.env), c = Ze(e2.state.env), u = ni(e2.state.env);
  if (s2 === 0) {
    let p = o2 + a;
    return { values: p ? [p] : [], quoted: false };
  }
  let f2;
  {
    let p = [];
    for (let d = 0; d < i2.length; d++) {
      let m = i2[d];
      d === 0 && (m = o2 + m), d === i2.length - 1 && (m = m + a), p.push(m);
    }
    if (c) f2 = p.filter((d) => d !== "");
    else if (u) {
      f2 = [];
      for (let d of p) {
        if (d === "") continue;
        let m = Ae(d, l);
        f2.push(...m);
      }
    } else {
      f2 = [];
      for (let d of p) if (d === "") f2.push("");
      else {
        let m = Ae(d, l);
        f2.push(...m);
      }
      for (; f2.length > 0 && f2[f2.length - 1] === ""; ) f2.pop();
    }
  }
  return f2.length === 0 ? { values: [], quoted: false } : { values: await ci(e2, f2), quoted: false };
}
var h0 = v(() => {
  Ys();
  de();
  St();
  nr();
  tr();
  rr();
  vn();
  ht();
});
async function y0(e2, t2, n2) {
  let r2 = t2.parts, { hasQuoted: s2, hasCommandSub: i2, hasArrayVar: o2, hasArrayAtExpansion: a, hasParamExpansion: l, hasVarNamePrefixExpansion: c, hasIndirection: u } = Lr(r2), p = n2.hasBraceExpansion(r2) ? await n2.expandWordWithBracesAsync(e2, t2) : null;
  if (p && p.length > 1) return nN(e2, p, s2);
  let d = await rN(e2, r2, a, c, u, n2);
  if (d !== null) return d;
  let m = await iN(e2, r2, n2);
  if (m !== null) return m;
  let h = await oN(e2, r2, n2);
  if (h !== null) return h;
  let g = await lN(e2, r2, n2.expandPart);
  if (g !== null) return g0(e2, g);
  if ((i2 || o2 || l) && !Ze(e2.state.env)) {
    let y = Ue(e2.state.env), w = n2.buildIfsCharClassPattern(y), E = await n2.smartWordSplit(e2, r2, y, w, n2.expandPart);
    return g0(e2, E);
  }
  let b = await n2.expandWordAsync(e2, t2);
  return cN(e2, t2, r2, b, s2, n2.expandWordForGlobbing);
}
async function nN(e2, t2, n2) {
  let r2 = [];
  for (let s2 of t2) if (!(!n2 && s2 === "")) if (!n2 && !e2.state.options.noglob && jt(s2, e2.state.shoptOptions.extglob)) {
    let i2 = await ui(e2, s2);
    r2.push(...i2);
  } else r2.push(s2);
  return { values: r2, quoted: false };
}
async function rN(e2, t2, n2, r2, s2, i2) {
  if (n2) {
    let o2 = qg(e2, t2);
    if (o2 !== null) return o2;
  }
  {
    let o2 = Gg(e2, t2);
    if (o2 !== null) return o2;
  }
  {
    let o2 = await Wg(e2, t2);
    if (o2 !== null) return o2;
  }
  {
    let o2 = await Bg(e2, t2, n2, i2.expandPart, i2.expandWordPartsAsync);
    if (o2 !== null) return o2;
  }
  {
    let o2 = await Ug(e2, t2, n2, i2.expandPart);
    if (o2 !== null) return o2;
  }
  {
    let o2 = await jg(e2, t2, i2.evaluateArithmetic);
    if (o2 !== null) return o2;
  }
  {
    let o2 = Hg(e2, t2);
    if (o2 !== null) return o2;
  }
  {
    let o2 = await _g(e2, t2, i2.expandWordPartsAsync, i2.expandPart);
    if (o2 !== null) return o2;
  }
  {
    let o2 = await Lg(e2, t2, i2.expandWordPartsAsync, i2.expandPart);
    if (o2 !== null) return o2;
  }
  if (r2 && t2.length === 1 && t2[0].type === "DoubleQuoted") {
    let o2 = sN(e2, t2);
    if (o2 !== null) return o2;
  }
  {
    let o2 = await Qg(e2, t2, s2, i2.expandParameterAsync, i2.expandWordPartsAsync);
    if (o2 !== null) return o2;
  }
  {
    let o2 = await Kg(e2, t2);
    if (o2 !== null) return o2;
  }
  {
    let o2 = await Xg(e2, t2);
    if (o2 !== null) return o2;
  }
  return null;
}
function sN(e2, t2) {
  var _a3, _b3;
  let n2 = t2[0];
  if (n2.type !== "DoubleQuoted") return null;
  if (n2.parts.length === 1 && n2.parts[0].type === "ParameterExpansion" && ((_a3 = n2.parts[0].operation) == null ? void 0 : _a3.type) === "VarNamePrefix") {
    let r2 = n2.parts[0].operation, s2 = sr(e2, r2.prefix);
    return r2.star ? { values: [s2.join(oe(e2.state.env))], quoted: true } : { values: s2, quoted: true };
  }
  if (n2.parts.length === 1 && n2.parts[0].type === "ParameterExpansion" && ((_b3 = n2.parts[0].operation) == null ? void 0 : _b3.type) === "ArrayKeys") {
    let r2 = n2.parts[0].operation, i2 = te(e2, r2.array).map(([o2]) => String(o2));
    return r2.star ? { values: [i2.join(oe(e2.state.env))], quoted: true } : { values: i2, quoted: true };
  }
  return null;
}
async function iN(e2, t2, n2) {
  {
    let r2 = await e0(e2, t2, n2.evaluateArithmetic, n2.expandPart);
    if (r2 !== null) return r2;
  }
  {
    let r2 = await t0(e2, t2, n2.expandPart, n2.expandWordPartsAsync);
    if (r2 !== null) return r2;
  }
  {
    let r2 = await n0(e2, t2, n2.expandPart, n2.expandWordPartsAsync);
    if (r2 !== null) return r2;
  }
  {
    let r2 = await r0(e2, t2, n2.expandPart);
    if (r2 !== null) return r2;
  }
  return null;
}
async function oN(e2, t2, n2) {
  {
    let r2 = await i0(e2, t2, n2.expandWordPartsAsync, n2.expandPart);
    if (r2 !== null) return r2;
  }
  {
    let r2 = await o0(e2, t2, n2.expandWordPartsAsync, n2.expandPart);
    if (r2 !== null) return r2;
  }
  {
    let r2 = await a0(e2, t2, n2.expandWordPartsAsync, n2.expandPart);
    if (r2 !== null) return r2;
  }
  {
    let r2 = await l0(e2, t2, n2.evaluateArithmetic, n2.expandPart);
    if (r2 !== null) return r2;
  }
  {
    let r2 = await c0(e2, t2);
    if (r2 !== null) return r2;
  }
  {
    let r2 = await u0(e2, t2);
    if (r2 !== null) return r2;
  }
  {
    let r2 = f0(e2, t2);
    if (r2 !== null) return r2;
  }
  {
    let r2 = p0(e2, t2);
    if (r2 !== null) return r2;
  }
  {
    let r2 = await d0(e2, t2, n2.expandPart);
    if (r2 !== null) return r2;
  }
  return null;
}
function m0(e2) {
  if (e2.type !== "DoubleQuoted") return null;
  for (let t2 = 0; t2 < e2.parts.length; t2++) {
    let n2 = e2.parts[t2];
    if (n2.type !== "ParameterExpansion" || n2.operation) continue;
    let r2 = n2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
    if (r2) return { type: "array", name: r2[1], atIndex: t2, isStar: r2[2] === "*" };
    if (n2.parameter === "@" || n2.parameter === "*") return { type: "positional", atIndex: t2, isStar: n2.parameter === "*" };
  }
  return null;
}
async function aN(e2, t2, n2, r2) {
  let s2 = "";
  for (let a = 0; a < n2.atIndex; a++) s2 += await r2(e2, t2.parts[a]);
  let i2 = "";
  for (let a = n2.atIndex + 1; a < t2.parts.length; a++) i2 += await r2(e2, t2.parts[a]);
  let o2;
  if (n2.type === "array") {
    if (o2 = te(e2, n2.name).map(([, l]) => l), o2.length === 0) {
      let l = e2.state.env[n2.name];
      l !== void 0 && (o2 = [l]);
    }
  } else {
    let a = Number.parseInt(e2.state.env["#"] || "0", 10);
    o2 = [];
    for (let l = 1; l <= a; l++) o2.push(e2.state.env[String(l)] || "");
  }
  if (n2.isStar) {
    let a = oe(e2.state.env), l = o2.join(a);
    return [s2 + l + i2];
  }
  if (o2.length === 0) {
    let a = s2 + i2;
    return a ? [a] : [];
  }
  return o2.length === 1 ? [s2 + o2[0] + i2] : [s2 + o2[0], ...o2.slice(1, -1), o2[o2.length - 1] + i2];
}
async function lN(e2, t2, n2) {
  if (t2.length < 2) return null;
  let r2 = false;
  for (let l of t2) if (m0(l)) {
    r2 = true;
    break;
  }
  if (!r2) return null;
  let s2 = Ue(e2.state.env), i2 = Ze(e2.state.env), o2 = [];
  for (let l of t2) {
    let c = m0(l);
    if (c && l.type === "DoubleQuoted") {
      let u = await aN(e2, l, c, n2);
      o2.push(u);
    } else if (l.type === "DoubleQuoted" || l.type === "SingleQuoted") {
      let u = await n2(e2, l);
      o2.push([u]);
    } else if (l.type === "Literal") o2.push([l.value]);
    else if (l.type === "ParameterExpansion") {
      let u = await n2(e2, l);
      if (i2) o2.push(u ? [u] : []);
      else {
        let f2 = Ae(u, s2);
        o2.push(f2);
      }
    } else {
      let u = await n2(e2, l);
      if (i2) o2.push(u ? [u] : []);
      else {
        let f2 = Ae(u, s2);
        o2.push(f2);
      }
    }
  }
  let a = [];
  for (let l of o2) if (l.length !== 0) if (a.length === 0) a.push(...l);
  else {
    let c = a.length - 1;
    a[c] = a[c] + l[0];
    for (let u = 1; u < l.length; u++) a.push(l[u]);
  }
  return a;
}
async function g0(e2, t2) {
  if (e2.state.options.noglob) return { values: t2, quoted: false };
  let n2 = [];
  for (let r2 of t2) if (jt(r2, e2.state.shoptOptions.extglob)) {
    let s2 = await ui(e2, r2);
    n2.push(...s2);
  } else n2.push(r2);
  return { values: n2, quoted: false };
}
async function ui(e2, t2) {
  let n2 = new rn(e2.fs, e2.state.cwd, e2.state.env, { globstar: e2.state.shoptOptions.globstar, nullglob: e2.state.shoptOptions.nullglob, failglob: e2.state.shoptOptions.failglob, dotglob: e2.state.shoptOptions.dotglob, extglob: e2.state.shoptOptions.extglob, globskipdots: e2.state.shoptOptions.globskipdots }), r2 = await n2.expand(t2);
  if (r2.length > 0) return r2;
  if (n2.hasFailglob()) throw new _t(t2);
  return n2.hasNullglob() ? [] : [t2];
}
async function cN(e2, t2, n2, r2, s2, i2) {
  let o2 = n2.some((a) => a.type === "Glob");
  if (!e2.state.options.noglob && o2) {
    let a = await i2(e2, t2);
    if (jt(a, e2.state.shoptOptions.extglob)) {
      let c = await ui(e2, a);
      if (c.length > 0 && c[0] !== a) return { values: c, quoted: false };
      if (c.length === 0) return { values: [], quoted: false };
    }
    let l = Ha(r2);
    if (!Ze(e2.state.env)) {
      let c = Ue(e2.state.env);
      return { values: Ae(l, c), quoted: false };
    }
    return { values: [l], quoted: false };
  }
  if (!s2 && !e2.state.options.noglob && jt(r2, e2.state.shoptOptions.extglob)) {
    let a = await i2(e2, t2);
    if (jt(a, e2.state.shoptOptions.extglob)) {
      let l = await ui(e2, a);
      if (l.length > 0 && l[0] !== a) return { values: l, quoted: false };
    }
  }
  if (r2 === "" && !s2) return { values: [], quoted: false };
  if (o2 && !s2) {
    let a = Ha(r2);
    if (!Ze(e2.state.env)) {
      let l = Ue(e2.state.env);
      return { values: Ae(a, l), quoted: false };
    }
    return { values: [a], quoted: false };
  }
  return { values: [r2], quoted: s2 };
}
var b0 = v(() => {
  Ys();
  de();
  St();
  ei();
  Mg();
  zg();
  Vg();
  Zg();
  tr();
  Jg();
  vn();
  s0();
  h0();
  ht();
});
async function x0(e2, t2) {
  let n2 = t2.operation;
  if (!n2 || n2.type !== "DefaultValue" && n2.type !== "AssignDefault" && n2.type !== "UseAlternative") return null;
  let r2 = n2.word;
  if (!r2 || r2.parts.length === 0) return null;
  let s2 = await zt(e2, t2.parameter), o2 = await me(e2, t2.parameter, false) === "", a = n2.checkEmpty ?? false, l;
  return n2.type === "UseAlternative" ? l = s2 && !(a && o2) : l = !s2 || a && o2, l ? r2.parts : null;
}
function uN(e2) {
  return e2.type === "SingleQuoted" ? true : e2.type === "DoubleQuoted" ? e2.parts.every((n2) => n2.type === "Literal") : false;
}
async function fN(e2, t2) {
  if (t2.type !== "ParameterExpansion") return null;
  let n2 = await x0(e2, t2);
  if (!n2 || n2.length <= 1) return null;
  let r2 = n2.some((i2) => uN(i2)), s2 = n2.some((i2) => i2.type === "Literal" || i2.type === "ParameterExpansion" || i2.type === "CommandSubstitution" || i2.type === "ArithmeticExpansion");
  return r2 && s2 ? n2 : null;
}
function pN(e2) {
  return e2.type === "DoubleQuoted" || e2.type === "SingleQuoted" || e2.type === "Literal" ? false : e2.type === "Glob" ? La(e2.pattern) : !(!(e2.type === "ParameterExpansion" || e2.type === "CommandSubstitution" || e2.type === "ArithmeticExpansion") || e2.type === "ParameterExpansion" && rg(e2));
}
async function E0(e2, t2, n2, r2, s2) {
  if (t2.length === 1 && t2[0].type === "ParameterExpansion") {
    let p = t2[0], d = await x0(e2, p);
    if (d && d.length > 0 && d.length > 1 && d.some((h) => h.type === "DoubleQuoted" || h.type === "SingleQuoted") && d.some((h) => h.type === "Literal" || h.type === "ParameterExpansion" || h.type === "CommandSubstitution" || h.type === "ArithmeticExpansion")) return w0(e2, d, n2, r2, s2);
  }
  let i2 = [], o2 = false;
  for (let p of t2) {
    let d = pN(p), m = p.type === "DoubleQuoted" || p.type === "SingleQuoted", h = d ? await fN(e2, p) : null, g = await s2(e2, p);
    i2.push({ value: g, isSplittable: d, isQuoted: m, mixedDefaultParts: h ?? void 0 }), d && (o2 = true);
  }
  if (!o2) {
    let p = i2.map((d) => d.value).join("");
    return p ? [p] : [];
  }
  let a = [], l = "", c = false, u = false, f2 = false;
  for (let p of i2) if (!p.isSplittable) u ? p.isQuoted && p.value === "" ? (l !== "" && a.push(l), a.push(""), c = true, l = "", u = false, f2 = true) : p.value !== "" ? (l !== "" && a.push(l), l = p.value, u = false, f2 = false) : (l += p.value, f2 = false) : (l += p.value, f2 = p.isQuoted && p.value === "");
  else if (p.mixedDefaultParts) {
    let d = await w0(e2, p.mixedDefaultParts, n2, r2, s2);
    if (d.length !== 0) if (d.length === 1) l += d[0], c = true;
    else {
      l += d[0], a.push(l), c = true;
      for (let m = 1; m < d.length - 1; m++) a.push(d[m]);
      l = d[d.length - 1];
    }
    u = false, f2 = false;
  } else {
    let { words: d, hadLeadingDelimiter: m, hadTrailingDelimiter: h } = ri(p.value, n2);
    if (f2 && m && l === "" && (a.push(""), c = true), d.length === 0) h && (u = true);
    else if (d.length === 1) l += d[0], c = true, u = h;
    else {
      l += d[0], a.push(l), c = true;
      for (let g = 1; g < d.length - 1; g++) a.push(d[g]);
      l = d[d.length - 1], u = h;
    }
    f2 = false;
  }
  return l !== "" ? a.push(l) : a.length === 0 && c && a.push(""), a;
}
function dN(e2, t2) {
  return e2.length > 0 && t2.includes(e2[0]);
}
async function w0(e2, t2, n2, r2, s2) {
  let i2 = [];
  for (let u of t2) {
    let p = !(u.type === "DoubleQuoted" || u.type === "SingleQuoted"), d = await s2(e2, u);
    i2.push({ value: d, isSplittable: p });
  }
  let o2 = [], a = "", l = false, c = false;
  for (let u of i2) if (!u.isSplittable) c && u.value !== "" ? (a !== "" && o2.push(a), a = u.value, c = false) : a += u.value;
  else {
    dN(u.value, n2) && a !== "" && (o2.push(a), a = "", l = true);
    let { words: p, hadTrailingDelimiter: d } = ri(u.value, n2);
    if (p.length === 0) d && (c = true);
    else if (p.length === 1) a += p[0], l = true, c = d;
    else {
      a += p[0], o2.push(a), l = true;
      for (let m = 1; m < p.length - 1; m++) o2.push(p[m]);
      a = p[p.length - 1], c = d;
    }
  }
  return a !== "" ? o2.push(a) : o2.length === 0 && l && o2.push(""), o2;
}
var S0 = v(() => {
  ht();
  St();
  ei();
});
function A0(e2) {
  switch (e2.type) {
    case "Literal":
      return e2.value;
    case "SingleQuoted":
      return e2.value;
    case "Escaped":
      return e2.value;
    default:
      return null;
  }
}
function C0(e2) {
  switch (e2.type) {
    case "SingleQuoted":
    case "Escaped":
    case "DoubleQuoted":
      return true;
    case "Literal":
      return e2.value === "";
    default:
      return false;
  }
}
var N0 = v(() => {
});
var Ya = {};
V(Ya, { escapeGlobChars: () => mt, escapeRegexChars: () => er, expandRedirectTarget: () => Br, expandWord: () => J, expandWordForPattern: () => Xa, expandWordForRegex: () => Ka, expandWordWithGlob: () => Ft, getArrayElements: () => te, getVariable: () => me, hasQuotedMultiValueAt: () => Wr, isArray: () => Qt, isWordFullyQuoted: () => Qa });
async function Dt(e2, t2, n2 = false) {
  let r2 = [];
  for (let s2 of t2) r2.push(await At(e2, s2, n2));
  return r2.join("");
}
function hN(e2) {
  return C0(e2);
}
function Qa(e2) {
  if (e2.parts.length === 0) return true;
  for (let t2 of e2.parts) if (!hN(t2)) return false;
  return true;
}
function mN(e2, t2, n2 = false) {
  let r2 = A0(t2);
  if (r2 !== null) return r2;
  switch (t2.type) {
    case "TildeExpansion":
      return n2 ? t2.user === null ? "~" : `~${t2.user}` : t2.user === null ? e2.state.env.HOME !== void 0 ? e2.state.env.HOME : "/home/user" : t2.user === "root" ? "/root" : `~${t2.user}`;
    case "Glob":
      return Ga(e2, t2.pattern);
    default:
      return null;
  }
}
async function J(e2, t2) {
  return Ja(e2, t2);
}
async function Ka(e2, t2) {
  let n2 = [];
  for (let r2 of t2.parts) if (r2.type === "Escaped") n2.push(`\\${r2.value}`);
  else if (r2.type === "SingleQuoted") n2.push(r2.value);
  else if (r2.type === "DoubleQuoted") {
    let s2 = await Dt(e2, r2.parts);
    n2.push(s2);
  } else if (r2.type === "TildeExpansion") {
    let s2 = await At(e2, r2);
    n2.push(er(s2));
  } else n2.push(await At(e2, r2));
  return n2.join("");
}
async function Xa(e2, t2) {
  let n2 = [];
  for (let r2 of t2.parts) if (r2.type === "Escaped") {
    let s2 = r2.value;
    "()|*?[]".includes(s2) ? n2.push(`\\${s2}`) : n2.push(s2);
  } else if (r2.type === "SingleQuoted") n2.push(mt(r2.value));
  else if (r2.type === "DoubleQuoted") {
    let s2 = await Dt(e2, r2.parts);
    n2.push(mt(s2));
  } else n2.push(await At(e2, r2));
  return n2.join("");
}
async function k0(e2, t2) {
  let n2 = [];
  for (let r2 of t2.parts) if (r2.type === "SingleQuoted") n2.push(mt(r2.value));
  else if (r2.type === "Escaped") {
    let s2 = r2.value;
    "*?[]\\()|".includes(s2) ? n2.push(`\\${s2}`) : n2.push(s2);
  } else if (r2.type === "DoubleQuoted") {
    let s2 = await Dt(e2, r2.parts);
    n2.push(mt(s2));
  } else r2.type === "Glob" ? Rg(r2.pattern) ? n2.push(await Tg(e2, r2.pattern)) : n2.push(Ga(e2, r2.pattern)) : r2.type === "Literal" ? n2.push(r2.value) : n2.push(await At(e2, r2));
  return n2.join("");
}
function pi(e2) {
  for (let t2 of e2) if (t2.type === "BraceExpansion" || t2.type === "DoubleQuoted" && pi(t2.parts)) return true;
  return false;
}
async function v0(e2, t2, n2 = { count: 0 }) {
  if (n2.count > Za) return [[]];
  let r2 = [[]];
  for (let s2 of t2) if (s2.type === "BraceExpansion") {
    let i2 = [], o2 = false, a = "";
    for (let u of s2.items) if (u.type === "Range") {
      let f2 = ja(u.start, u.end, u.step, u.startStr, u.endStr);
      if (f2.expanded) for (let p of f2.expanded) n2.count++, i2.push(p);
      else {
        o2 = true, a = f2.literal;
        break;
      }
    } else {
      let f2 = await v0(e2, u.word.parts, n2);
      for (let p of f2) {
        n2.count++;
        let d = [];
        for (let m of p) typeof m == "string" ? d.push(m) : d.push(await At(e2, m));
        i2.push(d.join(""));
      }
    }
    if (o2) {
      for (let u of r2) n2.count++, u.push(a);
      continue;
    }
    if (r2.length * i2.length > gN || n2.count > Za) return r2;
    let c = [];
    for (let u of r2) for (let f2 of i2) {
      if (n2.count++, n2.count > Za) return c.length > 0 ? c : r2;
      c.push([...u, f2]);
    }
    r2 = c;
  } else for (let i2 of r2) n2.count++, i2.push(s2);
  return r2;
}
async function $0(e2, t2) {
  let n2 = t2.parts;
  if (!pi(n2)) return [await J(e2, t2)];
  let r2 = await v0(e2, n2), s2 = [];
  for (let i2 of r2) {
    let o2 = [];
    for (let a of i2) typeof a == "string" ? o2.push(a) : o2.push(await At(e2, a));
    s2.push(Dg(e2, o2.join("")));
  }
  return s2;
}
function yN() {
  return { expandWordAsync: Ja, expandWordForGlobbing: k0, expandWordWithBracesAsync: $0, expandWordPartsAsync: Dt, expandPart: At, expandParameterAsync: fi, hasBraceExpansion: pi, evaluateArithmetic: Q, buildIfsCharClassPattern: sg, smartWordSplit: E0 };
}
async function Ft(e2, t2) {
  return y0(e2, t2, yN());
}
function bN(e2) {
  for (let t2 of e2) {
    if (t2.type === "ParameterExpansion") return t2.parameter;
    if (t2.type === "Literal") return t2.value;
  }
  return "";
}
function Wr(e2, t2) {
  if (Number.parseInt(e2.state.env["#"] || "0", 10) < 2) return false;
  function r2(s2) {
    for (let i2 of s2) if (i2.type === "DoubleQuoted") {
      for (let o2 of i2.parts) if (o2.type === "ParameterExpansion" && o2.parameter === "@" && !o2.operation) return true;
    }
    return false;
  }
  return r2(t2.parts);
}
async function Br(e2, t2) {
  if (Wr(e2, t2)) return { error: `bash: $@: ambiguous redirect
` };
  let n2 = t2.parts, { hasQuoted: r2 } = Lr(n2);
  if (pi(n2) && (await $0(e2, t2)).length > 1) return { error: `bash: ${n2.map((d) => d.type === "Literal" ? d.value : d.type === "BraceExpansion" ? `{${d.items.map((h) => {
    if (h.type === "Range") {
      let g = h.step ? `..${h.step}` : "";
      return `${h.startStr ?? h.start}..${h.endStr ?? h.end}${g}`;
    }
    return h.word.parts.map((g) => g.type === "Literal" ? g.value : "").join("");
  }).join(",")}}` : "").join("")}: ambiguous redirect
` };
  let s2 = await Ja(e2, t2), { hasParamExpansion: i2, hasCommandSub: o2 } = Lr(n2);
  if ((i2 || o2) && !r2 && !Ze(e2.state.env)) {
    let f2 = Ue(e2.state.env);
    if (Ae(s2, f2).length > 1) return { error: `bash: $${bN(n2)}: ambiguous redirect
` };
  }
  if (r2 || e2.state.options.noglob) return { target: s2 };
  let l = await k0(e2, t2);
  if (!jt(l, e2.state.shoptOptions.extglob)) return { target: s2 };
  let c = new rn(e2.fs, e2.state.cwd, e2.state.env, { globstar: e2.state.shoptOptions.globstar, nullglob: e2.state.shoptOptions.nullglob, failglob: e2.state.shoptOptions.failglob, dotglob: e2.state.shoptOptions.dotglob, extglob: e2.state.shoptOptions.extglob, globskipdots: e2.state.shoptOptions.globskipdots }), u = await c.expand(l);
  return u.length === 0 ? c.hasFailglob() ? { error: `bash: no match: ${s2}
` } : { target: s2 } : u.length === 1 ? { target: u[0] } : { error: `bash: ${s2}: ambiguous redirect
` };
}
async function Ja(e2, t2) {
  let n2 = t2.parts, r2 = n2.length;
  if (r2 === 1) return At(e2, n2[0]);
  let s2 = [];
  for (let i2 = 0; i2 < r2; i2++) s2.push(await At(e2, n2[i2]));
  return s2.join("");
}
async function At(e2, t2, n2 = false) {
  if (t2.type === "ParameterExpansion") return fi(e2, t2, n2);
  let r2 = mN(e2, t2, n2);
  if (r2 !== null) return r2;
  switch (t2.type) {
    case "DoubleQuoted": {
      let s2 = [];
      for (let i2 of t2.parts) s2.push(await At(e2, i2, true));
      return s2.join("");
    }
    case "CommandSubstitution": {
      let s2 = dg(t2.body);
      if (s2) try {
        let c = await J(e2, s2.target), u = c.startsWith("/") ? c : `${e2.state.cwd}/${c}`, f2 = await e2.fs.readFile(u);
        return e2.state.lastExitCode = 0, e2.state.env["?"] = "0", f2.replace(/\n+$/, "");
      } catch {
        return e2.state.lastExitCode = 1, e2.state.env["?"] = "1", "";
      }
      let i2 = e2.state.bashPid;
      e2.state.bashPid = e2.state.nextVirtualPid++;
      let o2 = { ...e2.state.env }, a = e2.state.cwd, l = e2.state.suppressVerbose;
      e2.state.suppressVerbose = true;
      try {
        let c = await e2.executeScript(t2.body), u = c.exitCode;
        return e2.state.env = o2, e2.state.cwd = a, e2.state.suppressVerbose = l, e2.state.lastExitCode = u, e2.state.env["?"] = String(u), c.stderr && (e2.state.expansionStderr = (e2.state.expansionStderr || "") + c.stderr), e2.state.bashPid = i2, c.stdout.replace(/\n+$/, "");
      } catch (c) {
        if (e2.state.env = o2, e2.state.cwd = a, e2.state.bashPid = i2, e2.state.suppressVerbose = l, c instanceof ne) throw c;
        if (c instanceof ae) return e2.state.lastExitCode = c.exitCode, e2.state.env["?"] = String(c.exitCode), c.stderr && (e2.state.expansionStderr = (e2.state.expansionStderr || "") + c.stderr), c.stdout.replace(/\n+$/, "");
        throw c;
      }
    }
    case "ArithmeticExpansion": {
      let s2 = t2.expression.originalText;
      if (s2 && /\$[a-zA-Z_][a-zA-Z0-9_]*(?![{[(])/.test(s2)) {
        let o2 = await ug(e2, s2), a = new se(), l = he(a, o2);
        return String(await Q(e2, l.expression, true));
      }
      return String(await Q(e2, t2.expression.expression, true));
    }
    case "BraceExpansion": {
      let s2 = [];
      for (let i2 of t2.items) if (i2.type === "Range") {
        let o2 = ja(i2.start, i2.end, i2.step, i2.startStr, i2.endStr);
        if (o2.expanded) s2.push(...o2.expanded);
        else return o2.literal;
      } else s2.push(await J(e2, i2.word));
      return s2.join(" ");
    }
    default:
      return "";
  }
}
async function fi(e2, t2, n2 = false) {
  var _a3, _b3;
  let { parameter: r2 } = t2, { operation: s2 } = t2, i2 = r2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (i2) {
    let [, p, d] = i2;
    if (((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(p)) || d.includes("$(") || d.includes("`") || d.includes("${")) {
      let h = await za(e2, d);
      r2 = `${p}[${h}]`;
    }
  } else if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r2) && Se(e2, r2)) {
    let p = st(e2, r2);
    if (p && p !== r2) {
      let d = p.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
      if (d) {
        let [, m, h] = d;
        if (((_b3 = e2.state.associativeArrays) == null ? void 0 : _b3.has(m)) || h.includes("$(") || h.includes("`") || h.includes("${")) {
          let b = await za(e2, h);
          r2 = `${m}[${b}]`;
        }
      }
    }
  }
  let o2 = s2 && (s2.type === "DefaultValue" || s2.type === "AssignDefault" || s2.type === "UseAlternative" || s2.type === "ErrorIfUnset"), a = await me(e2, r2, !o2);
  if (!s2) return a;
  let l = !await zt(e2, r2), { isEmpty: c, effectiveValue: u } = $g(e2, r2, a, n2), f2 = { isUnset: l, isEmpty: c, effectiveValue: u, inDoubleQuotes: n2 };
  switch (s2.type) {
    case "DefaultValue":
      return mg(e2, s2, f2, Dt);
    case "AssignDefault":
      return gg(e2, r2, s2, f2, Dt);
    case "ErrorIfUnset":
      return yg(e2, r2, s2, f2, Dt);
    case "UseAlternative":
      return bg(e2, s2, f2, Dt);
    case "PatternRemoval":
      return wg(e2, a, s2, Dt, At);
    case "PatternReplacement":
      return xg(e2, a, s2, Dt, At);
    case "Length":
      return Eg(e2, r2, a);
    case "LengthSliceError":
      throw new nt(r2);
    case "BadSubstitution":
      throw new nt(s2.text);
    case "Substring":
      return Sg(e2, r2, a, s2);
    case "CaseModification":
      return Ag(e2, a, s2, Dt, fi);
    case "Transform":
      return Cg(e2, r2, a, l, s2);
    case "Indirection":
      return Ng(e2, r2, a, l, s2, fi, n2);
    case "ArrayKeys":
      return kg(e2, s2);
    case "VarNamePrefix":
      return vg(e2, s2);
    default:
      return a;
  }
}
var gN, Za, ot = v(() => {
  Je();
  Fe();
  Ys();
  it();
  de();
  ei();
  fg();
  pg();
  hg();
  tr();
  Ig();
  Og();
  Fg();
  ht();
  b0();
  S0();
  St();
  Tt();
  N0();
  tr();
  ht();
  gN = 1e4, Za = 1e5;
});
function wN(e2, t2, n2) {
  switch (n2) {
    case "+":
      return e2 + t2;
    case "-":
      return e2 - t2;
    case "*":
      return e2 * t2;
    case "/":
      if (t2 === 0) throw new Ee("division by 0");
      return Math.trunc(e2 / t2);
    case "%":
      if (t2 === 0) throw new Ee("division by 0");
      return e2 % t2;
    case "**":
      if (t2 < 0) throw new Ee("exponent less than 0");
      return e2 ** t2;
    case "<<":
      return e2 << t2;
    case ">>":
      return e2 >> t2;
    case "<":
      return e2 < t2 ? 1 : 0;
    case "<=":
      return e2 <= t2 ? 1 : 0;
    case ">":
      return e2 > t2 ? 1 : 0;
    case ">=":
      return e2 >= t2 ? 1 : 0;
    case "==":
      return e2 === t2 ? 1 : 0;
    case "!=":
      return e2 !== t2 ? 1 : 0;
    case "&":
      return e2 & t2;
    case "|":
      return e2 | t2;
    case "^":
      return e2 ^ t2;
    case ",":
      return t2;
    default:
      return 0;
  }
}
function I0(e2, t2, n2) {
  switch (n2) {
    case "=":
      return t2;
    case "+=":
      return e2 + t2;
    case "-=":
      return e2 - t2;
    case "*=":
      return e2 * t2;
    case "/=":
      return t2 !== 0 ? Math.trunc(e2 / t2) : 0;
    case "%=":
      return t2 !== 0 ? e2 % t2 : 0;
    case "<<=":
      return e2 << t2;
    case ">>=":
      return e2 >> t2;
    case "&=":
      return e2 & t2;
    case "|=":
      return e2 | t2;
    case "^=":
      return e2 ^ t2;
    default:
      return t2;
  }
}
function xN(e2, t2) {
  switch (t2) {
    case "-":
      return -e2;
    case "+":
      return +e2;
    case "!":
      return e2 === 0 ? 1 : 0;
    case "~":
      return ~e2;
    default:
      return e2;
  }
}
async function EN(e2, t2) {
  let n2 = e2.state.env[t2];
  if (n2 !== void 0) return n2;
  let r2 = e2.state.env[`${t2}_0`];
  return r2 !== void 0 ? r2 : await me(e2, t2);
}
function SN(e2) {
  if (!e2) return 0;
  let t2 = Number.parseInt(e2, 10);
  if (!Number.isNaN(t2) && /^-?\d+$/.test(e2.trim())) return t2;
  let n2 = e2.trim();
  if (!n2) return 0;
  try {
    let r2 = new se(), { expr: s2, pos: i2 } = Et(r2, n2, 0);
    if (i2 < n2.length) {
      let o2 = n2.slice(i2).trim().split(/\s+/)[0];
      throw new Ee(`${n2}: syntax error in expression (error token is "${o2}")`);
    }
    return s2.type === "ArithNumber" ? s2.value : t2 || 0;
  } catch (r2) {
    if (r2 instanceof Ee) throw r2;
    let s2 = n2.split(/\s+/).slice(1)[0] || n2;
    throw new Ee(`${n2}: syntax error in expression (error token is "${s2}")`);
  }
}
async function el(e2, t2) {
  if (!t2) return 0;
  let n2 = Number.parseInt(t2, 10);
  if (!Number.isNaN(n2) && /^-?\d+$/.test(t2.trim())) return n2;
  let r2 = t2.trim();
  if (!r2) return 0;
  let s2 = new se(), { expr: i2, pos: o2 } = Et(s2, r2, 0);
  if (o2 < r2.length) {
    let a = r2.slice(o2).trim(), l = a.split(/\s+/)[0] || a;
    throw new Ee(`syntax error in expression (error token is "${l}")`, "", "");
  }
  return await Q(e2, i2);
}
async function tl(e2, t2, n2 = /* @__PURE__ */ new Set()) {
  if (n2.has(t2)) return 0;
  n2.add(t2);
  let r2 = await EN(e2, t2);
  if (!r2) return 0;
  let s2 = Number.parseInt(r2, 10);
  if (!Number.isNaN(s2) && /^-?\d+$/.test(r2.trim())) return s2;
  let i2 = r2.trim();
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(i2)) return await tl(e2, i2, n2);
  let o2 = new se(), { expr: a, pos: l } = Et(o2, i2, 0);
  if (l < i2.length) {
    let c = i2.slice(l).trim(), u = c.split(/\s+/)[0] || c;
    throw new Ee(`${i2}: syntax error in expression (error token is "${u}")`);
  }
  return await Q(e2, a);
}
async function di(e2, t2) {
  if (t2.startsWith("#")) {
    let f2 = t2.slice(1), p = f2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
    if (p) {
      let m = p[1], h = te(e2, m);
      return String(h.length);
    }
    let d = e2.state.env[f2] || "";
    return String(d.length);
  }
  if (t2.startsWith("!")) {
    let f2 = t2.slice(1), p = e2.state.env[f2] || "";
    return e2.state.env[p] || "";
  }
  let n2 = [":-", ":=", ":?", ":+", "-", "=", "?", "+"], r2 = -1, s2 = "";
  for (let f2 of n2) {
    let p = t2.indexOf(f2);
    p > 0 && (r2 === -1 || p < r2) && (r2 = p, s2 = f2);
  }
  if (r2 === -1) return await me(e2, t2);
  let i2 = t2.slice(0, r2), o2 = t2.slice(r2 + s2.length), a = e2.state.env[i2], l = a === void 0, c = a === "", u = s2.startsWith(":");
  switch (s2) {
    case ":-":
    case "-":
      return l || u && c ? o2 : a || "";
    case ":=":
    case "=":
      return l || u && c ? (e2.state.env[i2] = o2, o2) : a || "";
    case ":+":
    case "+":
      return !(l || u && c) ? o2 : "";
    case ":?":
    case "?": {
      if (l || u && c) throw new Error(o2 || `${i2}: parameter null or not set`);
      return a || "";
    }
    default:
      return a || "";
  }
}
async function Q(e2, t2, n2 = false) {
  var _a3, _b3, _c2, _d2, _e2, _f2, _g2;
  switch (t2.type) {
    case "ArithNumber":
      if (Number.isNaN(t2.value)) throw new Ee("value too great for base");
      return t2.value;
    case "ArithVariable":
      return await tl(e2, t2.name);
    case "ArithSpecialVar": {
      let s2 = (await me(e2, t2.name)).trim();
      if (!s2) return 0;
      let i2 = Number.parseInt(s2, 10);
      if (!Number.isNaN(i2) && /^-?\d+$/.test(s2)) return i2;
      let o2 = new se(), { expr: a } = Et(o2, s2, 0);
      return await Q(e2, a);
    }
    case "ArithNested":
      return await Q(e2, t2.expression);
    case "ArithCommandSubst": {
      if (e2.execFn) {
        let r2 = await e2.execFn(t2.command);
        r2.stderr && (e2.state.expansionStderr = (e2.state.expansionStderr || "") + r2.stderr);
        let s2 = r2.stdout.trim();
        return Number.parseInt(s2, 10) || 0;
      }
      return 0;
    }
    case "ArithBracedExpansion": {
      let r2 = await di(e2, t2.content);
      return Number.parseInt(r2, 10) || 0;
    }
    case "ArithDynamicBase": {
      let r2 = await di(e2, t2.baseExpr), s2 = Number.parseInt(r2, 10);
      if (s2 < 2 || s2 > 64) return 0;
      let i2 = `${s2}#${t2.value}`;
      return Fr(i2);
    }
    case "ArithDynamicNumber": {
      let s2 = await di(e2, t2.prefix) + t2.suffix;
      return Fr(s2);
    }
    case "ArithArrayElement": {
      let r2 = (_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(t2.array), s2 = async (i2) => {
        let o2 = e2.state.env[i2];
        return o2 !== void 0 ? await el(e2, o2) : 0;
      };
      if (t2.stringKey !== void 0) return await s2(`${t2.array}_${t2.stringKey}`);
      if (r2 && ((_b3 = t2.index) == null ? void 0 : _b3.type) === "ArithVariable" && !t2.index.hasDollarPrefix) return await s2(`${t2.array}_${t2.index.name}`);
      if (r2 && ((_c2 = t2.index) == null ? void 0 : _c2.type) === "ArithVariable" && t2.index.hasDollarPrefix) {
        let i2 = await me(e2, t2.index.name);
        return await s2(`${t2.array}_${i2}`);
      }
      if (t2.index) {
        let i2 = await Q(e2, t2.index, n2);
        if (i2 < 0) {
          let l = te(e2, t2.array), c = e2.state.currentLine;
          if (l.length === 0) return e2.state.expansionStderr = (e2.state.expansionStderr || "") + `bash: line ${c}: ${t2.array}: bad array subscript
`, 0;
          let f2 = Math.max(...l.map(([p]) => typeof p == "number" ? p : 0)) + 1 + i2;
          if (f2 < 0) return e2.state.expansionStderr = (e2.state.expansionStderr || "") + `bash: line ${c}: ${t2.array}: bad array subscript
`, 0;
          i2 = f2;
        }
        let o2 = `${t2.array}_${i2}`, a = e2.state.env[o2];
        if (a !== void 0) return el(e2, a);
        if (i2 === 0) {
          let l = e2.state.env[t2.array];
          if (l !== void 0) return el(e2, l);
        }
        if (e2.state.options.nounset && !Object.keys(e2.state.env).some((c) => c === t2.array || c.startsWith(`${t2.array}_`))) throw new tt(`${t2.array}[${i2}]`);
        return 0;
      }
      return 0;
    }
    case "ArithDoubleSubscript":
      throw new Ee("double subscript", "", "");
    case "ArithNumberSubscript":
      throw new Ee(`${t2.number}${t2.errorToken}: syntax error: invalid arithmetic operator (error token is "${t2.errorToken}")`);
    case "ArithSyntaxError":
      throw new Ee(t2.message, "", "", true);
    case "ArithSingleQuote": {
      if (n2) throw new Ee(`syntax error: operand expected (error token is "'${t2.content}'")`);
      return t2.value;
    }
    case "ArithBinary": {
      if (t2.operator === "||") return await Q(e2, t2.left, n2) || await Q(e2, t2.right, n2) ? 1 : 0;
      if (t2.operator === "&&") return await Q(e2, t2.left, n2) && await Q(e2, t2.right, n2) ? 1 : 0;
      let r2 = await Q(e2, t2.left, n2), s2 = await Q(e2, t2.right, n2);
      return wN(r2, s2, t2.operator);
    }
    case "ArithUnary": {
      let r2 = await Q(e2, t2.operand, n2);
      if (t2.operator === "++" || t2.operator === "--") {
        if (t2.operand.type === "ArithVariable") {
          let s2 = t2.operand.name, i2 = Number.parseInt(await me(e2, s2), 10) || 0, o2 = t2.operator === "++" ? i2 + 1 : i2 - 1;
          return e2.state.env[s2] = String(o2), t2.prefix ? o2 : i2;
        }
        if (t2.operand.type === "ArithArrayElement") {
          let s2 = t2.operand.array, i2 = (_d2 = e2.state.associativeArrays) == null ? void 0 : _d2.has(s2), o2;
          if (t2.operand.stringKey !== void 0) o2 = `${s2}_${t2.operand.stringKey}`;
          else if (i2 && ((_e2 = t2.operand.index) == null ? void 0 : _e2.type) === "ArithVariable" && !t2.operand.index.hasDollarPrefix) o2 = `${s2}_${t2.operand.index.name}`;
          else if (i2 && ((_f2 = t2.operand.index) == null ? void 0 : _f2.type) === "ArithVariable" && t2.operand.index.hasDollarPrefix) {
            let c = await me(e2, t2.operand.index.name);
            o2 = `${s2}_${c}`;
          } else if (t2.operand.index) {
            let c = await Q(e2, t2.operand.index, n2);
            o2 = `${s2}_${c}`;
          } else return r2;
          let a = Number.parseInt(e2.state.env[o2] || "0", 10) || 0, l = t2.operator === "++" ? a + 1 : a - 1;
          return e2.state.env[o2] = String(l), t2.prefix ? l : a;
        }
        if (t2.operand.type === "ArithConcat") {
          let s2 = "";
          for (let i2 of t2.operand.parts) s2 += await ir(e2, i2, n2);
          if (s2 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s2)) {
            let i2 = Number.parseInt(e2.state.env[s2] || "0", 10) || 0, o2 = t2.operator === "++" ? i2 + 1 : i2 - 1;
            return e2.state.env[s2] = String(o2), t2.prefix ? o2 : i2;
          }
        }
        if (t2.operand.type === "ArithDynamicElement") {
          let s2 = "";
          if (t2.operand.nameExpr.type === "ArithConcat") for (let i2 of t2.operand.nameExpr.parts) s2 += await ir(e2, i2, n2);
          else t2.operand.nameExpr.type === "ArithVariable" && (s2 = t2.operand.nameExpr.hasDollarPrefix ? await me(e2, t2.operand.nameExpr.name) : t2.operand.nameExpr.name);
          if (s2 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s2)) {
            let i2 = await Q(e2, t2.operand.subscript, n2), o2 = `${s2}_${i2}`, a = Number.parseInt(e2.state.env[o2] || "0", 10) || 0, l = t2.operator === "++" ? a + 1 : a - 1;
            return e2.state.env[o2] = String(l), t2.prefix ? l : a;
          }
        }
        return r2;
      }
      return xN(r2, t2.operator);
    }
    case "ArithTernary":
      return await Q(e2, t2.condition, n2) ? await Q(e2, t2.consequent, n2) : await Q(e2, t2.alternate, n2);
    case "ArithAssignment": {
      let r2 = t2.variable, s2 = r2;
      if (t2.stringKey !== void 0) s2 = `${r2}_${t2.stringKey}`;
      else if (t2.subscript) {
        let l = (_g2 = e2.state.associativeArrays) == null ? void 0 : _g2.has(r2);
        if (l && t2.subscript.type === "ArithVariable" && !t2.subscript.hasDollarPrefix) s2 = `${r2}_${t2.subscript.name}`;
        else if (l && t2.subscript.type === "ArithVariable" && t2.subscript.hasDollarPrefix) {
          let c = await me(e2, t2.subscript.name);
          s2 = `${r2}_${c || "\\"}`;
        } else if (l) {
          let c = await Q(e2, t2.subscript, n2);
          s2 = `${r2}_${c}`;
        } else {
          let c = await Q(e2, t2.subscript, n2);
          if (c < 0) {
            let u = te(e2, r2);
            u.length > 0 && (c = Math.max(...u.map(([p]) => typeof p == "number" ? p : 0)) + 1 + c);
          }
          s2 = `${r2}_${c}`;
        }
      }
      let i2 = Number.parseInt(e2.state.env[s2] || "0", 10) || 0, o2 = await Q(e2, t2.value, n2), a = I0(i2, o2, t2.operator);
      return e2.state.env[s2] = String(a), a;
    }
    case "ArithGroup":
      return await Q(e2, t2.expression, n2);
    case "ArithConcat": {
      let r2 = "";
      for (let s2 of t2.parts) r2 += await ir(e2, s2, n2);
      return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r2) ? await tl(e2, r2) : Number.parseInt(r2, 10) || 0;
    }
    case "ArithDynamicAssignment": {
      let r2 = "";
      if (t2.target.type === "ArithConcat") for (let l of t2.target.parts) r2 += await ir(e2, l, n2);
      else t2.target.type === "ArithVariable" && (r2 = t2.target.hasDollarPrefix ? await me(e2, t2.target.name) : t2.target.name);
      if (!r2 || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r2)) return 0;
      let s2 = r2;
      if (t2.subscript) {
        let l = await Q(e2, t2.subscript, n2);
        s2 = `${r2}_${l}`;
      }
      let i2 = Number.parseInt(e2.state.env[s2] || "0", 10) || 0, o2 = await Q(e2, t2.value, n2), a = I0(i2, o2, t2.operator);
      return e2.state.env[s2] = String(a), a;
    }
    case "ArithDynamicElement": {
      let r2 = "";
      if (t2.nameExpr.type === "ArithConcat") for (let a of t2.nameExpr.parts) r2 += await ir(e2, a, n2);
      else t2.nameExpr.type === "ArithVariable" && (r2 = t2.nameExpr.hasDollarPrefix ? await me(e2, t2.nameExpr.name) : t2.nameExpr.name);
      if (!r2 || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r2)) return 0;
      let s2 = await Q(e2, t2.subscript, n2), i2 = `${r2}_${s2}`, o2 = e2.state.env[i2];
      return o2 !== void 0 ? SN(o2) : 0;
    }
    default:
      return 0;
  }
}
async function ir(e2, t2, n2 = false) {
  switch (t2.type) {
    case "ArithNumber":
      return String(t2.value);
    case "ArithSingleQuote":
      return String(await Q(e2, t2, n2));
    case "ArithVariable":
      return t2.hasDollarPrefix ? await me(e2, t2.name) : t2.name;
    case "ArithSpecialVar":
      return await me(e2, t2.name);
    case "ArithBracedExpansion":
      return await di(e2, t2.content);
    case "ArithCommandSubst":
      return e2.execFn ? (await e2.execFn(t2.command)).stdout.trim() : "0";
    case "ArithConcat": {
      let r2 = "";
      for (let s2 of t2.parts) r2 += await ir(e2, s2, n2);
      return r2;
    }
    default:
      return String(await Q(e2, t2, n2));
  }
}
var it = v(() => {
  Je();
  Fe();
  de();
  ot();
});
var aa = [{ name: "echo", load: async () => (await Promise.resolve().then(() => (Jl(), Xl))).echoCommand }, { name: "cat", load: async () => (await Promise.resolve().then(() => (ec(), Yl))).catCommand }, { name: "printf", load: async () => (await Promise.resolve().then(() => (cc(), lc))).printfCommand }, { name: "ls", load: async () => (await Promise.resolve().then(() => (dc(), pc))).lsCommand }, { name: "mkdir", load: async () => (await Promise.resolve().then(() => (mc(), hc))).mkdirCommand }, { name: "rmdir", load: async () => (await Promise.resolve().then(() => (wc(), bc))).rmdirCommand }, { name: "touch", load: async () => (await Promise.resolve().then(() => (Ec(), xc))).touchCommand }, { name: "rm", load: async () => (await Promise.resolve().then(() => (Ac(), Sc))).rmCommand }, { name: "cp", load: async () => (await Promise.resolve().then(() => (Nc(), Cc))).cpCommand }, { name: "mv", load: async () => (await Promise.resolve().then(() => (vc(), kc))).mvCommand }, { name: "ln", load: async () => (await Promise.resolve().then(() => (Ic(), $c))).lnCommand }, { name: "chmod", load: async () => (await Promise.resolve().then(() => (Tc(), Pc))).chmodCommand }, { name: "pwd", load: async () => (await Promise.resolve().then(() => (Dc(), Oc))).pwdCommand }, { name: "readlink", load: async () => (await Promise.resolve().then(() => (_c(), Fc))).readlinkCommand }, { name: "head", load: async () => (await Promise.resolve().then(() => (Bc(), Wc))).headCommand }, { name: "tail", load: async () => (await Promise.resolve().then(() => (zc(), Uc))).tailCommand }, { name: "wc", load: async () => (await Promise.resolve().then(() => (Vc(), Hc))).wcCommand }, { name: "stat", load: async () => (await Promise.resolve().then(() => (Zc(), Gc))).statCommand }, { name: "grep", load: async () => (await Promise.resolve().then(() => (os(), is))).grepCommand }, { name: "fgrep", load: async () => (await Promise.resolve().then(() => (os(), is))).fgrepCommand }, { name: "egrep", load: async () => (await Promise.resolve().then(() => (os(), is))).egrepCommand }, { name: "rg", load: async () => (await Promise.resolve().then(() => (gu(), mu))).rgCommand }, { name: "sed", load: async () => (await Promise.resolve().then(() => (vu(), ku))).sedCommand }, { name: "awk", load: async () => (await Promise.resolve().then(() => (of(), sf))).awkCommand2 }, { name: "sort", load: async () => (await Promise.resolve().then(() => (gf(), mf))).sortCommand }, { name: "uniq", load: async () => (await Promise.resolve().then(() => (bf(), yf))).uniqCommand }, { name: "comm", load: async () => (await Promise.resolve().then(() => (xf(), wf))).commCommand }, { name: "cut", load: async () => (await Promise.resolve().then(() => (Sf(), Ef))).cutCommand }, { name: "paste", load: async () => (await Promise.resolve().then(() => (Nf(), Cf))).pasteCommand }, { name: "tr", load: async () => (await Promise.resolve().then(() => ($f(), vf))).trCommand }, { name: "rev", load: async () => (await Promise.resolve().then(() => (Rf(), If))).rev }, { name: "nl", load: async () => (await Promise.resolve().then(() => (Of(), Tf))).nl }, { name: "fold", load: async () => (await Promise.resolve().then(() => (_f(), Ff))).fold }, { name: "expand", load: async () => (await Promise.resolve().then(() => (Wf(), Mf))).expand }, { name: "unexpand", load: async () => (await Promise.resolve().then(() => (jf(), zf))).unexpand }, { name: "strings", load: async () => (await Promise.resolve().then(() => (Gf(), qf))).strings }, { name: "split", load: async () => (await Promise.resolve().then(() => (Kf(), Qf))).split }, { name: "column", load: async () => (await Promise.resolve().then(() => (Yf(), Jf))).column }, { name: "join", load: async () => (await Promise.resolve().then(() => (tp(), ep))).join }, { name: "tee", load: async () => (await Promise.resolve().then(() => (rp(), np))).teeCommand }, { name: "find", load: async () => (await Promise.resolve().then(() => (pp$a(), fp))).findCommand }, { name: "basename", load: async () => (await Promise.resolve().then(() => (hp(), dp))).basenameCommand }, { name: "dirname", load: async () => (await Promise.resolve().then(() => (gp(), mp))).dirnameCommand }, { name: "tree", load: async () => (await Promise.resolve().then(() => (wp(), bp))).treeCommand }, { name: "du", load: async () => (await Promise.resolve().then(() => (Sp(), Ep))).duCommand }, { name: "env", load: async () => (await Promise.resolve().then(() => (xo(), wo))).envCommand }, { name: "printenv", load: async () => (await Promise.resolve().then(() => (xo(), wo))).printenvCommand }, { name: "alias", load: async () => (await Promise.resolve().then(() => (So(), Eo))).aliasCommand }, { name: "unalias", load: async () => (await Promise.resolve().then(() => (So(), Eo))).unaliasCommand }, { name: "history", load: async () => (await Promise.resolve().then(() => (Np(), Cp))).historyCommand }, { name: "xargs", load: async () => (await Promise.resolve().then(() => (vp(), kp))).xargsCommand }, { name: "true", load: async () => (await Promise.resolve().then(() => (Co(), Ao))).trueCommand }, { name: "false", load: async () => (await Promise.resolve().then(() => (Co(), Ao))).falseCommand }, { name: "clear", load: async () => (await Promise.resolve().then(() => (Ip(), $p))).clearCommand }, { name: "bash", load: async () => (await Promise.resolve().then(() => (ko(), No))).bashCommand }, { name: "sh", load: async () => (await Promise.resolve().then(() => (ko(), No))).shCommand }, { name: "jq", load: async () => (await Promise.resolve().then(() => (nd(), td))).jqCommand }, { name: "base64", load: async () => (await Promise.resolve().then(() => (id(), sd))).base64Command }, { name: "diff", load: async () => (await Promise.resolve().then(() => (ld(), ad))).diffCommand }, { name: "date", load: async () => (await Promise.resolve().then(() => (ud(), cd))).dateCommand }, { name: "sleep", load: async () => (await Promise.resolve().then(() => (pd(), fd))).sleepCommand }, { name: "timeout", load: async () => (await Promise.resolve().then(() => (hd(), dd))).timeoutCommand }, { name: "time", load: async () => (await Promise.resolve().then(() => (gd(), md))).timeCommand }, { name: "seq", load: async () => (await Promise.resolve().then(() => (bd(), yd))).seqCommand }, { name: "expr", load: async () => (await Promise.resolve().then(() => (xd(), wd))).exprCommand }, { name: "md5sum", load: async () => (await Promise.resolve().then(() => (Ad(), Sd))).md5sumCommand }, { name: "sha1sum", load: async () => (await Promise.resolve().then(() => (Nd(), Cd))).sha1sumCommand }, { name: "sha256sum", load: async () => (await Promise.resolve().then(() => (vd(), kd))).sha256sumCommand }, { name: "file", load: async () => (await Promise.resolve().then(() => (xh(), wh))).fileCommand }, { name: "html-to-markdown", load: async () => (await Promise.resolve().then(() => (Sh(), Eh))).htmlToMarkdownCommand }, { name: "help", load: async () => (await Promise.resolve().then(() => (Ch(), Ah))).helpCommand }, { name: "which", load: async () => (await Promise.resolve().then(() => (kh(), Nh))).whichCommand }, { name: "tac", load: async () => (await Promise.resolve().then(() => ($h(), vh))).tac }, { name: "hostname", load: async () => (await Promise.resolve().then(() => (Rh(), Ih))).hostname }, { name: "whoami", load: async () => (await Promise.resolve().then(() => (Th(), Ph))).whoami }, { name: "od", load: async () => (await Promise.resolve().then(() => (Dh(), Oh))).od }, { name: "gzip", load: async () => (await Promise.resolve().then(() => (Hs(), js))).gzipCommand }, { name: "gunzip", load: async () => (await Promise.resolve().then(() => (Hs(), js))).gunzipCommand }, { name: "zcat", load: async () => (await Promise.resolve().then(() => (Hs(), js))).zcatCommand }], Kh = [{ name: "curl", load: async () => (await Promise.resolve().then(() => (Zh(), Gh))).curlCommand }], Qh = /* @__PURE__ */ new Map();
function Xh(e2) {
  return { name: e2.name, async execute(t2, n2) {
    let r2 = Qh.get(e2.name);
    return r2 || (r2 = await e2.load(), Qh.set(e2.name, r2)), r2.execute(t2, n2);
  } };
}
function Jh(e2) {
  return (e2 ? aa.filter((n2) => e2.includes(n2.name)) : aa).map(Xh);
}
function Yh() {
  return Kh.map(Xh);
}
function em(e2) {
  return "load" in e2 && typeof e2.load == "function";
}
function GA(e2, t2) {
  return { name: e2, execute: t2 };
}
function tm(e2) {
  let t2 = null;
  return { name: e2.name, async execute(n2, r2) {
    return t2 || (t2 = await e2.load()), t2.execute(n2, r2);
  } };
}
var ZA = new TextEncoder(), QA = new TextDecoder();
function la(e2, t2) {
  if (e2 instanceof Uint8Array) return e2;
  if (t2 === "base64") return Uint8Array.from(atob(e2), (n2) => n2.charCodeAt(0));
  if (t2 === "hex") {
    let n2 = new Uint8Array(e2.length / 2);
    for (let r2 = 0; r2 < e2.length; r2 += 2) n2[r2 / 2] = parseInt(e2.slice(r2, r2 + 2), 16);
    return n2;
  }
  return t2 === "binary" || t2 === "latin1" ? Uint8Array.from(e2, (n2) => n2.charCodeAt(0)) : ZA.encode(e2);
}
function nm(e2, t2) {
  return t2 === "base64" ? btoa(String.fromCharCode(...e2)) : t2 === "hex" ? Array.from(e2).map((n2) => n2.toString(16).padStart(2, "0")).join("") : t2 === "binary" || t2 === "latin1" ? String.fromCharCode(...e2) : QA.decode(e2);
}
function Vs(e2) {
  if (e2 != null) return typeof e2 == "string" ? e2 : e2.encoding ?? void 0;
}
var qs = new TextEncoder();
function KA(e2) {
  return typeof e2 == "object" && e2 !== null && !(e2 instanceof Uint8Array) && "content" in e2;
}
var En = class {
  constructor(t2) {
    __publicField(this, "data", /* @__PURE__ */ new Map());
    if (this.data.set("/", { type: "directory", mode: 493, mtime: /* @__PURE__ */ new Date() }), t2) for (let [n2, r2] of Object.entries(t2)) KA(r2) ? this.writeFileSync(n2, r2.content, void 0, { mode: r2.mode, mtime: r2.mtime }) : this.writeFileSync(n2, r2);
  }
  normalizePath(t2) {
    if (!t2 || t2 === "/") return "/";
    let n2 = t2.endsWith("/") && t2 !== "/" ? t2.slice(0, -1) : t2;
    n2.startsWith("/") || (n2 = `/${n2}`);
    let r2 = n2.split("/").filter((i2) => i2 && i2 !== "."), s2 = [];
    for (let i2 of r2) i2 === ".." ? s2.pop() : s2.push(i2);
    return `/${s2.join("/")}` || "/";
  }
  dirname(t2) {
    let n2 = this.normalizePath(t2);
    if (n2 === "/") return "/";
    let r2 = n2.lastIndexOf("/");
    return r2 === 0 ? "/" : n2.slice(0, r2);
  }
  ensureParentDirs(t2) {
    let n2 = this.dirname(t2);
    n2 !== "/" && (this.data.has(n2) || (this.ensureParentDirs(n2), this.data.set(n2, { type: "directory", mode: 493, mtime: /* @__PURE__ */ new Date() })));
  }
  writeFileSync(t2, n2, r2, s2) {
    let i2 = this.normalizePath(t2);
    this.ensureParentDirs(i2);
    let o2 = Vs(r2), a = la(n2, o2);
    this.data.set(i2, { type: "file", content: a, mode: (s2 == null ? void 0 : s2.mode) ?? 420, mtime: (s2 == null ? void 0 : s2.mtime) ?? /* @__PURE__ */ new Date() });
  }
  async readFile(t2, n2) {
    let r2 = await this.readFileBuffer(t2), s2 = Vs(n2);
    return nm(r2, s2);
  }
  async readFileBuffer(t2) {
    let n2 = this.resolvePathWithSymlinks(t2), r2 = this.data.get(n2);
    if (!r2) throw new Error(`ENOENT: no such file or directory, open '${t2}'`);
    if (r2.type !== "file") throw new Error(`EISDIR: illegal operation on a directory, read '${t2}'`);
    return r2.content instanceof Uint8Array ? r2.content : qs.encode(r2.content);
  }
  async writeFile(t2, n2, r2) {
    this.writeFileSync(t2, n2, r2);
  }
  async appendFile(t2, n2, r2) {
    let s2 = this.normalizePath(t2), i2 = this.data.get(s2);
    if (i2 && i2.type === "directory") throw new Error(`EISDIR: illegal operation on a directory, write '${t2}'`);
    let o2 = Vs(r2), a = la(n2, o2);
    if ((i2 == null ? void 0 : i2.type) === "file") {
      let l = i2.content instanceof Uint8Array ? i2.content : qs.encode(i2.content), c = new Uint8Array(l.length + a.length);
      c.set(l), c.set(a, l.length), this.data.set(s2, { type: "file", content: c, mode: i2.mode, mtime: /* @__PURE__ */ new Date() });
    } else this.writeFileSync(t2, n2, r2);
  }
  async exists(t2) {
    try {
      let n2 = this.resolvePathWithSymlinks(t2);
      return this.data.has(n2);
    } catch {
      return false;
    }
  }
  async stat(t2) {
    let n2 = this.resolvePathWithSymlinks(t2), r2 = this.data.get(n2);
    if (!r2) throw new Error(`ENOENT: no such file or directory, stat '${t2}'`);
    let s2 = 0;
    return r2.type === "file" && r2.content && (r2.content instanceof Uint8Array ? s2 = r2.content.length : s2 = qs.encode(r2.content).length), { isFile: r2.type === "file", isDirectory: r2.type === "directory", isSymbolicLink: false, mode: r2.mode, size: s2, mtime: r2.mtime || /* @__PURE__ */ new Date() };
  }
  async lstat(t2) {
    let n2 = this.resolveIntermediateSymlinks(t2), r2 = this.data.get(n2);
    if (!r2) throw new Error(`ENOENT: no such file or directory, lstat '${t2}'`);
    if (r2.type === "symlink") return { isFile: false, isDirectory: false, isSymbolicLink: true, mode: r2.mode, size: r2.target.length, mtime: r2.mtime || /* @__PURE__ */ new Date() };
    let s2 = 0;
    return r2.type === "file" && r2.content && (r2.content instanceof Uint8Array ? s2 = r2.content.length : s2 = qs.encode(r2.content).length), { isFile: r2.type === "file", isDirectory: r2.type === "directory", isSymbolicLink: false, mode: r2.mode, size: s2, mtime: r2.mtime || /* @__PURE__ */ new Date() };
  }
  resolveSymlink(t2, n2) {
    if (n2.startsWith("/")) return this.normalizePath(n2);
    let r2 = this.dirname(t2);
    return this.normalizePath(r2 === "/" ? `/${n2}` : `${r2}/${n2}`);
  }
  resolveIntermediateSymlinks(t2) {
    let n2 = this.normalizePath(t2);
    if (n2 === "/") return "/";
    let r2 = n2.slice(1).split("/");
    if (r2.length <= 1) return n2;
    let s2 = "", i2 = /* @__PURE__ */ new Set();
    for (let o2 = 0; o2 < r2.length - 1; o2++) {
      let a = r2[o2];
      s2 = `${s2}/${a}`;
      let l = this.data.get(s2), c = 0, u = 40;
      for (; l && l.type === "symlink" && c < u; ) {
        if (i2.has(s2)) throw new Error(`ELOOP: too many levels of symbolic links, lstat '${t2}'`);
        i2.add(s2), s2 = this.resolveSymlink(s2, l.target), l = this.data.get(s2), c++;
      }
      if (c >= u) throw new Error(`ELOOP: too many levels of symbolic links, lstat '${t2}'`);
    }
    return `${s2}/${r2[r2.length - 1]}`;
  }
  resolvePathWithSymlinks(t2) {
    let n2 = this.normalizePath(t2);
    if (n2 === "/") return "/";
    let r2 = n2.slice(1).split("/"), s2 = "", i2 = /* @__PURE__ */ new Set();
    for (let o2 of r2) {
      s2 = `${s2}/${o2}`;
      let a = this.data.get(s2), l = 0, c = 40;
      for (; a && a.type === "symlink" && l < c; ) {
        if (i2.has(s2)) throw new Error(`ELOOP: too many levels of symbolic links, open '${t2}'`);
        i2.add(s2), s2 = this.resolveSymlink(s2, a.target), a = this.data.get(s2), l++;
      }
      if (l >= c) throw new Error(`ELOOP: too many levels of symbolic links, open '${t2}'`);
    }
    return s2;
  }
  async mkdir(t2, n2) {
    this.mkdirSync(t2, n2);
  }
  mkdirSync(t2, n2) {
    var _a3;
    let r2 = this.normalizePath(t2);
    if (this.data.has(r2)) {
      if (((_a3 = this.data.get(r2)) == null ? void 0 : _a3.type) === "file") throw new Error(`EEXIST: file already exists, mkdir '${t2}'`);
      if (!(n2 == null ? void 0 : n2.recursive)) throw new Error(`EEXIST: directory already exists, mkdir '${t2}'`);
      return;
    }
    let s2 = this.dirname(r2);
    if (s2 !== "/" && !this.data.has(s2)) if (n2 == null ? void 0 : n2.recursive) this.mkdirSync(s2, { recursive: true });
    else throw new Error(`ENOENT: no such file or directory, mkdir '${t2}'`);
    this.data.set(r2, { type: "directory", mode: 493, mtime: /* @__PURE__ */ new Date() });
  }
  async readdir(t2) {
    return (await this.readdirWithFileTypes(t2)).map((r2) => r2.name);
  }
  async readdirWithFileTypes(t2) {
    let n2 = this.normalizePath(t2), r2 = this.data.get(n2);
    if (!r2) throw new Error(`ENOENT: no such file or directory, scandir '${t2}'`);
    let s2 = /* @__PURE__ */ new Set();
    for (; r2 && r2.type === "symlink"; ) {
      if (s2.has(n2)) throw new Error(`ELOOP: too many levels of symbolic links, scandir '${t2}'`);
      s2.add(n2), n2 = this.resolveSymlink(n2, r2.target), r2 = this.data.get(n2);
    }
    if (!r2) throw new Error(`ENOENT: no such file or directory, scandir '${t2}'`);
    if (r2.type !== "directory") throw new Error(`ENOTDIR: not a directory, scandir '${t2}'`);
    let i2 = n2 === "/" ? "/" : `${n2}/`, o2 = /* @__PURE__ */ new Map();
    for (let [a, l] of this.data.entries()) if (a !== n2 && a.startsWith(i2)) {
      let c = a.slice(i2.length), u = c.split("/")[0];
      u && !c.includes("/", u.length) && !o2.has(u) && o2.set(u, { name: u, isFile: l.type === "file", isDirectory: l.type === "directory", isSymbolicLink: l.type === "symlink" });
    }
    return Array.from(o2.values()).sort((a, l) => a.name < l.name ? -1 : a.name > l.name ? 1 : 0);
  }
  async rm(t2, n2) {
    let r2 = this.normalizePath(t2), s2 = this.data.get(r2);
    if (!s2) {
      if (n2 == null ? void 0 : n2.force) return;
      throw new Error(`ENOENT: no such file or directory, rm '${t2}'`);
    }
    if (s2.type === "directory") {
      let i2 = await this.readdir(r2);
      if (i2.length > 0) {
        if (!(n2 == null ? void 0 : n2.recursive)) throw new Error(`ENOTEMPTY: directory not empty, rm '${t2}'`);
        for (let o2 of i2) {
          let a = r2 === "/" ? `/${o2}` : `${r2}/${o2}`;
          await this.rm(a, n2);
        }
      }
    }
    this.data.delete(r2);
  }
  async cp(t2, n2, r2) {
    let s2 = this.normalizePath(t2), i2 = this.normalizePath(n2), o2 = this.data.get(s2);
    if (!o2) throw new Error(`ENOENT: no such file or directory, cp '${t2}'`);
    if (o2.type === "file") this.ensureParentDirs(i2), this.data.set(i2, { ...o2 });
    else if (o2.type === "directory") {
      if (!(r2 == null ? void 0 : r2.recursive)) throw new Error(`EISDIR: is a directory, cp '${t2}'`);
      await this.mkdir(i2, { recursive: true });
      let a = await this.readdir(s2);
      for (let l of a) {
        let c = s2 === "/" ? `/${l}` : `${s2}/${l}`, u = i2 === "/" ? `/${l}` : `${i2}/${l}`;
        await this.cp(c, u, r2);
      }
    }
  }
  async mv(t2, n2) {
    await this.cp(t2, n2, { recursive: true }), await this.rm(t2, { recursive: true });
  }
  getAllPaths() {
    return Array.from(this.data.keys());
  }
  resolvePath(t2, n2) {
    if (n2.startsWith("/")) return this.normalizePath(n2);
    let r2 = t2 === "/" ? `/${n2}` : `${t2}/${n2}`;
    return this.normalizePath(r2);
  }
  async chmod(t2, n2) {
    let r2 = this.normalizePath(t2), s2 = this.data.get(r2);
    if (!s2) throw new Error(`ENOENT: no such file or directory, chmod '${t2}'`);
    s2.mode = n2;
  }
  async symlink(t2, n2) {
    let r2 = this.normalizePath(n2);
    if (this.data.has(r2)) throw new Error(`EEXIST: file already exists, symlink '${n2}'`);
    this.ensureParentDirs(r2), this.data.set(r2, { type: "symlink", target: t2, mode: 511, mtime: /* @__PURE__ */ new Date() });
  }
  async link(t2, n2) {
    let r2 = this.normalizePath(t2), s2 = this.normalizePath(n2), i2 = this.data.get(r2);
    if (!i2) throw new Error(`ENOENT: no such file or directory, link '${t2}'`);
    if (i2.type !== "file") throw new Error(`EPERM: operation not permitted, link '${t2}'`);
    if (this.data.has(s2)) throw new Error(`EEXIST: file already exists, link '${n2}'`);
    this.ensureParentDirs(s2), this.data.set(s2, { type: "file", content: i2.content, mode: i2.mode, mtime: i2.mtime });
  }
  async readlink(t2) {
    let n2 = this.normalizePath(t2), r2 = this.data.get(n2);
    if (!r2) throw new Error(`ENOENT: no such file or directory, readlink '${t2}'`);
    if (r2.type !== "symlink") throw new Error(`EINVAL: invalid argument, readlink '${t2}'`);
    return r2.target;
  }
  async realpath(t2) {
    let n2 = this.resolvePathWithSymlinks(t2);
    if (!this.data.has(n2)) throw new Error(`ENOENT: no such file or directory, realpath '${t2}'`);
    return n2;
  }
  async utimes(t2, n2, r2) {
    let s2 = this.normalizePath(t2), i2 = this.resolvePathWithSymlinks(s2), o2 = this.data.get(i2);
    if (!o2) throw new Error(`ENOENT: no such file or directory, utimes '${t2}'`);
    o2.mtime = r2;
  }
};
ca();
function XA(e2) {
  let t2 = e2;
  return typeof t2.mkdirSync == "function" && typeof t2.writeFileSync == "function";
}
function JA(e2, t2) {
  e2.mkdirSync("/bin", { recursive: true }), e2.mkdirSync("/usr/bin", { recursive: true }), t2 && (e2.mkdirSync("/home/user", { recursive: true }), e2.mkdirSync("/tmp", { recursive: true }));
}
function YA(e2) {
  e2.mkdirSync("/dev", { recursive: true }), e2.writeFileSync("/dev/null", ""), e2.writeFileSync("/dev/zero", new Uint8Array(0)), e2.writeFileSync("/dev/stdin", ""), e2.writeFileSync("/dev/stdout", ""), e2.writeFileSync("/dev/stderr", "");
}
function eC(e2) {
  e2.mkdirSync("/proc/self/fd", { recursive: true }), e2.writeFileSync("/proc/version", `${sm}
`), e2.writeFileSync("/proc/self/exe", "/bin/bash"), e2.writeFileSync("/proc/self/cmdline", "bash\0"), e2.writeFileSync("/proc/self/comm", `bash
`), e2.writeFileSync("/proc/self/status", im()), e2.writeFileSync("/proc/self/fd/0", "/dev/stdin"), e2.writeFileSync("/proc/self/fd/1", "/dev/stdout"), e2.writeFileSync("/proc/self/fd/2", "/dev/stderr");
}
function om(e2, t2) {
  XA(e2) && (JA(e2, t2), YA(e2), eC(e2));
}
de();
var tC = ["allexport", "errexit", "noglob", "noclobber", "noexec", "nounset", "pipefail", "posix", "verbose", "xtrace"], nC = ["braceexpand", "hashall", "interactive-comments"];
function ua(e2) {
  let t2 = [], n2 = [...nC.map((r2) => ({ name: r2, enabled: true })), ...tC.map((r2) => ({ name: r2, enabled: e2[r2] }))].sort((r2, s2) => r2.name.localeCompare(s2.name));
  for (let r2 of n2) r2.enabled && t2.push(r2.name);
  return t2.join(":");
}
function Jn(e2) {
  e2.state.env.SHELLOPTS = ua(e2.state.options);
}
var rC = ["dotglob", "expand_aliases", "extglob", "failglob", "globskipdots", "globstar", "lastpipe", "nocaseglob", "nocasematch", "nullglob", "xpg_echo"];
function fa(e2) {
  let t2 = [];
  for (let n2 of rC) e2[n2] && t2.push(n2);
  return t2.join(":");
}
function pa(e2) {
  e2.state.env.BASHOPTS = fa(e2.state.shoptOptions);
}
An();
Fe();
An();
var OC = "BASH_ALIAS_";
function Qm(e2) {
  return e2.parts.length !== 1 ? false : e2.parts[0].type === "Literal";
}
function Km(e2) {
  if (e2.parts.length !== 1) return null;
  let t2 = e2.parts[0];
  return t2.type === "Literal" ? t2.value : null;
}
function Xm(e2, t2) {
  return e2.env[`${OC}${t2}`];
}
function Oa(e2, t2, n2) {
  if (!t2.name || !Qm(t2.name)) return t2;
  let r2 = Km(t2.name);
  if (!r2) return t2;
  let s2 = Xm(e2, r2);
  if (!s2 || n2.has(r2)) return t2;
  try {
    n2.add(r2);
    let i2 = new se(), o2 = s2, a = s2.endsWith(" ");
    if (!a) for (let f2 of t2.args) {
      let p = Ym(f2);
      o2 += ` ${p}`;
    }
    let l;
    try {
      l = i2.parse(o2);
    } catch (f2) {
      if (f2 instanceof Ge) throw f2;
      return t2;
    }
    if (l.statements.length !== 1 || l.statements[0].pipelines.length !== 1 || l.statements[0].pipelines[0].commands.length !== 1) return Jm(t2, s2);
    let c = l.statements[0].pipelines[0].commands[0];
    if (c.type !== "SimpleCommand") return Jm(t2, s2);
    let u = { ...c, assignments: [...t2.assignments, ...c.assignments], redirections: [...c.redirections, ...t2.redirections], line: t2.line };
    if (a && t2.args.length > 0 && (u = { ...u, args: [...u.args, ...t2.args] }, u.args.length > 0)) {
      let f2 = u.args[0];
      if (Qm(f2)) {
        let p = Km(f2);
        if (p && Xm(e2, p)) {
          let d = { type: "SimpleCommand", name: f2, args: u.args.slice(1), assignments: [], redirections: [] }, m = Oa(e2, d, n2);
          m !== d && (u = { ...u, name: m.name, args: [...m.args] });
        }
      }
    }
    return u;
  } catch (i2) {
    throw n2.delete(r2), i2;
  }
}
function Jm(e2, t2) {
  let n2 = t2;
  for (let o2 of e2.args) {
    let a = Ym(o2);
    n2 += ` ${a}`;
  }
  let r2 = new se(), s2 = r2.parseWordFromString("eval", false, false), i2 = r2.parseWordFromString(`'${n2.replace(/'/g, "'\\''")}'`, false, false);
  return { type: "SimpleCommand", name: s2, args: [i2], assignments: e2.assignments, redirections: e2.redirections, line: e2.line };
}
function Ym(e2) {
  let t2 = "";
  for (let n2 of e2.parts) switch (n2.type) {
    case "Literal":
      t2 += n2.value.replace(/([\s"'$`\\*?[\]{}()<>|&;#!])/g, "\\$1");
      break;
    case "SingleQuoted":
      t2 += `'${n2.value}'`;
      break;
    case "DoubleQuoted":
      t2 += `"${n2.parts.map((r2) => r2.type === "Literal" ? r2.value : `$${r2.type}`).join("")}"`;
      break;
    case "ParameterExpansion":
      t2 += `\${${n2.parameter}}`;
      break;
    case "CommandSubstitution":
      t2 += "$(...)";
      break;
    case "ArithmeticExpansion":
      t2 += `$((${n2.expression}))`;
      break;
    case "Glob":
      t2 += n2.pattern;
      break;
  }
  return t2;
}
it();
ot();
$t();
async function R0(e2, t2) {
  let n2 = t2.parts.map((u) => u.type === "Literal" ? u.value : "\0").join(""), r2 = n2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\(/);
  if (!r2 || !n2.endsWith(")")) return null;
  let s2 = r2[1], i2 = [], o2 = false, a = "", l = false;
  for (let u of t2.parts) if (u.type === "Literal") {
    let f2 = u.value;
    if (!o2) {
      let p = f2.indexOf("=(");
      p !== -1 && (o2 = true, f2 = f2.slice(p + 2));
    }
    if (o2) {
      f2.endsWith(")") && (f2 = f2.slice(0, -1));
      let p = f2.split(/(\s+)/);
      for (let d of p) /^\s+$/.test(d) ? (a || l) && (i2.push(a), a = "", l = false) : d && (a += d);
    }
  } else if (o2) if (u.type === "BraceExpansion") if (/^\[.+\]=/.test(a)) a += Yn({ parts: [u] });
  else {
    (a || l) && (i2.push(a), a = "", l = false);
    let p = await Ft(e2, { type: "Word", parts: [u] });
    i2.push(...p.values);
  }
  else {
    (u.type === "SingleQuoted" || u.type === "DoubleQuoted" || u.type === "Escaped") && (l = true);
    let f2 = await J(e2, { parts: [u] });
    a += f2;
  }
  (a || l) && i2.push(a);
  let c = i2.map((u) => /^\[.+\]=/.test(u) ? u : u === "" ? "''" : /[\s"'\\$`!*?[\]{}|&;<>()]/.test(u) && !u.startsWith("'") && !u.startsWith('"') ? `'${u.replace(/'/g, "'\\''")}'` : u);
  return `${s2}=(${c.join(" ")})`;
}
async function P0(e2, t2) {
  let n2 = -1, r2 = -1, s2 = false;
  for (let h = 0; h < t2.parts.length; h++) {
    let g = t2.parts[h];
    if (g.type === "Literal") {
      let b = g.value.indexOf("+=");
      if (b !== -1) {
        let w = g.value.slice(0, b);
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(w)) {
          n2 = h, r2 = b, s2 = true;
          break;
        }
        if (/^[a-zA-Z_][a-zA-Z0-9_]*\[[^\]]+\]$/.test(w)) {
          n2 = h, r2 = b, s2 = true;
          break;
        }
      }
      let y = g.value.indexOf("=");
      if (y !== -1 && (y === 0 || g.value[y - 1] !== "+")) {
        let w = g.value.slice(0, y);
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(w) || /^[a-zA-Z_][a-zA-Z0-9_]*\[[^\]]+\]$/.test(w)) {
          n2 = h, r2 = y;
          break;
        }
      }
    }
  }
  if (n2 === -1) return null;
  let i2 = t2.parts.slice(0, n2), o2 = t2.parts[n2];
  if (o2.type !== "Literal") return null;
  let a = s2 ? 2 : 1, l = o2.value.slice(0, r2), c = o2.value.slice(r2 + a), u = t2.parts.slice(n2 + 1), f2 = "";
  for (let h of i2) f2 += await J(e2, { parts: [h] });
  f2 += l;
  let p = { parts: c !== "" ? [{ type: "Literal", value: c }, ...u] : u }, d = p.parts.length > 0 ? await J(e2, p) : "";
  return `${f2}${s2 ? "+=" : "="}${d}`;
}
var AN = ["tar", "yq", "xan", "sqlite3", "python3", "python"];
function T0(e2) {
  return AN.includes(e2);
}
de();
de();
var le = Object.freeze({ stdout: "", stderr: "", exitCode: 0 });
function ue(e2 = "") {
  return { stdout: e2, stderr: "", exitCode: 0 };
}
function M(e2, t2 = 1) {
  return { stdout: "", stderr: e2, exitCode: t2 };
}
function W(e2, t2, n2) {
  return { stdout: e2, stderr: t2, exitCode: n2 };
}
function Le(e2) {
  return { stdout: "", stderr: "", exitCode: e2 ? 0 : 1 };
}
function Xt(e2, t2, n2 = "", r2 = "") {
  throw new ne(e2, t2, n2, r2);
}
function nl(e2, t2) {
  if (e2.state.loopDepth === 0) {
    if (e2.state.parentHasLoopContext) throw new Lt();
    return le;
  }
  if (t2.length > 1) throw new ae(1, "", `bash: break: too many arguments
`);
  let n2 = 1;
  if (t2.length > 0) {
    let r2 = Number.parseInt(t2[0], 10);
    if (Number.isNaN(r2) || r2 < 1) throw new ae(128, "", `bash: break: ${t2[0]}: numeric argument required
`);
    n2 = r2;
  }
  throw new Qe(n2);
}
async function rl(e2, t2) {
  let n2, r2 = false, s2 = false, i2 = 0;
  for (; i2 < t2.length; ) if (t2[i2] === "--") {
    i2++;
    break;
  } else if (t2[i2] === "-L") s2 = false, i2++;
  else if (t2[i2] === "-P") s2 = true, i2++;
  else if (t2[i2].startsWith("-") && t2[i2] !== "-") i2++;
  else break;
  let o2 = t2.slice(i2);
  if (o2.length === 0 || o2[0] === "~" ? n2 = e2.state.env.HOME || "/" : o2[0] === "-" ? (n2 = e2.state.previousDir, r2 = true) : n2 = o2[0], !n2.startsWith("/") && !n2.startsWith("./") && !n2.startsWith("../") && n2 !== "." && n2 !== "..") {
    let f2 = e2.state.env.CDPATH;
    if (f2) {
      let p = f2.split(":").filter((d) => d);
      for (let d of p) {
        let m = d.startsWith("/") ? `${d}/${n2}` : `${e2.state.cwd}/${d}/${n2}`;
        try {
          if ((await e2.fs.stat(m)).isDirectory) {
            n2 = m, r2 = true;
            break;
          }
        } catch {
        }
      }
    }
  }
  let l = (n2.startsWith("/") ? n2 : `${e2.state.cwd}/${n2}`).split("/").filter((f2) => f2 && f2 !== "."), c = "";
  for (let f2 of l) if (f2 === "..") c = c.split("/").slice(0, -1).join("/") || "/";
  else {
    c = c ? `${c}/${f2}` : `/${f2}`;
    try {
      if (!(await e2.fs.stat(c)).isDirectory) return M(`bash: cd: ${n2}: Not a directory
`);
    } catch {
      return M(`bash: cd: ${n2}: No such file or directory
`);
    }
  }
  let u = c || "/";
  if (s2) try {
    u = await e2.fs.realpath(u);
  } catch {
  }
  return e2.state.previousDir = e2.state.cwd, e2.state.cwd = u, e2.state.env.PWD = e2.state.cwd, e2.state.env.OLDPWD = e2.state.previousDir, ue(r2 ? `${u}
` : "");
}
Fe();
Je();
Fe();
it();
ot();
$t();
function sl(e2, t2) {
  return e2.fs.resolvePath(e2.state.cwd, t2);
}
var CN = ["-e", "-a", "-f", "-d", "-r", "-w", "-x", "-s", "-L", "-h", "-k", "-g", "-u", "-G", "-O", "-b", "-c", "-p", "-S", "-t", "-N"];
function hi(e2) {
  return CN.includes(e2);
}
async function mi(e2, t2, n2) {
  let r2 = sl(e2, n2);
  switch (t2) {
    case "-e":
    case "-a":
      return e2.fs.exists(r2);
    case "-f":
      return await e2.fs.exists(r2) ? (await e2.fs.stat(r2)).isFile : false;
    case "-d":
      return await e2.fs.exists(r2) ? (await e2.fs.stat(r2)).isDirectory : false;
    case "-r":
      return await e2.fs.exists(r2) ? ((await e2.fs.stat(r2)).mode & 256) !== 0 : false;
    case "-w":
      return await e2.fs.exists(r2) ? ((await e2.fs.stat(r2)).mode & 128) !== 0 : false;
    case "-x":
      return await e2.fs.exists(r2) ? ((await e2.fs.stat(r2)).mode & 64) !== 0 : false;
    case "-s":
      return await e2.fs.exists(r2) ? (await e2.fs.stat(r2)).size > 0 : false;
    case "-L":
    case "-h":
      try {
        return (await e2.fs.lstat(r2)).isSymbolicLink;
      } catch {
        return false;
      }
    case "-k":
      return await e2.fs.exists(r2) ? ((await e2.fs.stat(r2)).mode & 512) !== 0 : false;
    case "-g":
      return await e2.fs.exists(r2) ? ((await e2.fs.stat(r2)).mode & 1024) !== 0 : false;
    case "-u":
      return await e2.fs.exists(r2) ? ((await e2.fs.stat(r2)).mode & 2048) !== 0 : false;
    case "-G":
    case "-O":
      return e2.fs.exists(r2);
    case "-b":
      return false;
    case "-c":
      return ["/dev/null", "/dev/zero", "/dev/random", "/dev/urandom", "/dev/tty", "/dev/stdin", "/dev/stdout", "/dev/stderr"].some((i2) => r2 === i2 || r2.endsWith(i2));
    case "-p":
      return false;
    case "-S":
      return false;
    case "-t":
      return false;
    case "-N":
      return e2.fs.exists(r2);
    default:
      return false;
  }
}
var NN = ["-nt", "-ot", "-ef"];
function gi(e2) {
  return NN.includes(e2);
}
async function yi(e2, t2, n2, r2) {
  let s2 = sl(e2, n2), i2 = sl(e2, r2);
  switch (t2) {
    case "-nt":
      try {
        let o2 = await e2.fs.stat(s2), a = await e2.fs.stat(i2);
        return o2.mtime > a.mtime;
      } catch {
        return false;
      }
    case "-ot":
      try {
        let o2 = await e2.fs.stat(s2), a = await e2.fs.stat(i2);
        return o2.mtime < a.mtime;
      } catch {
        return false;
      }
    case "-ef":
      try {
        if (!await e2.fs.exists(s2) || !await e2.fs.exists(i2)) return false;
        let o2 = e2.fs.resolvePath(e2.state.cwd, s2), a = e2.fs.resolvePath(e2.state.cwd, i2);
        return o2 === a;
      } catch {
        return false;
      }
    default:
      return false;
  }
}
var kN = /* @__PURE__ */ new Set(["-eq", "-ne", "-lt", "-le", "-gt", "-ge"]);
function bi(e2) {
  return kN.has(e2);
}
function wi(e2, t2, n2) {
  switch (e2) {
    case "-eq":
      return t2 === n2;
    case "-ne":
      return t2 !== n2;
    case "-lt":
      return t2 < n2;
    case "-le":
      return t2 <= n2;
    case "-gt":
      return t2 > n2;
    case "-ge":
      return t2 >= n2;
  }
}
function Ur(e2) {
  return e2 === "=" || e2 === "==" || e2 === "!=";
}
function xi(e2, t2, n2, r2 = false, s2 = false, i2 = false) {
  if (r2) {
    let a = or(t2, n2, s2, i2);
    return e2 === "!=" ? !a : a;
  }
  if (s2) {
    let a = t2.toLowerCase() === n2.toLowerCase();
    return e2 === "!=" ? !a : a;
  }
  let o2 = t2 === n2;
  return e2 === "!=" ? !o2 : o2;
}
var vN = /* @__PURE__ */ new Set(["-z", "-n"]);
function Ei(e2) {
  return vN.has(e2);
}
function Si(e2, t2) {
  switch (e2) {
    case "-z":
      return t2 === "";
    case "-n":
      return t2 !== "";
  }
}
Je();
Fe();
it();
$t();
async function Ai(e2, t2) {
  var _a3, _b3;
  let n2 = t2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (n2) {
    let r2 = n2[1], s2 = n2[2];
    if ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(r2)) {
      let a = s2;
      return (a.startsWith("'") && a.endsWith("'") || a.startsWith('"') && a.endsWith('"')) && (a = a.slice(1, -1)), a = a.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (l, c) => e2.state.env[c] || ""), `${r2}_${a}` in e2.state.env;
    }
    let o2;
    try {
      let a = new se(), l = he(a, s2);
      o2 = await Q(e2, l.expression);
    } catch {
      if (/^-?\d+$/.test(s2)) o2 = Number.parseInt(s2, 10);
      else {
        let a = e2.state.env[s2];
        o2 = a ? Number.parseInt(a, 10) : 0;
      }
    }
    if (o2 < 0) {
      let a = _e(e2, r2), l = e2.state.currentLine;
      if (a.length === 0) return e2.state.expansionStderr = (e2.state.expansionStderr || "") + `bash: line ${l}: ${r2}: bad array subscript
`, false;
      if (o2 = Math.max(...a) + 1 + o2, o2 < 0) return e2.state.expansionStderr = (e2.state.expansionStderr || "") + `bash: line ${l}: ${r2}: bad array subscript
`, false;
    }
    return `${r2}_${o2}` in e2.state.env;
  }
  return t2 in e2.state.env ? true : ((_b3 = e2.state.associativeArrays) == null ? void 0 : _b3.has(t2)) ? Pt(e2, t2).length > 0 : _e(e2, t2).length > 0;
}
async function ln(e2, t2) {
  switch (t2.type) {
    case "CondBinary": {
      let n2 = await J(e2, t2.left), r2 = t2.right.parts.length > 0 && t2.right.parts.every((i2) => i2.type === "SingleQuoted" || i2.type === "DoubleQuoted" || i2.type === "Escaped" && t2.operator !== "=~"), s2;
      if (t2.operator === "=~") if (r2) {
        let i2 = await J(e2, t2.right);
        s2 = er(i2);
      } else s2 = await Ka(e2, t2.right);
      else Ur(t2.operator) && !r2 ? s2 = await Xa(e2, t2.right) : s2 = await J(e2, t2.right);
      if (Ur(t2.operator)) {
        let i2 = e2.state.shoptOptions.nocasematch;
        return xi(t2.operator, n2, s2, !r2, i2, true);
      }
      if (bi(t2.operator)) return wi(t2.operator, await D0(e2, n2), await D0(e2, s2));
      if (gi(t2.operator)) return yi(e2, t2.operator, n2, s2);
      switch (t2.operator) {
        case "=~":
          try {
            let i2 = e2.state.shoptOptions.nocasematch, o2 = PN(s2), a = new RegExp(o2, i2 ? "i" : ""), l = n2.match(a);
            if (Ut(e2, "BASH_REMATCH"), l) for (let c = 0; c < l.length; c++) e2.state.env[`BASH_REMATCH_${c}`] = l[c] || "";
            return l !== null;
          } catch {
            throw new Error("syntax error in regular expression");
          }
        case "<":
          return n2 < s2;
        case ">":
          return n2 > s2;
        default:
          return false;
      }
    }
    case "CondUnary": {
      let n2 = await J(e2, t2.operand);
      return hi(t2.operator) ? mi(e2, t2.operator, n2) : Ei(t2.operator) ? Si(t2.operator, n2) : t2.operator === "-v" ? await Ai(e2, n2) : t2.operator === "-o" ? ol(e2, n2) : false;
    }
    case "CondNot":
      return e2.state.shoptOptions.extglob && t2.operand.type === "CondGroup" && t2.operand.expression.type === "CondWord" ? `!(${await J(e2, t2.operand.expression.word)})` !== "" : !await ln(e2, t2.operand);
    case "CondAnd":
      return await ln(e2, t2.left) ? await ln(e2, t2.right) : false;
    case "CondOr":
      return await ln(e2, t2.left) ? true : await ln(e2, t2.right);
    case "CondGroup":
      return await ln(e2, t2.expression);
    case "CondWord":
      return await J(e2, t2.word) !== "";
    default:
      return false;
  }
}
async function zr(e2, t2) {
  if (t2.length === 0) return W("", "", 1);
  if (t2.length === 1) return Le(!!t2[0]);
  if (t2.length === 2) {
    let r2 = t2[0], s2 = t2[1];
    return r2 === "(" ? M(`test: '(' without matching ')'
`, 2) : hi(r2) ? Le(await mi(e2, r2, s2)) : Ei(r2) ? Le(Si(r2, s2)) : r2 === "!" ? Le(!s2) : r2 === "-v" ? Le(await Ai(e2, s2)) : r2 === "-o" ? Le(ol(e2, s2)) : r2 === "=" || r2 === "==" || r2 === "!=" || r2 === "<" || r2 === ">" || r2 === "-eq" || r2 === "-ne" || r2 === "-lt" || r2 === "-le" || r2 === "-gt" || r2 === "-ge" || r2 === "-nt" || r2 === "-ot" || r2 === "-ef" ? M(`test: ${r2}: unary operator expected
`, 2) : W("", "", 1);
  }
  if (t2.length === 3) {
    let r2 = t2[0], s2 = t2[1], i2 = t2[2];
    if (Ur(s2)) return Le(xi(s2, r2, i2));
    if (bi(s2)) {
      let o2 = Ci(r2), a = Ci(i2);
      return !o2.valid || !a.valid ? W("", "", 2) : Le(wi(s2, o2.value, a.value));
    }
    if (gi(s2)) return Le(await yi(e2, s2, r2, i2));
    switch (s2) {
      case "-a":
        return Le(r2 !== "" && i2 !== "");
      case "-o":
        return Le(r2 !== "" || i2 !== "");
      case ">":
        return Le(r2 > i2);
      case "<":
        return Le(r2 < i2);
    }
    if (r2 === "!") {
      let o2 = await zr(e2, [s2, i2]);
      return W("", o2.stderr, o2.exitCode === 0 ? 1 : o2.exitCode === 1 ? 0 : o2.exitCode);
    }
    if (r2 === "(" && i2 === ")") return Le(s2 !== "");
  }
  if (t2.length === 4) {
    if (t2[0] === "!") {
      let r2 = await zr(e2, t2.slice(1));
      return W("", r2.stderr, r2.exitCode === 0 ? 1 : r2.exitCode === 1 ? 0 : r2.exitCode);
    }
    if (t2[0] === "(" && t2[3] === ")") return zr(e2, [t2[1], t2[2]]);
  }
  let n2 = await _0(e2, t2, 0);
  return n2.pos < t2.length ? M(`test: too many arguments
`, 2) : Le(n2.value);
}
async function _0(e2, t2, n2) {
  return $N(e2, t2, n2);
}
async function $N(e2, t2, n2) {
  let { value: r2, pos: s2 } = await O0(e2, t2, n2);
  for (; t2[s2] === "-o"; ) {
    let i2 = await O0(e2, t2, s2 + 1);
    r2 = r2 || i2.value, s2 = i2.pos;
  }
  return { value: r2, pos: s2 };
}
async function O0(e2, t2, n2) {
  let { value: r2, pos: s2 } = await il(e2, t2, n2);
  for (; t2[s2] === "-a"; ) {
    let i2 = await il(e2, t2, s2 + 1);
    r2 = r2 && i2.value, s2 = i2.pos;
  }
  return { value: r2, pos: s2 };
}
async function il(e2, t2, n2) {
  if (t2[n2] === "!") {
    let { value: r2, pos: s2 } = await il(e2, t2, n2 + 1);
    return { value: !r2, pos: s2 };
  }
  return IN(e2, t2, n2);
}
async function IN(e2, t2, n2) {
  let r2 = t2[n2];
  if (r2 === "(") {
    let { value: i2, pos: o2 } = await _0(e2, t2, n2 + 1);
    return { value: i2, pos: t2[o2] === ")" ? o2 + 1 : o2 };
  }
  let s2 = t2[n2 + 1];
  if (Ur(s2)) {
    let i2 = r2, o2 = t2[n2 + 2] ?? "";
    return { value: xi(s2, i2, o2), pos: n2 + 3 };
  }
  if (bi(s2)) {
    let i2 = Ci(r2), o2 = Ci(t2[n2 + 2] ?? "0");
    return !i2.valid || !o2.valid ? { value: false, pos: n2 + 3 } : { value: wi(s2, i2.value, o2.value), pos: n2 + 3 };
  }
  if (gi(s2)) {
    let i2 = r2, o2 = t2[n2 + 2] ?? "";
    return { value: await yi(e2, s2, i2, o2), pos: n2 + 3 };
  }
  if (hi(r2)) {
    let i2 = t2[n2 + 1] ?? "";
    return { value: await mi(e2, r2, i2), pos: n2 + 2 };
  }
  if (Ei(r2)) {
    let i2 = t2[n2 + 1] ?? "";
    return { value: Si(r2, i2), pos: n2 + 2 };
  }
  if (r2 === "-v") {
    let i2 = t2[n2 + 1] ?? "";
    return { value: await Ai(e2, i2), pos: n2 + 2 };
  }
  if (r2 === "-o") {
    let i2 = t2[n2 + 1] ?? "";
    return { value: ol(e2, i2), pos: n2 + 2 };
  }
  return { value: r2 !== void 0 && r2 !== "", pos: n2 + 1 };
}
function or(e2, t2, n2 = false, r2 = false) {
  let s2 = `^${L0(t2, r2)}$`, i2 = n2 ? "is" : "s";
  return new RegExp(s2, i2).test(e2);
}
function L0(e2, t2) {
  let n2 = "";
  for (let r2 = 0; r2 < e2.length; r2++) {
    let s2 = e2[r2];
    if (t2 && (s2 === "@" || s2 === "*" || s2 === "+" || s2 === "?" || s2 === "!") && r2 + 1 < e2.length && e2[r2 + 1] === "(") {
      let i2 = M0(e2, r2 + 1);
      if (i2 !== -1) {
        let o2 = e2.slice(r2 + 2, i2), a = W0(o2), l = a.map((u) => L0(u, t2)), c = l.length > 0 ? l.join("|") : "(?:)";
        if (s2 === "@") n2 += `(?:${c})`;
        else if (s2 === "*") n2 += `(?:${c})*`;
        else if (s2 === "+") n2 += `(?:${c})+`;
        else if (s2 === "?") n2 += `(?:${c})?`;
        else if (s2 === "!") if (i2 < e2.length - 1) {
          let f2 = a.map((d) => B0(d, t2));
          if (f2.every((d) => d !== null) && f2.every((d) => d === f2[0]) && f2[0] !== null) {
            let d = f2[0];
            if (d === 0) n2 += "(?:.+)";
            else {
              let m = [];
              d > 0 && m.push(`.{0,${d - 1}}`), m.push(`.{${d + 1},}`), m.push(`(?!(?:${c})).{${d}}`), n2 += `(?:${m.join("|")})`;
            }
          } else n2 += `(?:(?!(?:${c})).)*?`;
        } else n2 += `(?!(?:${c})$).*`;
        r2 = i2;
        continue;
      }
    }
    if (s2 === "\\") if (r2 + 1 < e2.length) {
      let i2 = e2[r2 + 1];
      /[\\^$.|+(){}[\]*?]/.test(i2) ? n2 += `\\${i2}` : n2 += i2, r2++;
    } else n2 += "\\\\";
    else if (s2 === "*") n2 += ".*";
    else if (s2 === "?") n2 += ".";
    else if (s2 === "[") {
      let i2 = e2.indexOf("]", r2 + 1);
      i2 !== -1 ? (n2 += e2.slice(r2, i2 + 1), r2 = i2) : n2 += "\\[";
    } else /[\\^$.|+(){}]/.test(s2) ? n2 += `\\${s2}` : n2 += s2;
  }
  return n2;
}
function M0(e2, t2) {
  let n2 = 1, r2 = t2 + 1;
  for (; r2 < e2.length && n2 > 0; ) {
    let s2 = e2[r2];
    if (s2 === "\\") {
      r2 += 2;
      continue;
    }
    if (s2 === "(") n2++;
    else if (s2 === ")" && (n2--, n2 === 0)) return r2;
    r2++;
  }
  return -1;
}
function W0(e2) {
  let t2 = [], n2 = "", r2 = 0, s2 = 0;
  for (; s2 < e2.length; ) {
    let i2 = e2[s2];
    if (i2 === "\\") {
      n2 += i2, s2 + 1 < e2.length ? (n2 += e2[s2 + 1], s2 += 2) : s2++;
      continue;
    }
    i2 === "(" ? (r2++, n2 += i2) : i2 === ")" ? (r2--, n2 += i2) : i2 === "|" && r2 === 0 ? (t2.push(n2), n2 = "") : n2 += i2, s2++;
  }
  return t2.push(n2), t2;
}
function B0(e2, t2) {
  let n2 = 0, r2 = 0;
  for (; r2 < e2.length; ) {
    let s2 = e2[r2];
    if (t2 && (s2 === "@" || s2 === "*" || s2 === "+" || s2 === "?" || s2 === "!") && r2 + 1 < e2.length && e2[r2 + 1] === "(") {
      let i2 = M0(e2, r2 + 1);
      if (i2 !== -1) {
        if (s2 === "@") {
          let o2 = e2.slice(r2 + 2, i2), l = W0(o2).map((c) => B0(c, t2));
          if (l.every((c) => c !== null) && l.every((c) => c === l[0])) {
            n2 += l[0], r2 = i2 + 1;
            continue;
          }
          return null;
        }
        return null;
      }
    }
    if (s2 === "*") return null;
    if (s2 === "?") {
      n2 += 1, r2++;
      continue;
    }
    if (s2 === "[") {
      let i2 = e2.indexOf("]", r2 + 1);
      if (i2 !== -1) {
        n2 += 1, r2 = i2 + 1;
        continue;
      }
      n2 += 1, r2++;
      continue;
    }
    if (s2 === "\\") {
      n2 += 1, r2 += 2;
      continue;
    }
    n2 += 1, r2++;
  }
  return n2;
}
function ol(e2, t2) {
  let r2 = { errexit: () => e2.state.options.errexit === true, nounset: () => e2.state.options.nounset === true, pipefail: () => e2.state.options.pipefail === true, xtrace: () => e2.state.options.xtrace === true, e: () => e2.state.options.errexit === true, u: () => e2.state.options.nounset === true, x: () => e2.state.options.xtrace === true }[t2];
  return r2 ? r2() : false;
}
async function D0(e2, t2) {
  if (t2 = t2.trim(), t2 === "") return 0;
  if (/^[+-]?(\d+#[a-zA-Z0-9@_]+|0[xX][0-9a-fA-F]+|0[0-7]+|\d+)$/.test(t2)) return F0(t2);
  try {
    let n2 = new se(), r2 = he(n2, t2);
    return await Q(e2, r2.expression);
  } catch {
    return F0(t2);
  }
}
function RN(e2, t2) {
  let n2 = 0;
  for (let r2 of e2) {
    let s2;
    if (r2 >= "0" && r2 <= "9") s2 = r2.charCodeAt(0) - 48;
    else if (r2 >= "a" && r2 <= "z") s2 = r2.charCodeAt(0) - 97 + 10;
    else if (r2 >= "A" && r2 <= "Z") s2 = r2.charCodeAt(0) - 65 + 36;
    else if (r2 === "@") s2 = 62;
    else if (r2 === "_") s2 = 63;
    else return Number.NaN;
    if (s2 >= t2) return Number.NaN;
    n2 = n2 * t2 + s2;
  }
  return n2;
}
function F0(e2) {
  if (e2 = e2.trim(), e2 === "") return 0;
  let t2 = false;
  e2.startsWith("-") ? (t2 = true, e2 = e2.slice(1)) : e2.startsWith("+") && (e2 = e2.slice(1));
  let n2, r2 = e2.match(/^(\d+)#([a-zA-Z0-9@_]+)$/);
  if (r2) {
    let s2 = Number.parseInt(r2[1], 10);
    s2 >= 2 && s2 <= 64 ? n2 = RN(r2[2], s2) : n2 = 0;
  } else /^0[xX][0-9a-fA-F]+$/.test(e2) ? n2 = Number.parseInt(e2, 16) : /^0[0-7]+$/.test(e2) ? n2 = Number.parseInt(e2, 8) : n2 = Number.parseInt(e2, 10);
  return Number.isNaN(n2) && (n2 = 0), t2 ? -n2 : n2;
}
function Ci(e2) {
  if (e2 = e2.trim(), e2 === "") return { value: 0, valid: true };
  let t2 = false;
  if (e2.startsWith("-") ? (t2 = true, e2 = e2.slice(1)) : e2.startsWith("+") && (e2 = e2.slice(1)), !/^\d+$/.test(e2)) return { value: 0, valid: false };
  let n2 = Number.parseInt(e2, 10);
  return Number.isNaN(n2) ? { value: 0, valid: false } : { value: t2 ? -n2 : n2, valid: true };
}
function PN(e2) {
  let t2 = "", n2 = 0;
  for (; n2 < e2.length; ) if (e2[n2] === "\\" && n2 + 1 < e2.length) t2 += e2[n2] + e2[n2 + 1], n2 += 2;
  else if (e2[n2] === "[") {
    let r2 = TN(e2, n2);
    t2 += r2.converted, n2 = r2.endIndex;
  } else t2 += e2[n2], n2++;
  return t2;
}
function TN(e2, t2) {
  let n2 = t2 + 1, r2 = "[";
  n2 < e2.length && (e2[n2] === "^" || e2[n2] === "!") && (r2 += "^", n2++);
  let s2 = false;
  n2 < e2.length && e2[n2] === "]" && (s2 = true, n2++);
  let i2 = false;
  n2 < e2.length && e2[n2] === "[" && n2 + 1 < e2.length && e2[n2 + 1] !== ":" && (i2 = true, n2++);
  let o2 = "", a = false;
  for (; n2 < e2.length; ) {
    let l = e2[n2];
    if (l === "]") {
      a = true, n2++;
      break;
    }
    if (l === "[" && n2 + 1 < e2.length && e2[n2 + 1] === ":") {
      let c = e2.indexOf(":]", n2 + 2);
      if (c !== -1) {
        let u = e2.slice(n2 + 2, c);
        o2 += ON(u), n2 = c + 2;
        continue;
      }
    }
    if (l === "[" && n2 + 1 < e2.length) {
      let c = e2[n2 + 1];
      if (c === "." || c === "=") {
        let u = `${c}]`, f2 = e2.indexOf(u, n2 + 2);
        if (f2 !== -1) {
          let p = e2.slice(n2 + 2, f2);
          o2 += p, n2 = f2 + 2;
          continue;
        }
      }
    }
    if (l === "\\" && n2 + 1 < e2.length) {
      o2 += l + e2[n2 + 1], n2 += 2;
      continue;
    }
    o2 += l, n2++;
  }
  return a ? (s2 && (r2 += "\\]"), i2 && (r2 += "\\["), r2 += o2, r2 += "]", { converted: r2, endIndex: n2 }) : { converted: "\\[", endIndex: t2 + 1 };
}
function ON(e2) {
  return { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "!-~", lower: "a-z", print: " -~", punct: "!-/:-@\\[-`{-~", space: " \\t\\n\\r\\f\\v", upper: "A-Z", word: "a-zA-Z0-9_", xdigit: "0-9A-Fa-f" }[e2] ?? "";
}
ot();
Je();
Fe();
it();
on$1();
function Vt(e2) {
  let t2 = [], n2 = "", r2 = false, s2 = false, i2 = false, o2 = false;
  for (let a of e2) {
    if (i2) {
      n2 += a, i2 = false, o2 = true;
      continue;
    }
    if (a === "\\") {
      i2 = true;
      continue;
    }
    if (a === "'" && !s2) {
      r2 || (o2 = true), r2 = !r2;
      continue;
    }
    if (a === '"' && !r2) {
      s2 || (o2 = true), s2 = !s2;
      continue;
    }
    if ((a === " " || a === "	" || a === `
`) && !r2 && !s2) {
      o2 && (t2.push(n2), n2 = "", o2 = false);
      continue;
    }
    n2 += a, o2 = true;
  }
  return o2 && t2.push(n2), t2;
}
function Ni(e2) {
  let t2 = [], n2 = 0;
  for (; n2 < e2.length; ) {
    for (; n2 < e2.length && /\s/.test(e2[n2]); ) n2++;
    if (n2 >= e2.length) break;
    if (e2[n2] !== "[") {
      n2++;
      continue;
    }
    n2++;
    let r2 = "";
    if (e2[n2] === "'" || e2[n2] === '"') {
      let i2 = e2[n2];
      for (n2++; n2 < e2.length && e2[n2] !== i2; ) r2 += e2[n2], n2++;
      e2[n2] === i2 && n2++;
    } else for (; n2 < e2.length && e2[n2] !== "]" && e2[n2] !== "="; ) r2 += e2[n2], n2++;
    for (; n2 < e2.length && e2[n2] !== "]"; ) n2++;
    if (e2[n2] === "]" && n2++, e2[n2] !== "=") continue;
    n2++;
    let s2 = "";
    if (e2[n2] === "'" || e2[n2] === '"') {
      let i2 = e2[n2];
      for (n2++; n2 < e2.length && e2[n2] !== i2; ) e2[n2] === "\\" && n2 + 1 < e2.length && n2++, s2 += e2[n2], n2++;
      e2[n2] === i2 && n2++;
    } else for (; n2 < e2.length && !/\s/.test(e2[n2]); ) s2 += e2[n2], n2++;
    t2.push([r2, s2]);
  }
  return t2;
}
function U0(e2) {
  let t2 = e2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
  if (t2) return { name: t2[1], isArray: true, arrayElements: Vt(t2[2]) };
  let n2 = e2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([^\]]+)\]=(.*)$/s);
  if (n2) return { name: n2[1], isArray: false, arrayIndex: n2[2], value: n2[3] };
  if (e2.includes("=")) {
    let r2 = e2.indexOf("=");
    return { name: e2.slice(0, r2), isArray: false, value: e2.slice(r2 + 1) };
  }
  return { name: e2, isArray: false };
}
async function DN(e2, t2) {
  try {
    let n2 = new se(), r2 = he(n2, t2);
    return await Q(e2, r2.expression);
  } catch {
    let n2 = parseInt(t2, 10);
    return Number.isNaN(n2) ? 0 : n2;
  }
}
async function z0(e2, t2, n2 = {}) {
  let { name: r2, isArray: s2, arrayElements: i2, value: o2, arrayIndex: a } = t2, { makeReadonly: l = false, checkReadonly: c = true } = n2;
  if (c) {
    je(e2, r2);
  }
  if (s2 && i2) {
    for (let u = 0; u < i2.length; u++) e2.state.env[`${r2}_${u}`] = i2[u];
    e2.state.env[`${r2}__length`] = String(i2.length);
  } else if (a !== void 0 && o2 !== void 0) {
    let u = await DN(e2, a);
    e2.state.env[`${r2}_${u}`] = o2;
    let f2 = parseInt(e2.state.env[`${r2}__length`] ?? "0", 10);
    u >= f2 && (e2.state.env[`${r2}__length`] = String(u + 1));
  } else o2 !== void 0 && (e2.state.env[r2] = o2);
  return l && gt(e2, r2), null;
}
function cn(e2, t2) {
  e2.state.localVarDepth = e2.state.localVarDepth || /* @__PURE__ */ new Map(), e2.state.localVarDepth.set(t2, e2.state.callDepth);
}
function ar(e2, t2) {
  var _a3;
  return (_a3 = e2.state.localVarDepth) == null ? void 0 : _a3.get(t2);
}
function ki(e2, t2) {
  var _a3;
  (_a3 = e2.state.localVarDepth) == null ? void 0 : _a3.delete(t2);
}
function j0(e2, t2, n2) {
  e2.state.localVarStack = e2.state.localVarStack || /* @__PURE__ */ new Map();
  let r2 = e2.state.localVarStack.get(t2) || [];
  r2.push({ value: n2, scopeIndex: e2.state.localScopes.length - 1 }), e2.state.localVarStack.set(t2, r2);
}
function vi(e2, t2) {
  var _a3;
  let n2 = (_a3 = e2.state.localVarStack) == null ? void 0 : _a3.get(t2);
  if (!(!n2 || n2.length === 0)) return n2.pop();
}
function H0(e2, t2) {
  if (e2.state.localVarStack) for (let [n2, r2] of e2.state.localVarStack.entries()) {
    for (; r2.length > 0 && r2[r2.length - 1].scopeIndex === t2; ) r2.pop();
    r2.length === 0 && e2.state.localVarStack.delete(n2);
  }
}
de();
ot();
var al = /* @__PURE__ */ new Set([":", ".", "break", "continue", "eval", "exec", "exit", "export", "readonly", "return", "set", "shift", "trap", "unset"]);
function V0(e2) {
  return al.has(e2);
}
var ll = /* @__PURE__ */ new Set(["if", "then", "else", "elif", "fi", "case", "esac", "for", "select", "while", "until", "do", "done", "in", "function", "{", "}", "time", "[[", "]]", "!"]), jr = /* @__PURE__ */ new Set([":", "true", "false", "cd", "export", "unset", "exit", "local", "set", "break", "continue", "return", "eval", "shift", "getopts", "compgen", "complete", "compopt", "pushd", "popd", "dirs", "source", ".", "read", "mapfile", "readarray", "declare", "typeset", "readonly", "let", "command", "shopt", "exec", "test", "[", "echo", "printf", "pwd", "alias", "unalias", "type", "hash", "ulimit", "umask", "trap", "times", "wait", "kill", "jobs", "fg", "bg", "disown", "suspend", "fc", "history", "help", "enable", "builtin", "caller"]);
ot();
async function $n(e2, t2, n2, r2) {
  try {
    if ((await e2.fs.stat(t2)).isDirectory) return `bash: ${n2}: Is a directory
`;
    if (r2.checkNoclobber && e2.state.options.noclobber && !r2.isClobber && n2 !== "/dev/null") return `bash: ${n2}: cannot overwrite existing file
`;
  } catch {
  }
  return null;
}
function He(e2) {
  for (let t2 = 0; t2 < e2.length; t2++) if (e2.charCodeAt(t2) > 255) return "utf8";
  return "binary";
}
function FN(e2) {
  if (!e2.startsWith("__rw__:")) return null;
  let t2 = e2.slice(7), n2 = t2.indexOf(":");
  if (n2 === -1) return null;
  let r2 = Number.parseInt(t2.slice(0, n2), 10);
  if (Number.isNaN(r2) || r2 < 0) return null;
  let s2 = n2 + 1, i2 = t2.slice(s2, s2 + r2), o2 = s2 + r2 + 1, a = t2.slice(o2), l = a.indexOf(":");
  if (l === -1) return null;
  let c = Number.parseInt(a.slice(0, l), 10);
  if (Number.isNaN(c) || c < 0) return null;
  let u = a.slice(l + 1);
  return { path: i2, position: c, content: u };
}
async function q0(e2, t2) {
  let n2 = /* @__PURE__ */ new Map();
  for (let r2 = 0; r2 < t2.length; r2++) {
    let s2 = t2[r2];
    if (s2.target.type === "HereDoc") continue;
    if (s2.operator === ">&" || s2.operator === "<&") {
      if (Wr(e2, s2.target)) return { targets: n2, error: `bash: $@: ambiguous redirect
` };
      n2.set(r2, await J(e2, s2.target));
    } else {
      let o2 = await Br(e2, s2.target);
      if ("error" in o2) return { targets: n2, error: o2.error };
      n2.set(r2, o2.target);
    }
  }
  return { targets: n2 };
}
function _N(e2) {
  e2.state.nextFd === void 0 && (e2.state.nextFd = 10);
  let t2 = e2.state.nextFd;
  return e2.state.nextFd++, t2;
}
async function $i(e2, t2) {
  for (let n2 of t2) {
    if (!n2.fdVariable) continue;
    if (e2.state.fileDescriptors || (e2.state.fileDescriptors = /* @__PURE__ */ new Map()), (n2.operator === ">&" || n2.operator === "<&") && n2.target.type === "Word" && await J(e2, n2.target) === "-") {
      let i2 = e2.state.env[n2.fdVariable];
      if (i2 !== void 0) {
        let o2 = Number.parseInt(i2, 10);
        Number.isNaN(o2) || e2.state.fileDescriptors.delete(o2);
      }
      continue;
    }
    let r2 = _N(e2);
    if (e2.state.env[n2.fdVariable] = String(r2), n2.target.type === "Word") {
      let s2 = await J(e2, n2.target);
      if (n2.operator === ">&" || n2.operator === "<&") {
        let i2 = Number.parseInt(s2, 10);
        if (!Number.isNaN(i2)) {
          let o2 = e2.state.fileDescriptors.get(i2);
          o2 !== void 0 && e2.state.fileDescriptors.set(r2, o2);
          continue;
        }
      }
      if (n2.operator === ">" || n2.operator === ">>" || n2.operator === ">|" || n2.operator === "&>" || n2.operator === "&>>") {
        let i2 = e2.fs.resolvePath(e2.state.cwd, s2);
        (n2.operator === ">" || n2.operator === ">|" || n2.operator === "&>") && await e2.fs.writeFile(i2, "", "binary"), e2.state.fileDescriptors.set(r2, `__file__:${i2}`);
      } else if (n2.operator === "<<<") e2.state.fileDescriptors.set(r2, `${s2}
`);
      else if (n2.operator === "<" || n2.operator === "<>") try {
        let i2 = e2.fs.resolvePath(e2.state.cwd, s2), o2 = await e2.fs.readFile(i2);
        e2.state.fileDescriptors.set(r2, o2);
      } catch {
        return W("", `bash: ${s2}: No such file or directory
`, 1);
      }
    }
  }
  return null;
}
async function qt(e2, t2) {
  for (let n2 of t2) {
    if (n2.target.type === "HereDoc") continue;
    let r2 = n2.operator === ">&";
    if (n2.operator !== ">" && n2.operator !== ">|" && n2.operator !== "&>" && !r2) continue;
    let s2;
    if (r2) {
      if (s2 = await J(e2, n2.target), s2 === "-" || !Number.isNaN(Number.parseInt(s2, 10)) || n2.fd != null) continue;
    } else {
      let a = await Br(e2, n2.target);
      if ("error" in a) return W("", a.error, 1);
      s2 = a.target;
    }
    let i2 = e2.fs.resolvePath(e2.state.cwd, s2), o2 = n2.operator === ">|";
    try {
      let a = await e2.fs.stat(i2);
      if (a.isDirectory) return W("", `bash: ${s2}: Is a directory
`, 1);
      if (e2.state.options.noclobber && !o2 && !a.isDirectory && s2 !== "/dev/null") return W("", `bash: ${s2}: cannot overwrite existing file
`, 1);
    } catch {
    }
    if (s2 !== "/dev/null" && s2 !== "/dev/stdout" && s2 !== "/dev/stderr" && s2 !== "/dev/full" && await e2.fs.writeFile(i2, "", "binary"), s2 === "/dev/full") return W("", `bash: /dev/full: No space left on device
`, 1);
  }
  return null;
}
async function $e(e2, t2, n2, r2) {
  var _a3, _b3, _c2, _d2, _e2, _f2;
  let { stdout: s2, stderr: i2, exitCode: o2 } = t2;
  for (let c = 0; c < n2.length; c++) {
    let u = n2[c];
    if (u.target.type === "HereDoc") continue;
    let f2, p = r2 == null ? void 0 : r2.get(c);
    if (p !== void 0) f2 = p;
    else if (u.operator === ">&" || u.operator === "<&") {
      if (Wr(e2, u.target)) {
        i2 += `bash: $@: ambiguous redirect
`, o2 = 1, s2 = "";
        continue;
      }
      f2 = await J(e2, u.target);
    } else {
      let m = await Br(e2, u.target);
      if ("error" in m) {
        i2 += m.error, o2 = 1, s2 = "";
        continue;
      }
      f2 = m.target;
    }
    if (!u.fdVariable) switch (u.operator) {
      case ">":
      case ">|": {
        let d = u.fd ?? 1, m = u.operator === ">|";
        if (d === 1) {
          if (f2 === "/dev/stdout") break;
          if (f2 === "/dev/stderr") {
            i2 += s2, s2 = "";
            break;
          }
          if (f2 === "/dev/full") {
            i2 += `bash: echo: write error: No space left on device
`, o2 = 1, s2 = "";
            break;
          }
          let h = e2.fs.resolvePath(e2.state.cwd, f2), g = await $n(e2, h, f2, { checkNoclobber: true, isClobber: m });
          if (g) {
            i2 += g, o2 = 1, s2 = "";
            break;
          }
          await e2.fs.writeFile(h, s2, He(s2)), s2 = "";
        } else if (d === 2) {
          if (f2 === "/dev/stderr") break;
          if (f2 === "/dev/stdout") {
            s2 += i2, i2 = "";
            break;
          }
          if (f2 === "/dev/full") {
            i2 += `bash: echo: write error: No space left on device
`, o2 = 1;
            break;
          }
          if (f2 === "/dev/null") i2 = "";
          else {
            let h = e2.fs.resolvePath(e2.state.cwd, f2), g = await $n(e2, h, f2, { checkNoclobber: true, isClobber: m });
            if (g) {
              i2 += g, o2 = 1;
              break;
            }
            await e2.fs.writeFile(h, i2, He(i2)), i2 = "";
          }
        }
        break;
      }
      case ">>": {
        let d = u.fd ?? 1;
        if (d === 1) {
          if (f2 === "/dev/stdout") break;
          if (f2 === "/dev/stderr") {
            i2 += s2, s2 = "";
            break;
          }
          if (f2 === "/dev/full") {
            i2 += `bash: echo: write error: No space left on device
`, o2 = 1, s2 = "";
            break;
          }
          let m = e2.fs.resolvePath(e2.state.cwd, f2), h = await $n(e2, m, f2, {});
          if (h) {
            i2 += h, o2 = 1, s2 = "";
            break;
          }
          await e2.fs.appendFile(m, s2, He(s2)), s2 = "";
        } else if (d === 2) {
          if (f2 === "/dev/stderr") break;
          if (f2 === "/dev/stdout") {
            s2 += i2, i2 = "";
            break;
          }
          if (f2 === "/dev/full") {
            i2 += `bash: echo: write error: No space left on device
`, o2 = 1;
            break;
          }
          let m = e2.fs.resolvePath(e2.state.cwd, f2), h = await $n(e2, m, f2, {});
          if (h) {
            i2 += h, o2 = 1;
            break;
          }
          await e2.fs.appendFile(m, i2, He(i2)), i2 = "";
        }
        break;
      }
      case ">&":
      case "<&": {
        let d = u.fd ?? 1;
        if (f2 === "-") break;
        if (f2.endsWith("-")) {
          let m = f2.slice(0, -1), h = Number.parseInt(m, 10);
          if (!Number.isNaN(h)) {
            let g = (_a3 = e2.state.fileDescriptors) == null ? void 0 : _a3.get(h);
            g !== void 0 ? (e2.state.fileDescriptors || (e2.state.fileDescriptors = /* @__PURE__ */ new Map()), e2.state.fileDescriptors.set(d, g), h >= 3 && ((_b3 = e2.state.fileDescriptors) == null ? void 0 : _b3.delete(h))) : h === 1 || h === 2 ? (e2.state.fileDescriptors || (e2.state.fileDescriptors = /* @__PURE__ */ new Map()), e2.state.fileDescriptors.set(d, `__dupout__:${h}`)) : h === 0 ? (e2.state.fileDescriptors || (e2.state.fileDescriptors = /* @__PURE__ */ new Map()), e2.state.fileDescriptors.set(d, `__dupin__:${h}`)) : h >= 3 && (i2 += `bash: ${h}: Bad file descriptor
`, o2 = 1);
          }
          break;
        }
        if (f2 === "2" || f2 === "&2") d === 1 && (i2 += s2, s2 = "");
        else if (f2 === "1" || f2 === "&1") s2 += i2, i2 = "";
        else {
          let m = Number.parseInt(f2, 10);
          if (Number.isNaN(m)) {
            if (u.operator === ">&") {
              let h = e2.fs.resolvePath(e2.state.cwd, f2), g = await $n(e2, h, f2, { checkNoclobber: true });
              if (g) {
                i2 = g, o2 = 1, s2 = "";
                break;
              }
              if (u.fd == null) {
                let b = s2 + i2;
                await e2.fs.writeFile(h, b, He(b)), s2 = "", i2 = "";
              } else d === 1 ? (await e2.fs.writeFile(h, s2, He(s2)), s2 = "") : d === 2 && (await e2.fs.writeFile(h, i2, He(i2)), i2 = "");
            }
          } else {
            let h = (_c2 = e2.state.fileDescriptors) == null ? void 0 : _c2.get(m);
            if (h == null ? void 0 : h.startsWith("__file__:")) {
              let g = h.slice(9);
              d === 1 ? (await e2.fs.appendFile(g, s2, He(s2)), s2 = "") : d === 2 && (await e2.fs.appendFile(g, i2, He(i2)), i2 = "");
            } else if (h == null ? void 0 : h.startsWith("__rw__:")) {
              let g = FN(h);
              g && (d === 1 ? (await e2.fs.appendFile(g.path, s2, He(s2)), s2 = "") : d === 2 && (await e2.fs.appendFile(g.path, i2, He(i2)), i2 = ""));
            } else if (h == null ? void 0 : h.startsWith("__dupout__:")) {
              let g = Number.parseInt(h.slice(11), 10);
              if (g !== 1) if (g === 2) d === 1 && (i2 += s2, s2 = "");
              else {
                let b = (_d2 = e2.state.fileDescriptors) == null ? void 0 : _d2.get(g);
                if (b == null ? void 0 : b.startsWith("__file__:")) {
                  let y = b.slice(9);
                  d === 1 ? (await e2.fs.appendFile(y, s2, He(s2)), s2 = "") : d === 2 && (await e2.fs.appendFile(y, i2, He(i2)), i2 = "");
                }
              }
            } else (h == null ? void 0 : h.startsWith("__dupin__:")) ? (i2 += `bash: ${m}: Bad file descriptor
`, o2 = 1, s2 = "") : m >= 3 && (i2 += `bash: ${m}: Bad file descriptor
`, o2 = 1, s2 = "");
          }
        }
        break;
      }
      case "&>": {
        if (f2 === "/dev/full") {
          i2 = `bash: echo: write error: No space left on device
`, o2 = 1, s2 = "";
          break;
        }
        let d = e2.fs.resolvePath(e2.state.cwd, f2), m = await $n(e2, d, f2, { checkNoclobber: true });
        if (m) {
          i2 = m, o2 = 1, s2 = "";
          break;
        }
        let h = s2 + i2;
        await e2.fs.writeFile(d, h, He(h)), s2 = "", i2 = "";
        break;
      }
      case "&>>": {
        if (f2 === "/dev/full") {
          i2 = `bash: echo: write error: No space left on device
`, o2 = 1, s2 = "";
          break;
        }
        let d = e2.fs.resolvePath(e2.state.cwd, f2), m = await $n(e2, d, f2, {});
        if (m) {
          i2 = m, o2 = 1, s2 = "";
          break;
        }
        let h = s2 + i2;
        await e2.fs.appendFile(d, h, He(h)), s2 = "", i2 = "";
        break;
      }
    }
  }
  let a = (_e2 = e2.state.fileDescriptors) == null ? void 0 : _e2.get(1);
  if (a) {
    if (a === "__dupout__:2") i2 += s2, s2 = "";
    else if (a.startsWith("__file__:")) {
      let c = a.slice(9);
      await e2.fs.appendFile(c, s2, He(s2)), s2 = "";
    } else if (a.startsWith("__file_append__:")) {
      let c = a.slice(16);
      await e2.fs.appendFile(c, s2, He(s2)), s2 = "";
    }
  }
  let l = (_f2 = e2.state.fileDescriptors) == null ? void 0 : _f2.get(2);
  if (l) {
    if (l === "__dupout__:1") s2 += i2, i2 = "";
    else if (l.startsWith("__file__:")) {
      let c = l.slice(9);
      await e2.fs.appendFile(c, i2, He(i2)), i2 = "";
    } else if (l.startsWith("__file_append__:")) {
      let c = l.slice(16);
      await e2.fs.appendFile(c, i2, He(i2)), i2 = "";
    }
  }
  return W(s2, i2, o2);
}
function G0(e2, t2) {
  if (e2.state.options.posix && al.has(t2.name)) {
    let r2 = `bash: line ${e2.state.currentLine}: \`${t2.name}': is a special builtin
`;
    throw new ae(2, "", r2);
  }
  let n2 = { ...t2, sourceFile: t2.sourceFile ?? e2.state.currentSource ?? "main" };
  return e2.state.functions.set(t2.name, n2), le;
}
async function LN(e2, t2) {
  let n2 = "";
  for (let r2 of t2) if ((r2.operator === "<<" || r2.operator === "<<-") && r2.target.type === "HereDoc") {
    let s2 = r2.target, i2 = await J(e2, s2.content);
    s2.stripTabs && (i2 = i2.split(`
`).map((a) => a.replace(/^\t+/, "")).join(`
`)), (r2.fd ?? 0) === 0 && (n2 = i2);
  } else if (r2.operator === "<<<" && r2.target.type === "Word") n2 = `${await J(e2, r2.target)}
`;
  else if (r2.operator === "<" && r2.target.type === "Word") {
    let s2 = await J(e2, r2.target), i2 = e2.fs.resolvePath(e2.state.cwd, s2);
    try {
      n2 = await e2.fs.readFile(i2);
    } catch {
    }
  }
  return n2;
}
async function Ii(e2, t2, n2, r2 = "", s2) {
  e2.state.callDepth++, e2.state.callDepth > e2.limits.maxCallDepth && (e2.state.callDepth--, Xt(`${t2.name}: maximum recursion depth (${e2.limits.maxCallDepth}) exceeded, increase executionLimits.maxCallDepth`, "recursion")), e2.state.funcNameStack || (e2.state.funcNameStack = []), e2.state.callLineStack || (e2.state.callLineStack = []), e2.state.sourceStack || (e2.state.sourceStack = []), e2.state.funcNameStack.unshift(t2.name), e2.state.callLineStack.unshift(e2.state.currentLine), e2.state.sourceStack.unshift(t2.sourceFile ?? "main"), e2.state.localScopes.push(/* @__PURE__ */ new Map()), e2.state.localExportedVars || (e2.state.localExportedVars = []), e2.state.localExportedVars.push(/* @__PURE__ */ new Set());
  let i2 = {};
  for (let c = 0; c < n2.length; c++) i2[String(c + 1)] = e2.state.env[String(c + 1)], e2.state.env[String(c + 1)] = n2[c];
  i2["@"] = e2.state.env["@"], i2["#"] = e2.state.env["#"], e2.state.env["@"] = n2.join(" "), e2.state.env["#"] = String(n2.length);
  let o2 = () => {
    var _a3, _b3, _c2, _d2;
    let c = e2.state.localScopes.length - 1, u = e2.state.localScopes.pop();
    if (u) for (let [f2, p] of u) p === void 0 ? delete e2.state.env[f2] : e2.state.env[f2] = p;
    if (H0(e2, c), e2.state.fullyUnsetLocals) for (let [f2, p] of e2.state.fullyUnsetLocals.entries()) p === c && e2.state.fullyUnsetLocals.delete(f2);
    if (e2.state.localExportedVars && e2.state.localExportedVars.length > 0) {
      let f2 = e2.state.localExportedVars.pop();
      if (f2) for (let p of f2) (_a3 = e2.state.exportedVars) == null ? void 0 : _a3.delete(p);
    }
    for (let [f2, p] of Object.entries(i2)) p === void 0 ? delete e2.state.env[f2] : e2.state.env[f2] = p;
    (_b3 = e2.state.funcNameStack) == null ? void 0 : _b3.shift(), (_c2 = e2.state.callLineStack) == null ? void 0 : _c2.shift(), (_d2 = e2.state.sourceStack) == null ? void 0 : _d2.shift(), e2.state.callDepth--;
  }, { targets: a, error: l } = await q0(e2, t2.redirections);
  if (l) return o2(), W("", l, 1);
  try {
    let c = await LN(e2, t2.redirections), u = r2 || c, f2 = await e2.executeCommand(t2.body, u);
    return o2(), $e(e2, f2, t2.redirections, a);
  } catch (c) {
    if (o2(), c instanceof Ve) {
      let u = W(c.stdout, c.stderr, c.exitCode);
      return $e(e2, u, t2.redirections, a);
    }
    throw c;
  }
}
var Q0 = ["!", "[[", "]]", "case", "do", "done", "elif", "else", "esac", "fi", "for", "function", "if", "in", "then", "time", "until", "while", "{", "}"], ul = [".", ":", "[", "alias", "bg", "bind", "break", "builtin", "caller", "cd", "command", "compgen", "complete", "compopt", "continue", "declare", "dirs", "disown", "echo", "enable", "eval", "exec", "exit", "export", "false", "fc", "fg", "getopts", "hash", "help", "history", "jobs", "kill", "let", "local", "logout", "mapfile", "popd", "printf", "pushd", "pwd", "read", "readarray", "readonly", "return", "set", "shift", "shopt", "source", "suspend", "test", "times", "trap", "true", "type", "typeset", "ulimit", "umask", "unalias", "unset", "wait"], MN = ["autocd", "assoc_expand_once", "cdable_vars", "cdspell", "checkhash", "checkjobs", "checkwinsize", "cmdhist", "compat31", "compat32", "compat40", "compat41", "compat42", "compat43", "compat44", "complete_fullquote", "direxpand", "dirspell", "dotglob", "execfail", "expand_aliases", "extdebug", "extglob", "extquote", "failglob", "force_fignore", "globasciiranges", "globstar", "gnu_errfmt", "histappend", "histreedit", "histverify", "hostcomplete", "huponexit", "inherit_errexit", "interactive_comments", "lastpipe", "lithist", "localvar_inherit", "localvar_unset", "login_shell", "mailwarn", "no_empty_cmd_completion", "nocaseglob", "nocasematch", "nullglob", "progcomp", "progcomp_alias", "promptvars", "restricted_shell", "shift_verbose", "sourcepath", "xpg_echo"], WN = ul;
async function fl(e2, t2) {
  let n2 = [], r2 = null, s2 = "", i2 = "", o2 = null, a = false, l = false, c = false, u = null, f2 = null, p = null, d = [], m = ["alias", "arrayvar", "binding", "builtin", "command", "directory", "disabled", "enabled", "export", "file", "function", "group", "helptopic", "hostname", "job", "keyword", "running", "service", "setopt", "shopt", "signal", "stopped", "user", "variable"];
  for (let E = 0; E < t2.length; E++) {
    let C = t2[E];
    if (C === "-v") n2.push("variable");
    else if (C === "-e") n2.push("export");
    else if (C === "-f") n2.push("file");
    else if (C === "-d") n2.push("directory");
    else if (C === "-k") n2.push("keyword");
    else if (C === "-A") {
      if (E++, E >= t2.length) return M(`compgen: -A: option requires an argument
`, 2);
      let A = t2[E];
      if (!m.includes(A)) return M(`compgen: ${A}: invalid action name
`, 2);
      n2.push(A);
    } else if (C === "-W") {
      if (E++, E >= t2.length) return M(`compgen: -W: option requires an argument
`, 2);
      r2 = t2[E];
    } else if (C === "-P") {
      if (E++, E >= t2.length) return M(`compgen: -P: option requires an argument
`, 2);
      s2 = t2[E];
    } else if (C === "-S") {
      if (E++, E >= t2.length) return M(`compgen: -S: option requires an argument
`, 2);
      i2 = t2[E];
    } else if (C === "-o") {
      if (E++, E >= t2.length) return M(`compgen: -o: option requires an argument
`, 2);
      let A = t2[E];
      if (A === "plusdirs") a = true;
      else if (A === "dirnames") l = true;
      else if (A === "default") c = true;
      else if (!(A === "filenames" || A === "nospace" || A === "bashdefault" || A === "noquote")) return M(`compgen: ${A}: invalid option name
`, 2);
    } else if (C === "-F") {
      if (E++, E >= t2.length) return M(`compgen: -F: option requires an argument
`, 2);
      f2 = t2[E];
    } else if (C === "-C") {
      if (E++, E >= t2.length) return M(`compgen: -C: option requires an argument
`, 2);
      p = t2[E];
    } else if (C === "-X") {
      if (E++, E >= t2.length) return M(`compgen: -X: option requires an argument
`, 2);
      u = t2[E];
    } else if (C === "-G") {
      if (E++, E >= t2.length) return M(`compgen: -G: option requires an argument
`, 2);
    } else if (C === "--") {
      d.push(...t2.slice(E + 1));
      break;
    } else C.startsWith("-") || d.push(C);
  }
  o2 = d[0] ?? null;
  let h = [];
  if (l) {
    let E = await cl(e2, o2);
    h.push(...E);
  }
  if (c) {
    let E = await Z0(e2, o2);
    h.push(...E);
  }
  for (let E of n2) if (E === "variable") {
    let C = BN(e2, o2);
    h.push(...C);
  } else if (E === "export") {
    let C = UN(e2, o2);
    h.push(...C);
  } else if (E === "function") {
    let C = zN(e2, o2);
    h.push(...C);
  } else if (E === "builtin") {
    let C = jN(o2);
    h.push(...C);
  } else if (E === "keyword") {
    let C = HN(o2);
    h.push(...C);
  } else if (E === "alias") {
    let C = VN(e2, o2);
    h.push(...C);
  } else if (E === "shopt") {
    let C = qN(o2);
    h.push(...C);
  } else if (E === "helptopic") {
    let C = GN(o2);
    h.push(...C);
  } else if (E === "directory") {
    let C = await cl(e2, o2);
    h.push(...C);
  } else if (E === "file") {
    let C = await Z0(e2, o2);
    h.push(...C);
  } else if (E === "user") {
    let C = ZN();
    h.push(...C);
  } else if (E === "command") {
    let C = await QN(e2, o2);
    h.push(...C);
  }
  if (r2 !== null) try {
    let E = await KN(e2, r2), C = XN(e2, E);
    for (let A of C) (o2 === null || A.startsWith(o2)) && h.push(A);
  } catch {
    return W("", "", 1);
  }
  if (a) {
    let E = await cl(e2, o2);
    for (let C of E) h.includes(C) || h.push(C);
  }
  let g = "";
  if (f2 !== null) {
    let E = e2.state.functions.get(f2);
    if (E) {
      let C = {};
      C.COMP_WORDS__length = e2.state.env.COMP_WORDS__length, e2.state.env.COMP_WORDS__length = "0", C.COMP_CWORD = e2.state.env.COMP_CWORD, e2.state.env.COMP_CWORD = "-1", C.COMP_LINE = e2.state.env.COMP_LINE, e2.state.env.COMP_LINE = "", C.COMP_POINT = e2.state.env.COMP_POINT, e2.state.env.COMP_POINT = "0";
      let A = {};
      for (let O of Object.keys(e2.state.env)) (O === "COMPREPLY" || O.startsWith("COMPREPLY_") || O === "COMPREPLY__length") && (A[O] = e2.state.env[O], delete e2.state.env[O]);
      let I = ["compgen", d[0] ?? "", ""];
      try {
        let O = await Ii(e2, E, I, "");
        if (O.exitCode !== 0) return lr(e2, C), lr(e2, A), W("", O.stderr, 1);
        g = O.stdout;
        let L = JN(e2);
        h.push(...L);
      } catch {
        return lr(e2, C), lr(e2, A), W("", "", 1);
      }
      lr(e2, C), lr(e2, A);
    }
  }
  if (p !== null) try {
    let E = Bt(p), C = await e2.executeScript(E);
    if (C.exitCode !== 0) return W("", C.stderr, C.exitCode);
    if (C.stdout) {
      let A = C.stdout.split(`
`);
      for (let I of A) I.length > 0 && h.push(I);
    }
  } catch (E) {
    if (E.name === "ParseException") return M(`compgen: -C: ${E.message}
`, 2);
    throw E;
  }
  let b = h;
  if (u !== null) {
    let E = u.startsWith("!"), C = E ? u.slice(1) : u;
    b = h.filter((A) => {
      let I = or(A, C, false, true);
      return E ? I : !I;
    });
  }
  if (b.length === 0 && o2 !== null) return W(g, "", 1);
  let y = b.map((E) => `${s2}${E}${i2}`).join(`
`), w = g + (y ? `${y}
` : "");
  return ue(w);
}
function BN(e2, t2) {
  let n2 = /* @__PURE__ */ new Set();
  for (let s2 of Object.keys(e2.state.env)) {
    if (s2.includes("_") && /^[a-zA-Z_][a-zA-Z0-9_]*_\d+$/.test(s2) || s2.endsWith("__length")) continue;
    let i2 = s2.split("_")[0];
    /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s2) ? n2.add(s2) : i2 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(i2) && e2.state.env[`${i2}__length`] !== void 0 && n2.add(i2);
  }
  let r2 = Array.from(n2);
  return t2 !== null && (r2 = r2.filter((s2) => s2.startsWith(t2))), r2.sort();
}
function UN(e2, t2) {
  let n2 = e2.state.exportedVars ?? /* @__PURE__ */ new Set(), r2 = Array.from(n2);
  return t2 !== null && (r2 = r2.filter((s2) => s2.startsWith(t2))), r2 = r2.filter((s2) => s2.includes("_") && /^[a-zA-Z_][a-zA-Z0-9_]*_\d+$/.test(s2) || s2.endsWith("__length") ? false : e2.state.env[s2] !== void 0), r2.sort();
}
function zN(e2, t2) {
  let n2 = Array.from(e2.state.functions.keys());
  return t2 !== null && (n2 = n2.filter((r2) => r2.startsWith(t2))), n2.sort();
}
function jN(e2) {
  let t2 = [...ul];
  return e2 !== null && (t2 = t2.filter((n2) => n2.startsWith(e2))), t2.sort();
}
function HN(e2) {
  let t2 = [...Q0];
  return e2 !== null && (t2 = t2.filter((n2) => n2.startsWith(e2))), t2.sort();
}
function VN(e2, t2) {
  let n2 = [];
  for (let s2 of Object.keys(e2.state.env)) if (s2.startsWith("BASH_ALIAS_")) {
    let i2 = s2.slice(11);
    n2.push(i2);
  }
  let r2 = n2;
  return t2 !== null && (r2 = r2.filter((s2) => s2.startsWith(t2))), r2.sort();
}
function qN(e2) {
  let t2 = [...MN];
  return e2 !== null && (t2 = t2.filter((n2) => n2.startsWith(e2))), t2.sort();
}
function GN(e2) {
  let t2 = [...WN];
  return e2 !== null && (t2 = t2.filter((n2) => n2.startsWith(e2))), t2.sort();
}
async function cl(e2, t2) {
  let n2 = [];
  try {
    let r2 = e2.state.cwd, s2 = t2 ?? "";
    if (t2) {
      let o2 = t2.lastIndexOf("/");
      if (o2 !== -1) {
        let a = t2.slice(0, o2) || "/";
        s2 = t2.slice(o2 + 1), a.startsWith("/") ? r2 = a : r2 = `${e2.state.cwd}/${a}`;
      }
    }
    let i2 = await e2.fs.readdir(r2);
    for (let o2 of i2) {
      let a = `${r2}/${o2}`;
      try {
        if ((await e2.fs.stat(a)).isDirectory && (!s2 || o2.startsWith(s2))) if (t2 == null ? void 0 : t2.includes("/")) {
          let c = t2.lastIndexOf("/"), u = t2.slice(0, c + 1);
          n2.push(u + o2);
        } else n2.push(o2);
      } catch {
      }
    }
  } catch {
  }
  return n2.sort();
}
async function Z0(e2, t2) {
  let n2 = [];
  try {
    let r2 = e2.state.cwd, s2 = t2 ?? "";
    if (t2) {
      let o2 = t2.lastIndexOf("/");
      if (o2 !== -1) {
        let a = t2.slice(0, o2) || "/";
        s2 = t2.slice(o2 + 1), a.startsWith("/") ? r2 = a : r2 = `${e2.state.cwd}/${a}`;
      }
    }
    let i2 = await e2.fs.readdir(r2);
    for (let o2 of i2) if (!s2 || o2.startsWith(s2)) if (t2 == null ? void 0 : t2.includes("/")) {
      let a = t2.lastIndexOf("/"), l = t2.slice(0, a + 1);
      n2.push(l + o2);
    } else n2.push(o2);
  } catch {
  }
  return n2.sort();
}
function ZN(e2) {
  return ["root", "nobody"];
}
async function QN(e2, t2) {
  let n2 = /* @__PURE__ */ new Set();
  for (let i2 of ul) n2.add(i2);
  for (let i2 of e2.state.functions.keys()) n2.add(i2);
  for (let i2 of Object.keys(e2.state.env)) i2.startsWith("BASH_ALIAS_") && n2.add(i2.slice(11));
  for (let i2 of Q0) n2.add(i2);
  let r2 = e2.state.env.PATH ?? "/usr/bin:/bin";
  for (let i2 of r2.split(":")) if (i2) try {
    let o2 = await e2.fs.readdir(i2);
    for (let a of o2) n2.add(a);
  } catch {
  }
  let s2 = Array.from(n2);
  return t2 !== null && (s2 = s2.filter((i2) => i2.startsWith(t2))), s2.sort();
}
async function KN(e2, t2) {
  let r2 = new se().parseWordFromString(t2, false, false);
  return await J(e2, r2);
}
function XN(e2, t2) {
  let n2 = e2.state.env.IFS ?? ` 	
`;
  if (n2.length === 0) return [t2];
  let r2 = new Set(n2.split("")), s2 = [], i2 = "", o2 = 0;
  for (; o2 < t2.length; ) {
    let a = t2[o2];
    if (a === "\\" && o2 + 1 < t2.length) {
      let l = t2[o2 + 1];
      i2 += l, o2 += 2;
    } else r2.has(a) ? (i2.length > 0 && (s2.push(i2), i2 = ""), o2++) : (i2 += a, o2++);
  }
  return i2.length > 0 && s2.push(i2), s2;
}
function lr(e2, t2) {
  for (let [n2, r2] of Object.entries(t2)) r2 === void 0 ? delete e2.state.env[n2] : e2.state.env[n2] = r2;
}
function JN(e2) {
  let t2 = [];
  if (e2.state.env["COMPREPLY__length"] !== void 0) {
    let s2 = te(e2, "COMPREPLY");
    for (let [, i2] of s2) t2.push(i2);
  } else e2.state.env.COMPREPLY !== void 0 && t2.push(e2.state.env.COMPREPLY);
  return t2;
}
var YN = ["bashdefault", "default", "dirnames", "filenames", "noquote", "nosort", "nospace", "plusdirs"];
function dl(e2, t2) {
  e2.state.completionSpecs || (e2.state.completionSpecs = /* @__PURE__ */ new Map());
  let n2 = false, r2 = false, s2 = false, i2, o2, a, l = [], c = [], u = [];
  for (let f2 = 0; f2 < t2.length; f2++) {
    let p = t2[f2];
    if (p === "-p") n2 = true;
    else if (p === "-r") r2 = true;
    else if (p === "-D") s2 = true;
    else if (p === "-W") {
      if (f2++, f2 >= t2.length) return M(`complete: -W: option requires an argument
`, 2);
      i2 = t2[f2];
    } else if (p === "-F") {
      if (f2++, f2 >= t2.length) return M(`complete: -F: option requires an argument
`, 2);
      o2 = t2[f2];
    } else if (p === "-o") {
      if (f2++, f2 >= t2.length) return M(`complete: -o: option requires an argument
`, 2);
      let d = t2[f2];
      if (!YN.includes(d)) return M(`complete: ${d}: invalid option name
`, 2);
      l.push(d);
    } else if (p === "-A") {
      if (f2++, f2 >= t2.length) return M(`complete: -A: option requires an argument
`, 2);
      c.push(t2[f2]);
    } else if (p === "-C") {
      if (f2++, f2 >= t2.length) return M(`complete: -C: option requires an argument
`, 2);
      a = t2[f2];
    } else if (p === "-G") {
      if (f2++, f2 >= t2.length) return M(`complete: -G: option requires an argument
`, 2);
    } else if (p === "-P") {
      if (f2++, f2 >= t2.length) return M(`complete: -P: option requires an argument
`, 2);
    } else if (p === "-S") {
      if (f2++, f2 >= t2.length) return M(`complete: -S: option requires an argument
`, 2);
    } else if (p === "-X") {
      if (f2++, f2 >= t2.length) return M(`complete: -X: option requires an argument
`, 2);
    } else if (p === "--") {
      u.push(...t2.slice(f2 + 1));
      break;
    } else p.startsWith("-") || u.push(p);
  }
  if (r2) {
    if (u.length === 0) return e2.state.completionSpecs.clear(), ue("");
    for (let f2 of u) e2.state.completionSpecs.delete(f2);
    return ue("");
  }
  if (n2) return u.length === 0 ? pl(e2) : pl(e2, u);
  if (t2.length === 0 || u.length === 0 && !i2 && !o2 && !a && l.length === 0 && c.length === 0 && !s2) return pl(e2);
  if (o2 && u.length === 0 && !s2) return M(`complete: -F: option requires a command name
`, 2);
  if (s2) {
    let f2 = { isDefault: true };
    return i2 !== void 0 && (f2.wordlist = i2), o2 !== void 0 && (f2.function = o2), a !== void 0 && (f2.command = a), l.length > 0 && (f2.options = l), c.length > 0 && (f2.actions = c), e2.state.completionSpecs.set("__default__", f2), ue("");
  }
  for (let f2 of u) {
    let p = {};
    i2 !== void 0 && (p.wordlist = i2), o2 !== void 0 && (p.function = o2), a !== void 0 && (p.command = a), l.length > 0 && (p.options = l), c.length > 0 && (p.actions = c), e2.state.completionSpecs.set(f2, p);
  }
  return ue("");
}
function pl(e2, t2) {
  let n2 = e2.state.completionSpecs;
  if (!n2 || n2.size === 0) {
    if (t2 && t2.length > 0) {
      let i2 = "";
      for (let o2 of t2) i2 += `complete: ${o2}: no completion specification
`;
      return W("", i2, 1);
    }
    return ue("");
  }
  let r2 = [], s2 = t2 || Array.from(n2.keys());
  for (let i2 of s2) {
    if (i2 === "__default__") continue;
    let o2 = n2.get(i2);
    if (!o2) {
      if (t2) return W(r2.join(`
`) + (r2.length > 0 ? `
` : ""), `complete: ${i2}: no completion specification
`, 1);
      continue;
    }
    let a = "complete";
    if (o2.options) for (let l of o2.options) a += ` -o ${l}`;
    if (o2.actions) for (let l of o2.actions) a += ` -A ${l}`;
    o2.wordlist !== void 0 && (o2.wordlist.includes(" ") || o2.wordlist.includes("'") ? a += ` -W '${o2.wordlist}'` : a += ` -W ${o2.wordlist}`), o2.function !== void 0 && (a += ` -F ${o2.function}`), o2.isDefault && (a += " -D"), a += ` ${i2}`, r2.push(a);
  }
  return r2.length === 0 ? ue("") : ue(`${r2.join(`
`)}
`);
}
var K0 = ["bashdefault", "default", "dirnames", "filenames", "noquote", "nosort", "nospace", "plusdirs"];
function hl(e2, t2) {
  e2.state.completionSpecs || (e2.state.completionSpecs = /* @__PURE__ */ new Map());
  let n2 = false, r2 = false, s2 = [], i2 = [], o2 = [];
  for (let a = 0; a < t2.length; a++) {
    let l = t2[a];
    if (l === "-D") n2 = true;
    else if (l === "-E") r2 = true;
    else if (l === "-o") {
      if (a++, a >= t2.length) return M(`compopt: -o: option requires an argument
`, 2);
      let c = t2[a];
      if (!K0.includes(c)) return M(`compopt: ${c}: invalid option name
`, 2);
      s2.push(c);
    } else if (l === "+o") {
      if (a++, a >= t2.length) return M(`compopt: +o: option requires an argument
`, 2);
      let c = t2[a];
      if (!K0.includes(c)) return M(`compopt: ${c}: invalid option name
`, 2);
      i2.push(c);
    } else if (l === "--") {
      o2.push(...t2.slice(a + 1));
      break;
    } else !l.startsWith("-") && !l.startsWith("+") && o2.push(l);
  }
  if (n2) {
    let a = e2.state.completionSpecs.get("__default__") ?? { isDefault: true }, l = new Set(a.options ?? []);
    for (let c of s2) l.add(c);
    for (let c of i2) l.delete(c);
    return a.options = l.size > 0 ? Array.from(l) : void 0, e2.state.completionSpecs.set("__default__", a), ue("");
  }
  if (r2) {
    let a = e2.state.completionSpecs.get("__empty__") ?? {}, l = new Set(a.options ?? []);
    for (let c of s2) l.add(c);
    for (let c of i2) l.delete(c);
    return a.options = l.size > 0 ? Array.from(l) : void 0, e2.state.completionSpecs.set("__empty__", a), ue("");
  }
  if (o2.length > 0) {
    for (let a of o2) {
      let l = e2.state.completionSpecs.get(a) ?? {}, c = new Set(l.options ?? []);
      for (let u of s2) c.add(u);
      for (let u of i2) c.delete(u);
      l.options = c.size > 0 ? Array.from(c) : void 0, e2.state.completionSpecs.set(a, l);
    }
    return ue("");
  }
  return M(`compopt: not currently executing completion function
`, 1);
}
de();
function ml(e2, t2) {
  if (e2.state.loopDepth === 0) {
    if (e2.state.parentHasLoopContext) throw new Lt();
    return le;
  }
  if (t2.length > 1) throw new ae(1, "", `bash: continue: too many arguments
`);
  let n2 = 1;
  if (t2.length > 0) {
    let r2 = Number.parseInt(t2[0], 10);
    if (Number.isNaN(r2) || r2 < 1) throw new ae(1, "", `bash: continue: ${t2[0]}: numeric argument required
`);
    n2 = r2;
  }
  throw new Ke(n2);
}
Je();
Fe();
it();
$t();
Tt();
on$1();
function Te(e2, t2) {
  let n2 = e2.state.env.HOME || "/home/user";
  return t2.split(":").map((i2) => i2 === "~" ? n2 : i2 === "~root" ? "/root" : i2.startsWith("~/") ? n2 + i2.slice(1) : i2.startsWith("~root/") ? `/root${i2.slice(5)}` : i2).join(":");
}
$t();
Tt();
function gl(e2) {
  for (let t2 = 0; t2 < e2.length; t2++) {
    let n2 = e2.charCodeAt(t2);
    if (n2 < 32 || n2 === 127) return true;
  }
  return false;
}
function yl(e2) {
  let t2 = "$'";
  for (let n2 = 0; n2 < e2.length; n2++) {
    let r2 = e2[n2], s2 = e2.charCodeAt(n2);
    s2 === 7 ? t2 += "\\a" : s2 === 8 ? t2 += "\\b" : s2 === 9 ? t2 += "\\t" : s2 === 10 ? t2 += "\\n" : s2 === 11 ? t2 += "\\v" : s2 === 12 ? t2 += "\\f" : s2 === 13 ? t2 += "\\r" : s2 === 27 ? t2 += "\\e" : s2 === 39 ? t2 += "\\'" : s2 === 92 ? t2 += "\\\\" : s2 < 32 || s2 === 127 ? t2 += `\\${s2.toString(8).padStart(3, "0")}` : t2 += r2;
  }
  return t2 += "'", t2;
}
function Ri(e2) {
  return gl(e2) ? yl(e2) : /^[a-zA-Z0-9_/.:\-@%+,=]*$/.test(e2) ? e2 : `'${e2.replace(/'/g, "'\\''")}'`;
}
function In(e2) {
  return gl(e2) ? yl(e2) : `"${e2.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function bl(e2) {
  return gl(e2) ? yl(e2) : `"${e2.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function X0(e2, t2) {
  var _a3, _b3, _c2, _d2, _e2;
  let n2 = "";
  return ((_a3 = e2.state.integerVars) == null ? void 0 : _a3.has(t2)) && (n2 += "i"), ((_b3 = e2.state.lowercaseVars) == null ? void 0 : _b3.has(t2)) && (n2 += "l"), Se(e2, t2) && (n2 += "n"), ((_c2 = e2.state.readonlyVars) == null ? void 0 : _c2.has(t2)) && (n2 += "r"), ((_d2 = e2.state.uppercaseVars) == null ? void 0 : _d2.has(t2)) && (n2 += "u"), ((_e2 = e2.state.exportedVars) == null ? void 0 : _e2.has(t2)) && (n2 += "x"), n2 === "" ? "--" : `-${n2}`;
}
function wl(e2) {
  return e2 === "" ? "''" : /[\s'\\]/.test(e2) ? `'${e2.replace(/'/g, "'\\''")}'` : e2;
}
function J0(e2, t2) {
  var _a3, _b3, _c2;
  let n2 = "", r2 = "", s2 = false;
  for (let i2 of t2) {
    let o2 = X0(e2, i2);
    if ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(i2)) {
      let u = Pt(e2, i2);
      if (u.length === 0) n2 += `declare -A ${i2}=()
`;
      else {
        let f2 = u.map((p) => {
          let d = e2.state.env[`${i2}_${p}`] ?? "", m = wl(d);
          return `['${p}']=${m}`;
        });
        n2 += `declare -A ${i2}=(${f2.join(" ")})
`;
      }
      continue;
    }
    let l = _e(e2, i2);
    if (l.length > 0) {
      let u = l.map((f2) => {
        let p = e2.state.env[`${i2}_${f2}`] ?? "";
        return `[${f2}]=${In(p)}`;
      });
      n2 += `declare -a ${i2}=(${u.join(" ")})
`;
      continue;
    }
    if (e2.state.env[`${i2}__length`] !== void 0) {
      n2 += `declare -a ${i2}=()
`;
      continue;
    }
    let c = e2.state.env[i2];
    if (c !== void 0) n2 += `declare ${o2} ${i2}=${bl(c)}
`;
    else {
      let u = (_b3 = e2.state.declaredVars) == null ? void 0 : _b3.has(i2), f2 = (_c2 = e2.state.localVarDepth) == null ? void 0 : _c2.has(i2);
      u || f2 ? n2 += `declare ${o2} ${i2}
` : (r2 += `bash: declare: ${i2}: not found
`, s2 = true);
    }
  }
  return W(n2, r2, s2 ? 1 : 0);
}
function Y0(e2, t2) {
  var _a3, _b3, _c2, _d2;
  let { filterExport: n2, filterReadonly: r2, filterNameref: s2, filterIndexedArray: i2, filterAssocArray: o2 } = t2, a = n2 || r2 || s2 || i2 || o2, l = "", c = /* @__PURE__ */ new Set();
  for (let f2 of Object.keys(e2.state.env)) {
    if (f2.startsWith("BASH_")) continue;
    if (f2.endsWith("__length")) {
      let d = f2.slice(0, -8);
      c.add(d);
      continue;
    }
    let p = f2.lastIndexOf("_");
    if (p > 0) {
      let d = f2.slice(0, p), m = f2.slice(p + 1);
      if (/^\d+$/.test(m) || ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(d))) {
        c.add(d);
        continue;
      }
    }
    c.add(f2);
  }
  if (e2.state.localVarDepth) for (let f2 of e2.state.localVarDepth.keys()) c.add(f2);
  if (e2.state.associativeArrays) for (let f2 of e2.state.associativeArrays) c.add(f2);
  let u = Array.from(c).sort();
  for (let f2 of u) {
    let p = X0(e2, f2), d = (_b3 = e2.state.associativeArrays) == null ? void 0 : _b3.has(f2), m = _e(e2, f2), h = !d && (m.length > 0 || e2.state.env[`${f2}__length`] !== void 0);
    if (a && (o2 && !d || i2 && !h || n2 && !((_c2 = e2.state.exportedVars) == null ? void 0 : _c2.has(f2)) || r2 && !((_d2 = e2.state.readonlyVars) == null ? void 0 : _d2.has(f2)) || s2 && !Se(e2, f2))) continue;
    if (d) {
      let b = Pt(e2, f2);
      if (b.length === 0) l += `declare -A ${f2}=()
`;
      else {
        let y = b.map((w) => {
          let E = e2.state.env[`${f2}_${w}`] ?? "", C = wl(E);
          return `['${w}']=${C}`;
        });
        l += `declare -A ${f2}=(${y.join(" ")})
`;
      }
      continue;
    }
    if (m.length > 0) {
      let b = m.map((y) => {
        let w = e2.state.env[`${f2}_${y}`] ?? "";
        return `[${y}]=${In(w)}`;
      });
      l += `declare -a ${f2}=(${b.join(" ")})
`;
      continue;
    }
    if (e2.state.env[`${f2}__length`] !== void 0) {
      l += `declare -a ${f2}=()
`;
      continue;
    }
    let g = e2.state.env[f2];
    g !== void 0 && (l += `declare ${p} ${f2}=${bl(g)}
`);
  }
  return ue(l);
}
function ey(e2) {
  let t2 = "", n2 = Array.from(e2.state.associativeArrays ?? []).sort();
  for (let r2 of n2) {
    let s2 = Pt(e2, r2);
    if (s2.length === 0) t2 += `declare -A ${r2}=()
`;
    else {
      let i2 = s2.map((o2) => {
        let a = e2.state.env[`${r2}_${o2}`] ?? "", l = wl(a);
        return `['${o2}']=${l}`;
      });
      t2 += `declare -A ${r2}=(${i2.join(" ")})
`;
    }
  }
  return ue(t2);
}
function ty(e2) {
  var _a3, _b3;
  let t2 = "", n2 = /* @__PURE__ */ new Set();
  for (let s2 of Object.keys(e2.state.env)) {
    if (s2.startsWith("BASH_")) continue;
    if (s2.endsWith("__length")) {
      let o2 = s2.slice(0, -8);
      ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(o2)) || n2.add(o2);
      continue;
    }
    let i2 = s2.lastIndexOf("_");
    if (i2 > 0) {
      let o2 = s2.slice(0, i2), a = s2.slice(i2 + 1);
      /^\d+$/.test(a) && (((_b3 = e2.state.associativeArrays) == null ? void 0 : _b3.has(o2)) || n2.add(o2));
    }
  }
  let r2 = Array.from(n2).sort();
  for (let s2 of r2) {
    let i2 = _e(e2, s2);
    if (i2.length === 0) t2 += `declare -a ${s2}=()
`;
    else {
      let o2 = i2.map((a) => {
        let l = e2.state.env[`${s2}_${a}`] ?? "";
        return `[${a}]=${In(l)}`;
      });
      t2 += `declare -a ${s2}=(${o2.join(" ")})
`;
    }
  }
  return ue(t2);
}
function ny(e2) {
  var _a3, _b3;
  let t2 = "", n2 = /* @__PURE__ */ new Set();
  for (let s2 of Object.keys(e2.state.env)) {
    if (s2.startsWith("BASH_")) continue;
    if (s2.endsWith("__length")) {
      let o2 = s2.slice(0, -8);
      n2.add(o2);
      continue;
    }
    let i2 = s2.lastIndexOf("_");
    if (i2 > 0) {
      let o2 = s2.slice(0, i2), a = s2.slice(i2 + 1);
      if (/^\d+$/.test(a) || ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(o2))) {
        n2.add(o2);
        continue;
      }
    }
    n2.add(s2);
  }
  let r2 = Array.from(n2).sort();
  for (let s2 of r2) {
    if (((_b3 = e2.state.associativeArrays) == null ? void 0 : _b3.has(s2)) || _e(e2, s2).length > 0 || e2.state.env[`${s2}__length`] !== void 0) continue;
    let a = e2.state.env[s2];
    a !== void 0 && (t2 += `${s2}=${Ri(a)}
`);
  }
  return ue(t2);
}
function xl(e2, t2) {
  var _a3;
  (_a3 = e2.state).integerVars ?? (_a3.integerVars = /* @__PURE__ */ new Set()), e2.state.integerVars.add(t2);
}
function Hr(e2, t2) {
  var _a3;
  return ((_a3 = e2.state.integerVars) == null ? void 0 : _a3.has(t2)) ?? false;
}
function El(e2, t2) {
  var _a3, _b3;
  (_a3 = e2.state).lowercaseVars ?? (_a3.lowercaseVars = /* @__PURE__ */ new Set()), e2.state.lowercaseVars.add(t2), (_b3 = e2.state.uppercaseVars) == null ? void 0 : _b3.delete(t2);
}
function ek(e2, t2) {
  var _a3;
  return ((_a3 = e2.state.lowercaseVars) == null ? void 0 : _a3.has(t2)) ?? false;
}
function Sl(e2, t2) {
  var _a3, _b3;
  (_a3 = e2.state).uppercaseVars ?? (_a3.uppercaseVars = /* @__PURE__ */ new Set()), e2.state.uppercaseVars.add(t2), (_b3 = e2.state.lowercaseVars) == null ? void 0 : _b3.delete(t2);
}
function tk(e2, t2) {
  var _a3;
  return ((_a3 = e2.state.uppercaseVars) == null ? void 0 : _a3.has(t2)) ?? false;
}
function cr(e2, t2, n2) {
  return ek(e2, t2) ? n2.toLowerCase() : tk(e2, t2) ? n2.toUpperCase() : n2;
}
async function ry(e2, t2) {
  try {
    let n2 = new se(), r2 = he(n2, t2), s2 = await Q(e2, r2.expression);
    return String(s2);
  } catch {
    return "0";
  }
}
function nk(e2) {
  let t2 = e2.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  if (!t2) return null;
  let n2 = t2[0], r2 = n2.length;
  if (e2[r2] !== "[") return null;
  let s2 = 0, i2 = r2 + 1;
  for (; r2 < e2.length; r2++) if (e2[r2] === "[") s2++;
  else if (e2[r2] === "]" && (s2--, s2 === 0)) break;
  if (s2 !== 0) return null;
  let o2 = e2.slice(i2, r2);
  if (r2++, e2[r2] !== "=") return null;
  r2++;
  let a = e2.slice(r2);
  return { name: n2, indexExpr: o2, value: a };
}
async function Al(e2, t2) {
  var _a3, _b3, _c2, _d2, _e2, _f2;
  let n2 = false, r2 = false, s2 = false, i2 = false, o2 = false, a = false, l = false, c = false, u = false, f2 = false, p = false, d = false, m = false, h = false, g = false, b = [];
  for (let L = 0; L < t2.length; L++) {
    let D = t2[L];
    if (D === "-a") n2 = true;
    else if (D === "-A") r2 = true;
    else if (D === "-r") s2 = true;
    else if (D === "-x") i2 = true;
    else if (D === "-p") o2 = true;
    else if (D === "-n") a = true;
    else if (D === "+n") l = true;
    else if (D === "+a") c = true;
    else if (D === "+x") u = true;
    else if (D === "--") {
      b.push(...t2.slice(L + 1));
      break;
    } else if (D.startsWith("+")) {
      for (let $ of D.slice(1)) if ($ === "n") l = true;
      else if ($ === "a") c = true;
      else if ($ === "x") u = true;
      else if ($ !== "r") {
        if ($ !== "i") {
          if (!($ === "f" || $ === "F")) return W("", `bash: typeset: +${$}: invalid option
`, 2);
        }
      }
    } else if (D === "-i") f2 = true;
    else if (D === "-l") p = true;
    else if (D === "-u") d = true;
    else if (D === "-f") m = true;
    else if (D === "-F") h = true;
    else if (D === "-g") g = true;
    else if (D.startsWith("-")) for (let $ of D.slice(1)) if ($ === "a") n2 = true;
    else if ($ === "A") r2 = true;
    else if ($ === "r") s2 = true;
    else if ($ === "x") i2 = true;
    else if ($ === "p") o2 = true;
    else if ($ === "n") a = true;
    else if ($ === "i") f2 = true;
    else if ($ === "l") p = true;
    else if ($ === "u") d = true;
    else if ($ === "f") m = true;
    else if ($ === "F") h = true;
    else if ($ === "g") g = true;
    else return W("", `bash: typeset: -${$}: invalid option
`, 2);
    else b.push(D);
  }
  let w = e2.state.localScopes.length > 0 && !g, E = (L) => {
    if (!w) return;
    let D = e2.state.localScopes[e2.state.localScopes.length - 1];
    D.has(L) || D.set(L, e2.state.env[L]);
  }, C = (L) => {
    if (!w) return;
    let D = e2.state.localScopes[e2.state.localScopes.length - 1];
    D.has(L) || D.set(L, e2.state.env[L]);
    let $ = `${L}_`;
    for (let P of Object.keys(e2.state.env)) P.startsWith($) && !P.includes("__") && (D.has(P) || D.set(P, e2.state.env[P]));
    let N2 = `${L}__length`;
    e2.state.env[N2] !== void 0 && !D.has(N2) && D.set(N2, e2.state.env[N2]);
  }, A = (L) => {
    w && cn(e2, L);
  };
  if (h) {
    if (b.length === 0) {
      let $ = Array.from(e2.state.functions.keys()).sort(), N2 = "";
      for (let P of $) N2 += `declare -f ${P}
`;
      return ue(N2);
    }
    let L = true, D = "";
    for (let $ of b) e2.state.functions.has($) ? D += `${$}
` : L = false;
    return W(D, "", L ? 0 : 1);
  }
  if (m) {
    if (b.length === 0) {
      let D = "", $ = Array.from(e2.state.functions.keys()).sort();
      for (let N2 of $) D += `${N2} ()
{
    # function body
}
`;
      return ue(D);
    }
    let L = true;
    for (let D of b) e2.state.functions.has(D) || (L = false);
    return W("", "", L ? 0 : 1);
  }
  if (o2 && b.length > 0) return J0(e2, b);
  if (o2 && b.length === 0) return Y0(e2, { filterExport: i2, filterReadonly: s2, filterNameref: a, filterIndexedArray: n2, filterAssocArray: r2 });
  if (b.length === 0 && r2 && !o2) return ey(e2);
  if (b.length === 0 && n2 && !o2) return ty(e2);
  if (b.length === 0 && !o2) return ny(e2);
  let I = "", O = 0;
  for (let L of b) {
    let D = L.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
    if (D && !c) {
      let k = D[1], R2 = D[2];
      if (r2 && _e(e2, k).length > 0) {
        I += `bash: declare: ${k}: cannot convert indexed to associative array
`, O = 1;
        continue;
      }
      if ((n2 || !r2 && !n2) && ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(k))) {
        I += `bash: declare: ${k}: cannot convert associative to indexed array
`, O = 1;
        continue;
      }
      if (C(k), r2 && ((_b3 = e2.state).associativeArrays ?? (_b3.associativeArrays = /* @__PURE__ */ new Set()), e2.state.associativeArrays.add(k)), Ut(e2, k), delete e2.state.env[k], delete e2.state.env[`${k}__length`], r2 && R2.includes("[")) {
        let T = Ni(R2);
        for (let [Y, ie] of T) {
          let K = Te(e2, ie);
          e2.state.env[`${k}_${Y}`] = K;
        }
      } else if (r2) {
        let T = Vt(R2);
        for (let Y = 0; Y < T.length; Y += 2) {
          let ie = T[Y], K = Y + 1 < T.length ? Te(e2, T[Y + 1]) : "";
          e2.state.env[`${k}_${ie}`] = K;
        }
      } else {
        let T = Vt(R2);
        if (T.some((ie) => /^\[[^\]]+\]=/.test(ie))) {
          let ie = 0;
          for (let K of T) {
            let B = K.match(/^\[([^\]]+)\]=(.*)$/);
            if (B) {
              let q = B[1], be = B[2], ee = Te(e2, be), ge;
              if (/^-?\d+$/.test(q)) ge = Number.parseInt(q, 10);
              else try {
                let U2 = new se(), ye = he(U2, q);
                ge = await Q(e2, ye.expression);
              } catch {
                ge = 0;
              }
              e2.state.env[`${k}_${ge}`] = ee, ie = ge + 1;
            } else {
              let q = Te(e2, K);
              e2.state.env[`${k}_${ie}`] = q, ie++;
            }
          }
        } else {
          for (let ie = 0; ie < T.length; ie++) e2.state.env[`${k}_${ie}`] = T[ie];
          e2.state.env[`${k}__length`] = String(T.length);
        }
      }
      A(k), s2 && gt(e2, k), i2 && Ot(e2, k);
      continue;
    }
    if (l) {
      let k = L.includes("=") ? L.slice(0, L.indexOf("=")) : L;
      if (og(e2, k), !L.includes("=")) continue;
    }
    if (u) {
      let k = L.includes("=") ? L.slice(0, L.indexOf("=")) : L;
      if (oi(e2, k), !L.includes("=")) continue;
    }
    let $ = nk(L);
    if ($) {
      let { name: k, indexExpr: R2, value: T } = $;
      je(e2, k);
      C(k);
      let ie;
      try {
        let B = new se(), q = he(B, R2);
        ie = await Q(e2, q.expression);
      } catch {
        let B = parseInt(R2, 10);
        ie = Number.isNaN(B) ? 0 : B;
      }
      e2.state.env[`${k}_${ie}`] = T;
      let K = parseInt(e2.state.env[`${k}__length`] ?? "0", 10);
      ie >= K && (e2.state.env[`${k}__length`] = String(ie + 1)), A(k), s2 && gt(e2, k), i2 && Ot(e2, k);
      continue;
    }
    let N2 = L.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
    if (N2 && !c) {
      let k = N2[1], R2 = N2[2];
      je(e2, k);
      C(k);
      let Y = Vt(R2);
      if ((_c2 = e2.state.associativeArrays) == null ? void 0 : _c2.has(k)) {
        let ie = Ni(R2);
        for (let [K, B] of ie) {
          let q = Te(e2, B);
          e2.state.env[`${k}_${K}`] = q;
        }
      } else {
        let ie = _e(e2, k), K = 0;
        if (ie.length === 0 && e2.state.env[k] !== void 0) {
          let q = e2.state.env[k];
          e2.state.env[`${k}_0`] = q, delete e2.state.env[k], K = 1;
        } else ie.length > 0 && (K = Math.max(...ie) + 1);
        for (let q = 0; q < Y.length; q++) e2.state.env[`${k}_${K + q}`] = Te(e2, Y[q]);
        let B = K + Y.length;
        e2.state.env[`${k}__length`] = String(B);
      }
      A(k), s2 && gt(e2, k), i2 && Ot(e2, k);
      continue;
    }
    let P = L.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (P) {
      let k = P[1], R2 = Te(e2, P[2]);
      je(e2, k);
      E(k), f2 && xl(e2, k), p && El(e2, k), d && Sl(e2, k);
      let ie = _e(e2, k).length > 0 || ((_d2 = e2.state.associativeArrays) == null ? void 0 : _d2.has(k));
      if (Hr(e2, k)) {
        let K = e2.state.env[k] ?? "0", B = parseInt(K, 10) || 0, q = parseInt(await ry(e2, R2), 10) || 0;
        R2 = String(B + q), e2.state.env[k] = R2;
      } else if (ie) {
        R2 = cr(e2, k, R2);
        let K = `${k}_0`, B = e2.state.env[K] ?? "";
        e2.state.env[K] = B + R2;
      } else {
        R2 = cr(e2, k, R2);
        let K = e2.state.env[k] ?? "";
        e2.state.env[k] = K + R2;
      }
      A(k), s2 && gt(e2, k), i2 && Ot(e2, k), e2.state.options.allexport && !u && (e2.state.exportedVars = e2.state.exportedVars || /* @__PURE__ */ new Set(), e2.state.exportedVars.add(k));
      continue;
    }
    if (L.includes("=")) {
      let k = L.indexOf("="), R2 = L.slice(0, k), T = L.slice(k + 1);
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(R2)) {
        I += `bash: typeset: \`${R2}': not a valid identifier
`, O = 1;
        continue;
      }
      je(e2, R2);
      if (E(R2), a) {
        if (T !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(T)) {
          I += `bash: declare: \`${T}': invalid variable name for name reference
`, O = 1;
          continue;
        }
        e2.state.env[R2] = T, Zt(e2, R2), T !== "" && si(e2, T) && Ua(e2, R2), A(R2), s2 && gt(e2, R2), i2 && Ot(e2, R2);
        continue;
      }
      if (f2 && xl(e2, R2), p && El(e2, R2), d && Sl(e2, R2), Hr(e2, R2) && (T = await ry(e2, T)), T = cr(e2, R2, T), Se(e2, R2)) {
        let ie = st(e2, R2);
        ie && ie !== R2 ? e2.state.env[ie] = T : e2.state.env[R2] = T;
      } else e2.state.env[R2] = T;
      A(R2), s2 && gt(e2, R2), i2 && Ot(e2, R2), e2.state.options.allexport && !u && (e2.state.exportedVars = e2.state.exportedVars || /* @__PURE__ */ new Set(), e2.state.exportedVars.add(R2));
    } else {
      let k = L;
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(k)) {
        I += `bash: typeset: \`${k}': not a valid identifier
`, O = 1;
        continue;
      }
      if (n2 || r2 ? C(k) : E(k), a) {
        Zt(e2, k);
        let T = e2.state.env[k];
        T !== void 0 && T !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(T) ? ag(e2, k) : T && si(e2, T) && Ua(e2, k), A(k), s2 && gt(e2, k), i2 && Ot(e2, k);
        continue;
      }
      if (f2 && xl(e2, k), p && El(e2, k), d && Sl(e2, k), r2) {
        if (_e(e2, k).length > 0) {
          I += `bash: declare: ${k}: cannot convert indexed to associative array
`, O = 1;
          continue;
        }
        (_e2 = e2.state).associativeArrays ?? (_e2.associativeArrays = /* @__PURE__ */ new Set()), e2.state.associativeArrays.add(k);
      }
      let R2 = Object.keys(e2.state.env).some((T) => T.startsWith(`${k}_`) && !T.startsWith(`${k}__length`));
      !(k in e2.state.env) && !R2 && (n2 || r2 ? e2.state.env[`${k}__length`] = "0" : ((_f2 = e2.state).declaredVars ?? (_f2.declaredVars = /* @__PURE__ */ new Set()), e2.state.declaredVars.add(k))), A(k), s2 && gt(e2, k), i2 && Ot(e2, k);
    }
  }
  return W("", I, O);
}
async function Cl(e2, t2) {
  var _a3;
  let i2 = [];
  for (let o2 = 0; o2 < t2.length; o2++) {
    let a = t2[o2];
    if (a === "-a") ;
    else if (a === "-A") ;
    else if (a === "-p") ;
    else if (a === "--") {
      i2.push(...t2.slice(o2 + 1));
      break;
    } else a.startsWith("-") || i2.push(a);
  }
  if (i2.length === 0) {
    let o2 = "", a = Array.from(e2.state.readonlyVars || []).sort();
    for (let l of a) {
      let c = e2.state.env[l];
      if (c !== void 0) {
        let u = c.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        o2 += `declare -r ${l}="${u}"
`;
      }
    }
    return ue(o2);
  }
  for (let o2 of i2) {
    let a = o2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
    if (a) {
      let f2 = a[1], p = a[2];
      je(e2, f2);
      let m = Vt(p);
      if ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(f2)) {
        let h = Ni(p);
        for (let [g, b] of h) {
          let y = Te(e2, b);
          e2.state.env[`${f2}_${g}`] = y;
        }
      } else {
        let h = _e(e2, f2), g = 0;
        if (h.length === 0 && e2.state.env[f2] !== void 0) {
          let y = e2.state.env[f2];
          e2.state.env[`${f2}_0`] = y, delete e2.state.env[f2], g = 1;
        } else h.length > 0 && (g = Math.max(...h) + 1);
        for (let y = 0; y < m.length; y++) e2.state.env[`${f2}_${g + y}`] = Te(e2, m[y]);
        let b = g + m.length;
        e2.state.env[`${f2}__length`] = String(b);
      }
      gt(e2, f2);
      continue;
    }
    let l = o2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (l) {
      let f2 = l[1], p = Te(e2, l[2]);
      je(e2, f2);
      let m = e2.state.env[f2] ?? "";
      e2.state.env[f2] = m + p, gt(e2, f2);
      continue;
    }
    let c = U0(o2);
    if (c.value === void 0 && !c.isArray) {
      gt(e2, c.name);
      continue;
    }
    let u = await z0(e2, c, { makeReadonly: true });
    if (u) return u;
  }
  return le;
}
function Nl(e2) {
  var _a3;
  return (_a3 = e2.state).directoryStack ?? (_a3.directoryStack = []), e2.state.directoryStack;
}
function Vr(e2, t2) {
  return t2 && e2 === t2 ? "~" : t2 && e2.startsWith(`${t2}/`) ? `~${e2.slice(t2.length)}` : e2;
}
function rk(e2) {
  let t2 = e2.split("/").filter((r2) => r2 && r2 !== "."), n2 = [];
  for (let r2 of t2) r2 === ".." ? n2.pop() : n2.push(r2);
  return `/${n2.join("/")}`;
}
async function kl(e2, t2) {
  let n2 = Nl(e2), r2;
  for (let a = 0; a < t2.length; a++) {
    let l = t2[a];
    if (l === "--") {
      if (a + 1 < t2.length) {
        if (r2 !== void 0) return M(`bash: pushd: too many arguments
`, 2);
        r2 = t2[a + 1], a++;
      }
    } else {
      if (l.startsWith("-") && l !== "-") return M(`bash: pushd: ${l}: invalid option
`, 2);
      if (r2 !== void 0) return M(`bash: pushd: too many arguments
`, 2);
      r2 = l;
    }
  }
  if (r2 === void 0) {
    if (n2.length < 2) return M(`bash: pushd: no other directory
`, 1);
    let a = n2[0];
    n2[0] = n2[1], n2[1] = a, r2 = n2[0];
  }
  let s2;
  if (r2.startsWith("/")) s2 = r2;
  else if (r2 === "..") {
    let a = e2.state.cwd.split("/").filter((l) => l);
    a.pop(), s2 = `/${a.join("/")}`;
  } else r2 === "." ? s2 = e2.state.cwd : r2.startsWith("~") ? s2 = (e2.state.env.HOME || "/") + r2.slice(1) : s2 = `${e2.state.cwd}/${r2}`;
  s2 = rk(s2);
  try {
    if (!(await e2.fs.stat(s2)).isDirectory) return M(`bash: pushd: ${r2}: Not a directory
`, 1);
  } catch {
    return M(`bash: pushd: ${r2}: No such file or directory
`, 1);
  }
  n2.unshift(e2.state.cwd), e2.state.previousDir = e2.state.cwd, e2.state.cwd = s2, e2.state.env.PWD = s2, e2.state.env.OLDPWD = e2.state.previousDir;
  let i2 = e2.state.env.HOME || "", o2 = `${[s2, ...n2].map((a) => Vr(a, i2)).join(" ")}
`;
  return ue(o2);
}
function vl(e2, t2) {
  let n2 = Nl(e2);
  for (let o2 of t2) if (o2 !== "--") return o2.startsWith("-") && o2 !== "-" ? M(`bash: popd: ${o2}: invalid option
`, 2) : M(`bash: popd: too many arguments
`, 2);
  if (n2.length === 0) return M(`bash: popd: directory stack empty
`, 1);
  let r2 = n2.shift();
  if (!r2) return M(`bash: popd: directory stack empty
`, 1);
  e2.state.previousDir = e2.state.cwd, e2.state.cwd = r2, e2.state.env.PWD = r2, e2.state.env.OLDPWD = e2.state.previousDir;
  let s2 = e2.state.env.HOME || "", i2 = `${[r2, ...n2].map((o2) => Vr(o2, s2)).join(" ")}
`;
  return ue(i2);
}
function $l(e2, t2) {
  let n2 = Nl(e2), r2 = false, s2 = false, i2 = false, o2 = false;
  for (let u of t2) if (u !== "--") if (u.startsWith("-")) for (let f2 of u.slice(1)) if (f2 === "c") r2 = true;
  else if (f2 === "l") s2 = true;
  else if (f2 === "p") i2 = true;
  else if (f2 === "v") i2 = true, o2 = true;
  else return M(`bash: dirs: -${f2}: invalid option
`, 2);
  else return M(`bash: dirs: too many arguments
`, 1);
  if (r2) return e2.state.directoryStack = [], le;
  let a = [e2.state.cwd, ...n2], l = e2.state.env.HOME || "", c;
  return o2 ? (c = a.map((u, f2) => {
    let p = s2 ? u : Vr(u, l);
    return ` ${f2}  ${p}`;
  }).join(`
`), c += `
`) : i2 ? c = a.map((u) => s2 ? u : Vr(u, l)).join(`
`) + `
` : c = a.map((u) => s2 ? u : Vr(u, l)).join(" ") + `
`, ue(c);
}
Fe();
de();
async function Pi(e2, t2, n2) {
  let r2 = t2;
  if (r2.length > 0) {
    let a = r2[0];
    if (a === "--") r2 = r2.slice(1);
    else if (a.startsWith("-") && a !== "-" && a.length > 1) return M(`bash: eval: ${a}: invalid option
eval: usage: eval [arg ...]
`, 2);
  }
  if (r2.length === 0) return le;
  let s2 = r2.join(" ");
  if (s2.trim() === "") return le;
  let i2 = e2.state.groupStdin, o2 = n2 ?? e2.state.groupStdin;
  o2 !== void 0 && (e2.state.groupStdin = o2);
  try {
    let a = Bt(s2);
    return await e2.executeScript(a);
  } catch (a) {
    if (a instanceof Qe || a instanceof Ke || a instanceof Ve || a instanceof ae) throw a;
    if (a.name === "ParseException") return M(`bash: eval: ${a.message}
`);
    throw a;
  } finally {
    e2.state.groupStdin = i2;
  }
}
de();
function Il(e2, t2) {
  let n2, r2 = "";
  if (t2.length === 0) n2 = e2.state.lastExitCode;
  else {
    let s2 = t2[0], i2 = Number.parseInt(s2, 10);
    s2 === "" || Number.isNaN(i2) || !/^-?\d+$/.test(s2) ? (r2 = `bash: exit: ${s2}: numeric argument required
`, n2 = 2) : n2 = (i2 % 256 + 256) % 256;
  }
  throw new ae(n2, "", r2);
}
on$1();
function Rl(e2, t2) {
  let n2 = false, r2 = [];
  for (let o2 of t2) o2 === "-n" ? n2 = true : o2 === "-p" || o2 === "--" || r2.push(o2);
  if (r2.length === 0 && !n2) {
    let o2 = "", a = e2.state.exportedVars ?? /* @__PURE__ */ new Set(), l = Array.from(a).sort();
    for (let c of l) {
      let u = e2.state.env[c];
      if (u !== void 0) {
        let f2 = u.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        o2 += `declare -x ${c}="${f2}"
`;
      }
    }
    return ue(o2);
  }
  if (n2) {
    for (let o2 of r2) {
      let a, l;
      if (o2.includes("=")) {
        let c = o2.indexOf("=");
        a = o2.slice(0, c), l = Te(e2, o2.slice(c + 1)), e2.state.env[a] = l;
      } else a = o2;
      oi(e2, a);
    }
    return le;
  }
  let s2 = "", i2 = 0;
  for (let o2 of r2) {
    let a, l, c = false, u = o2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (u) a = u[1], l = Te(e2, u[2]), c = true;
    else if (o2.includes("=")) {
      let f2 = o2.indexOf("=");
      a = o2.slice(0, f2), l = Te(e2, o2.slice(f2 + 1));
    } else a = o2;
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(a)) {
      s2 += `bash: export: \`${o2}': not a valid identifier
`, i2 = 1;
      continue;
    }
    if (l !== void 0) if (c) {
      let f2 = e2.state.env[a] ?? "";
      e2.state.env[a] = f2 + l;
    } else e2.state.env[a] = l;
    else a in e2.state.env || (e2.state.env[a] = "");
    Ot(e2, a);
  }
  return W("", s2, i2);
}
function Ti(e2, t2) {
  if (t2.length < 2) return M(`bash: getopts: usage: getopts optstring name [arg ...]
`);
  let n2 = t2[0], r2 = t2[1], s2 = !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r2), i2 = n2.startsWith(":"), o2 = i2 ? n2.slice(1) : n2, a;
  if (t2.length > 2) a = t2.slice(2);
  else {
    let h = Number.parseInt(e2.state.env["#"] || "0", 10);
    a = [];
    for (let g = 1; g <= h; g++) a.push(e2.state.env[String(g)] || "");
  }
  let l = Number.parseInt(e2.state.env.OPTIND || "1", 10);
  l < 1 && (l = 1);
  let c = Number.parseInt(e2.state.env.__GETOPTS_CHARINDEX || "0", 10);
  if (e2.state.env.OPTARG = "", l > a.length) return s2 || (e2.state.env[r2] = "?"), e2.state.env.OPTIND = String(a.length + 1), e2.state.env.__GETOPTS_CHARINDEX = "0", { exitCode: s2 ? 2 : 1, stdout: "", stderr: "" };
  let u = a[l - 1];
  if (!u || u === "-" || !u.startsWith("-")) return s2 || (e2.state.env[r2] = "?"), { exitCode: s2 ? 2 : 1, stdout: "", stderr: "" };
  if (u === "--") return e2.state.env.OPTIND = String(l + 1), e2.state.env.__GETOPTS_CHARINDEX = "0", s2 || (e2.state.env[r2] = "?"), { exitCode: s2 ? 2 : 1, stdout: "", stderr: "" };
  let f2 = c === 0 ? 1 : c, p = u[f2];
  if (!p) return e2.state.env.OPTIND = String(l + 1), e2.state.env.__GETOPTS_CHARINDEX = "0", Ti(e2, t2);
  let d = o2.indexOf(p);
  if (d === -1) {
    let h = "";
    return i2 ? e2.state.env.OPTARG = p : h = `bash: illegal option -- ${p}
`, s2 || (e2.state.env[r2] = "?"), f2 + 1 < u.length ? (e2.state.env.__GETOPTS_CHARINDEX = String(f2 + 1), e2.state.env.OPTIND = String(l)) : (e2.state.env.OPTIND = String(l + 1), e2.state.env.__GETOPTS_CHARINDEX = "0"), { exitCode: s2 ? 2 : 0, stdout: "", stderr: h };
  }
  if (d + 1 < o2.length && o2[d + 1] === ":") if (f2 + 1 < u.length) e2.state.env.OPTARG = u.slice(f2 + 1), e2.state.env.OPTIND = String(l + 1), e2.state.env.__GETOPTS_CHARINDEX = "0";
  else {
    if (l >= a.length) {
      let h = "";
      return i2 ? (e2.state.env.OPTARG = p, s2 || (e2.state.env[r2] = ":")) : (h = `bash: option requires an argument -- ${p}
`, s2 || (e2.state.env[r2] = "?")), e2.state.env.OPTIND = String(l + 1), e2.state.env.__GETOPTS_CHARINDEX = "0", { exitCode: s2 ? 2 : 0, stdout: "", stderr: h };
    }
    e2.state.env.OPTARG = a[l], e2.state.env.OPTIND = String(l + 2), e2.state.env.__GETOPTS_CHARINDEX = "0";
  }
  else f2 + 1 < u.length ? (e2.state.env.__GETOPTS_CHARINDEX = String(f2 + 1), e2.state.env.OPTIND = String(l)) : (e2.state.env.OPTIND = String(l + 1), e2.state.env.__GETOPTS_CHARINDEX = "0");
  return s2 || (e2.state.env[r2] = p), { exitCode: s2 ? 2 : 0, stdout: "", stderr: "" };
}
async function Pl(e2, t2) {
  e2.state.hashTable || (e2.state.hashTable = /* @__PURE__ */ new Map());
  let n2 = false, r2 = false, s2 = false, i2 = false, o2 = false, a = "", l = [], c = 0;
  for (; c < t2.length; ) {
    let m = t2[c];
    if (m === "--") {
      c++, l.push(...t2.slice(c));
      break;
    }
    if (m === "-r") n2 = true, c++;
    else if (m === "-d") r2 = true, c++;
    else if (m === "-l") s2 = true, c++;
    else if (m === "-t") o2 = true, c++;
    else if (m === "-p") {
      if (i2 = true, c++, c >= t2.length) return M(`bash: hash: -p: option requires an argument
`, 1);
      a = t2[c], c++;
    } else if (m.startsWith("-") && m.length > 1) {
      for (let h of m.slice(1)) if (h === "r") n2 = true;
      else if (h === "d") r2 = true;
      else if (h === "l") s2 = true;
      else if (h === "t") o2 = true;
      else return h === "p" ? M(`bash: hash: -p: option requires an argument
`, 1) : M(`bash: hash: -${h}: invalid option
`, 1);
      c++;
    } else l.push(m), c++;
  }
  if (n2) return e2.state.hashTable.clear(), le;
  if (r2) {
    if (l.length === 0) return M(`bash: hash: -d: option requires an argument
`, 1);
    let m = false, h = "";
    for (let g of l) e2.state.hashTable.has(g) ? e2.state.hashTable.delete(g) : (h += `bash: hash: ${g}: not found
`, m = true);
    return m ? M(h, 1) : le;
  }
  if (o2) {
    if (l.length === 0) return M(`bash: hash: -t: option requires an argument
`, 1);
    let m = "", h = false, g = "";
    for (let b of l) {
      let y = e2.state.hashTable.get(b);
      y ? l.length > 1 ? m += `${b}	${y}
` : m += `${y}
` : (g += `bash: hash: ${b}: not found
`, h = true);
    }
    return h ? { exitCode: 1, stdout: m, stderr: g } : ue(m);
  }
  if (i2) {
    if (l.length === 0) return M(`bash: hash: usage: hash [-lr] [-p pathname] [-dt] [name ...]
`, 1);
    let m = l[0];
    return e2.state.hashTable.set(m, a), le;
  }
  if (l.length === 0) {
    if (e2.state.hashTable.size === 0) return ue(`hash: hash table empty
`);
    let m = "";
    if (s2) for (let [h, g] of e2.state.hashTable) m += `builtin hash -p ${g} ${h}
`;
    else {
      m = `hits	command
`;
      for (let [, h] of e2.state.hashTable) m += `   1	${h}
`;
    }
    return ue(m);
  }
  let u = false, f2 = "", d = (e2.state.env.PATH || "/usr/bin:/bin").split(":");
  for (let m of l) {
    if (m.includes("/")) {
      f2 += `bash: hash: ${m}: cannot use / in name
`, u = true;
      continue;
    }
    let h = false;
    for (let g of d) {
      if (!g) continue;
      let b = `${g}/${m}`;
      if (await e2.fs.exists(b)) {
        e2.state.hashTable.set(m, b), h = true;
        break;
      }
    }
    h || (f2 += `bash: hash: ${m}: not found
`, u = true);
  }
  return u ? M(f2, 1) : le;
}
var sy = { ":": [": [arguments]", `Null command.
    No effect; the command does nothing.
    Exit Status:
    Always succeeds.`], ".": [". filename [arguments]", `Execute commands from a file in the current shell.
    Read and execute commands from FILENAME in the current shell.
    The entries in $PATH are used to find the directory containing FILENAME.
    Exit Status:
    Returns the status of the last command executed in FILENAME.`], "[": ["[ arg... ]", `Evaluate conditional expression.
    This is a synonym for the "test" builtin, but the last argument must
    be a literal \`]', to match the opening \`['.`], alias: ["alias [-p] [name[=value] ... ]", `Define or display aliases.
    Without arguments, \`alias' prints the list of aliases in the reusable
    form \`alias NAME=VALUE' on standard output.
    Exit Status:
    alias returns true unless a NAME is supplied for which no alias has been
    defined.`], bg: ["bg [job_spec ...]", `Move jobs to the background.
    Place the jobs identified by each JOB_SPEC in the background, as if they
    had been started with \`&'.`], break: ["break [n]", `Exit for, while, or until loops.
    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing
    loops.
    Exit Status:
    The exit status is 0 unless N is not greater than or equal to 1.`], builtin: ["builtin [shell-builtin [arg ...]]", `Execute shell builtins.
    Execute SHELL-BUILTIN with arguments ARGs without performing command
    lookup.  This is useful when you wish to reimplement a shell builtin
    as a shell function, but need to execute the builtin within the function.
    Exit Status:
    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is
    not a shell builtin.`], caller: ["caller [expr]", `Return the context of the current subroutine call.
    Without EXPR, returns "$line $filename".  With EXPR, returns
    "$line $subroutine $filename"; this extra information can be used to
    provide a stack trace.
    Exit Status:
    Returns 0 unless the shell is not executing a subroutine call or
    EXPR is invalid.`], cd: ["cd [-L|-P] [dir]", `Change the shell working directory.
    Change the current directory to DIR.  The default DIR is the value of the
    HOME shell variable.

    The variable CDPATH defines the search path for the directory containing
    DIR.  Alternative directory names in CDPATH are separated by a colon (:).
    A null directory name is the same as the current directory.  If DIR begins
    with a slash (/), then CDPATH is not used.

    If the directory is not found, and the shell option \`cdable_vars' is set,
    the word is assumed to be a variable name.  If that variable has a value,
    its value is used for DIR.

    Options:
      -L	force symbolic links to be followed
      -P	use the physical directory structure without following symbolic
    	links

    The default is to follow symbolic links, as if \`-L' were specified.

    Exit Status:
    Returns 0 if the directory is changed; non-zero otherwise.`], command: ["command [-pVv] command [arg ...]", `Execute a simple command or display information about commands.
    Runs COMMAND with ARGS suppressing shell function lookup, or display
    information about the specified COMMANDs.

    Options:
      -p	use a default value for PATH that is guaranteed to find all of
    	the standard utilities
      -v	print a description of COMMAND similar to the \`type' builtin
      -V	print a more verbose description of each COMMAND

    Exit Status:
    Returns exit status of COMMAND, or failure if COMMAND is not found.`], compgen: ["compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]", `Display possible completions depending on the options.
    Intended to be used from within a shell function generating possible
    completions.  If the optional WORD argument is supplied, matches against
    WORD are generated.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`], complete: ["complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]", `Specify how arguments are to be completed.
    For each NAME, specify how arguments are to be completed.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`], continue: ["continue [n]", `Resume for, while, or until loops.
    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.
    If N is specified, resumes the Nth enclosing loop.
    Exit Status:
    The exit status is 0 unless N is not greater than or equal to 1.`], declare: ["declare [-aAfFgilnrtux] [-p] [name[=value] ...]", `Set variable values and attributes.
    Declare variables and give them attributes.  If no NAMEs are given,
    display the attributes and values of all variables.

    Options:
      -a	to make NAMEs indexed arrays (if supported)
      -A	to make NAMEs associative arrays (if supported)
      -i	to make NAMEs have the \`integer' attribute
      -l	to convert the value of each NAME to lower case on assignment
      -n	make NAME a reference to the variable named by its value
      -r	to make NAMEs readonly
      -t	to make NAMEs have the \`trace' attribute
      -u	to convert the value of each NAME to upper case on assignment
      -x	to make NAMEs export

    Exit Status:
    Returns success unless an invalid option is supplied or a variable
    assignment error occurs.`], dirs: ["dirs [-clpv] [+N] [-N]", `Display directory stack.
    Display the list of currently remembered directories.  Directories
    find their way onto the list with the \`pushd' command; you can get
    back up through the list with the \`popd' command.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`], disown: ["disown [-h] [-ar] [jobspec ...]", `Remove jobs from current shell.
    Without any JOBSPECs, remove the current job.`], echo: ["echo [-neE] [arg ...]", `Write arguments to the standard output.
    Display the ARGs, separated by a single space character and followed by a
    newline, on the standard output.

    Options:
      -n	do not append a newline
      -e	enable interpretation of the following backslash escapes
      -E	explicitly suppress interpretation of backslash escapes

    Exit Status:
    Returns success unless a write error occurs.`], enable: ["enable [-a] [-dnps] [-f filename] [name ...]", `Enable and disable shell builtins.
    Enables and disables builtin shell commands.
    Exit Status:
    Returns success unless NAME is not a shell builtin or an error occurs.`], eval: ["eval [arg ...]", `Execute arguments as a shell command.
    Combine ARGs into a single string, use the result as input to the shell,
    and execute the resulting commands.
    Exit Status:
    Returns exit status of command or success if command is null.`], exec: ["exec [-cl] [-a name] [command [arguments ...]] [redirection ...]", `Replace the shell with the given command.
    Execute COMMAND, replacing this shell with the specified program.
    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,
    any redirections take effect in the current shell.
    Exit Status:
    Returns success unless COMMAND is not found or a redirection error occurs.`], exit: ["exit [n]", `Exit the shell.
    Exits the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.`], export: ["export [-fn] [name[=value] ...] or export -p", `Set export attribute for shell variables.
    Marks each NAME for automatic export to the environment of subsequently
    executed commands.  If VALUE is supplied, assign VALUE before exporting.

    Options:
      -f	refer to shell functions
      -n	remove the export property from each NAME
      -p	display a list of all exported variables and functions

    Exit Status:
    Returns success unless an invalid option is given or NAME is invalid.`], false: ["false", `Return an unsuccessful result.
    Exit Status:
    Always fails.`], fc: ["fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]", `Display or execute commands from the history list.
    Exit Status:
    Returns success or status of executed command.`], fg: ["fg [job_spec]", `Move job to the foreground.
    Place the job identified by JOB_SPEC in the foreground, making it the
    current job.`], getopts: ["getopts optstring name [arg]", `Parse option arguments.
    Getopts is used by shell procedures to parse positional parameters
    as options.

    OPTSTRING contains the option letters to be recognized; if a letter
    is followed by a colon, the option is expected to have an argument,
    which should be separated from it by white space.
    Exit Status:
    Returns success if an option is found; fails if the end of options is
    encountered or an error occurs.`], hash: ["hash [-lr] [-p pathname] [-dt] [name ...]", `Remember or display program locations.
    Determine and remember the full pathname of each command NAME.
    Exit Status:
    Returns success unless NAME is not found or an invalid option is given.`], help: ["help [-s] [pattern ...]", `Display information about builtin commands.
    Displays brief summaries of builtin commands.  If PATTERN is
    specified, gives detailed help on all commands matching PATTERN,
    otherwise the list of help topics is printed.

    Options:
      -s	output only a short usage synopsis for each topic matching
    	PATTERN

    Exit Status:
    Returns success unless PATTERN is not found.`], history: ["history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]", `Display or manipulate the history list.
    Display the history list with line numbers, prefixing each modified
    entry with a \`*'.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`], jobs: ["jobs [-lnprs] [jobspec ...] or jobs -x command [args]", `Display status of jobs.
    Lists the active jobs.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`], kill: ["kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]", `Send a signal to a job.
    Send the processes identified by PID or JOBSPEC the signal named by
    SIGSPEC or SIGNUM.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`], let: ["let arg [arg ...]", `Evaluate arithmetic expressions.
    Evaluate each ARG as an arithmetic expression.  Evaluation is done in
    fixed-width integers with no check for overflow, though division by 0
    is trapped and flagged as an error.
    Exit Status:
    If the last ARG evaluates to 0, let returns 1; 0 is returned otherwise.`], local: ["local [option] name[=value] ...", `Define local variables.
    Create a local variable called NAME, and give it VALUE.  OPTION can
    be any option accepted by \`declare'.

    Local can only be used within a function; it makes the variable NAME
    have a visible scope restricted to that function and its children.
    Exit Status:
    Returns success unless an invalid option is supplied, a variable
    assignment error occurs, or the shell is not executing a function.`], logout: ["logout [n]", `Exit a login shell.
    Exits a login shell with exit status N.  Returns an error if not executed
    in a login shell.`], mapfile: ["mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]", `Read lines from the standard input into an indexed array variable.
    Read lines from the standard input into the indexed array variable ARRAY,
    or from file descriptor FD if the -u option is supplied.

    Options:
      -d delim	Use DELIM to terminate lines, instead of newline
      -n count	Copy at most COUNT lines
      -O origin	Begin assigning to ARRAY at index ORIGIN
      -s count	Discard the first COUNT lines read
      -t	Remove a trailing DELIM from each line read (default newline)
      -u fd	Read lines from file descriptor FD instead of standard input

    Exit Status:
    Returns success unless an invalid option is given or ARRAY is readonly.`], popd: ["popd [-n] [+N | -N]", `Remove directories from stack.
    Removes entries from the directory stack.
    Exit Status:
    Returns success unless an invalid argument is supplied or the directory
    change fails.`], printf: ["printf [-v var] format [arguments]", `Formats and prints ARGUMENTS under control of the FORMAT.

    Options:
      -v var	assign the output to shell variable VAR rather than
    		display it on the standard output

    FORMAT is a character string which contains three types of objects: plain
    characters, which are simply copied to standard output; character escape
    sequences, which are converted and copied to the standard output; and
    format specifications, each of which causes printing of the next successive
    argument.
    Exit Status:
    Returns success unless an invalid option is given or a write or assignment
    error occurs.`], pushd: ["pushd [-n] [+N | -N | dir]", `Add directories to stack.
    Adds a directory to the top of the directory stack, or rotates
    the stack, making the new top of the stack the current working
    directory.
    Exit Status:
    Returns success unless an invalid argument is supplied or the directory
    change fails.`], pwd: ["pwd [-LP]", `Print the name of the current working directory.

    Options:
      -L	print the value of $PWD if it names the current working
    	directory
      -P	print the physical directory, without any symbolic links

    By default, \`pwd' behaves as if \`-L' were specified.
    Exit Status:
    Returns 0 unless an invalid option is given or the current directory
    cannot be read.`], read: ["read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]", `Read a line from the standard input and split it into fields.
    Reads a single line from the standard input, or from file descriptor FD
    if the -u option is supplied.  The line is split into fields as with word
    splitting, and the first word is assigned to the first NAME, the second
    word to the second NAME, and so on, with any leftover words assigned to
    the last NAME.
    Exit Status:
    The return code is zero, unless end-of-file is encountered, read times out,
    or an invalid file descriptor is supplied as the argument to -u.`], readarray: ["readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]", "Read lines from a file into an array variable.\n    A synonym for `mapfile'."], readonly: ["readonly [-aAf] [name[=value] ...] or readonly -p", `Mark shell variables as unchangeable.
    Mark each NAME as read-only; the values of these NAMEs may not be
    changed by subsequent assignment.
    Exit Status:
    Returns success unless an invalid option is given or NAME is invalid.`], return: ["return [n]", `Return from a shell function.
    Causes a function or sourced script to exit with the return value
    specified by N.  If N is omitted, the return status is that of the
    last command executed within the function or script.
    Exit Status:
    Returns N, or failure if the shell is not executing a function or script.`], set: ["set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]", `Set or unset values of shell options and positional parameters.
    Change the value of shell attributes and positional parameters, or
    display the names and values of shell variables.

    Options:
      -e  Exit immediately if a command exits with a non-zero status.
      -u  Treat unset variables as an error when substituting.
      -x  Print commands and their arguments as they are executed.
      -o option-name
          Set the variable corresponding to option-name

    Exit Status:
    Returns success unless an invalid option is given.`], shift: ["shift [n]", `Shift positional parameters.
    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is
    not given, it is assumed to be 1.
    Exit Status:
    Returns success unless N is negative or greater than $#.`], shopt: ["shopt [-pqsu] [-o] [optname ...]", `Set and unset shell options.
    Change the setting of each shell option OPTNAME.  Without any option
    arguments, list each supplied OPTNAME, or all shell options if no
    OPTNAMEs are given, with an indication of whether or not each is set.

    Options:
      -o	restrict OPTNAMEs to those defined for use with \`set -o'
      -p	print each shell option with an indication of its status
      -q	suppress output
      -s	enable (set) each OPTNAME
      -u	disable (unset) each OPTNAME

    Exit Status:
    Returns success if OPTNAME is enabled; fails if an invalid option is
    given or OPTNAME is disabled.`], source: ["source filename [arguments]", `Execute commands from a file in the current shell.
    Read and execute commands from FILENAME in the current shell.
    The entries in $PATH are used to find the directory containing FILENAME.
    Exit Status:
    Returns the status of the last command executed in FILENAME.`], suspend: ["suspend [-f]", `Suspend shell execution.
    Suspend the execution of this shell until it receives a SIGCONT signal.`], test: ["test [expr]", `Evaluate conditional expression.
    Exits with a status of 0 (true) or 1 (false) depending on
    the evaluation of EXPR.  Expressions may be unary or binary.
    Exit Status:
    Returns success if EXPR evaluates to true; fails if EXPR evaluates to
    false or an invalid argument is given.`], times: ["times", `Display process times.
    Prints the accumulated user and system times for the shell and all of its
    child processes.
    Exit Status:
    Always succeeds.`], trap: ["trap [-lp] [[arg] signal_spec ...]", `Trap signals and other events.
    Defines and activates handlers to be run when the shell receives signals
    or other conditions.
    Exit Status:
    Returns success unless a SIGSPEC is invalid or an invalid option is given.`], true: ["true", `Return a successful result.
    Exit Status:
    Always succeeds.`], type: ["type [-afptP] name [name ...]", `Display information about command type.
    For each NAME, indicate how it would be interpreted if used as a
    command name.

    Options:
      -a	display all locations containing an executable named NAME
      -f	suppress shell function lookup
      -P	force a PATH search for each NAME, even if it is an alias,
    	builtin, or function, and returns the name of the disk file
    	that would be executed
      -p	returns either the name of the disk file that would be executed,
    	or nothing if \`type -t NAME' would not return \`file'
      -t	output a single word which is one of \`alias', \`keyword',
    	\`function', \`builtin', \`file' or \`', if NAME is an alias,
    	shell reserved word, shell function, shell builtin, disk file,
    	or not found, respectively

    Exit Status:
    Returns success if all of the NAMEs are found; fails if any are not found.`], typeset: ["typeset [-aAfFgilnrtux] [-p] name[=value] ...", "Set variable values and attributes.\n    A synonym for `declare'."], ulimit: ["ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]", `Modify shell resource limits.
    Provides control over the resources available to the shell and processes
    it creates, on systems that allow such control.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`], umask: ["umask [-p] [-S] [mode]", `Display or set file mode mask.
    Sets the user file-creation mask to MODE.  If MODE is omitted, prints
    the current value of the mask.
    Exit Status:
    Returns success unless MODE is invalid or an invalid option is given.`], unalias: ["unalias [-a] name [name ...]", `Remove each NAME from the list of defined aliases.
    Exit Status:
    Returns success unless a NAME is not an existing alias.`], unset: ["unset [-f] [-v] [-n] [name ...]", `Unset values and attributes of shell variables and functions.
    For each NAME, remove the corresponding variable or function.

    Options:
      -f	treat each NAME as a shell function
      -v	treat each NAME as a shell variable
      -n	treat each NAME as a name reference and unset the variable itself
    	rather than the variable it references

    Without options, unset first tries to unset a variable, and if that fails,
    tries to unset a function.
    Exit Status:
    Returns success unless an invalid option is given or a NAME is read-only.`], wait: ["wait [-fn] [id ...]", `Wait for job completion and return exit status.
    Waits for each process identified by an ID, which may be a process ID or a
    job specification, and reports its termination status.
    Exit Status:
    Returns the status of the last ID; fails if ID is invalid or an invalid
    option is given.`] }, iy = Object.keys(sy).sort();
function Tl(e2, t2) {
  let n2 = false, r2 = [], s2 = 0;
  for (; s2 < t2.length; ) {
    let l = t2[s2];
    if (l === "--") {
      for (s2++; s2 < t2.length; ) r2.push(t2[s2]), s2++;
      break;
    }
    if (l.startsWith("-") && l.length > 1) {
      for (let c = 1; c < l.length; c++) {
        let u = l[c];
        if (u === "s") n2 = true;
        else return M(`bash: help: -${u}: invalid option
`, 2);
      }
      s2++;
    } else r2.push(l), s2++;
  }
  if (r2.length === 0) return ik();
  let i2 = "", o2 = false, a = "";
  for (let l of r2) {
    let c = sk(l);
    if (c.length === 0) {
      a += `bash: help: no help topics match \`${l}'.  Try \`help help' or \`man -k ${l}' or \`info ${l}'.
`, o2 = true;
      continue;
    }
    for (let u of c) {
      let [f2, p] = sy[u];
      n2 ? i2 += `${u}: ${f2}
` : i2 += `${u}: ${f2}
${p}
`;
    }
  }
  return { exitCode: o2 ? 1 : 0, stdout: i2, stderr: a };
}
function sk(e2) {
  let t2 = e2.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*").replace(/\?/g, "."), n2 = new RegExp(`^${t2}$`);
  return iy.filter((r2) => n2.test(r2));
}
function ik() {
  let e2 = [];
  e2.push("just-bash shell builtins"), e2.push("These shell commands are defined internally. Type `help' to see this list."), e2.push("Type `help name' to find out more about the function `name'."), e2.push("");
  let t2 = 36, n2 = iy.slice(), r2 = Math.ceil(n2.length / 2);
  for (let s2 = 0; s2 < r2; s2++) {
    let i2 = n2[s2] || "", o2 = n2[s2 + r2] || "", a = i2.padEnd(t2);
    e2.push(o2 ? `${a}${o2}` : i2);
  }
  return ue(`${e2.join(`
`)}
`);
}
Fe();
it();
function ok(e2) {
  let t2 = [], n2 = "", r2 = 0;
  for (let s2 of e2) {
    for (let i2 of s2) i2 === "(" ? r2++ : i2 === ")" && r2--;
    n2 ? n2 += ` ${s2}` : n2 = s2, r2 === 0 && (t2.push(n2), n2 = "");
  }
  return n2 && t2.push(n2), t2;
}
async function Ol(e2, t2) {
  if (t2.length === 0) return M(`bash: let: expression expected
`);
  let n2 = ok(t2), r2 = 0;
  for (let s2 of n2) try {
    let o2 = Bt(`(( ${s2} ))`).statements[0];
    if (o2 && o2.pipelines.length > 0 && o2.pipelines[0].commands.length > 0) {
      let a = o2.pipelines[0].commands[0];
      a.type === "ArithmeticCommand" && (r2 = await Q(e2, a.expression.expression));
    }
  } catch (i2) {
    return M(`bash: let: ${s2}: ${i2.message}
`);
  }
  return W("", "", r2 === 0 ? 1 : 0);
}
Je();
Fe();
it();
$t();
Tt();
on$1();
async function Dl(e2, t2) {
  var _a3, _b3, _c2;
  if (e2.state.localScopes.length === 0) return M(`bash: local: can only be used in a function
`);
  let n2 = e2.state.localScopes[e2.state.localScopes.length - 1], r2 = "", s2 = 0, i2 = false, o2 = false, l = [];
  for (let c of t2) if (c === "-n") i2 = true;
  else if (c === "-a") o2 = true;
  else if (c === "-p") ;
  else if (c.startsWith("-") && !c.includes("=")) for (let u of c.slice(1)) u === "n" ? i2 = true : u === "a" ? o2 = true : u === "p" && true;
  else l.push(c);
  if (l.length === 0) {
    let c = "", u = Array.from(n2.keys()).filter((f2) => !f2.includes("_") || !f2.match(/_\d+$/)).filter((f2) => !f2.includes("__length")).sort();
    for (let f2 of u) {
      let p = e2.state.env[f2];
      p !== void 0 && (c += `${f2}=${p}
`);
    }
    return W(c, "", 0);
  }
  for (let c of l) {
    let u, f2, p = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
    if (p) {
      u = p[1];
      let b = p[2];
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u)) {
        r2 += `bash: local: \`${c}': not a valid identifier
`, s2 = 1;
        continue;
      }
      if (je(e2, u, "bash"), !n2.has(u)) {
        n2.set(u, e2.state.env[u]);
        let E = `${u}_`;
        for (let C of Object.keys(e2.state.env)) C.startsWith(E) && !C.includes("__") && (n2.has(C) || n2.set(C, e2.state.env[C]));
      }
      let y = `${u}_`;
      for (let E of Object.keys(e2.state.env)) E.startsWith(y) && !E.includes("__") && delete e2.state.env[E];
      let w = Vt(b);
      for (let E = 0; E < w.length; E++) e2.state.env[`${u}_${E}`] = w[E];
      e2.state.env[`${u}__length`] = String(w.length), cn(e2, u), i2 && Zt(e2, u);
      continue;
    }
    let d = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
    if (d) {
      u = d[1];
      let b = d[2];
      if (je(e2, u, "bash"), !n2.has(u)) {
        n2.set(u, e2.state.env[u]);
        let A = `${u}_`;
        for (let O of Object.keys(e2.state.env)) O.startsWith(A) && !O.includes("__") && (n2.has(O) || n2.set(O, e2.state.env[O]));
        let I = `${u}__length`;
        e2.state.env[I] !== void 0 && !n2.has(I) && n2.set(I, e2.state.env[I]);
      }
      let y = Vt(b), w = _e(e2, u), E = 0;
      if (w.length === 0 && e2.state.env[u] !== void 0) {
        let A = e2.state.env[u];
        e2.state.env[`${u}_0`] = A, delete e2.state.env[u], E = 1;
      } else w.length > 0 && (E = Math.max(...w) + 1);
      for (let A = 0; A < y.length; A++) e2.state.env[`${u}_${E + A}`] = Te(e2, y[A]);
      let C = E + y.length;
      e2.state.env[`${u}__length`] = String(C), cn(e2, u), i2 && Zt(e2, u);
      continue;
    }
    let m = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (m) {
      u = m[1];
      let b = Te(e2, m[2]);
      je(e2, u, "bash"), n2.has(u) || n2.set(u, e2.state.env[u]);
      let y = e2.state.env[u] ?? "";
      e2.state.env[u] = y + b, cn(e2, u), i2 && Zt(e2, u);
      continue;
    }
    let h = c.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([^\]]+)\]=(.*)$/s);
    if (h) {
      u = h[1];
      let b = h[2], y = Te(e2, h[3]);
      if (je(e2, u, "bash"), !n2.has(u)) {
        n2.set(u, e2.state.env[u]);
        let C = `${u}_`;
        for (let I of Object.keys(e2.state.env)) I.startsWith(C) && !I.includes("__") && (n2.has(I) || n2.set(I, e2.state.env[I]));
        let A = `${u}__length`;
        e2.state.env[A] !== void 0 && !n2.has(A) && n2.set(A, e2.state.env[A]);
      }
      let w;
      try {
        let C = new se(), A = he(C, b);
        w = await Q(e2, A.expression);
      } catch {
        let C = parseInt(b, 10);
        w = Number.isNaN(C) ? 0 : C;
      }
      e2.state.env[`${u}_${w}`] = y;
      let E = parseInt(e2.state.env[`${u}__length`] ?? "0", 10);
      w >= E && (e2.state.env[`${u}__length`] = String(w + 1)), cn(e2, u), i2 && Zt(e2, u);
      continue;
    }
    if (c.includes("=")) {
      let b = c.indexOf("=");
      u = c.slice(0, b), f2 = Te(e2, c.slice(b + 1));
    } else u = c;
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u)) {
      r2 += `bash: local: \`${c}': not a valid identifier
`, s2 = 1;
      continue;
    }
    let g = n2.has(u);
    if (f2 !== void 0) {
      let b = e2.state.env[u];
      if (e2.state.tempEnvBindings) {
        let y = (_a3 = e2.state.accessedTempEnvVars) == null ? void 0 : _a3.has(u), w = (_b3 = e2.state.mutatedTempEnvVars) == null ? void 0 : _b3.has(u);
        if (!y && !w) for (let E = e2.state.tempEnvBindings.length - 1; E >= 0; E--) {
          let C = e2.state.tempEnvBindings[E];
          if (C.has(u)) {
            b = C.get(u);
            break;
          }
        }
      }
      j0(e2, u, b);
    }
    if (!g) {
      let b = e2.state.env[u];
      if (e2.state.tempEnvBindings) for (let y = e2.state.tempEnvBindings.length - 1; y >= 0; y--) {
        let w = e2.state.tempEnvBindings[y];
        if (w.has(u)) {
          b = w.get(u);
          break;
        }
      }
      if (n2.set(u, b), o2) {
        let y = `${u}_`;
        for (let E of Object.keys(e2.state.env)) E.startsWith(y) && !E.includes("__") && (n2.has(E) || n2.set(E, e2.state.env[E]));
        let w = `${u}__length`;
        e2.state.env[w] !== void 0 && !n2.has(w) && n2.set(w, e2.state.env[w]);
      }
    }
    if (o2 && f2 === void 0) {
      let b = `${u}_`;
      for (let y of Object.keys(e2.state.env)) y.startsWith(b) && !y.includes("__") && delete e2.state.env[y];
      e2.state.env[`${u}__length`] = "0";
    } else if (f2 !== void 0) {
      if (je(e2, u, "bash"), i2 && f2 !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(f2)) {
        r2 += `bash: local: \`${f2}': invalid variable name for name reference
`, s2 = 1;
        continue;
      }
      e2.state.env[u] = f2, e2.state.options.allexport && (e2.state.exportedVars = e2.state.exportedVars || /* @__PURE__ */ new Set(), e2.state.exportedVars.add(u));
    } else {
      let b = (_c2 = e2.state.tempEnvBindings) == null ? void 0 : _c2.some((y) => y.has(u));
      !g && !b && delete e2.state.env[u];
    }
    cn(e2, u), i2 && Zt(e2, u);
  }
  return W("", r2, s2);
}
$t();
function Fl(e2, t2, n2) {
  let r2 = `
`, s2 = 0, i2 = 0, o2 = 0, a = false, l = "MAPFILE", c = 0;
  for (; c < t2.length; ) {
    let b = t2[c];
    b === "-d" && c + 1 < t2.length ? (r2 = t2[c + 1] === "" ? "\0" : t2[c + 1] || `
`, c += 2) : b === "-n" && c + 1 < t2.length ? (s2 = Number.parseInt(t2[c + 1], 10) || 0, c += 2) : b === "-O" && c + 1 < t2.length ? (i2 = Number.parseInt(t2[c + 1], 10) || 0, c += 2) : b === "-s" && c + 1 < t2.length ? (o2 = Number.parseInt(t2[c + 1], 10) || 0, c += 2) : b === "-t" ? (a = true, c++) : b === "-u" || b === "-C" || b === "-c" ? c += 2 : (b.startsWith("-") || (l = b), c++);
  }
  let u = n2;
  !u && e2.state.groupStdin !== void 0 && (u = e2.state.groupStdin);
  let f2 = [], p = u, d = 0, m = 0;
  for (; p.length > 0; ) {
    let b = p.indexOf(r2);
    if (b === -1) {
      if (p.length > 0) {
        if (m < o2) m++;
        else if (s2 === 0 || d < s2) {
          let E = p, C = E.indexOf("\0");
          C !== -1 && (E = E.substring(0, C)), f2.push(E), d++;
        }
      }
      break;
    }
    let y = p.substring(0, b), w = y.indexOf("\0");
    if (w !== -1 && (y = y.substring(0, w)), !a && r2 !== "\0" && (y += r2), p = p.substring(b + r2.length), m < o2) {
      m++;
      continue;
    }
    if (s2 > 0 && d >= s2) break;
    f2.push(y), d++;
  }
  i2 === 0 && Ut(e2, l);
  for (let b = 0; b < f2.length; b++) e2.state.env[`${l}_${i2 + b}`] = f2[b];
  let h = parseInt(e2.state.env[`${l}__length`] || "0", 10), g = i2 + f2.length;
  return e2.state.env[`${l}__length`] = String(Math.max(h, g)), e2.state.groupStdin !== void 0 && !n2 && (e2.state.groupStdin = ""), W("", "", 0);
}
$t();
St();
function ak(e2) {
  if (!e2.startsWith("__rw__:")) return null;
  let t2 = e2.slice(7), n2 = t2.indexOf(":");
  if (n2 === -1) return null;
  let r2 = Number.parseInt(t2.slice(0, n2), 10);
  if (Number.isNaN(r2) || r2 < 0) return null;
  let s2 = n2 + 1, i2 = t2.slice(s2, s2 + r2), o2 = s2 + r2 + 1, a = t2.slice(o2), l = a.indexOf(":");
  if (l === -1) return null;
  let c = Number.parseInt(a.slice(0, l), 10);
  if (Number.isNaN(c) || c < 0) return null;
  let u = a.slice(l + 1);
  return { path: i2, position: c, content: u };
}
function lk(e2, t2, n2) {
  return `__rw__:${e2.length}:${e2}:${t2}:${n2}`;
}
function _l(e2, t2, n2, r2 = -1) {
  let s2 = false, i2 = `
`, a = -1, l = -1, c = null, u = -1, f2 = -1, p = [], d = 0, m = false, h = ($, N2) => {
    let P = 1;
    for (; P < $.length; ) {
      let k = $[P];
      if (k === "r") s2 = true, P++;
      else if (k === "s") P++;
      else {
        if (k === "d") return P + 1 < $.length ? (i2 = $.substring(P + 1), { nextArgIndex: N2 + 1 }) : N2 + 1 < t2.length ? (i2 = t2[N2 + 1], { nextArgIndex: N2 + 2 }) : { nextArgIndex: N2 + 1 };
        if (k === "n") {
          if (P + 1 < $.length) {
            let R2 = $.substring(P + 1);
            return a = Number.parseInt(R2, 10), (Number.isNaN(a) || a < 0) && (m = true, a = 0), { nextArgIndex: N2 + 1 };
          } else if (N2 + 1 < t2.length) return a = Number.parseInt(t2[N2 + 1], 10), (Number.isNaN(a) || a < 0) && (m = true, a = 0), { nextArgIndex: N2 + 2 };
          return { nextArgIndex: N2 + 1 };
        } else if (k === "N") {
          if (P + 1 < $.length) {
            let R2 = $.substring(P + 1);
            return l = Number.parseInt(R2, 10), (Number.isNaN(l) || l < 0) && (m = true, l = 0), { nextArgIndex: N2 + 1 };
          } else if (N2 + 1 < t2.length) return l = Number.parseInt(t2[N2 + 1], 10), (Number.isNaN(l) || l < 0) && (m = true, l = 0), { nextArgIndex: N2 + 2 };
          return { nextArgIndex: N2 + 1 };
        } else {
          if (k === "a") return P + 1 < $.length ? (c = $.substring(P + 1), { nextArgIndex: N2 + 1 }) : N2 + 1 < t2.length ? (c = t2[N2 + 1], { nextArgIndex: N2 + 2 }) : { nextArgIndex: N2 + 1 };
          if (k === "p") return P + 1 < $.length ? ($.substring(P + 1), { nextArgIndex: N2 + 1 }) : N2 + 1 < t2.length ? (t2[N2 + 1], { nextArgIndex: N2 + 2 }) : { nextArgIndex: N2 + 1 };
          if (k === "u") {
            if (P + 1 < $.length) {
              let R2 = $.substring(P + 1);
              return u = Number.parseInt(R2, 10), Number.isNaN(u) || u < 0 ? { nextArgIndex: -2 } : { nextArgIndex: N2 + 1 };
            } else if (N2 + 1 < t2.length) return u = Number.parseInt(t2[N2 + 1], 10), Number.isNaN(u) || u < 0 ? { nextArgIndex: -2 } : { nextArgIndex: N2 + 2 };
            return { nextArgIndex: N2 + 1 };
          } else if (k === "t") {
            if (P + 1 < $.length) {
              let R2 = $.substring(P + 1);
              return f2 = Number.parseFloat(R2), Number.isNaN(f2) && (f2 = 0), { nextArgIndex: N2 + 1 };
            } else if (N2 + 1 < t2.length) return f2 = Number.parseFloat(t2[N2 + 1]), Number.isNaN(f2) && (f2 = 0), { nextArgIndex: N2 + 2 };
            return { nextArgIndex: N2 + 1 };
          } else if (k === "e" || k === "i" || k === "P") {
            if (k === "i" && N2 + 1 < t2.length) return { nextArgIndex: N2 + 2 };
            P++;
          } else P++;
        }
      }
    }
    return { nextArgIndex: N2 + 1 };
  };
  for (; d < t2.length; ) {
    let $ = t2[d];
    if ($.startsWith("-") && $.length > 1 && $ !== "--") {
      let N2 = h($, d);
      if (N2.nextArgIndex === -1) return { stdout: "", stderr: "", exitCode: 2 };
      if (N2.nextArgIndex === -2) return { stdout: "", stderr: "", exitCode: 1 };
      d = N2.nextArgIndex;
    } else if ($ === "--") for (d++; d < t2.length; ) p.push(t2[d]), d++;
    else p.push($), d++;
  }
  if (m) return W("", "", 1);
  if (p.length === 0 && c === null && p.push("REPLY"), f2 === 0) {
    if (c) Ut(e2, c);
    else {
      for (let $ of p) e2.state.env[$] = "";
      p.length === 0 && (e2.state.env.REPLY = "");
    }
    return W("", "", 0);
  }
  if (f2 < 0 && f2 !== -1) return W("", "", 1);
  let g = n2;
  u >= 0 ? e2.state.fileDescriptors ? g = e2.state.fileDescriptors.get(u) || "" : g = "" : !g && e2.state.groupStdin !== void 0 && (g = e2.state.groupStdin);
  let b = i2 === "" ? "\0" : i2, y = "", w = 0, E = true, C = ($) => {
    if (u >= 0 && e2.state.fileDescriptors) e2.state.fileDescriptors.set(u, g.substring($));
    else if (r2 >= 0 && e2.state.fileDescriptors) {
      let N2 = e2.state.fileDescriptors.get(r2);
      if (N2 == null ? void 0 : N2.startsWith("__rw__:")) {
        let P = ak(N2);
        if (P) {
          let k = P.position + $;
          e2.state.fileDescriptors.set(r2, lk(P.path, k, P.content));
        }
      }
    } else e2.state.groupStdin !== void 0 && !n2 && (e2.state.groupStdin = g.substring($));
  };
  if (l >= 0) {
    let $ = Math.min(l, g.length);
    y = g.substring(0, $), w = $, E = $ >= l, C(w);
    let N2 = p[0] || "REPLY";
    e2.state.env[N2] = y;
    for (let P = 1; P < p.length; P++) e2.state.env[p[P]] = "";
    return W("", "", E ? 0 : 1);
  } else if (a >= 0) {
    let $ = 0, N2 = 0, P = false;
    for (; N2 < g.length && $ < a; ) {
      let k = g[N2];
      if (k === b) {
        w = N2 + 1, P = true;
        break;
      }
      if (!s2 && k === "\\" && N2 + 1 < g.length) {
        let R2 = g[N2 + 1];
        if (R2 === b && b === `
`) {
          N2 += 2, w = N2;
          continue;
        }
        if (R2 === b) {
          N2 += 2, $++, y += R2, w = N2;
          continue;
        }
        y += R2, N2 += 2, $++, w = N2;
      } else y += k, N2++, $++, w = N2;
    }
    E = $ >= a || P, C(w);
  } else {
    w = 0;
    let $ = 0;
    for (; $ < g.length; ) {
      let N2 = g[$];
      if (N2 === b) {
        w = $ + b.length, E = true;
        break;
      }
      if (!s2 && N2 === "\\" && $ + 1 < g.length) {
        let P = g[$ + 1];
        if (P === `
`) {
          $ += 2;
          continue;
        }
        if (P === b) {
          y += P, $ += 2;
          continue;
        }
        y += N2, y += P, $ += 2;
        continue;
      }
      y += N2, $++;
    }
    if ($ >= g.length && (E = false, w = $, y.length === 0 && g.length === 0)) {
      for (let N2 of p) e2.state.env[N2] = "";
      return c && Ut(e2, c), W("", "", 1);
    }
    C(w);
  }
  b === `
` && y.endsWith(`
`) && (y = y.slice(0, -1));
  let A = ($) => s2 ? $ : $.replace(/\\(.)/g, "$1");
  if (p.length === 1 && p[0] === "REPLY") return e2.state.env.REPLY = A(y), W("", "", E ? 0 : 1);
  let I = Ue(e2.state.env);
  if (c) {
    let { words: $ } = Ba(y, I, void 0, s2);
    Ut(e2, c);
    for (let N2 = 0; N2 < $.length; N2++) e2.state.env[`${c}_${N2}`] = A($[N2]);
    return W("", "", E ? 0 : 1);
  }
  let O = p.length, { words: L, wordStarts: D } = Ba(y, I, O, s2);
  for (let $ = 0; $ < p.length; $++) {
    let N2 = p[$];
    if ($ < p.length - 1) e2.state.env[N2] = A(L[$] ?? "");
    else if ($ < D.length) {
      let P = y.substring(D[$]);
      P = ig(P, I, s2), P = A(P), e2.state.env[N2] = P;
    } else e2.state.env[N2] = "";
  }
  return W("", "", E ? 0 : 1);
}
de();
function Ll(e2, t2) {
  if (e2.state.callDepth === 0 && e2.state.sourceDepth === 0) return M("bash: return: can only `return' from a function or sourced script\n");
  let n2 = e2.state.lastExitCode;
  if (t2.length > 0) {
    let r2 = t2[0], s2 = Number.parseInt(r2, 10);
    if (r2 === "" || Number.isNaN(s2) || !/^-?\d+$/.test(r2)) return M(`bash: return: ${r2}: numeric argument required
`, 2);
    n2 = (s2 % 256 + 256) % 256;
  }
  throw new Ve(n2);
}
de();
$t();
var Oi = `set: usage: set [-eux] [+eux] [-o option] [+o option]
Options:
  -e            Exit immediately if a command exits with non-zero status
  +e            Disable -e
  -u            Treat unset variables as an error when substituting
  +u            Disable -u
  -x            Print commands and their arguments as they are executed
  +x            Disable -x
  -o errexit    Same as -e
  +o errexit    Disable errexit
  -o nounset    Same as -u
  +o nounset    Disable nounset
  -o pipefail   Return status of last failing command in pipeline
  +o pipefail   Disable pipefail
  -o xtrace     Same as -x
  +o xtrace     Disable xtrace
`, oy = { e: "errexit", u: "nounset", x: "xtrace", v: "verbose", f: "noglob", C: "noclobber", a: "allexport", n: "noexec", h: null, b: null, m: null, B: null, H: null, P: null, T: null, E: null, p: null }, ay = { errexit: "errexit", pipefail: "pipefail", nounset: "nounset", xtrace: "xtrace", verbose: "verbose", noclobber: "noclobber", noglob: "noglob", allexport: "allexport", noexec: "noexec", posix: "posix", vi: "vi", emacs: "emacs", notify: null, monitor: null, braceexpand: null, histexpand: null, physical: null, functrace: null, errtrace: null, privileged: null, hashall: null, ignoreeof: null, "interactive-comments": null, keyword: null, onecmd: null }, ly = ["errexit", "nounset", "pipefail", "verbose", "xtrace", "posix", "allexport", "noclobber", "noglob", "noexec", "vi", "emacs"], cy = ["braceexpand", "errtrace", "functrace", "hashall", "histexpand", "history", "ignoreeof", "interactive-comments", "keyword", "monitor", "nolog", "notify", "onecmd", "physical", "privileged"];
function uy(e2, t2, n2) {
  t2 !== null && (n2 && (t2 === "vi" ? e2.state.options.emacs = false : t2 === "emacs" && (e2.state.options.vi = false)), e2.state.options[t2] = n2, Jn(e2));
}
function ck(e2, t2) {
  return t2 + 1 < e2.length && !e2[t2 + 1].startsWith("-") && !e2[t2 + 1].startsWith("+");
}
function uk(e2, t2) {
  let n2 = _e(e2, t2);
  if (n2.length === 0) return `${t2}=()`;
  let r2 = n2.map((s2) => {
    let i2 = e2.state.env[`${t2}_${s2}`] ?? "";
    return `[${s2}]=${In(i2)}`;
  });
  return `${t2}=(${r2.join(" ")})`;
}
function fk(e2) {
  return /^[a-zA-Z0-9_]+$/.test(e2) ? e2 : `"${e2.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function pk(e2, t2) {
  let n2 = Pt(e2, t2);
  if (n2.length === 0) return `${t2}=()`;
  let r2 = n2.map((s2) => {
    let i2 = e2.state.env[`${t2}_${s2}`] ?? "";
    return `[${fk(s2)}]=${In(i2)}`;
  });
  return `${t2}=(${r2.join(" ")} )`;
}
function dk(e2) {
  let t2 = /* @__PURE__ */ new Set(), n2 = e2.state.associativeArrays ?? /* @__PURE__ */ new Set();
  for (let r2 of Object.keys(e2.state.env)) {
    let s2 = r2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_(\d+)$/);
    if (s2) {
      let i2 = s2[1];
      n2.has(i2) || t2.add(i2);
    }
  }
  return t2;
}
function hk(e2) {
  return e2.state.associativeArrays ?? /* @__PURE__ */ new Set();
}
function Wl(e2, t2) {
  if (t2.includes("--help")) return ue(Oi);
  if (t2.length === 0) {
    let r2 = dk(e2), s2 = hk(e2), i2 = (l) => {
      for (let c of s2) {
        let u = `${c}_`, f2 = `${c}__length`;
        if (l !== f2 && l.startsWith(u)) {
          if (l.slice(u.length).startsWith("_length")) continue;
          return true;
        }
      }
      return false;
    }, o2 = [];
    for (let [l, c] of Object.entries(e2.state.env)) {
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(l) || r2.has(l) || s2.has(l)) continue;
      let u = l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_(\d+)$/);
      if (u && r2.has(u[1])) continue;
      let f2 = l.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
      f2 && r2.has(f2[1]) || i2(l) || f2 && s2.has(f2[1]) || o2.push([l, c]);
    }
    let a = [];
    for (let [l, c] of o2.sort(([u], [f2]) => u < f2 ? -1 : u > f2 ? 1 : 0)) a.push(`${l}=${Ri(c)}`);
    for (let l of [...r2].sort((c, u) => c < u ? -1 : c > u ? 1 : 0)) a.push(uk(e2, l));
    for (let l of [...s2].sort((c, u) => c < u ? -1 : c > u ? 1 : 0)) a.push(pk(e2, l));
    return a.sort((l, c) => {
      let u = l.split("=")[0], f2 = c.split("=")[0];
      return u < f2 ? -1 : u > f2 ? 1 : 0;
    }), ue(a.length > 0 ? `${a.join(`
`)}
` : "");
  }
  let n2 = 0;
  for (; n2 < t2.length; ) {
    let r2 = t2[n2];
    if ((r2 === "-o" || r2 === "+o") && ck(t2, n2)) {
      let s2 = t2[n2 + 1];
      if (!(s2 in ay)) {
        let i2 = `bash: set: ${s2}: invalid option name
${Oi}`;
        if (e2.state.options.posix) throw new xt(1, "", i2);
        return M(i2);
      }
      uy(e2, ay[s2], r2 === "-o"), n2 += 2;
      continue;
    }
    if (r2 === "-o") {
      let s2 = ly.map((a) => `${a.padEnd(16)}${e2.state.options[a] ? "on" : "off"}`), i2 = cy.map((a) => `${a.padEnd(16)}off`), o2 = [...s2, ...i2].sort();
      return ue(`${o2.join(`
`)}
`);
    }
    if (r2 === "+o") {
      let s2 = ly.map((a) => `set ${e2.state.options[a] ? "-o" : "+o"} ${a}`), i2 = cy.map((a) => `set +o ${a}`), o2 = [...s2, ...i2].sort();
      return ue(`${o2.join(`
`)}
`);
    }
    if (r2.length > 1 && (r2[0] === "-" || r2[0] === "+") && r2[1] !== "-") {
      let s2 = r2[0] === "-";
      for (let i2 = 1; i2 < r2.length; i2++) {
        let o2 = r2[i2];
        if (!(o2 in oy)) {
          let a = `bash: set: ${r2[0]}${o2}: invalid option
${Oi}`;
          if (e2.state.options.posix) throw new xt(1, "", a);
          return M(a);
        }
        uy(e2, oy[o2], s2);
      }
      n2++;
      continue;
    }
    if (r2 === "--") return Ml(e2, t2.slice(n2 + 1)), le;
    if (r2 === "-") {
      if (e2.state.options.xtrace = false, e2.state.options.verbose = false, Jn(e2), n2 + 1 < t2.length) return Ml(e2, t2.slice(n2 + 1)), le;
      n2++;
      continue;
    }
    if (r2 === "+") {
      n2++;
      continue;
    }
    if (r2.startsWith("-") || r2.startsWith("+")) {
      let s2 = `bash: set: ${r2}: invalid option
${Oi}`;
      if (e2.state.options.posix) throw new xt(1, "", s2);
      return M(s2);
    }
    return Ml(e2, t2.slice(n2)), le;
  }
  return le;
}
function Ml(e2, t2) {
  let n2 = 1;
  for (; e2.state.env[String(n2)] !== void 0; ) delete e2.state.env[String(n2)], n2++;
  for (let r2 = 0; r2 < t2.length; r2++) e2.state.env[String(r2 + 1)] = t2[r2];
  e2.state.env["#"] = String(t2.length), e2.state.env["@"] = t2.join(" "), e2.state.env["*"] = t2.join(" ");
}
de();
function Bl(e2, t2) {
  let n2 = 1;
  if (t2.length > 0) {
    let o2 = Number.parseInt(t2[0], 10);
    if (Number.isNaN(o2) || o2 < 0) {
      let a = `bash: shift: ${t2[0]}: numeric argument required
`;
      if (e2.state.options.posix) throw new xt(1, "", a);
      return M(a);
    }
    n2 = o2;
  }
  let r2 = Number.parseInt(e2.state.env["#"] || "0", 10);
  if (n2 > r2) {
    let o2 = `bash: shift: shift count out of range
`;
    if (e2.state.options.posix) throw new xt(1, "", o2);
    return M(o2);
  }
  if (n2 === 0) return le;
  let s2 = [];
  for (let o2 = 1; o2 <= r2; o2++) s2.push(e2.state.env[String(o2)] || "");
  let i2 = s2.slice(n2);
  for (let o2 = 1; o2 <= r2; o2++) delete e2.state.env[String(o2)];
  for (let o2 = 0; o2 < i2.length; o2++) e2.state.env[String(o2 + 1)] = i2[o2];
  return e2.state.env["#"] = String(i2.length), e2.state.env["@"] = i2.join(" "), le;
}
Fe();
de();
async function Ul(e2, t2) {
  let n2 = t2;
  if (n2.length > 0 && n2[0] === "--" && (n2 = n2.slice(1)), n2.length === 0) return W("", `bash: source: filename argument required
`, 2);
  let r2 = n2[0], s2 = null, i2 = null;
  if (r2.includes("/")) {
    let c = e2.fs.resolvePath(e2.state.cwd, r2);
    try {
      i2 = await e2.fs.readFile(c), s2 = c;
    } catch {
    }
  } else {
    let u = (e2.state.env.PATH || "").split(":").filter((f2) => f2);
    for (let f2 of u) {
      let p = e2.fs.resolvePath(e2.state.cwd, `${f2}/${r2}`);
      try {
        if ((await e2.fs.stat(p)).isDirectory) continue;
        i2 = await e2.fs.readFile(p), s2 = p;
        break;
      } catch {
      }
    }
    if (i2 === null) {
      let f2 = e2.fs.resolvePath(e2.state.cwd, r2);
      try {
        i2 = await e2.fs.readFile(f2), s2 = f2;
      } catch {
      }
    }
  }
  if (i2 === null) return M(`bash: ${r2}: No such file or directory
`);
  let o2 = {};
  if (n2.length > 1) {
    for (let u = 1; u <= 9; u++) o2[String(u)] = e2.state.env[String(u)];
    o2["#"] = e2.state.env["#"], o2["@"] = e2.state.env["@"];
    let c = n2.slice(1);
    e2.state.env["#"] = String(c.length), e2.state.env["@"] = c.join(" ");
    for (let u = 0; u < c.length && u < 9; u++) e2.state.env[String(u + 1)] = c[u];
    for (let u = c.length + 1; u <= 9; u++) delete e2.state.env[String(u)];
  }
  let a = e2.state.currentSource, l = () => {
    if (e2.state.sourceDepth--, e2.state.currentSource = a, n2.length > 1) for (let [c, u] of Object.entries(o2)) u === void 0 ? delete e2.state.env[c] : e2.state.env[c] = u;
  };
  e2.state.sourceDepth++, e2.state.currentSource = r2;
  try {
    let c = Bt(i2), u = await e2.executeScript(c);
    return l(), u;
  } catch (c) {
    if (l(), c instanceof ae) throw c;
    if (c instanceof Ve) return W(c.stdout, c.stderr, c.exitCode);
    if (c.name === "ParseException") return M(`bash: ${r2}: ${c.message}
`);
    throw c;
  }
}
Je();
Fe();
it();
ht();
ot();
Tt();
on$1();
function fy(e2) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e2);
}
function mk(e2) {
  return e2.startsWith("'") && e2.endsWith("'") || e2.startsWith('"') && e2.endsWith('"');
}
async function py(e2, t2) {
  if (mk(t2)) return null;
  try {
    let n2 = new se(), r2 = he(n2, t2);
    return await Q(e2, r2.expression);
  } catch {
    let n2 = parseInt(t2, 10);
    return Number.isNaN(n2) ? 0 : n2;
  }
}
function dy(e2, t2) {
  var _a3, _b3, _c2, _d2;
  if ((_a3 = e2.state.localVarStack) == null ? void 0 : _a3.has(t2)) {
    let r2 = vi(e2, t2);
    if (r2) {
      r2.value === void 0 ? delete e2.state.env[t2] : e2.state.env[t2] = r2.value;
      let s2 = (_b3 = e2.state.localVarStack) == null ? void 0 : _b3.get(t2);
      if (!s2 || s2.length === 0) ki(e2, t2), (_c2 = e2.state.localVarStack) == null ? void 0 : _c2.delete(t2), e2.state.fullyUnsetLocals = e2.state.fullyUnsetLocals || /* @__PURE__ */ new Map(), e2.state.fullyUnsetLocals.set(t2, r2.scopeIndex), zl(e2, t2);
      else {
        let i2 = s2[s2.length - 1];
        e2.state.localVarDepth = e2.state.localVarDepth || /* @__PURE__ */ new Map(), e2.state.localVarDepth.set(t2, i2.scopeIndex + 1);
      }
      return true;
    }
    return delete e2.state.env[t2], ki(e2, t2), (_d2 = e2.state.localVarStack) == null ? void 0 : _d2.delete(t2), e2.state.fullyUnsetLocals = e2.state.fullyUnsetLocals || /* @__PURE__ */ new Map(), e2.state.fullyUnsetLocals.set(t2, 0), true;
  }
  for (let r2 = e2.state.localScopes.length - 1; r2 >= 0; r2--) {
    let s2 = e2.state.localScopes[r2];
    if (s2.has(t2)) {
      let i2 = s2.get(t2);
      i2 === void 0 ? delete e2.state.env[t2] : e2.state.env[t2] = i2, s2.delete(t2);
      let o2 = false;
      for (let a = r2 - 1; a >= 0; a--) if (e2.state.localScopes[a].has(t2)) {
        e2.state.localVarDepth && e2.state.localVarDepth.set(t2, a + 1), o2 = true;
        break;
      }
      return o2 || ki(e2, t2), true;
    }
  }
  return false;
}
function zl(e2, t2) {
  if (!e2.state.tempEnvBindings || e2.state.tempEnvBindings.length === 0) return false;
  for (let n2 = e2.state.tempEnvBindings.length - 1; n2 >= 0; n2--) {
    let r2 = e2.state.tempEnvBindings[n2];
    if (r2.has(t2)) {
      let s2 = r2.get(t2);
      return s2 === void 0 ? delete e2.state.env[t2] : e2.state.env[t2] = s2, r2.delete(t2), true;
    }
  }
  return false;
}
async function hy(e2, t2) {
  if (t2.startsWith("'") && t2.endsWith("'")) return t2.slice(1, -1);
  if (t2.startsWith('"') && t2.endsWith('"')) {
    let n2 = t2.slice(1, -1), s2 = new se().parseWordFromString(n2, true, false);
    return J(e2, s2);
  }
  if (t2.includes("$")) {
    let r2 = new se().parseWordFromString(t2, false, false);
    return J(e2, r2);
  }
  return t2;
}
async function jl(e2, t2) {
  var _a3, _b3, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j, _k2, _l2, _m2;
  let n2 = "both", r2 = "", s2 = 0;
  for (let i2 of t2) {
    if (i2 === "-v") {
      n2 = "variable";
      continue;
    }
    if (i2 === "-f") {
      n2 = "function";
      continue;
    }
    if (n2 === "function") {
      e2.state.functions.delete(i2);
      continue;
    }
    if (n2 === "variable") {
      let c = i2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
      if (c) {
        let p = c[1], d = c[2];
        if (d === "@" || d === "*") {
          let w = te(e2, p);
          for (let [E] of w) delete e2.state.env[`${p}_${E}`];
          delete e2.state.env[p];
          continue;
        }
        let m = (_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(p);
        if (m) {
          let w = await hy(e2, d);
          delete e2.state.env[`${p}_${w}`];
          continue;
        }
        let h = Qt(e2, p), g = (_b3 = e2.state.declaredVars) == null ? void 0 : _b3.has(p);
        if ((p in e2.state.env || g) && !h && !m) {
          r2 += `bash: unset: ${p}: not an array variable
`, s2 = 1;
          continue;
        }
        let y = await py(e2, d);
        if (y === null && h) {
          r2 += `bash: unset: ${d}: not a valid identifier
`, s2 = 1;
          continue;
        }
        if (y === null) continue;
        if (y < 0) {
          let w = te(e2, p), E = w.length, C = e2.state.currentLine;
          if (E === 0) {
            r2 += `bash: line ${C}: unset: [${y}]: bad array subscript
`, s2 = 1;
            continue;
          }
          let A = E + y;
          if (A < 0) {
            r2 += `bash: line ${C}: unset: [${y}]: bad array subscript
`, s2 = 1;
            continue;
          }
          let I = w[A][0];
          delete e2.state.env[`${p}_${I}`];
          continue;
        }
        delete e2.state.env[`${p}_${y}`];
        continue;
      }
      if (!fy(i2)) {
        r2 += `bash: unset: \`${i2}': not a valid identifier
`, s2 = 1;
        continue;
      }
      let u = i2;
      if (Se(e2, i2)) {
        let p = st(e2, i2);
        p && p !== i2 && (u = p);
      }
      if (Ht(e2, u)) {
        r2 += `bash: unset: ${u}: cannot unset: readonly variable
`, s2 = 1;
        continue;
      }
      let f2 = ar(e2, u);
      if (f2 !== void 0 && f2 !== e2.state.callDepth) dy(e2, u);
      else if ((_c2 = e2.state.fullyUnsetLocals) == null ? void 0 : _c2.has(u)) delete e2.state.env[u];
      else if (f2 !== void 0) {
        let p = (_d2 = e2.state.accessedTempEnvVars) == null ? void 0 : _d2.has(u), d = (_e2 = e2.state.mutatedTempEnvVars) == null ? void 0 : _e2.has(u);
        if ((p || d) && ((_f2 = e2.state.localVarStack) == null ? void 0 : _f2.has(u))) {
          let m = vi(e2, u);
          m ? m.value === void 0 ? delete e2.state.env[u] : e2.state.env[u] = m.value : delete e2.state.env[u];
        } else delete e2.state.env[u];
      } else zl(e2, u) || delete e2.state.env[u];
      (_g2 = e2.state.exportedVars) == null ? void 0 : _g2.delete(u);
      continue;
    }
    let o2 = i2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    if (o2) {
      let c = o2[1], u = o2[2];
      if (u === "@" || u === "*") {
        let h = te(e2, c);
        for (let [g] of h) delete e2.state.env[`${c}_${g}`];
        delete e2.state.env[c];
        continue;
      }
      let f2 = (_h2 = e2.state.associativeArrays) == null ? void 0 : _h2.has(c);
      if (f2) {
        let h = await hy(e2, u);
        delete e2.state.env[`${c}_${h}`];
        continue;
      }
      let p = Qt(e2, c);
      if (c in e2.state.env && !p && !f2) {
        r2 += `bash: unset: ${c}: not an array variable
`, s2 = 1;
        continue;
      }
      let m = await py(e2, u);
      if (m === null && p) {
        r2 += `bash: unset: ${u}: not a valid identifier
`, s2 = 1;
        continue;
      }
      if (m === null) continue;
      if (m < 0) {
        let h = te(e2, c), g = h.length, b = e2.state.currentLine;
        if (g === 0) {
          r2 += `bash: line ${b}: unset: [${m}]: bad array subscript
`, s2 = 1;
          continue;
        }
        let y = g + m;
        if (y < 0) {
          r2 += `bash: line ${b}: unset: [${m}]: bad array subscript
`, s2 = 1;
          continue;
        }
        let w = h[y][0];
        delete e2.state.env[`${c}_${w}`];
        continue;
      }
      delete e2.state.env[`${c}_${m}`];
      continue;
    }
    if (!fy(i2)) {
      r2 += `bash: unset: \`${i2}': not a valid identifier
`, s2 = 1;
      continue;
    }
    let a = i2;
    if (Se(e2, i2)) {
      let c = st(e2, i2);
      c && c !== i2 && (a = c);
    }
    if (Ht(e2, a)) {
      r2 += `bash: unset: ${a}: cannot unset: readonly variable
`, s2 = 1;
      continue;
    }
    let l = ar(e2, a);
    if (l !== void 0 && l !== e2.state.callDepth) dy(e2, a);
    else if ((_i2 = e2.state.fullyUnsetLocals) == null ? void 0 : _i2.has(a)) delete e2.state.env[a];
    else if (l !== void 0) {
      let c = (_j = e2.state.accessedTempEnvVars) == null ? void 0 : _j.has(a), u = (_k2 = e2.state.mutatedTempEnvVars) == null ? void 0 : _k2.has(a);
      if ((c || u) && ((_l2 = e2.state.localVarStack) == null ? void 0 : _l2.has(a))) {
        let f2 = vi(e2, a);
        f2 ? f2.value === void 0 ? delete e2.state.env[a] : e2.state.env[a] = f2.value : delete e2.state.env[a];
      } else delete e2.state.env[a];
    } else zl(e2, a) || delete e2.state.env[a];
    (_m2 = e2.state.exportedVars) == null ? void 0 : _m2.delete(a), e2.state.functions.delete(i2);
  }
  return W("", r2, s2);
}
var Hl = ["extglob", "dotglob", "nullglob", "failglob", "globstar", "globskipdots", "nocaseglob", "nocasematch", "expand_aliases", "lastpipe", "xpg_echo"], gk = ["autocd", "cdable_vars", "cdspell", "checkhash", "checkjobs", "checkwinsize", "cmdhist", "compat31", "compat32", "compat40", "compat41", "compat42", "compat43", "compat44", "complete_fullquote", "direxpand", "dirspell", "execfail", "extdebug", "extquote", "force_fignore", "globasciiranges", "gnu_errfmt", "histappend", "histreedit", "histverify", "hostcomplete", "huponexit", "inherit_errexit", "interactive_comments", "lithist", "localvar_inherit", "localvar_unset", "login_shell", "mailwarn", "no_empty_cmd_completion", "progcomp", "progcomp_alias", "promptvars", "restricted_shell", "shift_verbose", "sourcepath"];
function Di(e2) {
  return Hl.includes(e2);
}
function yk(e2) {
  return gk.includes(e2);
}
function my(e2, t2) {
  let n2 = false, r2 = false, s2 = false, i2 = false, o2 = false, a = [], l = 0;
  for (; l < t2.length; ) {
    let p = t2[l];
    if (p === "--") {
      l++;
      break;
    }
    if (p.startsWith("-") && p.length > 1) {
      for (let d = 1; d < p.length; d++) {
        let m = p[d];
        switch (m) {
          case "s":
            n2 = true;
            break;
          case "u":
            r2 = true;
            break;
          case "p":
            s2 = true;
            break;
          case "q":
            i2 = true;
            break;
          case "o":
            o2 = true;
            break;
          default:
            return { exitCode: 2, stdout: "", stderr: `shopt: -${m}: invalid option
` };
        }
      }
      l++;
    } else break;
  }
  for (; l < t2.length; ) a.push(t2[l]), l++;
  if (o2) return bk(e2, a, n2, r2, s2, i2);
  if (n2 && r2) return { exitCode: 1, stdout: "", stderr: `shopt: cannot set and unset shell options simultaneously
` };
  if (a.length === 0) {
    if (n2 || r2) {
      let d = [];
      for (let m of Hl) {
        let h = e2.state.shoptOptions[m];
        n2 && h ? d.push(s2 ? `shopt -s ${m}` : `${m}		on`) : r2 && !h && d.push(s2 ? `shopt -u ${m}` : `${m}		off`);
      }
      return { exitCode: 0, stdout: d.length > 0 ? `${d.join(`
`)}
` : "", stderr: "" };
    }
    let p = [];
    for (let d of Hl) {
      let m = e2.state.shoptOptions[d];
      p.push(s2 ? `shopt ${m ? "-s" : "-u"} ${d}` : `${d}		${m ? "on" : "off"}`);
    }
    return { exitCode: 0, stdout: `${p.join(`
`)}
`, stderr: "" };
  }
  let c = false, u = "", f2 = [];
  for (let p of a) {
    if (!Di(p) && !yk(p)) {
      u += `shopt: ${p}: invalid shell option name
`, c = true;
      continue;
    }
    if (n2) Di(p) && (e2.state.shoptOptions[p] = true, pa(e2));
    else if (r2) Di(p) && (e2.state.shoptOptions[p] = false, pa(e2));
    else if (Di(p)) {
      let d = e2.state.shoptOptions[p];
      i2 ? d || (c = true) : s2 ? (f2.push(`shopt ${d ? "-s" : "-u"} ${p}`), d || (c = true)) : (f2.push(`${p}		${d ? "on" : "off"}`), d || (c = true));
    } else i2 ? c = true : s2 ? (f2.push(`shopt -u ${p}`), c = true) : (f2.push(`${p}		off`), c = true);
  }
  return { exitCode: c ? 1 : 0, stdout: f2.length > 0 ? `${f2.join(`
`)}
` : "", stderr: u };
}
function bk(e2, t2, n2, r2, s2, i2) {
  let o2 = { errexit: "errexit", pipefail: "pipefail", nounset: "nounset", xtrace: "xtrace", verbose: "verbose", posix: "posix", allexport: "allexport", noclobber: "noclobber", noglob: "noglob", noexec: "noexec", vi: "vi", emacs: "emacs" }, a = ["braceexpand", "errtrace", "functrace", "hashall", "histexpand", "history", "ignoreeof", "interactive-comments", "keyword", "monitor", "nolog", "notify", "onecmd", "physical", "privileged"], l = [...Object.keys(o2), ...a].sort();
  if (t2.length === 0) {
    let p = [];
    for (let d of l) {
      let h = a.includes(d) ? false : e2.state.options[o2[d]];
      n2 && !h || r2 && h || p.push(s2 ? `set ${h ? "-o" : "+o"} ${d}` : `${d}		${h ? "on" : "off"}`);
    }
    return { exitCode: 0, stdout: p.length > 0 ? `${p.join(`
`)}
` : "", stderr: "" };
  }
  let c = false, u = "", f2 = [];
  for (let p of t2) {
    let d = p in o2, m = a.includes(p);
    if (!d && !m) {
      u += `shopt: ${p}: invalid option name
`, c = true;
      continue;
    }
    if (m) {
      n2 || r2 || (i2 ? c = true : s2 ? (f2.push(`set +o ${p}`), c = true) : (f2.push(`${p}		off`), c = true));
      continue;
    }
    let h = o2[p];
    if (n2) h === "vi" ? e2.state.options.emacs = false : h === "emacs" && (e2.state.options.vi = false), e2.state.options[h] = true, Jn(e2);
    else if (r2) e2.state.options[h] = false, Jn(e2);
    else {
      let g = e2.state.options[h];
      i2 ? g || (c = true) : s2 ? (f2.push(`set ${g ? "-o" : "+o"} ${p}`), g || (c = true)) : (f2.push(`${p}		${g ? "on" : "off"}`), g || (c = true));
    }
  }
  return { exitCode: c ? 1 : 0, stdout: f2.length > 0 ? `${f2.join(`
`)}
` : "", stderr: u };
}
async function gy(e2, t2, n2) {
  if (t2.includes("/")) {
    let o2 = e2.fs.resolvePath(e2.state.cwd, t2);
    if (!await e2.fs.exists(o2)) return { error: "not_found", path: o2 };
    let a = o2.split("/").pop() || t2, l = e2.commands.get(a);
    try {
      let c = await e2.fs.stat(o2);
      return c.isDirectory ? { error: "permission_denied", path: o2 } : l ? { cmd: l, path: o2 } : (c.mode & 73) !== 0 ? { script: true, path: o2 } : { error: "permission_denied", path: o2 };
    } catch {
      return { error: "not_found", path: o2 };
    }
  }
  if (!n2 && e2.state.hashTable) {
    let o2 = e2.state.hashTable.get(t2);
    if (o2) if (await e2.fs.exists(o2)) {
      let a = e2.commands.get(t2);
      if (a) return { cmd: a, path: o2 };
      try {
        let l = await e2.fs.stat(o2);
        if (!l.isDirectory && (l.mode & 73) !== 0) return { script: true, path: o2 };
      } catch {
      }
    } else e2.state.hashTable.delete(t2);
  }
  let s2 = (n2 ?? e2.state.env.PATH ?? "/usr/bin:/bin").split(":");
  for (let o2 of s2) {
    if (!o2) continue;
    let l = `${o2.startsWith("/") ? o2 : e2.fs.resolvePath(e2.state.cwd, o2)}/${t2}`;
    if (await e2.fs.exists(l)) try {
      let c = await e2.fs.stat(l);
      if (c.isDirectory) continue;
      let u = (c.mode & 73) !== 0, f2 = e2.commands.get(t2), p = o2 === "/bin" || o2 === "/usr/bin";
      if (f2 && p) return { cmd: f2, path: l };
      if (u) {
        if (f2 && !p) return { script: true, path: l };
        if (!f2) return { script: true, path: l };
      }
    } catch {
    }
  }
  if (!await e2.fs.exists("/usr/bin")) {
    let o2 = e2.commands.get(t2);
    if (o2) return { cmd: o2, path: `/usr/bin/${t2}` };
  }
  return null;
}
async function Fi(e2, t2) {
  let n2 = [];
  if (t2.includes("/")) {
    let i2 = e2.fs.resolvePath(e2.state.cwd, t2);
    if (await e2.fs.exists(i2)) try {
      let o2 = await e2.fs.stat(i2);
      o2.isDirectory || (o2.mode & 73) !== 0 && n2.push(t2);
    } catch {
    }
    return n2;
  }
  let s2 = (e2.state.env.PATH || "/usr/bin:/bin").split(":");
  for (let i2 of s2) {
    if (!i2) continue;
    let a = `${i2.startsWith("/") ? i2 : e2.fs.resolvePath(e2.state.cwd, i2)}/${t2}`;
    if (await e2.fs.exists(a)) {
      try {
        if ((await e2.fs.stat(a)).isDirectory) continue;
      } catch {
        continue;
      }
      n2.push(i2.startsWith("/") ? a : `${i2}/${t2}`);
    }
  }
  return n2;
}
wt();
async function xy(e2, t2, n2, r2) {
  let s2 = false, i2 = false, o2 = false, a = false, l = false, c = [];
  for (let h of t2) if (h.startsWith("-") && h.length > 1) for (let g of h.slice(1)) g === "t" ? s2 = true : g === "p" ? i2 = true : g === "P" ? o2 = true : g === "a" ? a = true : g === "f" && (l = true);
  else c.push(h);
  let u = "", f2 = "", p = 0, d = false, m = false;
  for (let h of c) {
    let g = false;
    if (o2) {
      if (a) {
        let A = await r2(h);
        if (A.length > 0) {
          for (let I of A) u += `${I}
`;
          d = true, g = true;
        }
      } else {
        let A = await n2(h);
        A && (u += `${A}
`, d = true, g = true);
      }
      g || (m = true);
      continue;
    }
    let b = !l && e2.state.functions.has(h);
    if (a && b) {
      if (!i2) if (s2) u += `function
`;
      else {
        let A = e2.state.functions.get(h), I = A ? yy(h, A) : `${h} is a function
`;
        u += I;
      }
      g = true;
    }
    let y = e2.state.env[`BASH_ALIAS_${h}`];
    if (y !== void 0 && (a || !g) && (i2 || (s2 ? u += `alias
` : u += `${h} is aliased to \`${y}'
`), g = true, !a) || ll.has(h) && (a || !g) && (i2 || (s2 ? u += `keyword
` : u += `${h} is a shell keyword
`), g = true, !a)) continue;
    if (!a && b && !g) {
      if (!i2) if (s2) u += `function
`;
      else {
        let A = e2.state.functions.get(h), I = A ? yy(h, A) : `${h} is a function
`;
        u += I;
      }
      g = true;
      continue;
    }
    if (!(jr.has(h) && (a || !g) && (i2 || (s2 ? u += `builtin
` : u += `${h} is a shell builtin
`), g = true, !a))) {
      if (a) {
        let A = await r2(h);
        for (let I of A) i2 ? u += `${I}
` : s2 ? u += `file
` : u += `${h} is ${I}
`, d = true, g = true;
      } else if (!g) {
        let A = await n2(h);
        A && (i2 ? u += `${A}
` : s2 ? u += `file
` : u += `${h} is ${A}
`, d = true, g = true);
      }
      if (!g && (m = true, !s2 && !i2)) {
        let A = true;
        if (h.includes("/")) {
          let I = e2.fs.resolvePath(e2.state.cwd, h);
          await e2.fs.exists(I) && (A = false);
        }
        A && (f2 += `bash: type: ${h}: not found
`);
      }
    }
  }
  return i2 ? p = m && !d ? 1 : 0 : p = m ? 1 : 0, W(u, f2, p);
}
function yy(e2, t2) {
  let n2;
  return t2.body.type === "Group" ? n2 = t2.body.body.map((s2) => qr(s2)).join("; ") : n2 = qr(t2.body), `${e2} is a function
${e2} () 
{ 
    ${n2}
}
`;
}
function qr(e2) {
  if (Array.isArray(e2)) return e2.map((t2) => qr(t2)).join("; ");
  if (e2.type === "Statement") {
    let t2 = [];
    for (let n2 = 0; n2 < e2.pipelines.length; n2++) {
      let r2 = e2.pipelines[n2];
      t2.push(wk(r2)), e2.operators[n2] && t2.push(e2.operators[n2]);
    }
    return t2.join(" ");
  }
  if (e2.type === "SimpleCommand") {
    let t2 = e2, n2 = [];
    t2.name && n2.push(by(t2.name));
    for (let r2 of t2.args) n2.push(by(r2));
    return n2.join(" ");
  }
  return e2.type === "Group" ? `{ ${e2.body.map((r2) => qr(r2)).join("; ")}; }` : "...";
}
function wk(e2) {
  let t2 = e2.commands.map((n2) => qr(n2));
  return (e2.negated ? "! " : "") + t2.join(" | ");
}
function by(e2) {
  let t2 = "";
  for (let n2 of e2.parts) n2.type === "Literal" ? t2 += n2.value : n2.type === "DoubleQuoted" ? t2 += `"${n2.parts.map((r2) => wy(r2)).join("")}"` : n2.type === "SingleQuoted" ? t2 += `'${n2.value}'` : t2 += wy(n2);
  return t2;
}
function wy(e2) {
  let t2 = e2;
  return t2.type === "Literal" ? t2.value ?? "" : t2.type === "Variable" ? `$${t2.name}` : "";
}
async function Ey(e2, t2, n2, r2) {
  let s2 = "", i2 = "", o2 = 0;
  for (let a of t2) {
    if (!a) {
      o2 = 1;
      continue;
    }
    let l = e2.state.env[`BASH_ALIAS_${a}`];
    if (l !== void 0) r2 ? s2 += `${a} is an alias for "${l}"
` : s2 += `alias ${a}='${l}'
`;
    else if (ll.has(a)) r2 ? s2 += `${a} is a shell keyword
` : s2 += `${a}
`;
    else if (jr.has(a)) r2 ? s2 += `${a} is a shell builtin
` : s2 += `${a}
`;
    else if (e2.state.functions.has(a)) r2 ? s2 += `${a} is a function
` : s2 += `${a}
`;
    else if (a.includes("/")) {
      let c = e2.fs.resolvePath(e2.state.cwd, a), u = false;
      if (await e2.fs.exists(c)) try {
        let f2 = await e2.fs.stat(c);
        f2.isDirectory || (f2.mode & 73) !== 0 && (r2 ? s2 += `${a} is ${a}
` : s2 += `${a}
`, u = true);
      } catch {
      }
      u || (r2 && (i2 += `${a}: not found
`), o2 = 1);
    } else if (e2.commands.has(a)) {
      let u = (e2.state.env.PATH ?? "/usr/bin:/bin").split(":"), f2 = null;
      for (let p of u) {
        if (!p) continue;
        let d = `${p}/${a}`;
        try {
          let m = await e2.fs.stat(d);
          if (!m.isDirectory && (m.mode & 73) !== 0) {
            f2 = d;
            break;
          }
        } catch {
        }
      }
      f2 || (f2 = `/usr/bin/${a}`), r2 ? s2 += `${a} is ${f2}
` : s2 += `${f2}
`;
    } else r2 && (i2 += `${a}: not found
`), o2 = 1;
  }
  return W(s2, i2, o2);
}
async function Sy(e2, t2) {
  if (t2.includes("/")) {
    let s2 = e2.fs.resolvePath(e2.state.cwd, t2);
    if (await e2.fs.exists(s2)) {
      try {
        let i2 = await e2.fs.stat(s2);
        if (i2.isDirectory || !((i2.mode & 73) !== 0)) return null;
      } catch {
        return null;
      }
      return t2;
    }
    return null;
  }
  let r2 = (e2.state.env.PATH ?? "/usr/bin:/bin").split(":");
  for (let s2 of r2) {
    if (!s2) continue;
    let o2 = `${s2.startsWith("/") ? s2 : e2.fs.resolvePath(e2.state.cwd, s2)}/${t2}`;
    if (await e2.fs.exists(o2)) {
      try {
        if ((await e2.fs.stat(o2)).isDirectory) continue;
      } catch {
        continue;
      }
      return `${s2}/${t2}`;
    }
  }
  if (e2.commands.has(t2)) {
    for (let s2 of r2) if (s2 === "/usr/bin" || s2 === "/bin") return `${s2}/${t2}`;
    return `/usr/bin/${t2}`;
  }
  return null;
}
async function Ay(e2, t2, n2, r2, s2, i2, o2, a) {
  let { ctx: l, runCommand: c } = e2;
  if (t2 === "export") return Rl(l, n2);
  if (t2 === "unset") return jl(l, n2);
  if (t2 === "exit") return Il(l, n2);
  if (t2 === "local") return Dl(l, n2);
  if (t2 === "set") return Wl(l, n2);
  if (t2 === "break") return nl(l, n2);
  if (t2 === "continue") return ml(l, n2);
  if (t2 === "return") return Ll(l, n2);
  if (t2 === "eval" && l.state.options.posix) return Pi(l, n2, s2);
  if (t2 === "shift") return Bl(l, n2);
  if (t2 === "getopts") return Ti(l, n2);
  if (t2 === "compgen") return fl(l, n2);
  if (t2 === "complete") return dl(l, n2);
  if (t2 === "compopt") return hl(l, n2);
  if (t2 === "pushd") return await kl(l, n2);
  if (t2 === "popd") return vl(l, n2);
  if (t2 === "dirs") return $l(l, n2);
  if (t2 === "source" || t2 === ".") return Ul(l, n2);
  if (t2 === "read") return _l(l, n2, s2, a);
  if (t2 === "mapfile" || t2 === "readarray") return Fl(l, n2, s2);
  if (t2 === "declare" || t2 === "typeset") return Al(l, n2);
  if (t2 === "readonly") return Cl(l, n2);
  if (!i2) {
    let u = l.state.functions.get(t2);
    if (u) return Ii(l, u, n2, s2);
  }
  if (t2 === "eval") return Pi(l, n2, s2);
  if (t2 === "cd") return await rl(l, n2);
  if (t2 === ":" || t2 === "true") return le;
  if (t2 === "false") return Le(false);
  if (t2 === "let") return Ol(l, n2);
  if (t2 === "command") return xk(e2, n2, s2);
  if (t2 === "builtin") return Ek(e2, n2, s2);
  if (t2 === "shopt") return my(l, n2);
  if (t2 === "exec") {
    if (n2.length === 0) return le;
    let [u, ...f2] = n2;
    return c(u, f2, [], s2, false, false, -1);
  }
  if (t2 === "wait") return le;
  if (t2 === "type") return await xy(l, n2, (u) => Sy(l, u), (u) => Fi(l, u));
  if (t2 === "hash") return Pl(l, n2);
  if (t2 === "help") return Tl(l, n2);
  if (t2 === "[" || t2 === "test") {
    let u = n2;
    if (t2 === "[") {
      if (n2[n2.length - 1] !== "]") return M("[: missing `]'\n", 2);
      u = n2.slice(0, -1);
    }
    return zr(l, u);
  }
  return null;
}
async function xk(e2, t2, n2) {
  let { ctx: r2, runCommand: s2 } = e2;
  if (t2.length === 0) return le;
  let i2 = false, o2 = false, a = false, l = t2;
  for (; l.length > 0 && l[0].startsWith("-"); ) {
    let f2 = l[0];
    if (f2 === "--") {
      l = l.slice(1);
      break;
    }
    for (let p of f2.slice(1)) p === "p" ? i2 = true : p === "V" ? o2 = true : p === "v" && (a = true);
    l = l.slice(1);
  }
  if (l.length === 0) return le;
  if (a || o2) return await Ey(r2, l, a, o2);
  let [c, ...u] = l;
  return s2(c, u, [], n2, true, i2, -1);
}
async function Ek(e2, t2, n2) {
  let { runCommand: r2 } = e2;
  if (t2.length === 0) return le;
  let s2 = t2;
  if (s2[0] === "--" && (s2 = s2.slice(1), s2.length === 0)) return le;
  let i2 = s2[0];
  if (!jr.has(i2)) return M(`bash: builtin: ${i2}: not a shell builtin
`);
  let [, ...o2] = s2;
  return r2(i2, o2, [], n2, true, false, -1);
}
async function Cy(e2, t2, n2, r2, s2) {
  let { ctx: i2, buildExportedEnv: o2, executeUserScript: a } = e2, c = await gy(i2, t2, s2 ? "/usr/bin:/bin" : void 0);
  if (!c) return T0(t2) ? M(`bash: ${t2}: command not available in browser environments. Exclude '${t2}' from your commands or use the Node.js bundle.
`, 127) : M(`bash: ${t2}: command not found
`, 127);
  if ("error" in c) return c.error === "permission_denied" ? M(`bash: ${t2}: Permission denied
`, 126) : M(`bash: ${t2}: No such file or directory
`, 127);
  if ("script" in c) return t2.includes("/") || (i2.state.hashTable || (i2.state.hashTable = /* @__PURE__ */ new Map()), i2.state.hashTable.set(t2, c.path)), await a(c.path, n2, r2);
  let { cmd: u, path: f2 } = c;
  t2.includes("/") || (i2.state.hashTable || (i2.state.hashTable = /* @__PURE__ */ new Map()), i2.state.hashTable.set(t2, f2));
  let p = r2 || i2.state.groupStdin || "", d = o2(), m = { fs: i2.fs, cwd: i2.state.cwd, env: i2.state.env, exportedEnv: d, stdin: p, limits: i2.limits, exec: i2.execFn, fetch: i2.fetch, getRegisteredCommands: () => Array.from(i2.commands.keys()), sleep: i2.sleep, trace: i2.trace, fileDescriptors: i2.state.fileDescriptors, xpgEcho: i2.state.shoptOptions.xpg_echo };
  try {
    return await u.execute(n2, m);
  } catch (h) {
    return M(`${t2}: ${Ne(h)}
`);
  }
}
it();
de();
ot();
async function Vl(e2, t2) {
  let n2 = e2.state.inCondition;
  e2.state.inCondition = true;
  let r2 = "", s2 = "", i2 = 0;
  try {
    for (let o2 of t2) {
      let a = await e2.executeStatement(o2);
      r2 += a.stdout, s2 += a.stderr, i2 = a.exitCode;
    }
  } finally {
    e2.state.inCondition = n2;
  }
  return { stdout: r2, stderr: s2, exitCode: i2 };
}
de();
wt();
function Gr(e2, t2, n2, r2) {
  if (e2 instanceof Qe) return t2 += e2.stdout, n2 += e2.stderr, e2.levels > 1 && r2 > 1 ? (e2.levels--, e2.stdout = t2, e2.stderr = n2, { action: "rethrow", stdout: t2, stderr: n2, error: e2 }) : { action: "break", stdout: t2, stderr: n2 };
  if (e2 instanceof Ke) return t2 += e2.stdout, n2 += e2.stderr, e2.levels > 1 && r2 > 1 ? (e2.levels--, e2.stdout = t2, e2.stderr = n2, { action: "rethrow", stdout: t2, stderr: n2, error: e2 }) : { action: "continue", stdout: t2, stderr: n2 };
  if (e2 instanceof Ve || e2 instanceof lt || e2 instanceof ae || e2 instanceof ne) return e2.prependOutput(t2, n2), { action: "rethrow", stdout: t2, stderr: n2, error: e2 };
  let s2 = Ne(e2);
  return { action: "error", stdout: t2, stderr: `${n2}${s2}
`, exitCode: 1 };
}
de();
wt();
async function _i(e2, t2, n2 = "", r2 = "") {
  let s2 = n2, i2 = r2, o2 = 0;
  try {
    for (let a of t2) {
      let l = await e2.executeStatement(a);
      s2 += l.stdout, i2 += l.stderr, o2 = l.exitCode;
    }
  } catch (a) {
    if (ls(a) || a instanceof lt || a instanceof ae || a instanceof ne || a instanceof Lt) throw a.prependOutput(s2, i2), a;
    return { stdout: s2, stderr: `${i2}${Ne(a)}
`, exitCode: 1 };
  }
  return { stdout: s2, stderr: i2, exitCode: o2 };
}
async function Ny(e2, t2) {
  let n2 = "", r2 = "";
  for (let s2 of t2.clauses) {
    let i2 = await Vl(e2, s2.condition);
    if (n2 += i2.stdout, r2 += i2.stderr, i2.exitCode === 0) return _i(e2, s2.body, n2, r2);
  }
  return t2.elseBody ? _i(e2, t2.elseBody, n2, r2) : W(n2, r2, 0);
}
async function ky(e2, t2) {
  let n2 = await qt(e2, t2.redirections);
  if (n2) return n2;
  let r2 = "", s2 = "", i2 = 0, o2 = 0;
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t2.variable)) return M(`bash: \`${t2.variable}': not a valid identifier
`);
  let a = [];
  if (t2.words === null) a = (e2.state.env["@"] || "").split(" ").filter(Boolean);
  else if (t2.words.length === 0) a = [];
  else try {
    for (let c of t2.words) {
      let u = await Ft(e2, c);
      a.push(...u.values);
    }
  } catch (c) {
    if (c instanceof _t) return { stdout: "", stderr: c.stderr, exitCode: 1 };
    throw c;
  }
  e2.state.loopDepth++;
  try {
    for (let c of a) {
      o2++, o2 > e2.limits.maxLoopIterations && Xt(`for loop: too many iterations (${e2.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", r2, s2), e2.state.env[t2.variable] = c;
      try {
        for (let u of t2.body) {
          let f2 = await e2.executeStatement(u);
          r2 += f2.stdout, s2 += f2.stderr, i2 = f2.exitCode;
        }
      } catch (u) {
        let f2 = Gr(u, r2, s2, e2.state.loopDepth);
        if (r2 = f2.stdout, s2 = f2.stderr, f2.action === "break") break;
        if (f2.action === "continue") continue;
        if (f2.action === "error") {
          let p = W(r2, s2, f2.exitCode ?? 1);
          return $e(e2, p, t2.redirections);
        }
        throw f2.error;
      }
    }
  } finally {
    e2.state.loopDepth--;
  }
  let l = W(r2, s2, i2);
  return $e(e2, l, t2.redirections);
}
async function vy(e2, t2) {
  let n2 = await qt(e2, t2.redirections);
  if (n2) return n2;
  let r2 = t2.line;
  r2 !== void 0 && (e2.state.currentLine = r2);
  let s2 = "", i2 = "", o2 = 0, a = 0;
  t2.init && await Q(e2, t2.init.expression), e2.state.loopDepth++;
  try {
    for (; a++, a > e2.limits.maxLoopIterations && Xt(`for loop: too many iterations (${e2.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", s2, i2), !(t2.condition && (r2 !== void 0 && (e2.state.currentLine = r2), await Q(e2, t2.condition.expression) === 0)); ) {
      try {
        for (let c of t2.body) {
          let u = await e2.executeStatement(c);
          s2 += u.stdout, i2 += u.stderr, o2 = u.exitCode;
        }
      } catch (c) {
        let u = Gr(c, s2, i2, e2.state.loopDepth);
        if (s2 = u.stdout, i2 = u.stderr, u.action === "break") break;
        if (u.action === "continue") {
          t2.update && await Q(e2, t2.update.expression);
          continue;
        }
        if (u.action === "error") {
          let f2 = W(s2, i2, u.exitCode ?? 1);
          return $e(e2, f2, t2.redirections);
        }
        throw u.error;
      }
      t2.update && await Q(e2, t2.update.expression);
    }
  } finally {
    e2.state.loopDepth--;
  }
  let l = W(s2, i2, o2);
  return $e(e2, l, t2.redirections);
}
async function $y(e2, t2, n2 = "") {
  let r2 = "", s2 = "", i2 = 0, o2 = 0, a = n2;
  for (let c of t2.redirections) if ((c.operator === "<<" || c.operator === "<<-") && c.target.type === "HereDoc") {
    let u = c.target, f2 = await J(e2, u.content);
    u.stripTabs && (f2 = f2.split(`
`).map((p) => p.replace(/^\t+/, "")).join(`
`)), a = f2;
  } else if (c.operator === "<<<" && c.target.type === "Word") a = `${await J(e2, c.target)}
`;
  else if (c.operator === "<" && c.target.type === "Word") try {
    let u = await J(e2, c.target), f2 = e2.fs.resolvePath(e2.state.cwd, u);
    a = await e2.fs.readFile(f2);
  } catch {
    let u = await J(e2, c.target);
    return M(`bash: ${u}: No such file or directory
`);
  }
  let l = e2.state.groupStdin;
  a && (e2.state.groupStdin = a), e2.state.loopDepth++;
  try {
    for (; ; ) {
      o2++, o2 > e2.limits.maxLoopIterations && Xt(`while loop: too many iterations (${e2.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", r2, s2);
      let c = 0, u = false, f2 = false, p = e2.state.inCondition;
      e2.state.inCondition = true;
      try {
        for (let d of t2.condition) {
          let m = await e2.executeStatement(d);
          r2 += m.stdout, s2 += m.stderr, c = m.exitCode;
        }
      } catch (d) {
        if (d instanceof Qe) {
          if (r2 += d.stdout, s2 += d.stderr, d.levels > 1 && e2.state.loopDepth > 1) throw d.levels--, d.stdout = r2, d.stderr = s2, e2.state.inCondition = p, d;
          u = true;
        } else if (d instanceof Ke) {
          if (r2 += d.stdout, s2 += d.stderr, d.levels > 1 && e2.state.loopDepth > 1) throw d.levels--, d.stdout = r2, d.stderr = s2, e2.state.inCondition = p, d;
          f2 = true;
        } else throw e2.state.inCondition = p, d;
      } finally {
        e2.state.inCondition = p;
      }
      if (u) break;
      if (!f2) {
        if (c !== 0) break;
        try {
          for (let d of t2.body) {
            let m = await e2.executeStatement(d);
            r2 += m.stdout, s2 += m.stderr, i2 = m.exitCode;
          }
        } catch (d) {
          let m = Gr(d, r2, s2, e2.state.loopDepth);
          if (r2 = m.stdout, s2 = m.stderr, m.action === "break") break;
          if (m.action === "continue") continue;
          if (m.action === "error") return W(r2, s2, m.exitCode ?? 1);
          throw m.error;
        }
      }
    }
  } finally {
    e2.state.loopDepth--, e2.state.groupStdin = l;
  }
  return W(r2, s2, i2);
}
async function Iy(e2, t2) {
  let n2 = "", r2 = "", s2 = 0, i2 = 0;
  e2.state.loopDepth++;
  try {
    for (; ; ) {
      i2++, i2 > e2.limits.maxLoopIterations && Xt(`until loop: too many iterations (${e2.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", n2, r2);
      let o2 = await Vl(e2, t2.condition);
      if (n2 += o2.stdout, r2 += o2.stderr, o2.exitCode === 0) break;
      try {
        for (let a of t2.body) {
          let l = await e2.executeStatement(a);
          n2 += l.stdout, r2 += l.stderr, s2 = l.exitCode;
        }
      } catch (a) {
        let l = Gr(a, n2, r2, e2.state.loopDepth);
        if (n2 = l.stdout, r2 = l.stderr, l.action === "break") break;
        if (l.action === "continue") continue;
        if (l.action === "error") return W(n2, r2, l.exitCode ?? 1);
        throw l.error;
      }
    }
  } finally {
    e2.state.loopDepth--;
  }
  return W(n2, r2, s2);
}
async function Ry(e2, t2) {
  let n2 = await qt(e2, t2.redirections);
  if (n2) return n2;
  let r2 = "", s2 = "", i2 = 0, o2 = await J(e2, t2.word), a = false;
  for (let c = 0; c < t2.items.length; c++) {
    let u = t2.items[c], f2 = a;
    if (!a) for (let p of u.patterns) {
      let d = await J(e2, p);
      Qa(p) && (d = mt(d));
      let m = e2.state.shoptOptions.nocasematch, h = e2.state.shoptOptions.extglob;
      if (or(o2, d, m, h)) {
        f2 = true;
        break;
      }
    }
    if (f2) {
      let p = await _i(e2, u.body, r2, s2);
      if (r2 = p.stdout, s2 = p.stderr, i2 = p.exitCode, u.terminator === ";;") break;
      u.terminator === ";&" ? a = true : a = false;
    } else a = false;
  }
  let l = W(r2, s2, i2);
  return $e(e2, l, t2.redirections);
}
de();
ot();
function ql(e2, t2) {
  if (e2.parts.length !== 1) return false;
  let n2 = e2.parts[0];
  return n2.type !== "Literal" ? false : t2.includes(n2.value);
}
function Py(e2) {
  if (!e2.startsWith("__rw__:")) return null;
  let t2 = e2.slice(7), n2 = t2.indexOf(":");
  if (n2 === -1) return null;
  let r2 = Number.parseInt(t2.slice(0, n2), 10);
  if (Number.isNaN(r2) || r2 < 0) return null;
  let s2 = n2 + 1, i2 = t2.slice(s2, s2 + r2), o2 = s2 + r2 + 1, a = t2.slice(o2), l = a.indexOf(":");
  if (l === -1) return null;
  let c = Number.parseInt(a.slice(0, l), 10);
  if (Number.isNaN(c) || c < 0) return null;
  let u = a.slice(l + 1);
  return { path: i2, position: c, content: u };
}
Fe();
ot();
var Ty = "+ ";
async function Oy(e2) {
  let t2 = e2.state.env.PS4;
  if (t2 === void 0) return Ty;
  if (t2 === "") return "";
  try {
    let r2 = new se().parseWordFromString(t2, false, false);
    return await J(e2, r2);
  } catch {
    return e2.state.expansionStderr = `${e2.state.expansionStderr || ""}bash: ${t2}: bad substitution
`, t2 || Ty;
  }
}
function Sk(e2) {
  return e2.map((t2) => Ak(t2)).join(" ");
}
function Ak(e2) {
  if (e2 === "") return "''";
  if (!/[\s'"\\$`!*?[\]{}|&;<>()~#\n\t]/.test(e2)) return e2;
  let n2 = /[\x00-\x1f\x7f]/.test(e2), r2 = e2.includes(`
`), s2 = e2.includes("	"), i2 = e2.includes("\\"), o2 = e2.includes("'");
  if (n2 || r2 || s2 || i2) {
    let l = "";
    for (let c of e2) {
      let u = c.charCodeAt(0);
      c === `
` ? l += "\\n" : c === "	" ? l += "\\t" : c === "\\" ? l += "\\\\" : c === "'" ? l += "'" : c === '"' ? l += '"' : u < 32 || u === 127 ? u < 256 ? l += `\\x${u.toString(16).padStart(2, "0")}` : l += `\\u${u.toString(16).padStart(4, "0")}` : l += c;
    }
    return `$'${l}'`;
  }
  return o2 ? `"${e2.replace(/([\\$`"])/g, "\\$1")}"` : `'${e2}'`;
}
async function Dy(e2, t2, n2) {
  if (!e2.state.options.xtrace) return "";
  let r2 = await Oy(e2), s2 = [t2, ...n2], i2 = Sk(s2);
  return `${r2}${i2}
`;
}
async function Fy(e2, t2, n2) {
  return e2.state.options.xtrace ? `${await Oy(e2)}${t2}=${n2}
` : "";
}
de();
async function _y(e2, t2, n2) {
  var _a3;
  let r2 = t2.timed ? performance.now() : 0, s2 = "", i2 = le, o2 = 0, a = [], l = t2.commands.length > 1, c = e2.state.lastArg;
  for (let f2 = 0; f2 < t2.commands.length; f2++) {
    let p = t2.commands[f2], d = f2 === t2.commands.length - 1;
    l && (e2.state.lastArg = "");
    let h = l && (!d || !e2.state.shoptOptions.lastpipe) ? { ...e2.state.env } : null, g;
    try {
      g = await n2(p, s2);
    } catch (b) {
      if (b instanceof nt) g = { stdout: b.stdout, stderr: b.stderr, exitCode: 1 };
      else if (b instanceof ae && t2.commands.length > 1) g = { stdout: b.stdout, stderr: b.stderr, exitCode: b.exitCode };
      else if (b instanceof lt && t2.commands.length > 1) g = { stdout: b.stdout, stderr: b.stderr, exitCode: b.exitCode };
      else throw h && (e2.state.env = h), b;
    }
    h && (e2.state.env = h), a.push(g.exitCode), g.exitCode !== 0 && (o2 = g.exitCode), d ? i2 = g : ((_a3 = t2.pipeStderr) == null ? void 0 : _a3[f2]) ?? false ? (s2 = g.stderr + g.stdout, i2 = { stdout: "", stderr: "", exitCode: g.exitCode }) : (s2 = g.stdout, i2 = { stdout: "", stderr: g.stderr, exitCode: g.exitCode });
  }
  if (t2.commands.length > 1 || t2.commands.length === 1 && t2.commands[0].type === "SimpleCommand") {
    for (let f2 of Object.keys(e2.state.env)) f2.startsWith("PIPESTATUS_") && delete e2.state.env[f2];
    for (let f2 = 0; f2 < a.length; f2++) e2.state.env[`PIPESTATUS_${f2}`] = String(a[f2]);
    e2.state.env.PIPESTATUS__length = String(a.length);
  }
  if (e2.state.options.pipefail && o2 !== 0 && (i2 = { ...i2, exitCode: o2 }), t2.negated && (i2 = { ...i2, exitCode: i2.exitCode === 0 ? 1 : 0 }), t2.timed) {
    let p = (performance.now() - r2) / 1e3, d = Math.floor(p / 60), m = p % 60, h;
    t2.timePosix ? h = `real ${p.toFixed(2)}
user 0.00
sys 0.00
` : h = `
real	${`${d}m${m.toFixed(3)}s`}
user	0m0.000s
sys	0m0.000s
`, i2 = { ...i2, stderr: i2.stderr + h };
  }
  return l && !e2.state.shoptOptions.lastpipe && (e2.state.lastArg = c), i2;
}
Je();
Fe();
it();
de();
ot();
$t();
Tt();
on$1();
async function Ly(e2, t2) {
  let n2 = {}, r2 = "";
  for (let s2 of t2.assignments) {
    let i2 = s2.name;
    if (s2.array) {
      let u = await Ck(e2, t2, i2, s2.array, s2.append, n2);
      if (u.error) return { continueToNext: false, xtraceOutput: r2, tempAssignments: n2, error: u.error };
      if (r2 += u.xtraceOutput, u.continueToNext) continue;
    }
    let o2 = s2.value ? await J(e2, s2.value) : "";
    if (i2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[\]$/)) return { continueToNext: false, xtraceOutput: r2, tempAssignments: n2, error: W("", `bash: ${i2}: bad array subscript
`, 1) };
    let l = i2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    if (l) {
      let u = await Ik(e2, t2, l[1], l[2], o2, s2.append, n2);
      if (u.error) return { continueToNext: false, xtraceOutput: r2, tempAssignments: n2, error: u.error };
      if (u.continueToNext) continue;
    }
    let c = await Pk(e2, t2, i2, o2, s2.append, n2);
    if (c.error) return { continueToNext: false, xtraceOutput: r2, tempAssignments: n2, error: c.error };
    r2 += c.xtraceOutput, c.continueToNext;
  }
  return { continueToNext: false, xtraceOutput: r2, tempAssignments: n2 };
}
async function Ck(e2, t2, n2, r2, s2, i2) {
  var _a3;
  let o2 = "";
  if (/\[.+\]$/.test(n2)) return { continueToNext: false, xtraceOutput: "", error: W("", `bash: ${n2}: cannot assign list to array member
`, 1) };
  if (Se(e2, n2)) {
    let u = kn(e2, n2);
    if (u === void 0 || u === "") throw new ae(1, "", "");
    let f2 = st(e2, n2);
    if (f2 && /^[a-zA-Z_][a-zA-Z0-9_]*\[@\]$/.test(f2)) return { continueToNext: false, xtraceOutput: "", error: W("", `bash: ${n2}: cannot assign list to array member
`, 1) };
  }
  if (Ht(e2, n2)) {
    if (t2.name) return o2 += `bash: ${n2}: readonly variable
`, { continueToNext: true, xtraceOutput: o2 };
    je(e2, n2);
  }
  let a = (_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(n2), l = Nk(r2), c = () => {
    let u = `${n2}_`;
    for (let f2 of Object.keys(e2.state.env)) f2.startsWith(u) && !f2.includes("__") && delete e2.state.env[f2];
    delete e2.state.env[n2];
  };
  if (a && l ? await kk(e2, t2, n2, r2, s2, c, (u) => {
    o2 += u;
  }) : l ? await vk(e2, n2, r2, s2, c) : await $k(e2, n2, r2, s2, c), t2.name) {
    i2[n2] = e2.state.env[n2];
    let f2 = `(${r2.map((p) => Yn(p)).join(" ")})`;
    e2.state.env[n2] = f2;
  }
  return { continueToNext: true, xtraceOutput: o2 };
}
function Nk(e2) {
  return e2.some((t2) => {
    if (t2.parts.length >= 2) {
      let n2 = t2.parts[0], r2 = t2.parts[1];
      if (n2.type !== "Glob" || !n2.pattern.startsWith("[")) return false;
      if (n2.pattern === "[" && (r2.type === "DoubleQuoted" || r2.type === "SingleQuoted")) {
        if (t2.parts.length < 3) return false;
        let s2 = t2.parts[2];
        return s2.type !== "Literal" ? false : s2.value.startsWith("]=") || s2.value.startsWith("]+=");
      }
      return r2.type !== "Literal" ? false : r2.value.startsWith("]") ? r2.value.startsWith("]=") || r2.value.startsWith("]+=") : n2.pattern.endsWith("]") ? r2.value.startsWith("=") || r2.value.startsWith("+=") : false;
    }
    return false;
  });
}
async function kk(e2, t2, n2, r2, s2, i2, o2) {
  let a = [];
  for (let l of r2) {
    let c = Ma(l);
    if (c) {
      let { key: u, valueParts: f2, append: p } = c, d;
      f2.length > 0 ? d = await J(e2, { parts: f2 }) : d = "", d = Te(e2, d), a.push({ type: "keyed", key: u, value: d, append: p });
    } else {
      let u = await J(e2, l);
      a.push({ type: "invalid", expandedValue: u });
    }
  }
  s2 || i2();
  for (let l of a) if (l.type === "keyed") if (l.append) {
    let c = e2.state.env[`${n2}_${l.key}`] ?? "";
    e2.state.env[`${n2}_${l.key}`] = c + l.value;
  } else e2.state.env[`${n2}_${l.key}`] = l.value;
  else {
    let c = t2.line ?? e2.state.currentLine ?? 1;
    o2(`bash: line ${c}: ${n2}: ${l.expandedValue}: must use subscript when assigning associative array
`);
  }
}
async function vk(e2, t2, n2, r2, s2) {
  let i2 = [];
  for (let a of n2) {
    let l = Ma(a);
    if (l) {
      let { key: c, valueParts: u, append: f2 } = l, p;
      u.length > 0 ? p = await J(e2, { parts: u }) : p = "", p = Te(e2, p), i2.push({ type: "keyed", indexExpr: c, value: p, append: f2 });
    } else {
      let c = await Ft(e2, a);
      i2.push({ type: "non-keyed", values: c.values });
    }
  }
  r2 || s2();
  let o2 = 0;
  for (let a of i2) if (a.type === "keyed") {
    let l;
    try {
      let c = new se(), u = he(c, a.indexExpr);
      l = await Q(e2, u.expression, false);
    } catch {
      if (/^-?\d+$/.test(a.indexExpr)) l = Number.parseInt(a.indexExpr, 10);
      else {
        let c = e2.state.env[a.indexExpr];
        l = c ? Number.parseInt(c, 10) : 0, Number.isNaN(l) && (l = 0);
      }
    }
    if (a.append) {
      let c = e2.state.env[`${t2}_${l}`] ?? "";
      e2.state.env[`${t2}_${l}`] = c + a.value;
    } else e2.state.env[`${t2}_${l}`] = a.value;
    o2 = l + 1;
  } else for (let l of a.values) e2.state.env[`${t2}_${o2++}`] = l;
}
async function $k(e2, t2, n2, r2, s2) {
  let i2 = [];
  for (let a of n2) {
    let l = await Ft(e2, a);
    i2.push(...l.values);
  }
  let o2 = 0;
  if (r2) {
    let a = te(e2, t2);
    if (a.length > 0) o2 = Math.max(...a.map(([c]) => typeof c == "number" ? c : 0)) + 1;
    else if (e2.state.env[t2] !== void 0) {
      let l = e2.state.env[t2];
      e2.state.env[`${t2}_0`] = l, delete e2.state.env[t2], o2 = 1;
    }
  } else s2();
  for (let a = 0; a < i2.length; a++) e2.state.env[`${t2}_${o2 + a}`] = i2[a];
  r2 || (e2.state.env[`${t2}__length`] = String(i2.length));
}
async function Ik(e2, t2, n2, r2, s2, i2, o2) {
  var _a3;
  let a = n2;
  if (Se(e2, n2)) {
    let f2 = st(e2, n2);
    if (f2 && f2 !== n2) {
      if (f2.includes("[")) return { continueToNext: false, xtraceOutput: "", error: W("", `bash: \`${f2}': not a valid identifier
`, 1) };
      a = f2;
    }
  }
  if (Ht(e2, a)) {
    if (t2.name) return { continueToNext: true, xtraceOutput: "" };
    je(e2, a);
  }
  let l = (_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(a), c;
  if (l) c = await My(e2, a, r2);
  else {
    let f2 = await Rk(e2, a, r2);
    if (f2.error) return { continueToNext: false, xtraceOutput: "", error: f2.error };
    c = `${a}_${f2.index}`;
  }
  let u = i2 ? (e2.state.env[c] || "") + s2 : s2;
  if (t2.name) o2[c] = e2.state.env[c], e2.state.env[c] = u;
  else {
    let f2 = ar(e2, a);
    if (f2 !== void 0 && f2 === e2.state.callDepth && e2.state.localScopes.length > 0) {
      let p = e2.state.localScopes[e2.state.localScopes.length - 1];
      p.has(c) || p.set(c, e2.state.env[c]);
    }
    e2.state.env[c] = u;
  }
  return { continueToNext: true, xtraceOutput: "" };
}
async function My(e2, t2, n2) {
  let r2;
  if (n2.startsWith("'") && n2.endsWith("'")) r2 = n2.slice(1, -1);
  else if (n2.startsWith('"') && n2.endsWith('"')) {
    let s2 = n2.slice(1, -1), o2 = new se().parseWordFromString(s2, true, false);
    r2 = await J(e2, o2);
  } else if (n2.includes("$")) {
    let i2 = new se().parseWordFromString(n2, false, false);
    r2 = await J(e2, i2);
  } else r2 = n2;
  return `${t2}_${r2}`;
}
async function Rk(e2, t2, n2) {
  let r2 = n2;
  n2.startsWith('"') && n2.endsWith('"') && n2.length >= 2 && (r2 = n2.slice(1, -1));
  let s2;
  if (/^-?\d+$/.test(r2)) s2 = Number.parseInt(r2, 10);
  else {
    try {
      let i2 = new se(), o2 = he(i2, r2);
      s2 = await Q(e2, o2.expression, false);
    } catch (i2) {
      if (i2 instanceof Ee) {
        let l = `bash: line ${e2.state.currentLine}: ${n2}: ${i2.message}
`;
        if (i2.fatal) throw new ae(1, "", l);
        return { index: 0, error: W("", l, 1) };
      }
      let o2 = e2.state.env[n2];
      s2 = o2 ? Number.parseInt(o2, 10) : 0;
    }
    Number.isNaN(s2) && (s2 = 0);
  }
  if (s2 < 0) {
    let i2 = te(e2, t2);
    if (i2.length === 0) {
      let a = e2.state.currentLine;
      return { index: 0, error: W("", `bash: line ${a}: ${t2}[${n2}]: bad array subscript
`, 1) };
    }
    if (s2 = Math.max(...i2.map(([a]) => typeof a == "number" ? a : 0)) + 1 + s2, s2 < 0) {
      let a = e2.state.currentLine;
      return { index: 0, error: W("", `bash: line ${a}: ${t2}[${n2}]: bad array subscript
`, 1) };
    }
  }
  return { index: s2 };
}
async function Pk(e2, t2, n2, r2, s2, i2) {
  var _a3;
  let o2 = "", a = n2, l = null;
  if (Se(e2, n2)) {
    let f2 = cg(e2, n2, r2);
    if (f2 === void 0) return { continueToNext: false, xtraceOutput: "", error: W("", `bash: ${n2}: circular name reference
`, 1) };
    if (f2 === null) return { continueToNext: true, xtraceOutput: "" };
    a = f2;
    let p = a.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    p && (l = { arrayName: p[1], subscriptExpr: p[2] }, a = p[1]);
  }
  if (Ht(e2, a)) {
    if (t2.name) return o2 += `bash: ${a}: readonly variable
`, { continueToNext: true, xtraceOutput: o2 };
    je(e2, a);
  }
  let c;
  if (Hr(e2, a)) try {
    let f2 = new se();
    if (s2) {
      let d = `(${e2.state.env[a] || "0"}) + (${r2})`, m = he(f2, d);
      c = String(await Q(e2, m.expression));
    } else {
      let p = he(f2, r2);
      c = String(await Q(e2, p.expression));
    }
  } catch {
    c = "0";
  }
  else {
    let { isArray: f2 } = await Promise.resolve().then(() => (ot(), Ya)), p = f2(e2, a) ? `${a}_0` : a;
    c = s2 ? (e2.state.env[p] || "") + r2 : r2;
  }
  c = cr(e2, a, c), o2 += await Fy(e2, a, c);
  let u = a;
  if (l) u = await Tk(e2, l);
  else {
    let { isArray: f2 } = await Promise.resolve().then(() => (ot(), Ya));
    f2(e2, a) && (u = `${a}_0`);
  }
  return t2.name ? (i2[u] = e2.state.env[u], e2.state.env[u] = c) : (e2.state.env[u] = c, e2.state.options.allexport && (e2.state.exportedVars = e2.state.exportedVars || /* @__PURE__ */ new Set(), e2.state.exportedVars.add(a)), ((_a3 = e2.state.tempEnvBindings) == null ? void 0 : _a3.some((f2) => f2.has(a))) && (e2.state.mutatedTempEnvVars = e2.state.mutatedTempEnvVars || /* @__PURE__ */ new Set(), e2.state.mutatedTempEnvVars.add(a))), { continueToNext: false, xtraceOutput: o2 };
}
async function Tk(e2, t2) {
  var _a3;
  let { arrayName: n2, subscriptExpr: r2 } = t2;
  if ((_a3 = e2.state.associativeArrays) == null ? void 0 : _a3.has(n2)) return My(e2, n2, r2);
  let i2;
  if (/^-?\d+$/.test(r2)) i2 = Number.parseInt(r2, 10);
  else {
    try {
      let o2 = new se(), a = he(o2, r2);
      i2 = await Q(e2, a.expression, false);
    } catch {
      let o2 = e2.state.env[r2];
      i2 = o2 ? Number.parseInt(o2, 10) : 0;
    }
    Number.isNaN(i2) && (i2 = 0);
  }
  if (i2 < 0) {
    let o2 = te(e2, n2);
    o2.length > 0 && (i2 = Math.max(...o2.map((l) => l[0])) + 1 + i2);
  }
  return `${n2}_${i2}`;
}
Fe();
de();
ot();
wt();
async function Wy(e2, t2, n2, r2) {
  let s2 = await qt(e2, t2.redirections);
  if (s2) return s2;
  let i2 = { ...e2.state.env }, o2 = e2.state.cwd, a = { ...e2.state.options }, l = e2.state.localScopes, c = e2.state.localVarStack, u = e2.state.localVarDepth, f2 = e2.state.fullyUnsetLocals;
  if (e2.state.localScopes = l.map((A) => new Map(A)), c) {
    e2.state.localVarStack = /* @__PURE__ */ new Map();
    for (let [A, I] of c.entries()) e2.state.localVarStack.set(A, I.map((O) => ({ ...O })));
  }
  u && (e2.state.localVarDepth = new Map(u)), f2 && (e2.state.fullyUnsetLocals = new Map(f2));
  let p = e2.state.loopDepth, d = e2.state.parentHasLoopContext;
  e2.state.parentHasLoopContext = p > 0, e2.state.loopDepth = 0;
  let m = e2.state.lastArg, h = e2.state.bashPid;
  e2.state.bashPid = e2.state.nextVirtualPid++;
  let g = e2.state.groupStdin;
  n2 && (e2.state.groupStdin = n2);
  let b = "", y = "", w = 0, E = () => {
    e2.state.env = i2, e2.state.cwd = o2, e2.state.options = a, e2.state.localScopes = l, e2.state.localVarStack = c, e2.state.localVarDepth = u, e2.state.fullyUnsetLocals = f2, e2.state.loopDepth = p, e2.state.parentHasLoopContext = d, e2.state.groupStdin = g, e2.state.bashPid = h, e2.state.lastArg = m;
  };
  try {
    for (let A of t2.body) {
      let I = await r2(A);
      b += I.stdout, y += I.stderr, w = I.exitCode;
    }
  } catch (A) {
    if (E(), A instanceof ne) throw A;
    if (A instanceof Lt) {
      b += A.stdout, y += A.stderr;
      let O = W(b, y, 0);
      return $e(e2, O, t2.redirections);
    }
    if (A instanceof Qe || A instanceof Ke) {
      b += A.stdout, y += A.stderr;
      let O = W(b, y, 0);
      return $e(e2, O, t2.redirections);
    }
    if (A instanceof ae) {
      b += A.stdout, y += A.stderr;
      let O = W(b, y, A.exitCode);
      return $e(e2, O, t2.redirections);
    }
    if (A instanceof Ve) {
      b += A.stdout, y += A.stderr;
      let O = W(b, y, A.exitCode);
      return $e(e2, O, t2.redirections);
    }
    if (A instanceof lt) {
      let O = W(b + A.stdout, y + A.stderr, A.exitCode);
      return $e(e2, O, t2.redirections);
    }
    let I = W(b, `${y}${Ne(A)}
`, 1);
    return $e(e2, I, t2.redirections);
  }
  E();
  let C = W(b, y, w);
  return $e(e2, C, t2.redirections);
}
async function By(e2, t2, n2, r2) {
  let s2 = "", i2 = "", o2 = 0, a = await $i(e2, t2.redirections);
  if (a) return a;
  let l = n2;
  for (let f2 of t2.redirections) if ((f2.operator === "<<" || f2.operator === "<<-") && f2.target.type === "HereDoc") {
    let p = f2.target, d = await J(e2, p.content);
    p.stripTabs && (d = d.split(`
`).map((h) => h.replace(/^\t+/, "")).join(`
`));
    let m = f2.fd ?? 0;
    m !== 0 ? (e2.state.fileDescriptors || (e2.state.fileDescriptors = /* @__PURE__ */ new Map()), e2.state.fileDescriptors.set(m, d)) : l = d;
  } else if (f2.operator === "<<<" && f2.target.type === "Word") l = `${await J(e2, f2.target)}
`;
  else if (f2.operator === "<" && f2.target.type === "Word") try {
    let p = await J(e2, f2.target), d = e2.fs.resolvePath(e2.state.cwd, p);
    l = await e2.fs.readFile(d);
  } catch {
    let p = await J(e2, f2.target);
    return W("", `bash: ${p}: No such file or directory
`, 1);
  }
  let c = e2.state.groupStdin;
  l && (e2.state.groupStdin = l);
  try {
    for (let f2 of t2.body) {
      let p = await r2(f2);
      s2 += p.stdout, i2 += p.stderr, o2 = p.exitCode;
    }
  } catch (f2) {
    if (e2.state.groupStdin = c, f2 instanceof ne) throw f2;
    if (ls(f2) || f2 instanceof lt || f2 instanceof ae) throw f2.prependOutput(s2, i2), f2;
    return W(s2, `${i2}${Ne(f2)}
`, 1);
  }
  e2.state.groupStdin = c;
  let u = W(s2, i2, o2);
  return $e(e2, u, t2.redirections);
}
async function Uy(e2, t2, n2, r2, s2) {
  let i2;
  try {
    i2 = await e2.fs.readFile(t2);
  } catch {
    return M(`bash: ${t2}: No such file or directory
`, 127);
  }
  if (i2.startsWith("#!")) {
    let g = i2.indexOf(`
`);
    g !== -1 && (i2 = i2.slice(g + 1));
  }
  let o2 = { ...e2.state.env }, a = e2.state.cwd, l = { ...e2.state.options }, c = e2.state.loopDepth, u = e2.state.parentHasLoopContext, f2 = e2.state.lastArg, p = e2.state.bashPid, d = e2.state.groupStdin, m = e2.state.currentSource;
  e2.state.parentHasLoopContext = c > 0, e2.state.loopDepth = 0, e2.state.bashPid = e2.state.nextVirtualPid++, r2 && (e2.state.groupStdin = r2), e2.state.currentSource = t2, e2.state.env[0] = t2, e2.state.env["#"] = String(n2.length), e2.state.env["@"] = n2.join(" "), e2.state.env["*"] = n2.join(" ");
  for (let g = 0; g < n2.length && g < 9; g++) e2.state.env[String(g + 1)] = n2[g];
  for (let g = n2.length + 1; g <= 9; g++) delete e2.state.env[String(g)];
  let h = () => {
    e2.state.env = o2, e2.state.cwd = a, e2.state.options = l, e2.state.loopDepth = c, e2.state.parentHasLoopContext = u, e2.state.lastArg = f2, e2.state.bashPid = p, e2.state.groupStdin = d, e2.state.currentSource = m;
  };
  try {
    let b = new se().parse(i2), y = await s2(b);
    return h(), y;
  } catch (g) {
    if (h(), g instanceof ae || g instanceof ne) throw g;
    if (g.name === "ParseException") return M(`bash: ${t2}: ${g.message}
`);
    throw g;
  }
}
var Zr = class {
  constructor(t2, n2) {
    __publicField(this, "ctx");
    __publicField(this, "aliasExpansionStack", /* @__PURE__ */ new Set());
    this.ctx = { state: n2, fs: t2.fs, commands: t2.commands, limits: t2.limits, execFn: t2.exec, executeScript: this.executeScript.bind(this), executeStatement: this.executeStatement.bind(this), executeCommand: this.executeCommand.bind(this), fetch: t2.fetch, sleep: t2.sleep, trace: t2.trace };
  }
  buildExportedEnv() {
    let t2 = this.ctx.state.exportedVars, n2 = this.ctx.state.tempExportedVars, r2 = /* @__PURE__ */ new Set();
    if (t2) for (let i2 of t2) r2.add(i2);
    if (n2) for (let i2 of n2) r2.add(i2);
    if (r2.size === 0) return {};
    let s2 = {};
    for (let i2 of r2) {
      let o2 = this.ctx.state.env[i2];
      o2 !== void 0 && (s2[i2] = o2);
    }
    return s2;
  }
  async executeScript(t2) {
    let n2 = "", r2 = "", s2 = 0;
    for (let i2 of t2.statements) try {
      let o2 = await this.executeStatement(i2);
      n2 += o2.stdout, r2 += o2.stderr, s2 = o2.exitCode, this.ctx.state.lastExitCode = s2, this.ctx.state.env["?"] = String(s2);
    } catch (o2) {
      if (o2 instanceof ae) throw o2.prependOutput(n2, r2), o2;
      if (o2 instanceof xt) return n2 += o2.stdout, r2 += o2.stderr, s2 = o2.exitCode, this.ctx.state.lastExitCode = s2, this.ctx.state.env["?"] = String(s2), { stdout: n2, stderr: r2, exitCode: s2, env: { ...this.ctx.state.env } };
      if (o2 instanceof ne) throw o2;
      if (o2 instanceof lt) return n2 += o2.stdout, r2 += o2.stderr, s2 = o2.exitCode, this.ctx.state.lastExitCode = s2, this.ctx.state.env["?"] = String(s2), { stdout: n2, stderr: r2, exitCode: s2, env: { ...this.ctx.state.env } };
      if (o2 instanceof tt) return n2 += o2.stdout, r2 += o2.stderr, s2 = 1, this.ctx.state.lastExitCode = s2, this.ctx.state.env["?"] = String(s2), { stdout: n2, stderr: r2, exitCode: s2, env: { ...this.ctx.state.env } };
      if (o2 instanceof nt) return n2 += o2.stdout, r2 += o2.stderr, s2 = 1, this.ctx.state.lastExitCode = s2, this.ctx.state.env["?"] = String(s2), { stdout: n2, stderr: r2, exitCode: s2, env: { ...this.ctx.state.env } };
      if (o2 instanceof Ee) {
        n2 += o2.stdout, r2 += o2.stderr, s2 = 1, this.ctx.state.lastExitCode = s2, this.ctx.state.env["?"] = String(s2);
        continue;
      }
      if (o2 instanceof Fn) {
        n2 += o2.stdout, r2 += o2.stderr, s2 = 1, this.ctx.state.lastExitCode = s2, this.ctx.state.env["?"] = String(s2);
        continue;
      }
      if (o2 instanceof Qe || o2 instanceof Ke) {
        if (this.ctx.state.loopDepth > 0) throw o2.prependOutput(n2, r2), o2;
        n2 += o2.stdout, r2 += o2.stderr;
        continue;
      }
      throw o2 instanceof Ve && o2.prependOutput(n2, r2), o2;
    }
    return { stdout: n2, stderr: r2, exitCode: s2, env: { ...this.ctx.state.env } };
  }
  async executeUserScript(t2, n2, r2 = "") {
    return Uy(this.ctx, t2, n2, r2, (s2) => this.executeScript(s2));
  }
  async executeStatement(t2) {
    if (this.ctx.state.commandCount++, this.ctx.state.commandCount > this.ctx.limits.maxCommandCount && Xt(`too many commands executed (>${this.ctx.limits.maxCommandCount}), increase executionLimits.maxCommandCount`, "commands"), t2.deferredError) throw new Ge(t2.deferredError.message, t2.line ?? 1, 1);
    if (this.ctx.state.options.noexec) return le;
    this.ctx.state.errexitSafe = false;
    let n2 = "", r2 = "";
    this.ctx.state.options.verbose && !this.ctx.state.suppressVerbose && t2.sourceText && (r2 += `${t2.sourceText}
`);
    let s2 = 0, i2 = -1, o2 = false;
    for (let c = 0; c < t2.pipelines.length; c++) {
      let u = t2.pipelines[c], f2 = c > 0 ? t2.operators[c - 1] : null;
      if (f2 === "&&" && s2 !== 0 || f2 === "||" && s2 === 0) continue;
      let p = await this.executePipeline(u);
      n2 += p.stdout, r2 += p.stderr, s2 = p.exitCode, i2 = c, o2 = u.negated, this.ctx.state.lastExitCode = s2, this.ctx.state.env["?"] = String(s2);
    }
    let a = i2 < t2.pipelines.length - 1, l = this.ctx.state.errexitSafe;
    if (this.ctx.state.errexitSafe = a || o2 || l, this.ctx.state.options.errexit && s2 !== 0 && i2 === t2.pipelines.length - 1 && !o2 && !this.ctx.state.inCondition && !l) throw new lt(s2, n2, r2);
    return W(n2, r2, s2);
  }
  async executePipeline(t2) {
    return _y(this.ctx, t2, (n2, r2) => this.executeCommand(n2, r2));
  }
  async executeCommand(t2, n2) {
    switch (t2.type) {
      case "SimpleCommand":
        return this.executeSimpleCommand(t2, n2);
      case "If":
        return Ny(this.ctx, t2);
      case "For":
        return ky(this.ctx, t2);
      case "CStyleFor":
        return vy(this.ctx, t2);
      case "While":
        return $y(this.ctx, t2, n2);
      case "Until":
        return Iy(this.ctx, t2);
      case "Case":
        return Ry(this.ctx, t2);
      case "Subshell":
        return this.executeSubshell(t2, n2);
      case "Group":
        return this.executeGroup(t2, n2);
      case "FunctionDef":
        return G0(this.ctx, t2);
      case "ArithmeticCommand":
        return this.executeArithmeticCommand(t2);
      case "ConditionalCommand":
        return this.executeConditionalCommand(t2);
      default:
        return le;
    }
  }
  async executeSimpleCommand(t2, n2) {
    try {
      return await this.executeSimpleCommandInner(t2, n2);
    } catch (r2) {
      if (r2 instanceof _t) return M(r2.stderr);
      throw r2;
    }
  }
  async executeSimpleCommandInner(t2, n2) {
    var _a3;
    if (t2.line !== void 0 && (this.ctx.state.currentLine = t2.line), this.ctx.state.shoptOptions.expand_aliases && t2.name) {
      let E = t2, C = 100;
      for (; C > 0; ) {
        let A = this.expandAlias(E);
        if (A === E) break;
        E = A, C--;
      }
      this.aliasExpansionStack.clear(), E !== t2 && (t2 = E);
    }
    this.ctx.state.expansionStderr = "";
    let r2 = await Ly(this.ctx, t2);
    if (r2.error) return r2.error;
    let s2 = r2.tempAssignments, i2 = r2.xtraceOutput;
    if (!t2.name) {
      if (t2.redirections.length > 0) {
        let C = await qt(this.ctx, t2.redirections);
        if (C) return C;
        let A = W("", i2, 0);
        return $e(this.ctx, A, t2.redirections);
      }
      this.ctx.state.lastArg = "";
      let E = (this.ctx.state.expansionStderr || "") + i2;
      return this.ctx.state.expansionStderr = "", W("", E, this.ctx.state.lastExitCode);
    }
    let o2 = t2.name && ql(t2.name, ["local", "declare", "typeset", "export", "readonly"]), a = Object.keys(s2);
    if (a.length > 0 && !o2) {
      this.ctx.state.tempExportedVars = this.ctx.state.tempExportedVars || /* @__PURE__ */ new Set();
      for (let E of a) this.ctx.state.tempExportedVars.add(E);
    }
    let l = await $i(this.ctx, t2.redirections);
    if (l) {
      for (let [E, C] of Object.entries(s2)) C === void 0 ? delete this.ctx.state.env[E] : this.ctx.state.env[E] = C;
      return l;
    }
    let c = -1;
    for (let E of t2.redirections) {
      if ((E.operator === "<<" || E.operator === "<<-") && E.target.type === "HereDoc") {
        let C = E.target, A = await J(this.ctx, C.content);
        C.stripTabs && (A = A.split(`
`).map((O) => O.replace(/^\t+/, "")).join(`
`));
        let I = E.fd ?? 0;
        I !== 0 ? (this.ctx.state.fileDescriptors || (this.ctx.state.fileDescriptors = /* @__PURE__ */ new Map()), this.ctx.state.fileDescriptors.set(I, A)) : n2 = A;
        continue;
      }
      if (E.operator === "<<<" && E.target.type === "Word") {
        n2 = `${await J(this.ctx, E.target)}
`;
        continue;
      }
      if (E.operator === "<" && E.target.type === "Word") try {
        let C = await J(this.ctx, E.target), A = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
        n2 = await this.ctx.fs.readFile(A);
      } catch {
        let C = await J(this.ctx, E.target);
        for (let [A, I] of Object.entries(s2)) I === void 0 ? delete this.ctx.state.env[A] : this.ctx.state.env[A] = I;
        return M(`bash: ${C}: No such file or directory
`);
      }
      if (E.operator === "<&" && E.target.type === "Word") {
        let C = await J(this.ctx, E.target), A = Number.parseInt(C, 10);
        if (!Number.isNaN(A) && this.ctx.state.fileDescriptors) {
          let I = this.ctx.state.fileDescriptors.get(A);
          if (I !== void 0) if (I.startsWith("__rw__:")) {
            let O = Py(I);
            O && (n2 = O.content.slice(O.position), c = A);
          } else I.startsWith("__file__:") || I.startsWith("__file_append__:") || (n2 = I);
        }
      }
    }
    let u = await J(this.ctx, t2.name), f2 = [], p = [];
    if (ql(t2.name, ["local", "declare", "typeset", "export", "readonly"]) && (u === "local" || u === "declare" || u === "typeset" || u === "export" || u === "readonly")) for (let E of t2.args) {
      let C = await R0(this.ctx, E);
      if (C) f2.push(C), p.push(true);
      else {
        let A = await P0(this.ctx, E);
        if (A !== null) f2.push(A), p.push(true);
        else {
          let I = await Ft(this.ctx, E);
          for (let O of I.values) f2.push(O), p.push(I.quoted);
        }
      }
    }
    else for (let E of t2.args) {
      let C = await Ft(this.ctx, E);
      for (let A of C.values) f2.push(A), p.push(C.quoted);
    }
    if (!u) {
      if (t2.name.parts.every((C) => C.type === "CommandSubstitution" || C.type === "ParameterExpansion" || C.type === "ArithmeticExpansion")) {
        if (f2.length > 0) {
          let C = f2.shift();
          return p.shift(), await this.runCommand(C, f2, p, n2, false, false, c);
        }
        return W("", "", this.ctx.state.lastExitCode);
      }
      return M(`bash: : command not found
`, 127);
    }
    if (u === "exec" && (f2.length === 0 || f2[0] === "--")) {
      for (let E of t2.redirections) {
        if (E.target.type === "HereDoc" || E.fdVariable) continue;
        let C = await J(this.ctx, E.target), A = E.fd ?? (E.operator === "<" || E.operator === "<>" ? 0 : 1);
        switch (this.ctx.state.fileDescriptors || (this.ctx.state.fileDescriptors = /* @__PURE__ */ new Map()), E.operator) {
          case ">":
          case ">|": {
            let I = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
            await this.ctx.fs.writeFile(I, "", "utf8"), this.ctx.state.fileDescriptors.set(A, `__file__:${I}`);
            break;
          }
          case ">>": {
            let I = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
            this.ctx.state.fileDescriptors.set(A, `__file_append__:${I}`);
            break;
          }
          case "<": {
            let I = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
            try {
              let O = await this.ctx.fs.readFile(I);
              this.ctx.state.fileDescriptors.set(A, O);
            } catch {
              return M(`bash: ${C}: No such file or directory
`);
            }
            break;
          }
          case "<>": {
            let I = this.ctx.fs.resolvePath(this.ctx.state.cwd, C);
            try {
              let O = await this.ctx.fs.readFile(I);
              this.ctx.state.fileDescriptors.set(A, `__rw__:${I.length}:${I}:0:${O}`);
            } catch {
              await this.ctx.fs.writeFile(I, "", "utf8"), this.ctx.state.fileDescriptors.set(A, `__rw__:${I.length}:${I}:0:`);
            }
            break;
          }
          case ">&": {
            if (C === "-") this.ctx.state.fileDescriptors.delete(A);
            else if (C.endsWith("-")) {
              let I = C.slice(0, -1), O = Number.parseInt(I, 10);
              if (!Number.isNaN(O)) {
                let L = this.ctx.state.fileDescriptors.get(O);
                L !== void 0 ? this.ctx.state.fileDescriptors.set(A, L) : this.ctx.state.fileDescriptors.set(A, `__dupout__:${O}`), this.ctx.state.fileDescriptors.delete(O);
              }
            } else {
              let I = Number.parseInt(C, 10);
              Number.isNaN(I) || this.ctx.state.fileDescriptors.set(A, `__dupout__:${I}`);
            }
            break;
          }
          case "<&": {
            if (C === "-") this.ctx.state.fileDescriptors.delete(A);
            else if (C.endsWith("-")) {
              let I = C.slice(0, -1), O = Number.parseInt(I, 10);
              if (!Number.isNaN(O)) {
                let L = this.ctx.state.fileDescriptors.get(O);
                L !== void 0 ? this.ctx.state.fileDescriptors.set(A, L) : this.ctx.state.fileDescriptors.set(A, `__dupin__:${O}`), this.ctx.state.fileDescriptors.delete(O);
              }
            } else {
              let I = Number.parseInt(C, 10);
              Number.isNaN(I) || this.ctx.state.fileDescriptors.set(A, `__dupin__:${I}`);
            }
            break;
          }
        }
      }
      for (let [E, C] of Object.entries(s2)) C === void 0 ? delete this.ctx.state.env[E] : this.ctx.state.env[E] = C;
      if (this.ctx.state.tempExportedVars) for (let E of Object.keys(s2)) this.ctx.state.tempExportedVars.delete(E);
      return le;
    }
    let m = await Dy(this.ctx, u, f2);
    Object.keys(s2).length > 0 && (this.ctx.state.tempEnvBindings = this.ctx.state.tempEnvBindings || [], this.ctx.state.tempEnvBindings.push(new Map(Object.entries(s2))));
    let h, g = null;
    try {
      h = await this.runCommand(u, f2, p, n2, false, false, c);
    } catch (E) {
      if (E instanceof Qe || E instanceof Ke) g = E, h = le;
      else throw E;
    }
    let b = i2 + m;
    if (b && (h = { ...h, stderr: b + h.stderr }), h = await $e(this.ctx, h, t2.redirections), g) throw g;
    if (f2.length > 0) {
      let E = f2[f2.length - 1];
      if ((u === "declare" || u === "local" || u === "typeset") && /^[a-zA-Z_][a-zA-Z0-9_]*=\(/.test(E)) {
        let C = E.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\(/);
        C && (E = C[1]);
      }
      this.ctx.state.lastArg = E;
    } else this.ctx.state.lastArg = u;
    let y = V0(u) && u !== "unset" && u !== "eval";
    if (!this.ctx.state.options.posix || !y) for (let [E, C] of Object.entries(s2)) ((_a3 = this.ctx.state.fullyUnsetLocals) == null ? void 0 : _a3.has(E)) || (C === void 0 ? delete this.ctx.state.env[E] : this.ctx.state.env[E] = C);
    if (this.ctx.state.tempExportedVars) for (let E of Object.keys(s2)) this.ctx.state.tempExportedVars.delete(E);
    return Object.keys(s2).length > 0 && this.ctx.state.tempEnvBindings && this.ctx.state.tempEnvBindings.pop(), this.ctx.state.expansionStderr && (h = { ...h, stderr: this.ctx.state.expansionStderr + h.stderr }, this.ctx.state.expansionStderr = ""), h;
  }
  async runCommand(t2, n2, r2, s2, i2 = false, o2 = false, a = -1) {
    let l = { ctx: this.ctx, runCommand: (u, f2, p, d, m, h, g) => this.runCommand(u, f2, p, d, m, h, g), buildExportedEnv: () => this.buildExportedEnv(), executeUserScript: (u, f2, p) => this.executeUserScript(u, f2, p) }, c = await Ay(l, t2, n2, r2, s2, i2, o2, a);
    return c !== null ? c : Cy(l, t2, n2, s2, o2);
  }
  expandAlias(t2) {
    return Oa(this.ctx.state, t2, this.aliasExpansionStack);
  }
  async findCommandInPath(t2) {
    return Fi(this.ctx, t2);
  }
  async executeSubshell(t2, n2 = "") {
    return Wy(this.ctx, t2, n2, (r2) => this.executeStatement(r2));
  }
  async executeGroup(t2, n2 = "") {
    return By(this.ctx, t2, n2, (r2) => this.executeStatement(r2));
  }
  async executeArithmeticCommand(t2) {
    t2.line !== void 0 && (this.ctx.state.currentLine = t2.line);
    let n2 = await qt(this.ctx, t2.redirections);
    if (n2) return n2;
    try {
      let r2 = await Q(this.ctx, t2.expression.expression), s2 = Le(r2 !== 0);
      return this.ctx.state.expansionStderr && (s2 = { ...s2, stderr: this.ctx.state.expansionStderr + s2.stderr }, this.ctx.state.expansionStderr = ""), $e(this.ctx, s2, t2.redirections);
    } catch (r2) {
      let s2 = M(`bash: arithmetic expression: ${r2.message}
`);
      return $e(this.ctx, s2, t2.redirections);
    }
  }
  async executeConditionalCommand(t2) {
    t2.line !== void 0 && (this.ctx.state.currentLine = t2.line);
    let n2 = await qt(this.ctx, t2.redirections);
    if (n2) return n2;
    try {
      let r2 = await ln(this.ctx, t2.expression), s2 = Le(r2);
      return this.ctx.state.expansionStderr && (s2 = { ...s2, stderr: this.ctx.state.expansionStderr + s2.stderr }, this.ctx.state.expansionStderr = ""), $e(this.ctx, s2, t2.redirections);
    } catch (r2) {
      let s2 = r2 instanceof Ee ? 1 : 2, i2 = M(`bash: conditional expression: ${r2.message}
`, s2);
      return $e(this.ctx, i2, t2.redirections);
    }
  }
};
var Jt = { maxCallDepth: 100, maxCommandCount: 1e4, maxLoopIterations: 1e4, maxAwkIterations: 1e4, maxSedIterations: 1e4, maxJqIterations: 1e4, maxSqliteTimeoutMs: 5e3, maxPythonTimeoutMs: 3e4 };
function zy(e2) {
  return e2 ? { maxCallDepth: e2.maxCallDepth ?? Jt.maxCallDepth, maxCommandCount: e2.maxCommandCount ?? Jt.maxCommandCount, maxLoopIterations: e2.maxLoopIterations ?? Jt.maxLoopIterations, maxAwkIterations: e2.maxAwkIterations ?? Jt.maxAwkIterations, maxSedIterations: e2.maxSedIterations ?? Jt.maxSedIterations, maxJqIterations: e2.maxJqIterations ?? Jt.maxJqIterations, maxSqliteTimeoutMs: e2.maxSqliteTimeoutMs ?? Jt.maxSqliteTimeoutMs, maxPythonTimeoutMs: e2.maxPythonTimeoutMs ?? Jt.maxPythonTimeoutMs } : { ...Jt };
}
function jy(e2) {
  try {
    let t2 = new URL(e2);
    return { origin: t2.origin, pathname: t2.pathname, href: t2.href };
  } catch {
    return null;
  }
}
function Ok(e2) {
  let t2 = jy(e2);
  return t2 ? { origin: t2.origin, pathPrefix: t2.pathname } : null;
}
function Dk(e2, t2) {
  let n2 = jy(e2);
  if (!n2) return false;
  let r2 = Ok(t2);
  return !r2 || n2.origin !== r2.origin ? false : r2.pathPrefix === "/" || r2.pathPrefix === "" ? true : n2.pathname.startsWith(r2.pathPrefix);
}
function Gl(e2, t2) {
  return !t2 || t2.length === 0 ? false : t2.some((n2) => Dk(e2, n2));
}
var ur = class extends Error {
  constructor(t2) {
    super(`Network access denied: URL not in allow-list: ${t2}`), this.name = "NetworkAccessDeniedError";
  }
}, fr = class extends Error {
  constructor(t2) {
    super(`Too many redirects (max: ${t2})`), this.name = "TooManyRedirectsError";
  }
}, pr = class extends Error {
  constructor(t2) {
    super(`Redirect target not in allow-list: ${t2}`), this.name = "RedirectNotAllowedError";
  }
}, Li = class extends Error {
  constructor(t2, n2) {
    super(`HTTP method '${t2}' not allowed. Allowed methods: ${n2.join(", ")}`), this.name = "MethodNotAllowedError";
  }
};
var Fk = 20, _k = 3e4, Lk = ["GET", "HEAD"], Mk = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]), Wk = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
function Zl(e2) {
  let t2 = e2.maxRedirects ?? Fk, n2 = e2.timeoutMs ?? _k, r2 = e2.dangerouslyAllowFullInternetAccess ? ["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"] : e2.allowedMethods ?? Lk;
  function s2(a) {
    if (!e2.dangerouslyAllowFullInternetAccess && !Gl(a, e2.allowedUrlPrefixes ?? [])) throw new ur(a);
  }
  function i2(a) {
    if (e2.dangerouslyAllowFullInternetAccess) return;
    let l = a.toUpperCase();
    if (!r2.includes(l)) throw new Li(l, r2);
  }
  async function o2(a, l = {}) {
    var _a3;
    let c = ((_a3 = l.method) == null ? void 0 : _a3.toUpperCase()) ?? "GET";
    s2(a), i2(c);
    let u = a, f2 = 0, p = l.followRedirects ?? true, d = l.timeoutMs !== void 0 ? Math.min(l.timeoutMs, n2) : n2;
    for (; ; ) {
      let m = new AbortController(), h = setTimeout(() => m.abort(), d);
      try {
        let g = { method: c, headers: l.headers, signal: m.signal, redirect: "manual" };
        l.body && !Mk.has(c) && (g.body = l.body);
        let b = await fetch(u, g);
        if (Wk.has(b.status) && p) {
          let y = b.headers.get("location");
          if (!y) return await Hy(b, u);
          let w = new URL(y, u).href;
          if (!e2.dangerouslyAllowFullInternetAccess && !Gl(w, e2.allowedUrlPrefixes ?? [])) throw new pr(w);
          if (f2++, f2 > t2) throw new fr(t2);
          u = w;
          continue;
        }
        return await Hy(b, u);
      } finally {
        clearTimeout(h);
      }
    }
  }
  return o2;
}
async function Hy(e2, t2) {
  let n2 = {};
  return e2.headers.forEach((r2, s2) => {
    n2[s2.toLowerCase()] = r2;
  }), { status: e2.status, statusText: e2.statusText, headers: n2, body: await e2.text(), url: t2 };
}
tn();
Fe();
var Ql = class {
  constructor(t2 = {}) {
    __publicField(this, "fs");
    __publicField(this, "commands", /* @__PURE__ */ new Map());
    __publicField(this, "useDefaultLayout", false);
    __publicField(this, "limits");
    __publicField(this, "secureFetch");
    __publicField(this, "sleepFn");
    __publicField(this, "traceFn");
    __publicField(this, "logger");
    __publicField(this, "state");
    let n2 = t2.fs ?? new En(t2.files);
    this.fs = n2, this.useDefaultLayout = !t2.cwd && !t2.files;
    let r2 = t2.cwd || (this.useDefaultLayout ? "/home/user" : "/"), s2 = { HOME: this.useDefaultLayout ? "/home/user" : "/", PATH: "/usr/bin:/bin", IFS: ` 	
`, OSTYPE: "linux-gnu", MACHTYPE: "x86_64-pc-linux-gnu", HOSTTYPE: "x86_64", HOSTNAME: "localhost", PWD: r2, OLDPWD: r2, OPTIND: "1", ...t2.env };
    if (this.limits = zy({ ...t2.executionLimits, ...t2.maxCallDepth !== void 0 && { maxCallDepth: t2.maxCallDepth }, ...t2.maxCommandCount !== void 0 && { maxCommandCount: t2.maxCommandCount }, ...t2.maxLoopIterations !== void 0 && { maxLoopIterations: t2.maxLoopIterations } }), t2.network && (this.secureFetch = Zl(t2.network)), this.sleepFn = t2.sleep, this.traceFn = t2.trace, this.logger = t2.logger, this.state = { env: s2, cwd: r2, previousDir: "/home/user", functions: /* @__PURE__ */ new Map(), localScopes: [], callDepth: 0, sourceDepth: 0, commandCount: 0, lastExitCode: 0, lastArg: "", startTime: Date.now(), lastBackgroundPid: 0, bashPid: process.pid, nextVirtualPid: process.pid + 1, currentLine: 1, options: { errexit: false, pipefail: false, nounset: false, xtrace: false, verbose: false, posix: false, allexport: false, noclobber: false, noglob: false, noexec: false, vi: false, emacs: false }, shoptOptions: { extglob: false, dotglob: false, nullglob: false, failglob: false, globstar: false, globskipdots: true, nocaseglob: false, nocasematch: false, expand_aliases: false, lastpipe: false, xpg_echo: false }, inCondition: false, loopDepth: 0, exportedVars: /* @__PURE__ */ new Set(["HOME", "PATH", "PWD", "OLDPWD", ...Object.keys(t2.env || {})]), readonlyVars: /* @__PURE__ */ new Set(["SHELLOPTS", "BASHOPTS"]), hashTable: /* @__PURE__ */ new Map() }, this.state.env.SHELLOPTS = ua(this.state.options), this.state.env.BASHOPTS = fa(this.state.shoptOptions), om(n2, this.useDefaultLayout), r2 !== "/" && n2 instanceof En) try {
      n2.mkdirSync(r2, { recursive: true });
    } catch {
    }
    for (let i2 of Jh(t2.commands)) this.registerCommand(i2);
    if (t2.network) for (let i2 of Yh()) this.registerCommand(i2);
    if (t2.customCommands) for (let i2 of t2.customCommands) em(i2) ? this.registerCommand(tm(i2)) : this.registerCommand(i2);
  }
  registerCommand(t2) {
    this.commands.set(t2.name, t2);
    let n2 = this.fs;
    if (typeof n2.writeFileSync == "function") {
      let r2 = `#!/bin/bash
# Built-in command: ${t2.name}
`;
      try {
        n2.writeFileSync(`/bin/${t2.name}`, r2);
      } catch {
      }
      try {
        n2.writeFileSync(`/usr/bin/${t2.name}`, r2);
      } catch {
      }
    }
  }
  logResult(t2) {
    return this.logger && (t2.stdout && this.logger.debug("stdout", { output: t2.stdout }), t2.stderr && this.logger.info("stderr", { output: t2.stderr }), this.logger.info("exit", { exitCode: t2.exitCode })), t2;
  }
  async exec(t2, n2) {
    var _a3;
    if (this.state.callDepth === 0 && (this.state.commandCount = 0), this.state.commandCount++, this.state.commandCount > this.limits.maxCommandCount) return { stdout: "", stderr: `bash: maximum command count (${this.limits.maxCommandCount}) exceeded (possible infinite loop). Increase with executionLimits.maxCommandCount option.
`, exitCode: 1, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env } };
    if (!t2.trim()) return { stdout: "", stderr: "", exitCode: 0, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env } };
    (_a3 = this.logger) == null ? void 0 : _a3.info("exec", { command: t2 });
    let r2 = (n2 == null ? void 0 : n2.cwd) ?? this.state.cwd, s2, i2 = r2;
    if (n2 == null ? void 0 : n2.cwd) if (n2.env && "PWD" in n2.env) s2 = n2.env.PWD;
    else if ((n2 == null ? void 0 : n2.env) && !("PWD" in n2.env)) try {
      s2 = await this.fs.realpath(r2), i2 = s2;
    } catch {
      s2 = r2;
    }
    else s2 = r2;
    let o2 = { ...this.state, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env, ...s2 !== void 0 ? { PWD: s2 } : {} }, cwd: i2, functions: new Map(this.state.functions), localScopes: [...this.state.localScopes], options: { ...this.state.options }, hashTable: this.state.hashTable }, a = t2;
    (n2 == null ? void 0 : n2.rawScript) || (a = Bk(t2));
    try {
      let l = Bt(a), c = { fs: this.fs, commands: this.commands, limits: this.limits, exec: this.exec.bind(this), fetch: this.secureFetch, sleep: this.sleepFn, trace: this.traceFn }, f2 = await new Zr(c, o2).executeScript(l);
      return this.logResult(f2);
    } catch (l) {
      if (l instanceof ae) return this.logResult({ stdout: l.stdout, stderr: l.stderr, exitCode: l.exitCode, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env } });
      if (l instanceof xt) return this.logResult({ stdout: l.stdout, stderr: l.stderr, exitCode: l.exitCode, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env } });
      if (l instanceof Ee) return this.logResult({ stdout: l.stdout, stderr: l.stderr, exitCode: 1, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env } });
      if (l instanceof ne) return this.logResult({ stdout: l.stdout, stderr: l.stderr, exitCode: ne.EXIT_CODE, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env } });
      if (l.name === "ParseException") return this.logResult({ stdout: "", stderr: `bash: syntax error: ${l.message}
`, exitCode: 2, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env } });
      if (l instanceof Sn) return this.logResult({ stdout: "", stderr: `bash: ${l.message}
`, exitCode: 2, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env } });
      if (l instanceof RangeError) return this.logResult({ stdout: "", stderr: `bash: ${l.message}
`, exitCode: 1, env: { ...this.state.env, ...n2 == null ? void 0 : n2.env } });
      throw l;
    }
  }
  async readFile(t2) {
    return this.fs.readFile(this.fs.resolvePath(this.state.cwd, t2));
  }
  async writeFile(t2, n2) {
    return this.fs.writeFile(this.fs.resolvePath(this.state.cwd, t2), n2);
  }
  getCwd() {
    return this.state.cwd;
  }
  getEnv() {
    return { ...this.state.env };
  }
};
function Bk(e2) {
  let t2 = e2.split(`
`), n2 = [], r2 = [];
  for (let s2 = 0; s2 < t2.length; s2++) {
    let i2 = t2[s2];
    if (r2.length > 0) {
      let l = r2[r2.length - 1];
      if ((l.stripTabs ? i2.replace(/^\t+/, "") : i2) === l.delimiter) {
        n2.push(i2.trimStart()), r2.pop();
        continue;
      }
      n2.push(i2);
      continue;
    }
    let o2 = i2.trimStart();
    n2.push(o2);
    let a = /<<(-?)\s*(['"]?)([\w-]+)\2/g;
    for (let l of o2.matchAll(a)) {
      let c = l[1] === "-", u = l[3];
      r2.push({ delimiter: u, stripTabs: c });
    }
  }
  return n2.join(`
`);
}
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
const _decoder = new TextDecoder();
class VirtualFSAdapter {
  constructor(vfs2) {
    this.vfs = vfs2;
  }
  /**
   * Read the contents of a file as a string
   */
  async readFile(path2, options2) {
    const encoding = typeof options2 === "string" ? options2 : options2 == null ? void 0 : options2.encoding;
    if (!encoding || encoding === "utf8" || encoding === "utf-8") {
      return this.vfs.readFileSync(path2, "utf8");
    }
    if (encoding === "binary" || encoding === "latin1") {
      const buffer = this.vfs.readFileSync(path2);
      return uint8ToBinaryString(buffer);
    }
    return this.vfs.readFileSync(path2, "utf8");
  }
  /**
   * Read the contents of a file as a Uint8Array (binary)
   */
  async readFileBuffer(path2) {
    return this.vfs.readFileSync(path2);
  }
  /**
   * Write content to a file, creating it if it doesn't exist
   */
  async writeFile(path2, content, _options3) {
    this.vfs.writeFileSync(path2, content);
  }
  /**
   * Append content to a file, creating it if it doesn't exist
   */
  async appendFile(path2, content, _options3) {
    let existing = "";
    try {
      existing = this.vfs.readFileSync(path2, "utf8");
    } catch {
    }
    const newContent = typeof content === "string" ? content : _decoder.decode(content);
    this.vfs.writeFileSync(path2, existing + newContent);
  }
  /**
   * Check if a path exists
   */
  async exists(path2) {
    return this.vfs.existsSync(path2);
  }
  /**
   * Get file/directory information
   */
  async stat(path2) {
    const stats = this.vfs.statSync(path2);
    const isFile = stats.isFile();
    const isDirectory = stats.isDirectory();
    let size = 0;
    if (isFile) {
      try {
        const content = this.vfs.readFileSync(path2);
        size = content.length;
      } catch {
      }
    }
    const isExecutable = isFile && path2.includes("/node_modules/.bin/");
    return {
      isFile,
      isDirectory,
      isSymbolicLink: false,
      mode: isDirectory ? 493 : isExecutable ? 493 : 420,
      size,
      mtime: /* @__PURE__ */ new Date()
    };
  }
  /**
   * Create a directory
   */
  async mkdir(path2, options2) {
    this.vfs.mkdirSync(path2, options2);
  }
  /**
   * Read directory contents
   */
  async readdir(path2) {
    return this.vfs.readdirSync(path2);
  }
  /**
   * Read directory contents with file type information
   */
  async readdirWithFileTypes(path2) {
    const entries = this.vfs.readdirSync(path2);
    const result = [];
    for (const name2 of entries) {
      const fullPath = path2 === "/" ? `/${name2}` : `${path2}/${name2}`;
      try {
        const stats = this.vfs.statSync(fullPath);
        result.push({
          name: name2,
          isFile: stats.isFile(),
          isDirectory: stats.isDirectory(),
          isSymbolicLink: false
        });
      } catch {
      }
    }
    return result;
  }
  /**
   * Remove a file or directory
   */
  async rm(path2, options2) {
    const exists = this.vfs.existsSync(path2);
    if (!exists) {
      if (options2 == null ? void 0 : options2.force) {
        return;
      }
      throw createNodeError("ENOENT", "rm", path2);
    }
    const stats = this.vfs.statSync(path2);
    if (stats.isFile()) {
      this.vfs.unlinkSync(path2);
    } else if (stats.isDirectory()) {
      if (options2 == null ? void 0 : options2.recursive) {
        await this.rmRecursive(path2);
      } else {
        this.vfs.rmdirSync(path2);
      }
    }
  }
  /**
   * Recursively remove a directory and its contents
   */
  async rmRecursive(path2) {
    const entries = this.vfs.readdirSync(path2);
    for (const entry of entries) {
      const fullPath = path2 === "/" ? `/${entry}` : `${path2}/${entry}`;
      const stats = this.vfs.statSync(fullPath);
      if (stats.isDirectory()) {
        await this.rmRecursive(fullPath);
      } else {
        this.vfs.unlinkSync(fullPath);
      }
    }
    this.vfs.rmdirSync(path2);
  }
  /**
   * Copy a file or directory
   */
  async cp(src, dest, options2) {
    const stats = this.vfs.statSync(src);
    if (stats.isFile()) {
      const content = this.vfs.readFileSync(src);
      this.vfs.writeFileSync(dest, content);
    } else if (stats.isDirectory()) {
      if (!(options2 == null ? void 0 : options2.recursive)) {
        throw new Error(
          `EISDIR: illegal operation on a directory, cannot copy '${src}'`
        );
      }
      await this.cpRecursive(src, dest);
    }
  }
  /**
   * Recursively copy a directory
   */
  async cpRecursive(src, dest) {
    this.vfs.mkdirSync(dest, { recursive: true });
    const entries = this.vfs.readdirSync(src);
    for (const entry of entries) {
      const srcPath = src === "/" ? `/${entry}` : `${src}/${entry}`;
      const destPath = dest === "/" ? `/${entry}` : `${dest}/${entry}`;
      const stats = this.vfs.statSync(srcPath);
      if (stats.isDirectory()) {
        await this.cpRecursive(srcPath, destPath);
      } else {
        const content = this.vfs.readFileSync(srcPath);
        this.vfs.writeFileSync(destPath, content);
      }
    }
  }
  /**
   * Move/rename a file or directory
   */
  async mv(src, dest) {
    this.vfs.renameSync(src, dest);
  }
  /**
   * Resolve a relative path against a base path
   */
  resolvePath(base, path2) {
    if (path2.startsWith("/")) {
      return this.normalizePath(path2);
    }
    const combined = base.endsWith("/") ? `${base}${path2}` : `${base}/${path2}`;
    return this.normalizePath(combined);
  }
  /**
   * Normalize a path (resolve . and .. segments)
   */
  normalizePath(path2) {
    if (!path2.startsWith("/")) {
      path2 = "/" + path2;
    }
    const parts = path2.split("/").filter(Boolean);
    const resolved = [];
    for (const part of parts) {
      if (part === "..") {
        resolved.pop();
      } else if (part !== ".") {
        resolved.push(part);
      }
    }
    return "/" + resolved.join("/");
  }
  /**
   * Get all paths in the filesystem
   */
  getAllPaths() {
    const paths = [];
    this.collectPaths("/", paths);
    return paths;
  }
  /**
   * Recursively collect all paths
   */
  collectPaths(dir, paths) {
    try {
      const entries = this.vfs.readdirSync(dir);
      for (const entry of entries) {
        const fullPath = dir === "/" ? `/${entry}` : `${dir}/${entry}`;
        paths.push(fullPath);
        try {
          const stats = this.vfs.statSync(fullPath);
          if (stats.isDirectory()) {
            this.collectPaths(fullPath, paths);
          }
        } catch {
        }
      }
    } catch {
    }
  }
  /**
   * Change file/directory permissions (no-op - VFS doesn't track permissions)
   */
  async chmod(_path, _mode) {
    if (!this.vfs.existsSync(_path)) {
      throw createNodeError("ENOENT", "chmod", _path);
    }
  }
  /**
   * Create a symbolic link (not supported)
   */
  async symlink(_target, _linkPath) {
    throw new Error("Symbolic links are not supported in VirtualFS");
  }
  /**
   * Create a hard link (not supported)
   */
  async link(_existingPath, _newPath) {
    throw new Error("Hard links are not supported in VirtualFS");
  }
  /**
   * Read the target of a symbolic link (not supported)
   */
  async readlink(_path) {
    throw new Error("Symbolic links are not supported in VirtualFS");
  }
  /**
   * Get file/directory information without following symlinks
   * Since VFS doesn't support symlinks, this is the same as stat
   */
  async lstat(path2) {
    return this.stat(path2);
  }
  /**
   * Resolve all symlinks in a path
   * Since VFS doesn't support symlinks, just normalize and return
   */
  async realpath(path2) {
    if (!this.vfs.existsSync(path2)) {
      throw createNodeError("ENOENT", "realpath", path2);
    }
    return this.normalizePath(path2);
  }
  /**
   * Set access and modification times (no-op - VFS doesn't track times)
   */
  async utimes(path2, _atime, _mtime) {
    if (!this.vfs.existsSync(path2)) {
      throw createNodeError("ENOENT", "utimes", path2);
    }
  }
}
if (typeof globalThis.process === "undefined") {
  globalThis.process = {
    env: {
      HOME: "/home/user",
      USER: "user",
      PATH: "/usr/local/bin:/usr/bin:/bin",
      NODE_ENV: "development"
    },
    cwd: () => "/",
    platform: "linux",
    version: "v18.0.0",
    versions: { node: "18.0.0" },
    stdout: { write: () => {
    } },
    stderr: { write: () => {
    } }
  };
}
let bashInstance = null;
let vfsAdapter = null;
let currentVfs = null;
let _activeForkedChildren = 0;
let _onForkedChildExit = null;
const _realDefineProperty = Object.defineProperty;
Object.defineProperty = function(target, key, descriptor) {
  if (target === globalThis && descriptor && !descriptor.configurable) {
    descriptor = { ...descriptor, configurable: true };
  }
  return _realDefineProperty.call(Object, target, key, descriptor);
};
let _streamStdout = null;
let _streamStderr = null;
let _abortSignal = null;
function setStreamingCallbacks(opts) {
  _streamStdout = opts.onStdout || null;
  _streamStderr = opts.onStderr || null;
  _abortSignal = opts.signal || null;
}
function clearStreamingCallbacks() {
  _streamStdout = null;
  _streamStderr = null;
  _abortSignal = null;
}
let _activeProcessStdin = null;
function sendStdin(data2) {
  if (_activeProcessStdin) {
    _activeProcessStdin.emit("data", data2);
    for (const ch2 of data2) {
      _activeProcessStdin.emit("keypress", ch2, {
        sequence: ch2,
        name: ch2,
        ctrl: false,
        meta: false,
        shift: false
      });
    }
  }
}
function initChildProcess(vfs2) {
  currentVfs = vfs2;
  vfsAdapter = new VirtualFSAdapter(vfs2);
  const nodeCommand = GA("node", async (args, ctx) => {
    if (!currentVfs) {
      return { stdout: "", stderr: "VFS not initialized\n", exitCode: 1 };
    }
    const scriptPath = args[0];
    if (!scriptPath) {
      return { stdout: "", stderr: "Usage: node <script.js> [args...]\n", exitCode: 1 };
    }
    const resolvedPath2 = scriptPath.startsWith("/") ? scriptPath : `${ctx.cwd}/${scriptPath}`.replace(/\/+/g, "/");
    if (!currentVfs.existsSync(resolvedPath2)) {
      return { stdout: "", stderr: `Error: Cannot find module '${resolvedPath2}'
`, exitCode: 1 };
    }
    let stdout = "";
    let stderr = "";
    let exitCalled = false;
    let exitCode = 0;
    let syncExecution = true;
    let exitResolve = null;
    const exitPromise = new Promise((resolve2) => {
      exitResolve = resolve2;
    });
    const appendStdout = (data2) => {
      stdout += data2;
      if (_streamStdout) _streamStdout(data2);
    };
    const appendStderr = (data2) => {
      stderr += data2;
      if (_streamStderr) _streamStderr(data2);
    };
    const runtime2 = new Runtime(currentVfs, {
      cwd: ctx.cwd,
      env: ctx.env,
      onConsole: (method, consoleArgs) => {
        const msg = consoleArgs.map((a) => String(a)).join(" ") + "\n";
        if (method === "error") {
          appendStderr(msg);
        } else {
          appendStdout(msg);
        }
      },
      onStdout: (data2) => {
        appendStdout(data2);
      },
      onStderr: (data2) => {
        appendStderr(data2);
      }
    });
    const proc = runtime2.getProcess();
    proc.exit = (code2 = 0) => {
      if (!exitCalled) {
        exitCalled = true;
        exitCode = code2;
        proc.emit("exit", code2);
        exitResolve(code2);
      }
      if (syncExecution) {
        throw new Error(`Process exited with code ${code2}`);
      }
    };
    proc.argv = ["node", resolvedPath2, ...args.slice(1)];
    if (_abortSignal) {
      proc.stdout.isTTY = true;
      proc.stderr.isTTY = true;
      proc.stdin.isTTY = true;
      proc.stdin.setRawMode = () => proc.stdin;
      _activeProcessStdin = proc.stdin;
    }
    try {
      runtime2.runFile(resolvedPath2);
    } catch (error) {
      if (error instanceof Error && error.message.startsWith("Process exited with code")) {
        return { stdout, stderr, exitCode };
      }
      const errorMsg = error instanceof Error ? `${error.message}
${error.stack || ""}` : String(error);
      return { stdout, stderr: stderr + `Error: ${errorMsg}
`, exitCode: 1 };
    } finally {
      syncExecution = false;
    }
    if (exitCalled) {
      return { stdout, stderr, exitCode };
    }
    if (stdout.length > 0 || stderr.length > 0) {
      await new Promise((r2) => setTimeout(r2, 0));
      return { stdout, stderr, exitCode: exitCalled ? exitCode : 0 };
    }
    const rejectionHandler = (event) => {
      const reason = event.reason;
      if (reason instanceof Error && reason.message.startsWith("Process exited with code")) {
        event.preventDefault();
        return;
      }
      const msg = reason instanceof Error ? `Unhandled rejection: ${reason.message}
${reason.stack || ""}
` : `Unhandled rejection: ${String(reason)}
`;
      appendStderr(msg);
    };
    globalThis.addEventListener("unhandledrejection", rejectionHandler);
    let childrenExited = false;
    const prevChildExitHandler = _onForkedChildExit;
    _onForkedChildExit = () => {
      if (_activeForkedChildren <= 0) childrenExited = true;
      prevChildExitHandler == null ? void 0 : prevChildExitHandler();
    };
    try {
      const MAX_TOTAL_MS = 6e4;
      const IDLE_TIMEOUT_MS = 500;
      const POST_CHILD_EXIT_IDLE_MS = 100;
      const CHECK_MS = 50;
      const startTime = Date.now();
      let lastOutputLen = stdout.length + stderr.length;
      let idleMs = 0;
      const isLongRunning = !!_abortSignal;
      while (!exitCalled) {
        if (_abortSignal == null ? void 0 : _abortSignal.aborted) break;
        const raceResult = await Promise.race([
          exitPromise.then(() => "exit"),
          new Promise((r2) => setTimeout(() => r2("tick"), CHECK_MS))
        ]);
        if (raceResult === "exit" || exitCalled) break;
        if (_abortSignal == null ? void 0 : _abortSignal.aborted) break;
        const currentLen = stdout.length + stderr.length;
        if (currentLen > lastOutputLen) {
          lastOutputLen = currentLen;
          idleMs = 0;
        } else {
          idleMs += CHECK_MS;
        }
        if (!isLongRunning) {
          const effectiveIdle = childrenExited ? POST_CHILD_EXIT_IDLE_MS : IDLE_TIMEOUT_MS;
          if (lastOutputLen > 0 && idleMs >= effectiveIdle) break;
        }
        if (!isLongRunning && Date.now() - startTime >= MAX_TOTAL_MS) break;
      }
      return { stdout, stderr, exitCode: exitCalled ? exitCode : 0 };
    } finally {
      _activeProcessStdin = null;
      _onForkedChildExit = prevChildExitHandler;
      globalThis.removeEventListener("unhandledrejection", rejectionHandler);
    }
  });
  const npmCommand = GA("npm", async (args, ctx) => {
    if (!currentVfs) {
      return { stdout: "", stderr: "VFS not initialized\n", exitCode: 1 };
    }
    const subcommand = args[0];
    if (!subcommand || subcommand === "help" || subcommand === "--help") {
      return {
        stdout: "Usage: npm <command>\n\nCommands:\n  run <script>   Run a script from package.json\n  start          Run the start script\n  test           Run the test script\n  install [pkg]  Install packages\n  ls             List installed packages\n",
        stderr: "",
        exitCode: 0
      };
    }
    switch (subcommand) {
      case "run":
      case "run-script":
        return handleNpmRun(args.slice(1), ctx);
      case "start":
        return handleNpmRun(["start"], ctx);
      case "test":
      case "t":
      case "tst":
        return handleNpmRun(["test"], ctx);
      case "install":
      case "i":
      case "add":
        return handleNpmInstall(args.slice(1), ctx);
      case "ls":
      case "list":
        return handleNpmList(ctx);
      default:
        return {
          stdout: "",
          stderr: `npm ERR! Unknown command: "${subcommand}"
`,
          exitCode: 1
        };
    }
  });
  bashInstance = new Ql({
    fs: vfsAdapter,
    cwd: "/",
    env: {
      HOME: "/home/user",
      USER: "user",
      PATH: "/usr/local/bin:/usr/bin:/bin:/node_modules/.bin",
      NODE_ENV: "development"
    },
    customCommands: [nodeCommand, npmCommand]
  });
}
function readPackageJson(cwd) {
  const pkgJsonPath = `${cwd}/package.json`.replace(/\/+/g, "/");
  if (!currentVfs.existsSync(pkgJsonPath)) {
    return {
      error: {
        stdout: "",
        stderr: "npm ERR! no package.json found\n",
        exitCode: 1
      }
    };
  }
  try {
    const pkgJson = JSON.parse(currentVfs.readFileSync(pkgJsonPath, "utf8"));
    return { pkgJson };
  } catch {
    return {
      error: {
        stdout: "",
        stderr: "npm ERR! Failed to parse package.json\n",
        exitCode: 1
      }
    };
  }
}
async function handleNpmRun(args, ctx) {
  const scriptName = args[0];
  if (!scriptName) {
    return listScripts(ctx);
  }
  const result = readPackageJson(ctx.cwd);
  if (result.error) return result.error;
  const pkgJson = result.pkgJson;
  const scripts = pkgJson.scripts || {};
  const scriptCommand = scripts[scriptName];
  if (!scriptCommand) {
    const available = Object.keys(scripts);
    let msg = `npm ERR! Missing script: "${scriptName}"
`;
    if (available.length > 0) {
      msg += "\nnpm ERR! Available scripts:\n";
      for (const name2 of available) {
        msg += `npm ERR!   ${name2}
`;
        msg += `npm ERR!     ${scripts[name2]}
`;
      }
    }
    return { stdout: "", stderr: msg, exitCode: 1 };
  }
  if (!ctx.exec) {
    return {
      stdout: "",
      stderr: "npm ERR! Script execution not available in this context\n",
      exitCode: 1
    };
  }
  const npmEnv = {
    ...ctx.env,
    npm_lifecycle_event: scriptName
  };
  if (pkgJson.name) npmEnv.npm_package_name = pkgJson.name;
  if (pkgJson.version) npmEnv.npm_package_version = pkgJson.version;
  let allStdout = "";
  let allStderr = "";
  const label = `${pkgJson.name || ""}@${pkgJson.version || ""}`;
  const preScript = scripts[`pre${scriptName}`];
  if (preScript) {
    allStderr += `
> ${label} pre${scriptName}
> ${preScript}

`;
    const preResult = await ctx.exec(preScript, { cwd: ctx.cwd, env: npmEnv });
    allStdout += preResult.stdout;
    allStderr += preResult.stderr;
    if (preResult.exitCode !== 0) {
      return { stdout: allStdout, stderr: allStderr, exitCode: preResult.exitCode };
    }
  }
  allStderr += `
> ${label} ${scriptName}
> ${scriptCommand}

`;
  const mainResult = await ctx.exec(scriptCommand, { cwd: ctx.cwd, env: npmEnv });
  allStdout += mainResult.stdout;
  allStderr += mainResult.stderr;
  if (mainResult.exitCode !== 0) {
    return { stdout: allStdout, stderr: allStderr, exitCode: mainResult.exitCode };
  }
  const postScript = scripts[`post${scriptName}`];
  if (postScript) {
    allStderr += `
> ${label} post${scriptName}
> ${postScript}

`;
    const postResult = await ctx.exec(postScript, { cwd: ctx.cwd, env: npmEnv });
    allStdout += postResult.stdout;
    allStderr += postResult.stderr;
    if (postResult.exitCode !== 0) {
      return { stdout: allStdout, stderr: allStderr, exitCode: postResult.exitCode };
    }
  }
  return { stdout: allStdout, stderr: allStderr, exitCode: 0 };
}
function listScripts(ctx) {
  const result = readPackageJson(ctx.cwd);
  if (result.error) return result.error;
  const pkgJson = result.pkgJson;
  const scripts = pkgJson.scripts || {};
  const names = Object.keys(scripts);
  if (names.length === 0) {
    return { stdout: "", stderr: "", exitCode: 0 };
  }
  const lifecycle = ["prestart", "start", "poststart", "pretest", "test", "posttest", "prestop", "stop", "poststop"];
  const lifecyclePresent = names.filter((n2) => lifecycle.includes(n2));
  const customPresent = names.filter((n2) => !lifecycle.includes(n2));
  let output = `Lifecycle scripts included in ${pkgJson.name || ""}:
`;
  for (const name2 of lifecyclePresent) {
    output += `  ${name2}
    ${scripts[name2]}
`;
  }
  if (customPresent.length > 0) {
    output += "\navailable via `npm run-script`:\n";
    for (const name2 of customPresent) {
      output += `  ${name2}
    ${scripts[name2]}
`;
    }
  }
  return { stdout: output, stderr: "", exitCode: 0 };
}
async function handleNpmInstall(args, ctx) {
  const { PackageManager: PackageManager2 } = await Promise.resolve().then(function() {
    return index;
  });
  const pm2 = new PackageManager2(currentVfs, { cwd: ctx.cwd });
  let stdout = "";
  try {
    const pkgArgs = args.filter((a) => !a.startsWith("-"));
    if (pkgArgs.length === 0) {
      const installResult = await pm2.installFromPackageJson({
        onProgress: (msg) => {
          stdout += msg + "\n";
        }
      });
      stdout += `added ${installResult.added.length} packages
`;
    } else {
      for (const arg of pkgArgs) {
        const installResult = await pm2.install(arg, {
          save: true,
          onProgress: (msg) => {
            stdout += msg + "\n";
          }
        });
        stdout += `added ${installResult.added.length} packages
`;
      }
    }
    return { stdout, stderr: "", exitCode: 0 };
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    return { stdout, stderr: `npm ERR! ${msg}
`, exitCode: 1 };
  }
}
async function handleNpmList(ctx) {
  const { PackageManager: PackageManager2 } = await Promise.resolve().then(function() {
    return index;
  });
  const pm2 = new PackageManager2(currentVfs, { cwd: ctx.cwd });
  const packages = pm2.list();
  const entries = Object.entries(packages);
  if (entries.length === 0) {
    return { stdout: "(empty)\n", stderr: "", exitCode: 0 };
  }
  let output = `${ctx.cwd}
`;
  for (const [name2, version2] of entries) {
    output += `+-- ${name2}@${version2}
`;
  }
  return { stdout: output, stderr: "", exitCode: 0 };
}
function exec(command, optionsOrCallback, callback) {
  let options2 = {};
  let cb2;
  if (typeof optionsOrCallback === "function") {
    cb2 = optionsOrCallback;
  } else if (optionsOrCallback) {
    options2 = optionsOrCallback;
    cb2 = callback;
  }
  const child = new ChildProcess();
  (async () => {
    var _a3, _b3, _c2, _d2;
    if (!bashInstance) {
      const error = new Error("child_process not initialized");
      child.emit("error", error);
      if (cb2) cb2(error, "", "");
      return;
    }
    try {
      const result = await bashInstance.exec(command, {
        cwd: options2.cwd,
        env: options2.env
      });
      const stdout = result.stdout || "";
      const stderr = result.stderr || "";
      if (stdout) {
        (_a3 = child.stdout) == null ? void 0 : _a3.push(BufferPolyfill.from(stdout));
      }
      (_b3 = child.stdout) == null ? void 0 : _b3.push(null);
      if (stderr) {
        (_c2 = child.stderr) == null ? void 0 : _c2.push(BufferPolyfill.from(stderr));
      }
      (_d2 = child.stderr) == null ? void 0 : _d2.push(null);
      child.emit("close", result.exitCode, null);
      child.emit("exit", result.exitCode, null);
      if (cb2) {
        if (result.exitCode !== 0) {
          const error = new Error(`Command failed: ${command}`);
          error.code = result.exitCode;
          cb2(error, stdout, stderr);
        } else {
          cb2(null, stdout, stderr);
        }
      }
    } catch (error) {
      child.emit("error", error);
      if (cb2) cb2(error, "", "");
    }
  })();
  return child;
}
function execSync(command, options2) {
  if (!bashInstance) {
    throw new Error("child_process not initialized");
  }
  throw new Error(
    "execSync is not supported in browser environment. Use exec() with async/await or callbacks instead."
  );
}
function spawn(command, args, options2) {
  let spawnArgs = [];
  let spawnOptions = {};
  if (Array.isArray(args)) {
    spawnArgs = args;
    spawnOptions = options2 || {};
  } else if (args) {
    spawnOptions = args;
  }
  const child = new ChildProcess();
  const fullCommand = spawnArgs.length > 0 ? `${command} ${spawnArgs.map(
    (arg) => arg.includes(" ") ? `"${arg}"` : arg
  ).join(" ")}` : command;
  (async () => {
    var _a3, _b3, _c2, _d2;
    if (!bashInstance) {
      const error = new Error("child_process not initialized");
      child.emit("error", error);
      return;
    }
    try {
      const result = await bashInstance.exec(fullCommand, {
        cwd: spawnOptions.cwd,
        env: spawnOptions.env
      });
      const stdout = result.stdout || "";
      const stderr = result.stderr || "";
      if (stdout) {
        (_a3 = child.stdout) == null ? void 0 : _a3.push(BufferPolyfill.from(stdout));
      }
      (_b3 = child.stdout) == null ? void 0 : _b3.push(null);
      if (stderr) {
        (_c2 = child.stderr) == null ? void 0 : _c2.push(BufferPolyfill.from(stderr));
      }
      (_d2 = child.stderr) == null ? void 0 : _d2.push(null);
      child.emit("close", result.exitCode, null);
      child.emit("exit", result.exitCode, null);
    } catch (error) {
      child.emit("error", error);
    }
  })();
  return child;
}
function spawnSync(command, args, options2) {
  throw new Error(
    "spawnSync is not supported in browser environment. Use spawn() instead."
  );
}
function execFile(file, args, options2, callback) {
  let execArgs = [];
  let execOptions = {};
  let cb2;
  if (Array.isArray(args)) {
    execArgs = args;
    if (typeof options2 === "function") {
      cb2 = options2;
    } else if (options2) {
      execOptions = options2;
      cb2 = callback;
    }
  } else if (typeof args === "function") {
    cb2 = args;
  } else if (args) {
    execOptions = args;
    cb2 = options2;
  }
  const command = execArgs.length > 0 ? `${file} ${execArgs.join(" ")}` : file;
  return exec(command, execOptions, cb2);
}
function fork$2(modulePath, argsOrOptions, options2) {
  if (!currentVfs) {
    throw new Error("VFS not initialized");
  }
  let args = [];
  let opts = {};
  if (Array.isArray(argsOrOptions)) {
    args = argsOrOptions;
    opts = options2 || {};
  } else if (argsOrOptions) {
    opts = argsOrOptions;
  }
  const cwd = opts.cwd || "/";
  const env = opts.env || {};
  const execArgv = opts.execArgv || [];
  const resolvedPath2 = modulePath.startsWith("/") ? modulePath : `${cwd}/${modulePath}`.replace(/\/+/g, "/");
  const child = new ChildProcess();
  child.connected = true;
  child.spawnargs = ["node", ...execArgv, resolvedPath2, ...args];
  child.spawnfile = "node";
  const childRuntime = new Runtime(currentVfs, {
    cwd,
    env,
    onConsole: (method, consoleArgs) => {
      var _a3, _b3;
      const msg = consoleArgs.map((a) => String(a)).join(" ");
      if (method === "error" || method === "warn") {
        (_a3 = child.stderr) == null ? void 0 : _a3.emit("data", msg + "\n");
      } else {
        (_b3 = child.stdout) == null ? void 0 : _b3.emit("data", msg + "\n");
      }
    },
    onStdout: (data2) => {
      var _a3;
      (_a3 = child.stdout) == null ? void 0 : _a3.emit("data", data2);
    },
    onStderr: (data2) => {
      var _a3;
      (_a3 = child.stderr) == null ? void 0 : _a3.emit("data", data2);
    }
  });
  const childProc = childRuntime.getProcess();
  childProc.argv = ["node", resolvedPath2, ...args];
  const cloneIpcMessage = (msg) => {
    try {
      return structuredClone(msg);
    } catch {
      return msg;
    }
  };
  child.send = (message, _callback) => {
    if (!child.connected) return false;
    const cloned = cloneIpcMessage(message);
    setTimeout(() => {
      childProc.emit("message", cloned);
    }, 0);
    return true;
  };
  let ipcQueue = Promise.resolve();
  childProc.send = (message, _callback) => {
    if (!child.connected) return false;
    const cloned = cloneIpcMessage(message);
    ipcQueue = ipcQueue.then(async () => {
      const listeners = child.listeners("message");
      for (const listener of listeners) {
        try {
          const result = listener(cloned);
          if (result && typeof result.then === "function") {
            await result;
          }
        } catch {
        }
      }
    });
    return true;
  };
  childProc.connected = true;
  _activeForkedChildren++;
  const notifyChildExit = () => {
    _activeForkedChildren--;
    _onForkedChildExit == null ? void 0 : _onForkedChildExit();
  };
  childProc.exit = (code2 = 0) => {
    child.exitCode = code2;
    child.connected = false;
    childProc.connected = false;
    childProc.emit("exit", code2);
    child.emit("exit", code2, null);
    child.emit("close", code2, null);
    notifyChildExit();
  };
  child.kill = (signal) => {
    child.killed = true;
    child.connected = false;
    childProc.connected = false;
    childProc.emit("exit", null, signal || "SIGTERM");
    child.emit("exit", null, signal || "SIGTERM");
    child.emit("close", null, signal || "SIGTERM");
    notifyChildExit();
    return true;
  };
  child.disconnect = () => {
    child.connected = false;
    childProc.connected = false;
    child.emit("disconnect");
  };
  setTimeout(() => {
    var _a3;
    try {
      childRuntime.runFile(resolvedPath2);
    } catch (error) {
      if (error instanceof Error && error.message.startsWith("Process exited with code")) {
        return;
      }
      const errorMsg = error instanceof Error ? error.message : String(error);
      (_a3 = child.stderr) == null ? void 0 : _a3.emit("data", `Error in forked process: ${errorMsg}
`);
      child.exitCode = 1;
      child.emit("error", error);
      child.emit("exit", 1, null);
      child.emit("close", 1, null);
    }
  }, 0);
  return child;
}
class ChildProcess extends EventEmitter {
  constructor() {
    super();
    __publicField(this, "pid");
    __publicField(this, "connected", false);
    __publicField(this, "killed", false);
    __publicField(this, "exitCode", null);
    __publicField(this, "signalCode", null);
    __publicField(this, "spawnargs", []);
    __publicField(this, "spawnfile", "");
    __publicField(this, "stdin");
    __publicField(this, "stdout");
    __publicField(this, "stderr");
    this.pid = Math.floor(Math.random() * 1e4) + 1e3;
    this.stdin = new Writable();
    this.stdout = new Readable();
    this.stderr = new Readable();
  }
  kill(signal) {
    this.killed = true;
    this.emit("exit", null, signal || "SIGTERM");
    return true;
  }
  disconnect() {
    this.connected = false;
  }
  send(message, callback) {
    if (callback) callback(new Error("IPC not supported"));
    return false;
  }
  ref() {
    return this;
  }
  unref() {
    return this;
  }
}
var child_process = {
  exec,
  execSync,
  execFile,
  spawn,
  spawnSync,
  fork: fork$2,
  ChildProcess,
  initChildProcess,
  setStreamingCallbacks,
  clearStreamingCallbacks
};
var childProcessShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ChildProcess,
  clearStreamingCallbacks,
  default: child_process,
  exec,
  execFile,
  execSync,
  fork: fork$2,
  initChildProcess,
  sendStdin,
  setStreamingCallbacks,
  spawn,
  spawnSync
});
let globalVFS$2 = null;
function setVFS$2(vfs2) {
  globalVFS$2 = vfs2;
}
class FSWatcher extends EventEmitter {
  constructor(options2 = {}) {
    super();
    __publicField(this, "vfs");
    __publicField(this, "watched", /* @__PURE__ */ new Map());
    __publicField(this, "options");
    __publicField(this, "closed", false);
    __publicField(this, "ready", false);
    __publicField(this, "_eventCounts");
    if (!globalVFS$2) {
      throw new Error("chokidar: VirtualFS not initialized. Call setVFS first.");
    }
    this.vfs = globalVFS$2;
    this.options = options2;
  }
  shouldIgnore(path2) {
    const { ignored } = this.options;
    if (!ignored) return false;
    const ignoreList = Array.isArray(ignored) ? ignored : [ignored];
    for (const pattern of ignoreList) {
      if (typeof pattern === "string") {
        if (path2 === pattern || path2.startsWith(pattern + "/")) return true;
      } else if (pattern instanceof RegExp) {
        if (pattern.test(path2)) return true;
      } else if (typeof pattern === "function") {
        if (pattern(path2)) return true;
      }
    }
    return false;
  }
  normalizePath(path2) {
    if (this.options.cwd && !path2.startsWith("/")) {
      path2 = this.options.cwd + "/" + path2;
    }
    if (!path2.startsWith("/")) {
      path2 = "/" + path2;
    }
    return path2;
  }
  add(paths) {
    if (this.closed) return this;
    const pathArray = Array.isArray(paths) ? paths : [paths];
    const pendingEmits = [];
    console.log("[chokidar] add:", pathArray);
    for (const p of pathArray) {
      const normalized = this.normalizePath(p);
      if (this.shouldIgnore(normalized)) continue;
      if (this.watched.has(normalized)) continue;
      try {
        if (!this.vfs.existsSync(normalized)) {
          const parentPath = normalized.substring(0, normalized.lastIndexOf("/")) || "/";
          if (this.vfs.existsSync(parentPath)) {
            this.watchPath(parentPath, normalized);
          }
          continue;
        }
        const stats = this.vfs.statSync(normalized);
        if (!this.options.ignoreInitial) {
          if (stats.isDirectory()) {
            this.collectDirContents(normalized, pendingEmits);
          } else {
            pendingEmits.push(() => this.emit("add", normalized, stats));
          }
        }
        this.watchPath(normalized);
        if (stats.isDirectory()) {
          this.watchDirRecursive(normalized);
        }
      } catch (err2) {
        this.emit("error", err2);
      }
    }
    if (!this.ready) {
      this.ready = true;
      setTimeout(() => {
        for (const emitFn of pendingEmits) {
          emitFn();
        }
        this.emit("ready");
      }, 0);
    }
    return this;
  }
  collectDirContents(dirPath, pendingEmits) {
    try {
      const entries = this.vfs.readdirSync(dirPath);
      for (const entry of entries) {
        const fullPath = dirPath === "/" ? "/" + entry : dirPath + "/" + entry;
        if (this.shouldIgnore(fullPath)) continue;
        const stats = this.vfs.statSync(fullPath);
        if (stats.isDirectory()) {
          pendingEmits.push(() => this.emit("addDir", fullPath, stats));
          this.collectDirContents(fullPath, pendingEmits);
        } else {
          pendingEmits.push(() => this.emit("add", fullPath, stats));
        }
      }
    } catch {
    }
  }
  watchPath(path2, watchFor) {
    if (this.watched.has(path2)) return;
    const watcher = this.vfs.watch(path2, { recursive: true }, (eventType, filename2) => {
      if (this.closed) return;
      let fullPath;
      if (filename2) {
        fullPath = path2 === "/" ? "/" + filename2 : path2 + "/" + filename2;
      } else {
        fullPath = path2;
      }
      const eventKey = `${eventType}:${fullPath}`;
      if (!this._eventCounts) this._eventCounts = /* @__PURE__ */ new Map();
      const count = (this._eventCounts.get(eventKey) || 0) + 1;
      this._eventCounts.set(eventKey, count);
      if (count === 5) {
        console.warn(`[chokidar] Repeated event: ${eventType} on ${fullPath} (${count}+ times)`);
      }
      console.log("[chokidar] event:", eventType, fullPath);
      if (watchFor && fullPath !== watchFor && !fullPath.startsWith(watchFor + "/")) {
        return;
      }
      if (this.shouldIgnore(fullPath)) {
        console.log("[chokidar] ignored:", fullPath);
        return;
      }
      if (eventType === "rename") {
        if (this.vfs.existsSync(fullPath)) {
          try {
            const stats = this.vfs.statSync(fullPath);
            if (stats.isDirectory()) {
              console.log("[chokidar] emit addDir:", fullPath);
              this.emit("addDir", fullPath, stats);
            } else {
              console.log("[chokidar] emit add:", fullPath);
              this.emit("add", fullPath, stats);
            }
          } catch {
          }
        } else {
          console.log("[chokidar] emit unlink:", fullPath);
          this.emit("unlink", fullPath);
        }
      } else if (eventType === "change") {
        try {
          const stats = this.vfs.statSync(fullPath);
          console.log("[chokidar] emit change:", fullPath);
          this.emit("change", fullPath, stats);
        } catch {
          this.emit("unlink", fullPath);
        }
      }
    });
    this.watched.set(path2, watcher);
  }
  watchDirRecursive(dirPath, depth = 0) {
    if (this.options.depth !== void 0 && depth > this.options.depth) return;
    try {
      const entries = this.vfs.readdirSync(dirPath);
      for (const entry of entries) {
        const fullPath = dirPath === "/" ? "/" + entry : dirPath + "/" + entry;
        if (this.shouldIgnore(fullPath)) continue;
        try {
          const stats = this.vfs.statSync(fullPath);
          if (stats.isDirectory()) {
            this.watchPath(fullPath);
            this.watchDirRecursive(fullPath, depth + 1);
          }
        } catch {
        }
      }
    } catch {
    }
  }
  unwatch(paths) {
    const pathArray = Array.isArray(paths) ? paths : [paths];
    for (const p of pathArray) {
      const normalized = this.normalizePath(p);
      const watcher = this.watched.get(normalized);
      if (watcher) {
        watcher.close();
        this.watched.delete(normalized);
      }
    }
    return this;
  }
  close() {
    this.closed = true;
    for (const watcher of this.watched.values()) {
      watcher.close();
    }
    this.watched.clear();
    this.emit("close");
    return Promise.resolve();
  }
  getWatched() {
    const result = {};
    for (const path2 of this.watched.keys()) {
      const dir = path2.substring(0, path2.lastIndexOf("/")) || "/";
      const basename2 = path2.substring(path2.lastIndexOf("/") + 1);
      if (!result[dir]) {
        result[dir] = [];
      }
      result[dir].push(basename2);
    }
    return result;
  }
}
function watch$2(paths, options2) {
  const watcher = new FSWatcher(options2);
  watcher.add(paths);
  return watcher;
}
var chokidar = { watch: watch$2, FSWatcher, setVFS: setVFS$2 };
var chokidarShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  FSWatcher,
  default: chokidar,
  setVFS: setVFS$2,
  watch: watch$2
});
const CloseEventPolyfill = typeof CloseEvent !== "undefined" ? CloseEvent : class CloseEvent2 extends Event {
  constructor(type2, init2) {
    super(type2);
    __publicField(this, "code");
    __publicField(this, "reason");
    __publicField(this, "wasClean");
    this.code = (init2 == null ? void 0 : init2.code) ?? 1e3;
    this.reason = (init2 == null ? void 0 : init2.reason) ?? "";
    this.wasClean = (init2 == null ? void 0 : init2.wasClean) ?? true;
  }
};
const MessageEventPolyfill = typeof MessageEvent !== "undefined" ? MessageEvent : class MessageEvent2 extends Event {
  constructor(type2, init2) {
    super(type2);
    __publicField(this, "data");
    this.data = init2 == null ? void 0 : init2.data;
  }
};
let messageChannel = null;
try {
  messageChannel = new BroadcastChannel("vite-ws-channel");
} catch {
}
const servers = /* @__PURE__ */ new Map();
let clientIdCounter = 0;
const _WebSocket = class _WebSocket extends EventEmitter {
  constructor(url2, protocols) {
    super();
    __publicField(this, "CONNECTING", _WebSocket.CONNECTING);
    __publicField(this, "OPEN", _WebSocket.OPEN);
    __publicField(this, "CLOSING", _WebSocket.CLOSING);
    __publicField(this, "CLOSED", _WebSocket.CLOSED);
    __publicField(this, "readyState", _WebSocket.CONNECTING);
    __publicField(this, "url");
    __publicField(this, "protocol", "");
    __publicField(this, "extensions", "");
    __publicField(this, "bufferedAmount", 0);
    __publicField(this, "binaryType", "blob");
    __publicField(this, "_id");
    __publicField(this, "_server", null);
    __publicField(this, "_nativeWs", null);
    // Event handler properties
    __publicField(this, "onopen", null);
    __publicField(this, "onclose", null);
    __publicField(this, "onerror", null);
    __publicField(this, "onmessage", null);
    this.url = url2;
    this._id = `client-${++clientIdCounter}`;
    if (protocols) {
      this.protocol = Array.isArray(protocols) ? protocols[0] : protocols;
    }
    setTimeout(() => this._connect(), 0);
  }
  _connect() {
    if (this.url.startsWith("internal://")) {
      this.readyState = _WebSocket.OPEN;
      this.emit("open");
      if (this.onopen) this.onopen(new Event("open"));
      return;
    }
    if (this.url.startsWith("ws://") || this.url.startsWith("wss://")) {
      this._connectNative();
      return;
    }
    if (!messageChannel) {
      setTimeout(() => {
        this.readyState = _WebSocket.OPEN;
        this.emit("open");
        if (this.onopen) this.onopen(new Event("open"));
      }, 0);
      return;
    }
    messageChannel.postMessage({
      type: "connect",
      clientId: this._id,
      url: this.url
    });
    const channel2 = messageChannel;
    const handler = (event) => {
      const data2 = event.data;
      if (data2.targetClient !== this._id) return;
      switch (data2.type) {
        case "connected":
          this.readyState = _WebSocket.OPEN;
          this.emit("open");
          if (this.onopen) this.onopen(new Event("open"));
          break;
        case "message":
          const msgEvent = new MessageEventPolyfill("message", { data: data2.payload });
          this.emit("message", msgEvent);
          if (this.onmessage) this.onmessage(msgEvent);
          break;
        case "close":
          this.readyState = _WebSocket.CLOSED;
          const closeEvent = new CloseEventPolyfill("close", {
            code: data2.code || 1e3,
            reason: data2.reason || "",
            wasClean: true
          });
          this.emit("close", closeEvent);
          if (this.onclose) this.onclose(closeEvent);
          channel2.removeEventListener("message", handler);
          break;
        case "error":
          const errorEvent = new Event("error");
          this.emit("error", errorEvent);
          if (this.onerror) this.onerror(errorEvent);
          break;
      }
    };
    channel2.addEventListener("message", handler);
    setTimeout(() => {
      if (this.readyState === _WebSocket.CONNECTING) {
        this.readyState = _WebSocket.OPEN;
        this.emit("open");
        if (this.onopen) this.onopen(new Event("open"));
      }
    }, 100);
  }
  _connectNative() {
    const isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
    const NativeWS = isBrowser2 && typeof globalThis.WebSocket === "function" && globalThis.WebSocket !== _WebSocket ? globalThis.WebSocket : null;
    if (!NativeWS) {
      setTimeout(() => {
        this.readyState = _WebSocket.OPEN;
        this.emit("open");
        if (this.onopen) this.onopen(new Event("open"));
      }, 0);
      return;
    }
    try {
      this._nativeWs = new NativeWS(this.url);
      this._nativeWs.binaryType = this.binaryType === "arraybuffer" ? "arraybuffer" : "blob";
    } catch {
      this.readyState = _WebSocket.CLOSED;
      const errorEvent = new Event("error");
      this.emit("error", errorEvent);
      if (this.onerror) this.onerror(errorEvent);
      return;
    }
    this._nativeWs.onopen = () => {
      this.readyState = _WebSocket.OPEN;
      this.emit("open");
      if (this.onopen) this.onopen(new Event("open"));
    };
    this._nativeWs.onmessage = (event) => {
      const msgEvent = new MessageEventPolyfill("message", { data: event.data });
      this.emit("message", msgEvent);
      if (this.onmessage) this.onmessage(msgEvent);
    };
    this._nativeWs.onclose = (event) => {
      this.readyState = _WebSocket.CLOSED;
      this._nativeWs = null;
      const closeEvent = new CloseEventPolyfill("close", {
        code: event.code,
        reason: event.reason,
        wasClean: event.wasClean
      });
      this.emit("close", closeEvent);
      if (this.onclose) this.onclose(closeEvent);
    };
    this._nativeWs.onerror = () => {
      const errorEvent = new Event("error");
      this.emit("error", errorEvent);
      if (this.onerror) this.onerror(errorEvent);
    };
  }
  send(data2) {
    if (this.readyState !== _WebSocket.OPEN) {
      throw new Error("WebSocket is not open");
    }
    if (this._nativeWs) {
      this._nativeWs.send(data2);
      return;
    }
    if (this._server) {
      this._server._handleClientMessage(this, data2);
      return;
    }
    if (messageChannel) {
      messageChannel.postMessage({
        type: "message",
        clientId: this._id,
        url: this.url,
        payload: data2
      });
    }
  }
  close(code2, reason) {
    if (this.readyState === _WebSocket.CLOSED || this.readyState === _WebSocket.CLOSING) {
      return;
    }
    this.readyState = _WebSocket.CLOSING;
    if (this._nativeWs) {
      this._nativeWs.close(code2, reason);
      return;
    }
    if (messageChannel) {
      messageChannel.postMessage({
        type: "disconnect",
        clientId: this._id,
        url: this.url,
        code: code2,
        reason
      });
    }
    setTimeout(() => {
      this.readyState = _WebSocket.CLOSED;
      const closeEvent = new CloseEventPolyfill("close", {
        code: code2 || 1e3,
        reason: reason || "",
        wasClean: true
      });
      this.emit("close", closeEvent);
      if (this.onclose) this.onclose(closeEvent);
    }, 0);
  }
  ping() {
  }
  pong() {
  }
  terminate() {
    if (this._nativeWs) {
      this._nativeWs.close();
      this._nativeWs = null;
    }
    this.readyState = _WebSocket.CLOSED;
    const closeEvent = new CloseEventPolyfill("close", {
      code: 1006,
      reason: "Connection terminated",
      wasClean: false
    });
    this.emit("close", closeEvent);
    if (this.onclose) this.onclose(closeEvent);
  }
  // For internal server use
  _setServer(server) {
    this._server = server;
  }
  _receiveMessage(data2) {
    const msgEvent = new MessageEventPolyfill("message", { data: data2 });
    this.emit("message", msgEvent);
    if (this.onmessage) this.onmessage(msgEvent);
  }
};
__publicField(_WebSocket, "CONNECTING", 0);
__publicField(_WebSocket, "OPEN", 1);
__publicField(_WebSocket, "CLOSING", 2);
__publicField(_WebSocket, "CLOSED", 3);
let WebSocket = _WebSocket;
class WebSocketServer extends EventEmitter {
  constructor(options2 = {}) {
    super();
    __publicField(this, "clients", /* @__PURE__ */ new Set());
    __publicField(this, "options");
    __publicField(this, "_path");
    __publicField(this, "_channelHandler", null);
    this.options = options2;
    this._path = options2.path || "/";
    if (!options2.noServer) {
      this._setupListener();
    }
    servers.set(this._path, this);
  }
  _setupListener() {
    if (!messageChannel) return;
    const channel2 = messageChannel;
    this._channelHandler = (event) => {
      const data2 = event.data;
      if (data2.type === "connect") {
        const ws2 = new WebSocket("internal://" + this._path);
        ws2._setServer(this);
        ws2._clientId = data2.clientId;
        this.clients.add(ws2);
        channel2.postMessage({
          type: "connected",
          targetClient: data2.clientId
        });
        this.emit("connection", ws2, { url: data2.url });
      }
      if (data2.type === "message") {
        for (const client of this.clients) {
          if (client._clientId === data2.clientId) {
            client._receiveMessage(data2.payload);
            break;
          }
        }
      }
      if (data2.type === "disconnect") {
        for (const client of this.clients) {
          if (client._clientId === data2.clientId) {
            client.close(data2.code, data2.reason);
            this.clients.delete(client);
            break;
          }
        }
      }
    };
    channel2.addEventListener("message", this._channelHandler);
  }
  _handleClientMessage(client, data2) {
    const msgEvent = new MessageEventPolyfill("message", { data: data2 });
    client.emit("message", msgEvent);
  }
  handleUpgrade(request2, socket, head, callback) {
    const ws2 = new WebSocket("internal://" + this._path);
    ws2._setServer(this);
    if (this.options.clientTracking !== false) {
      this.clients.add(ws2);
    }
    setTimeout(() => {
      callback(ws2, request2);
      this.emit("connection", ws2, request2);
    }, 0);
  }
  close(callback) {
    for (const client of this.clients) {
      client.close(1001, "Server shutting down");
    }
    this.clients.clear();
    servers.delete(this._path);
    if (this._channelHandler && messageChannel) {
      messageChannel.removeEventListener("message", this._channelHandler);
      this._channelHandler = null;
    }
    this.emit("close");
    if (callback) {
      setTimeout(callback, 0);
    }
  }
  address() {
    return {
      port: this.options.port || 0,
      family: "IPv4",
      address: this.options.host || "0.0.0.0"
    };
  }
}
const Server$1 = WebSocketServer;
const createWebSocketStream = () => {
  throw new Error("createWebSocketStream is not supported in browser");
};
var wsShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Server: Server$1,
  WebSocket,
  WebSocketServer,
  createWebSocketStream,
  default: WebSocket
});
const constants$1 = {
  kFSEventStreamEventFlagNone: 0,
  kFSEventStreamEventFlagMustScanSubDirs: 1,
  kFSEventStreamEventFlagUserDropped: 2,
  kFSEventStreamEventFlagKernelDropped: 4,
  kFSEventStreamEventFlagEventIdsWrapped: 8,
  kFSEventStreamEventFlagHistoryDone: 16,
  kFSEventStreamEventFlagRootChanged: 32,
  kFSEventStreamEventFlagMount: 64,
  kFSEventStreamEventFlagUnmount: 128,
  kFSEventStreamEventFlagItemCreated: 256,
  kFSEventStreamEventFlagItemRemoved: 512,
  kFSEventStreamEventFlagItemInodeMetaMod: 1024,
  kFSEventStreamEventFlagItemRenamed: 2048,
  kFSEventStreamEventFlagItemModified: 4096,
  kFSEventStreamEventFlagItemFinderInfoMod: 8192,
  kFSEventStreamEventFlagItemChangeOwner: 16384,
  kFSEventStreamEventFlagItemXattrMod: 32768,
  kFSEventStreamEventFlagItemIsFile: 65536,
  kFSEventStreamEventFlagItemIsDir: 131072,
  kFSEventStreamEventFlagItemIsSymlink: 262144
};
function watch$1(path2, handler) {
  return () => Promise.resolve();
}
function getInfo(path2, flags) {
  return {
    event: "unknown",
    path: path2,
    type: "file",
    changes: { inode: false, finder: false, access: false, xattrs: false },
    flags
  };
}
var fsevents = {
  watch: watch$1,
  getInfo,
  constants: constants$1
};
var fseventsShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  constants: constants$1,
  default: fsevents,
  getInfo,
  watch: watch$1
});
let globalVFS$1 = null;
function setVFS$1(vfs2) {
  globalVFS$1 = vfs2;
}
class ReaddirpStream {
  constructor(root2, options2 = {}) {
    __publicField(this, "options");
    __publicField(this, "root");
    __publicField(this, "entries", []);
    __publicField(this, "index", 0);
    __publicField(this, "collected", false);
    __publicField(this, "listeners", /* @__PURE__ */ new Map());
    this.root = root2;
    this.options = options2;
  }
  matchFilter(entry, filter2) {
    if (!filter2) return true;
    if (typeof filter2 === "function") {
      return filter2(entry);
    }
    const patterns = Array.isArray(filter2) ? filter2 : [filter2];
    for (const pattern of patterns) {
      if (pattern.startsWith("!")) {
        const posPattern = pattern.slice(1);
        if (this.matchGlob(entry.basename, posPattern)) {
          return false;
        }
      } else if (this.matchGlob(entry.basename, pattern)) {
        return true;
      }
    }
    return patterns.length === 0 || patterns.every((p) => p.startsWith("!"));
  }
  matchGlob(name2, pattern) {
    if (pattern === "*") return true;
    if (pattern.startsWith("*.")) {
      const ext2 = pattern.slice(1);
      return name2.endsWith(ext2);
    }
    if (pattern.endsWith("*")) {
      const prefix = pattern.slice(0, -1);
      return name2.startsWith(prefix);
    }
    return name2 === pattern;
  }
  collect(dir, depth, relativePath = "") {
    if (!globalVFS$1) return;
    if (this.options.depth !== void 0 && depth > this.options.depth) return;
    try {
      const entries = globalVFS$1.readdirSync(dir);
      for (const name2 of entries) {
        const fullPath = dir === "/" ? "/" + name2 : dir + "/" + name2;
        const relPath = relativePath ? relativePath + "/" + name2 : name2;
        try {
          const stats = globalVFS$1.statSync(fullPath);
          const isDir = stats.isDirectory();
          const entry = {
            path: relPath,
            fullPath,
            basename: name2,
            stats: this.options.alwaysStat ? stats : void 0,
            dirent: {
              isFile: () => !isDir,
              isDirectory: () => isDir,
              name: name2
            }
          };
          const type2 = this.options.type || "files";
          if (isDir) {
            if (!this.matchFilter(entry, this.options.directoryFilter)) {
              continue;
            }
            if (type2 === "directories" || type2 === "files_directories" || type2 === "all") {
              this.entries.push(entry);
            }
            this.collect(fullPath, depth + 1, relPath);
          } else {
            if (type2 === "files" || type2 === "files_directories" || type2 === "all") {
              if (this.matchFilter(entry, this.options.fileFilter)) {
                this.entries.push(entry);
              }
            }
          }
        } catch {
        }
      }
    } catch {
    }
  }
  // Async iterator
  async *[Symbol.asyncIterator]() {
    if (!this.collected) {
      this.collect(this.root, 0);
      this.collected = true;
    }
    for (const entry of this.entries) {
      yield entry;
    }
  }
  // Promise-based API
  async toArray() {
    if (!this.collected) {
      this.collect(this.root, 0);
      this.collected = true;
    }
    return [...this.entries];
  }
  // Stream-like API for compatibility
  on(event, callback) {
    if (event === "data") {
      setTimeout(async () => {
        if (!this.collected) {
          this.collect(this.root, 0);
          this.collected = true;
        }
        for (const entry of this.entries) {
          callback(entry);
        }
        this.emit("end");
      }, 0);
    }
    return this;
  }
  emit(event, ...args) {
    const handlers = this.listeners.get(event);
    if (handlers) {
      for (const handler of handlers) {
        handler(...args);
      }
    }
  }
  once(event, callback) {
    const wrapper = (...args) => {
      callback(...args);
      this.off(event, wrapper);
    };
    return this.on(event, wrapper);
  }
  off(event, callback) {
    const handlers = this.listeners.get(event);
    if (handlers) {
      const index2 = handlers.indexOf(callback);
      if (index2 !== -1) {
        handlers.splice(index2, 1);
      }
    }
    return this;
  }
}
function readdirp(root2, options2) {
  return new ReaddirpStream(root2, options2);
}
async function readdirpPromise(root2, options2) {
  const stream = new ReaddirpStream(root2, options2);
  return stream.toArray();
}
var readdirpShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ReaddirpStream,
  default: readdirp,
  readdirp,
  readdirpPromise,
  setVFS: setVFS$1
});
function createRequire$1(filename2) {
  return function require2(id2) {
    throw new Error(`Cannot find module '${id2}' from '${filename2}'`);
  };
}
const builtinModules$1 = [
  "assert",
  "buffer",
  "child_process",
  "cluster",
  "console",
  "constants",
  "crypto",
  "dgram",
  "dns",
  "domain",
  "events",
  "fs",
  "http",
  "https",
  "module",
  "net",
  "os",
  "path",
  "perf_hooks",
  "process",
  "punycode",
  "querystring",
  "readline",
  "repl",
  "stream",
  "string_decoder",
  "sys",
  "timers",
  "tls",
  "tty",
  "url",
  "util",
  "v8",
  "vm",
  "worker_threads",
  "zlib"
];
function isBuiltin(moduleName) {
  const name2 = moduleName.startsWith("node:") ? moduleName.slice(5) : moduleName;
  return builtinModules$1.includes(name2);
}
const _cache = {};
const _extensions = {
  ".js": () => {
  },
  ".json": () => {
  },
  ".node": () => {
  }
};
const _pathCache = {};
function syncBuiltinESMExports() {
}
const Module$1 = {
  createRequire: createRequire$1,
  builtinModules: builtinModules$1,
  isBuiltin,
  _cache,
  _extensions,
  _pathCache,
  syncBuiltinESMExports
};
var moduleShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Module: Module$1,
  _cache,
  _extensions,
  _pathCache,
  builtinModules: builtinModules$1,
  createRequire: createRequire$1,
  default: Module$1,
  isBuiltin,
  syncBuiltinESMExports
});
const performance$1 = globalThis.performance || {
  now: () => Date.now(),
  timeOrigin: Date.now(),
  mark: () => {
  },
  measure: () => {
  },
  getEntries: () => [],
  getEntriesByName: () => [],
  getEntriesByType: () => [],
  clearMarks: () => {
  },
  clearMeasures: () => {
  },
  clearResourceTimings: () => {
  }
};
class PerformanceObserver {
  constructor(callback) {
    __publicField(this, "callback");
    __publicField(this, "entryTypes", []);
    this.callback = callback;
  }
  observe(options2) {
    this.entryTypes = options2.entryTypes || (options2.type ? [options2.type] : []);
  }
  disconnect() {
    this.entryTypes = [];
  }
  takeRecords() {
    return [];
  }
}
__publicField(PerformanceObserver, "supportedEntryTypes", ["mark", "measure", "resource", "navigation"]);
class Histogram {
  constructor() {
    __publicField(this, "min", 0);
    __publicField(this, "max", 0);
    __publicField(this, "mean", 0);
    __publicField(this, "stddev", 0);
    __publicField(this, "percentiles", /* @__PURE__ */ new Map());
    __publicField(this, "exceeds", 0);
  }
  reset() {
    this.min = 0;
    this.max = 0;
    this.mean = 0;
    this.stddev = 0;
    this.percentiles.clear();
    this.exceeds = 0;
  }
  percentile(percentile) {
    return this.percentiles.get(percentile) || 0;
  }
}
function createHistogram() {
  return new Histogram();
}
function monitorEventLoopDelay(options2) {
  const histogram = new Histogram();
  return histogram;
}
var perf_hooks = {
  performance: performance$1,
  PerformanceObserver,
  createHistogram,
  monitorEventLoopDelay
};
var perfHooksShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Histogram,
  PerformanceObserver,
  createHistogram,
  default: perf_hooks,
  monitorEventLoopDelay,
  performance: performance$1
});
const isMainThread = true;
const parentPort = null;
const workerData = null;
const threadId = 0;
let Worker$1 = class Worker2 extends EventEmitter {
  constructor(filename2, options2) {
    super();
    __publicField(this, "threadId", 0);
    __publicField(this, "resourceLimits", {});
    console.warn("Worker threads are not fully supported in browser environment");
  }
  postMessage(value2, transferList) {
  }
  terminate() {
    return Promise.resolve(0);
  }
  ref() {
  }
  unref() {
  }
  getHeapSnapshot() {
    return Promise.resolve({});
  }
};
let MessageChannel$1 = class MessageChannel2 {
  constructor() {
    __publicField(this, "port1", new MessagePort());
    __publicField(this, "port2", new MessagePort());
  }
};
class MessagePort extends EventEmitter {
  postMessage(value2, transferList) {
  }
  start() {
  }
  close() {
  }
  ref() {
  }
  unref() {
  }
}
let BroadcastChannel$1 = class BroadcastChannel2 extends EventEmitter {
  constructor(name2) {
    super();
    __publicField(this, "name");
    this.name = name2;
  }
  postMessage(message) {
  }
  close() {
  }
  ref() {
  }
  unref() {
  }
};
function moveMessagePortToContext(port, contextifiedSandbox) {
  return port;
}
function receiveMessageOnPort(port) {
  return void 0;
}
const SHARE_ENV = Symbol.for("nodejs.worker_threads.SHARE_ENV");
function markAsUntransferable(object) {
}
function getEnvironmentData(key) {
  return void 0;
}
function setEnvironmentData(key, value2) {
}
var worker_threads = {
  isMainThread,
  parentPort,
  workerData,
  threadId,
  Worker: Worker$1,
  MessageChannel: MessageChannel$1,
  MessagePort,
  BroadcastChannel: BroadcastChannel$1,
  moveMessagePortToContext,
  receiveMessageOnPort,
  SHARE_ENV,
  markAsUntransferable,
  getEnvironmentData,
  setEnvironmentData
};
var workerThreadsShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BroadcastChannel: BroadcastChannel$1,
  MessageChannel: MessageChannel$1,
  MessagePort,
  SHARE_ENV,
  Worker: Worker$1,
  default: worker_threads,
  getEnvironmentData,
  isMainThread,
  markAsUntransferable,
  moveMessagePortToContext,
  parentPort,
  receiveMessageOnPort,
  setEnvironmentData,
  threadId,
  workerData
});
const ESBUILD_WASM_VERSION = "0.20.0";
const ROLLUP_BROWSER_VERSION = "4.9.0";
const ESBUILD_WASM_ESM_CDN = `https://esm.sh/esbuild-wasm@${ESBUILD_WASM_VERSION}`;
const ESBUILD_WASM_BINARY_CDN = `https://unpkg.com/esbuild-wasm@${ESBUILD_WASM_VERSION}/esbuild.wasm`;
const ESBUILD_WASM_BROWSER_CDN = `https://unpkg.com/esbuild-wasm@${ESBUILD_WASM_VERSION}/esm/browser.min.js`;
const ROLLUP_BROWSER_CDN = `https://esm.sh/@rollup/browser@${ROLLUP_BROWSER_VERSION}`;
const NODE_BUILTINS = /* @__PURE__ */ new Set([
  "assert",
  "buffer",
  "child_process",
  "cluster",
  "crypto",
  "dgram",
  "dns",
  "events",
  "fs",
  "http",
  "http2",
  "https",
  "net",
  "os",
  "path",
  "perf_hooks",
  "querystring",
  "readline",
  "stream",
  "string_decoder",
  "timers",
  "tls",
  "url",
  "util",
  "v8",
  "vm",
  "worker_threads",
  "zlib",
  "async_hooks",
  "inspector",
  "module",
  "process",
  "console",
  "constants",
  "domain",
  "punycode",
  "sys",
  "tty"
]);
const EXPORT_CONDITION_PRIORITY = ["module", "import", "require", "default"];
function resolveExportConditions(entry) {
  if (typeof entry === "string") {
    return entry;
  }
  if (typeof entry === "object" && entry !== null) {
    for (const condition of EXPORT_CONDITION_PRIORITY) {
      const conditionValue = entry[condition];
      if (conditionValue !== void 0) {
        const result = resolveExportConditions(conditionValue);
        if (result) {
          return result;
        }
      }
    }
  }
  return void 0;
}
function resolveNodeModuleImport(vfs2, importPath, extensions) {
  const pathParts = importPath.split("/");
  const isScoped = pathParts[0].startsWith("@");
  const moduleName = isScoped ? pathParts.slice(0, 2).join("/") : pathParts[0];
  const subPath = isScoped ? pathParts.slice(2).join("/") : pathParts.slice(1).join("/");
  let nodeModulesBase = "/node_modules/" + moduleName;
  if (!vfs2.existsSync(nodeModulesBase)) {
    nodeModulesBase = "/project/node_modules/" + moduleName;
    if (!vfs2.existsSync(nodeModulesBase)) {
      return null;
    }
  }
  const packageJsonPath = nodeModulesBase + "/package.json";
  if (!vfs2.existsSync(packageJsonPath)) {
    return null;
  }
  try {
    const packageJsonContent = vfs2.readFileSync(packageJsonPath, "utf8");
    const packageJson = JSON.parse(packageJsonContent);
    let resolvedPath2 = null;
    if (subPath) {
      resolvedPath2 = resolveSubpathImport(
        vfs2,
        packageJson,
        nodeModulesBase,
        subPath,
        extensions
      );
    } else {
      resolvedPath2 = resolveMainImport(
        vfs2,
        packageJson,
        nodeModulesBase,
        extensions
      );
    }
    if (resolvedPath2) {
      return { path: resolvedPath2, pluginData: { fromVFS: true } };
    }
  } catch {
  }
  return null;
}
function resolveSubpathImport(vfs2, packageJson, nodeModulesBase, subPath, extensions) {
  if (packageJson.exports && typeof packageJson.exports === "object") {
    const exportKey = "./" + subPath;
    const exportsMap = packageJson.exports;
    const exportEntry = exportsMap[exportKey];
    if (exportEntry) {
      const exportPath = resolveExportConditions(exportEntry);
      if (exportPath) {
        const resolvedPath2 = nodeModulesBase + "/" + exportPath.replace(/^\.\//, "");
        const foundPath = findVFSFile(vfs2, resolvedPath2, ["", ".js", ".ts", ".mjs"]);
        if (foundPath) {
          return foundPath;
        }
      }
    }
  }
  const directPath = nodeModulesBase + "/" + subPath;
  return findVFSFile(vfs2, directPath, extensions);
}
function resolveMainImport(vfs2, packageJson, nodeModulesBase, extensions) {
  if (packageJson.exports) {
    const mainExport = typeof packageJson.exports === "object" && !Array.isArray(packageJson.exports) ? packageJson.exports["."] || packageJson.exports : packageJson.exports;
    const exportPath = resolveExportConditions(mainExport);
    if (exportPath) {
      const resolvedPath22 = nodeModulesBase + "/" + exportPath.replace(/^\.\//, "");
      const foundPath = findVFSFile(vfs2, resolvedPath22, ["", ".js", ".ts", ".mjs"]);
      if (foundPath) {
        return foundPath;
      }
    }
  }
  const mainField = packageJson.module || packageJson.main || "index.js";
  const resolvedPath2 = nodeModulesBase + "/" + mainField.replace(/^\.\//, "");
  return findVFSFile(vfs2, resolvedPath2, extensions);
}
let esbuildInstance = null;
let initPromise = null;
let wasmURL = ESBUILD_WASM_BINARY_CDN;
let globalVFS = null;
function setVFS(vfs2) {
  globalVFS = vfs2;
}
function setWasmURL(url2) {
  wasmURL = url2;
}
async function initialize(options2) {
  if (esbuildInstance) {
    return;
  }
  if (typeof window !== "undefined" && window.__esbuild) {
    esbuildInstance = window.__esbuild;
    return;
  }
  if (typeof window !== "undefined" && window.__esbuildInitPromise) {
    await window.__esbuildInitPromise;
    if (window.__esbuild) {
      esbuildInstance = window.__esbuild;
      return;
    }
  }
  if (initPromise) {
    return initPromise;
  }
  initPromise = (async () => {
    try {
      const esbuild2 = await import(
        /* @vite-ignore */
        ESBUILD_WASM_BROWSER_CDN
      );
      await esbuild2.initialize({
        wasmURL: (options2 == null ? void 0 : options2.wasmURL) || wasmURL
      });
      esbuildInstance = esbuild2;
    } catch (error) {
      initPromise = null;
      throw new Error(`Failed to initialize esbuild-wasm: ${error}`);
    }
  })();
  return initPromise;
}
function isInitialized() {
  return esbuildInstance !== null;
}
async function transform(code2, options2) {
  if (!esbuildInstance) {
    await initialize();
  }
  if (!esbuildInstance) {
    throw new Error("esbuild not initialized");
  }
  return esbuildInstance.transform(code2, options2);
}
function transformSync(code2, options2) {
  if (!esbuildInstance) {
    throw new Error("esbuild not initialized. Call initialize() first.");
  }
  throw new Error("transformSync is not available in browser. Use transform() instead.");
}
async function transformToCommonJS(code2, options2) {
  const result = await transform(code2, {
    loader: (options2 == null ? void 0 : options2.loader) || "js",
    format: "cjs",
    target: "es2020"
  });
  return result.code;
}
function remapVFSPath(path2) {
  return path2;
}
function findVFSFile(vfs2, originalPath, extensions) {
  for (const ext2 of extensions) {
    const pathWithExt = originalPath + ext2;
    if (vfs2.existsSync(pathWithExt)) {
      try {
        if (!vfs2.statSync(pathWithExt).isDirectory()) {
          return pathWithExt;
        }
      } catch {
        return pathWithExt;
      }
    }
    const remapped = remapVFSPath(pathWithExt);
    if (remapped !== pathWithExt && vfs2.existsSync(remapped)) {
      try {
        if (!vfs2.statSync(remapped).isDirectory()) {
          return pathWithExt;
        }
      } catch {
        return pathWithExt;
      }
    }
  }
  return null;
}
function createVFSPlugin(externals) {
  if (!globalVFS) {
    return null;
  }
  const vfs2 = globalVFS;
  return {
    name: "vfs-loader",
    setup(build2) {
      const b = build2;
      function vfsResolved(foundPath) {
        if (foundPath.endsWith(".mjs") || foundPath.endsWith(".cjs")) {
          const jsPath = foundPath.slice(0, -4) + ".js";
          return { path: jsPath, pluginData: { fromVFS: true, realPath: foundPath } };
        }
        return { path: foundPath, pluginData: { fromVFS: true } };
      }
      b.onResolve({ filter: /.*/ }, (args) => {
        const { path: importPath, importer } = args;
        if (importPath.startsWith("node_modules/")) {
          return { external: true };
        }
        const extensions = ["", ".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs", ".json"];
        if (importPath.startsWith("/")) {
          const foundPath = findVFSFile(vfs2, importPath, extensions);
          if (foundPath) {
            return vfsResolved(foundPath);
          }
          return { external: true };
        }
        if (importPath.startsWith(".")) {
          let resolved = importPath;
          if (importer) {
            const importerDir = importer.substring(0, importer.lastIndexOf("/"));
            resolved = importerDir + "/" + importPath;
          }
          const parts = resolved.split("/").filter(Boolean);
          const normalized = [];
          for (const part of parts) {
            if (part === "..") {
              normalized.pop();
            } else if (part !== ".") {
              normalized.push(part);
            }
          }
          resolved = "/" + normalized.join("/");
          const foundPath = findVFSFile(vfs2, resolved, extensions);
          if (foundPath) {
            return vfsResolved(foundPath);
          }
          for (const ext2 of [".ts", ".tsx", ".js", ".jsx"]) {
            const indexPath = resolved + "/index" + ext2;
            const foundIndex = findVFSFile(vfs2, indexPath, [""]);
            if (foundIndex) {
              return vfsResolved(foundIndex);
            }
          }
        }
        if (externals && externals.some((ext2) => importPath === ext2 || importPath.startsWith(ext2 + "/"))) {
          return { external: true };
        }
        const resolution2 = resolveNodeModuleImport(vfs2, importPath, extensions);
        if (resolution2) {
          if (resolution2.path && (resolution2.path.endsWith(".mjs") || resolution2.path.endsWith(".cjs"))) {
            const jsPath = resolution2.path.slice(0, -4) + ".js";
            return { path: jsPath, pluginData: { ...resolution2.pluginData, realPath: resolution2.path } };
          }
          return resolution2;
        }
        const bareModule = importPath.replace(/^node:/, "");
        if (NODE_BUILTINS.has(bareModule)) {
          return { path: `/__node_stub__/${bareModule}`, namespace: "node-stub" };
        }
        return { external: true };
      });
      b.onLoad({ filter: /.*/, namespace: "node-stub" }, () => {
        return { contents: "module.exports = {};", loader: "js" };
      });
      b.onLoad({ filter: /^\/.*/ }, (args) => {
        var _a3;
        if (!((_a3 = args.pluginData) == null ? void 0 : _a3.fromVFS)) {
          return null;
        }
        try {
          const vfsPath = args.pluginData.realPath || args.path;
          let contents;
          const remappedPath = remapVFSPath(vfsPath);
          if (vfs2.existsSync(vfsPath)) {
            contents = vfs2.readFileSync(vfsPath, "utf8");
          } else if (remappedPath !== vfsPath && vfs2.existsSync(remappedPath)) {
            contents = vfs2.readFileSync(remappedPath, "utf8");
          } else {
            throw new Error(`File not found: ${vfsPath} (tried ${remappedPath})`);
          }
          const ext2 = args.path.substring(args.path.lastIndexOf("."));
          let loader = "ts";
          if (ext2 === ".tsx") loader = "tsx";
          else if (ext2 === ".js" || ext2 === ".mjs" || ext2 === ".cjs") loader = "js";
          else if (ext2 === ".jsx") loader = "jsx";
          else if (ext2 === ".json") loader = "json";
          return { contents, loader };
        } catch (err2) {
          return { errors: [{ text: `Failed to load ${args.path}: ${err2}` }] };
        }
      });
    }
  };
}
async function build(options2) {
  if (!esbuildInstance) {
    await initialize();
  }
  if (!esbuildInstance) {
    throw new Error("esbuild not initialized");
  }
  const vfsPlugin = createVFSPlugin(options2.external);
  const plugins = [...options2.plugins || []];
  if (vfsPlugin) {
    plugins.unshift(vfsPlugin);
  }
  let entryPoints = options2.entryPoints;
  if (entryPoints && globalVFS) {
    const absWorkingDir = options2.absWorkingDir || (typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/");
    entryPoints = entryPoints.map((ep2) => {
      if (ep2.includes("vfs:")) {
        const vfsIndex = ep2.indexOf("vfs:");
        ep2 = ep2.substring(vfsIndex + 4);
      }
      if (ep2.startsWith("/")) {
        return ep2;
      }
      if (ep2.startsWith("./")) {
        const base = absWorkingDir.endsWith("/") ? absWorkingDir.slice(0, -1) : absWorkingDir;
        const relative2 = ep2.slice(2);
        const resolved = base + "/" + relative2;
        return resolved;
      }
      if (ep2.startsWith("../")) {
        const base = absWorkingDir.endsWith("/") ? absWorkingDir.slice(0, -1) : absWorkingDir;
        const parts = base.split("/").filter(Boolean);
        parts.pop();
        const relative2 = ep2.slice(3);
        const resolved = "/" + parts.join("/") + "/" + relative2;
        return resolved;
      }
      return ep2;
    });
  }
  const resolvedAbsWorkingDir = options2.absWorkingDir || (typeof globalThis !== "undefined" && globalThis.process && typeof globalThis.process.cwd === "function" ? globalThis.process.cwd() : "/");
  const result = await esbuildInstance.build({
    ...options2,
    entryPoints,
    plugins,
    write: false,
    absWorkingDir: resolvedAbsWorkingDir
  });
  if (result.outputFiles) {
    for (const file of result.outputFiles) {
      if (file.path.includes("vfs:")) {
        file.path = file.path.replace(/vfs:/g, "");
      }
    }
  }
  if (result.metafile) {
    const meta = result.metafile;
    for (const key of ["inputs", "outputs"]) {
      const obj = meta[key];
      if (obj) {
        for (const k of Object.keys(obj)) {
          if (k.includes("vfs:")) {
            obj[k.replace(/vfs:/g, "")] = obj[k];
            delete obj[k];
          }
        }
      }
    }
  }
  return result;
}
function buildSync(_options3) {
  throw new Error("buildSync is not available in browser. Use build() instead.");
}
function version$1() {
  return "0.20.0";
}
async function context(_options3) {
  throw new Error("esbuild context API is not supported in browser");
}
var esbuild = {
  initialize,
  isInitialized,
  transform,
  transformSync,
  transformToCommonJS,
  build,
  buildSync,
  context,
  version: version$1,
  setWasmURL,
  setVFS
};
var esbuildShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  build,
  buildSync,
  context,
  default: esbuild,
  initialize,
  isInitialized,
  setVFS,
  setWasmURL,
  transform,
  transformSync,
  transformToCommonJS,
  version: version$1
});
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code2, set) {
  var pos = 65536;
  for (var i2 = 0; i2 < set.length; i2 += 2) {
    pos += set[i2];
    if (pos > code2) {
      return false;
    }
    pos += set[i2 + 1];
    if (pos >= code2) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart$1(code2, astral) {
  if (code2 < 65) {
    return code2 === 36;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes);
}
function isIdentifierChar(code2, astral) {
  if (code2 < 48) {
    return code2 === 36;
  }
  if (code2 < 58) {
    return true;
  }
  if (code2 < 65) {
    return false;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name2, prec) {
  return new TokenType(name2, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
var keywords$2 = {};
function kw(name2, options2) {
  if (options2 === void 0) options2 = {};
  options2.keyword = name2;
  return keywords$2[name2] = new TokenType(name2, options2);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code2) {
  return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
}
function nextLineBreak(code2, from, end) {
  if (end === void 0) end = code2.length;
  for (var i2 = from; i2 < end; i2++) {
    var next2 = code2.charCodeAt(i2);
    if (isNewLine(next2)) {
      return i2 < end - 1 && next2 === 13 && code2.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty$4 = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty$4.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code2) {
  if (code2 <= 65535) {
    return String.fromCharCode(code2);
  }
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options2 = {};
  for (var opt in defaultOptions) {
    options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options2.allowHashBang = options2.ecmaVersion >= 14;
  }
  if (isArray(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options2.onComment)) {
    options2.onComment = pushComment(options2, options2.onComment);
  }
  return options2;
}
function pushComment(options2, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options2.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment.range = [start, end];
    }
    array.push(comment);
  };
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
var Parser = function Parser2(options2, input, startPos) {
  this.options = options2 = getOptions(options2);
  this.sourceFile = options2.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options2.allowReserved !== true) {
    reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
    if (options2.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options2.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse2() {
  var node2 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node2);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
  for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
    var ref2 = this.scopeStack[i2];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
      return false;
    }
    if (flags & SCOPE_FUNCTION) {
      return (flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
    var ref2 = this.scopeStack[i2];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
      return true;
    }
  }
  return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend2() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i2 = 0; i2 < plugins.length; i2++) {
    cls = plugins[i2](cls);
  }
  return cls;
};
Parser.parse = function parse22(input, options2) {
  return new this(options2, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
  var parser = new this(options2, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options2) {
  return new this(options2, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match3 = literal.exec(this.input.slice(start));
    if (!match3) {
      return false;
    }
    if ((match3[1] || match3[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match3[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next2 = this.input.charAt(end);
      return next2 === ";" || next2 === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next2) || next2 === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match3[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type2) {
  if (this.type === type2) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name2) {
  return this.type === types$1.name && this.value === name2 && !this.containsEsc;
};
pp$9.eatContextual = function(name2) {
  if (!this.isContextual(name2)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name2) {
  if (!this.eatContextual(name2)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type2) {
  this.eat(type2) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node2) {
  var exports$1 = /* @__PURE__ */ Object.create(null);
  if (!node2.body) {
    node2.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports$1);
    node2.body.push(stmt);
  }
  if (this.inModule) {
    for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
      var name2 = list2[i2];
      this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node2.body);
  this.next();
  node2.sourceType = this.options.sourceType;
  return this.finishNode(node2, "Program");
};
var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
pp$8.isLet = function(context2) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context2) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart$1(nextCh, true)) {
    var pos = next2 + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next2, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next2)) && this.input.slice(next2, next2 + 8) === "function" && (next2 + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next2 + 8)) || after > 55295 && after < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next2 = this.pos + skip[0].length;
  if (lineBreak.test(this.input.slice(this.pos, next2))) {
    return false;
  }
  if (isAwaitUsing) {
    var awaitEndPos = next2 + 5, after;
    if (this.input.slice(next2, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
      return false;
    }
    skipWhiteSpace.lastIndex = awaitEndPos;
    var skipAfterUsing = skipWhiteSpace.exec(this.input);
    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
      return false;
    }
  }
  if (isFor) {
    var ofEndPos = next2 + 2, after$1;
    if (this.input.slice(next2, ofEndPos) === "of") {
      if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
        return false;
      }
    }
  }
  var ch2 = this.input.charCodeAt(next2);
  return isIdentifierStart$1(ch2, true) || ch2 === 92;
};
pp$8.isAwaitUsing = function(isFor) {
  return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
  return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context2, topLevel, exports$1) {
  var starttype = this.type, node2 = this.startNode(), kind;
  if (this.isLet(context2)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node2, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node2);
    case types$1._do:
      return this.parseDoStatement(node2);
    case types$1._for:
      return this.parseForStatement(node2);
    case types$1._function:
      if (context2 && (this.strict || context2 !== "if" && context2 !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node2, false, !context2);
    case types$1._class:
      if (context2) {
        this.unexpected();
      }
      return this.parseClass(node2, true);
    case types$1._if:
      return this.parseIfStatement(node2);
    case types$1._return:
      return this.parseReturnStatement(node2);
    case types$1._switch:
      return this.parseSwitchStatement(node2);
    case types$1._throw:
      return this.parseThrowStatement(node2);
    case types$1._try:
      return this.parseTryStatement(node2);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context2 && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node2, kind);
    case types$1._while:
      return this.parseWhileStatement(node2);
    case types$1._with:
      return this.parseWithStatement(node2);
    case types$1.braceL:
      return this.parseBlock(true, node2);
    case types$1.semi:
      return this.parseEmptyStatement(node2);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next2 = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next2);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node2, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports$1);
    default:
      if (this.isAsyncFunction()) {
        if (context2) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node2, true, !context2);
      }
      var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
      if (usingKind) {
        if (topLevel && this.options.sourceType === "script") {
          this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
        }
        if (usingKind === "await using") {
          if (!this.canAwait) {
            this.raise(this.start, "Await using cannot appear outside of async function");
          }
          this.next();
        }
        this.next();
        this.parseVar(node2, false, usingKind);
        this.semicolon();
        return this.finishNode(node2, "VariableDeclaration");
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node2, maybeName, expr, context2);
      } else {
        return this.parseExpressionStatement(node2, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node2, keyword2) {
  var isBreak = keyword2 === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node2.label = this.parseIdent();
    this.semicolon();
  }
  var i2 = 0;
  for (; i2 < this.labels.length; ++i2) {
    var lab = this.labels[i2];
    if (node2.label == null || lab.name === node2.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node2.label && isBreak) {
        break;
      }
    }
  }
  if (i2 === this.labels.length) {
    this.raise(node2.start, "Unsyntactic " + keyword2);
  }
  return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node2) {
  this.next();
  this.semicolon();
  return this.finishNode(node2, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node2) {
  this.next();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node2.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node2, "DoWhileStatement");
};
pp$8.parseForStatement = function(node2) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    return this.parseForAfterInit(node2, init$1, awaitAt);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
  if (usingKind) {
    var init$2 = this.startNode();
    this.next();
    if (usingKind === "await using") {
      this.next();
    }
    this.parseVar(init$2, true, usingKind);
    this.finishNode(init$2, "VariableDeclaration");
    return this.parseForAfterInit(node2, init$2, awaitAt);
  }
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init2 = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node2.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init2.start === initPos && !containsEsc && init2.type === "Identifier" && init2.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node2.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init2, false, refDestructuringErrors);
    this.checkLValPattern(init2);
    return this.parseForIn(node2, init2);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node2, init2);
};
pp$8.parseForAfterInit = function(node2, init2, awaitAt) {
  if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init2.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node2.await = awaitAt > -1;
      }
    }
    return this.parseForIn(node2, init2);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node2, init2);
};
pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  node2.consequent = this.parseStatement("if");
  node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node2, "IfStatement");
};
pp$8.parseReturnStatement = function(node2) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.argument = null;
  } else {
    node2.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node2, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node2) {
  this.next();
  node2.discriminant = this.parseParenExpression();
  node2.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node2.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node2, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node2) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node2.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node2, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node2) {
  this.next();
  node2.block = this.parseBlock();
  node2.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node2.handler = this.finishNode(clause, "CatchClause");
  }
  node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node2.handler && !node2.finalizer) {
    this.raise(node2.start, "Missing catch or finally clause");
  }
  return this.finishNode(node2, "TryStatement");
};
pp$8.parseVarStatement = function(node2, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node2, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node2, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node2, "WhileStatement");
};
pp$8.parseWithStatement = function(node2) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node2.object = this.parseParenExpression();
  node2.body = this.parseStatement("with");
  return this.finishNode(node2, "WithStatement");
};
pp$8.parseEmptyStatement = function(node2) {
  this.next();
  return this.finishNode(node2, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node2, maybeName, expr, context2) {
  for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
    var label = list2[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
    var label$1 = this.labels[i2];
    if (label$1.statementStart === node2.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node2.body = this.parseStatement(context2 ? context2.indexOf("label") === -1 ? context2 + "label" : context2 : "label");
  this.labels.pop();
  node2.label = expr;
  return this.finishNode(node2, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node2, expr) {
  node2.expression = expr;
  this.semicolon();
  return this.finishNode(node2, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node2 === void 0) node2 = this.startNode();
  node2.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node2, "BlockStatement");
};
pp$8.parseFor = function(node2, init2) {
  node2.init = init2;
  this.expect(types$1.semi);
  node2.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node2.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, "ForStatement");
};
pp$8.parseForIn = function(node2, init2) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init2.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node2.left = init2;
  node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node2, isFor, kind, allowMissingInitializer) {
  node2.declarations = [];
  node2.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
      this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node2;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node2.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node2.async, node2.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node2.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node2);
  this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node2) {
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node2, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node2, isStatement);
  this.parseClassSuper(node2);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node2.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node2.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion2 = this.options.ecmaVersion;
  var node2 = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node2);
      return node2;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node2.static = isStatic;
  if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node2.computed = false;
    node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node2.key.name = keyName;
    this.finishNode(node2.key, "Identifier");
  } else {
    this.parseClassElementName(node2);
  }
  if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node2.static && checkKeyName(node2, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node2.key.start, "Constructor can't have get/set modifier");
    }
    node2.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node2);
  }
  return node2;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value2.params.length !== 0) {
    this.raiseRecoverable(value2.start, "getter should have no params");
  }
  if (method.kind === "set" && value2.params.length !== 1) {
    this.raiseRecoverable(value2.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value2.params[0].type === "RestElement") {
    this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node2) {
  node2.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node2, "StaticBlock");
};
pp$8.parseClassId = function(node2, isStatement) {
  if (this.type === types$1.name) {
    node2.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node2.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node2.id = null;
  }
};
pp$8.parseClassSuper = function(node2) {
  node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i2 = 0; i2 < used.length; ++i2) {
    var id2 = used[i2];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name2 = element.key.name;
  var curr = privateNameMap[name2];
  var next2 = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next2 = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next2 === "iset" || curr === "iset" && next2 === "iget" || curr === "sget" && next2 === "sset" || curr === "sset" && next2 === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next2;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node2, name2) {
  var computed = node2.computed;
  var key = node2.key;
  return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
}
pp$8.parseExportAllDeclaration = function(node2, exports$1) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node2.exported = this.parseModuleExportName();
      this.checkExport(exports$1, node2.exported, this.lastTokStart);
    } else {
      node2.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node2.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node2.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node2, "ExportAllDeclaration");
};
pp$8.parseExport = function(node2, exports$1) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node2, exports$1);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports$1, "default", this.lastTokStart);
    node2.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node2, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node2.declaration = this.parseExportDeclaration(node2);
    if (node2.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports$1, node2.declaration.declarations);
    } else {
      this.checkExport(exports$1, node2.declaration.id, node2.declaration.id.start);
    }
    node2.specifiers = [];
    node2.source = null;
    if (this.options.ecmaVersion >= 16) {
      node2.attributes = [];
    }
  } else {
    node2.declaration = null;
    node2.specifiers = this.parseExportSpecifiers(exports$1);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node2.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node2.attributes = this.parseWithClause();
      }
    } else {
      for (var i2 = 0, list2 = node2.specifiers; i2 < list2.length; i2 += 1) {
        var spec2 = list2[i2];
        this.checkUnreserved(spec2.local);
        this.checkLocalExport(spec2.local);
        if (spec2.local.type === "Literal") {
          this.raise(spec2.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node2.source = null;
      if (this.options.ecmaVersion >= 16) {
        node2.attributes = [];
      }
    }
    this.semicolon();
  }
  return this.finishNode(node2, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node2) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports$1, name2, pos) {
  if (!exports$1) {
    return;
  }
  if (typeof name2 !== "string") {
    name2 = name2.type === "Identifier" ? name2.name : name2.value;
  }
  if (hasOwn(exports$1, name2)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
  }
  exports$1[name2] = true;
};
pp$8.checkPatternExport = function(exports$1, pat) {
  var type2 = pat.type;
  if (type2 === "Identifier") {
    this.checkExport(exports$1, pat, pat.start);
  } else if (type2 === "ObjectPattern") {
    for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
      var prop = list2[i2];
      this.checkPatternExport(exports$1, prop);
    }
  } else if (type2 === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports$1, elt);
      }
    }
  } else if (type2 === "Property") {
    this.checkPatternExport(exports$1, pat.value);
  } else if (type2 === "AssignmentPattern") {
    this.checkPatternExport(exports$1, pat.left);
  } else if (type2 === "RestElement") {
    this.checkPatternExport(exports$1, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports$1, decls) {
  if (!exports$1) {
    return;
  }
  for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
    var decl = list2[i2];
    this.checkPatternExport(exports$1, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports$1) {
  var node2 = this.startNode();
  node2.local = this.parseModuleExportName();
  node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
  this.checkExport(
    exports$1,
    node2.exported,
    node2.exported.start
  );
  return this.finishNode(node2, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports$1) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports$1));
  }
  return nodes;
};
pp$8.parseImport = function(node2) {
  this.next();
  if (this.type === types$1.string) {
    node2.specifiers = empty$1;
    node2.source = this.parseExprAtom();
  } else {
    node2.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node2.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node2, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node2 = this.startNode();
  node2.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node2.local = this.parseIdent();
  } else {
    this.checkUnreserved(node2.imported);
    node2.local = node2.imported;
  }
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node2 = this.startNode();
  node2.local = this.parseIdent();
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node2 = this.startNode();
  this.next();
  this.expectContextual("as");
  node2.local = this.parseIdent();
  this.checkLValSimple(node2.local, BIND_LEXICAL);
  return this.finishNode(node2, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node2 = this.startNode();
  node2.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node2.value = this.parseExprAtom();
  return this.finishNode(node2, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
    statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node2) {
    switch (node2.type) {
      case "Identifier":
        if (this.inAsync && node2.name === "await") {
          this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node2.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i2 = 0, list2 = node2.properties; i2 < list2.length; i2 += 1) {
          var prop = list2[i2];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node2.kind !== "init") {
          this.raise(node2.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node2.value, isBinding);
        break;
      case "ArrayExpression":
        node2.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node2.elements, isBinding);
        break;
      case "SpreadElement":
        node2.type = "RestElement";
        this.toAssignable(node2.argument, isBinding);
        if (node2.argument.type === "AssignmentPattern") {
          this.raise(node2.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node2.operator !== "=") {
          this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node2.type = "AssignmentPattern";
        delete node2.operator;
        this.toAssignable(node2.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node2.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node2;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i2 = 0; i2 < end; i2++) {
    var elt = exprList[i2];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node2, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node2.argument = this.parseBindingAtom();
  return this.finishNode(node2, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node2 = this.startNode();
        this.next();
        node2.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node2, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.right = this.parseMaybeAssign();
  return this.finishNode(node2, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
        var prop = list2[i2];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
    var context2 = this.context[i2];
    if (context2.token === "function") {
      return context2.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type2 = this.type;
  if (type2.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type2.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type2.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types.f_expr) {
      this.context[index2] = types.f_expr_gen;
    } else {
      this.context[index2] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name2;
  switch (key.type) {
    case "Identifier":
      name2 = key.name;
      break;
    case "Literal":
      name2 = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name2 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name2 = "$" + name2;
  var other = propHash[name2];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name2] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node2, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node2.left = left;
    this.next();
    node2.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node2, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.test = expr;
    node2.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node2.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node2, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op2 = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op2, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op2, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.operator = op2;
  node2.right = right;
  return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node2 = this.startNode(), update = this.type === types$1.incDec;
    node2.operator = this.value;
    node2.prefix = true;
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node2.argument);
    } else if (this.strict && node2.operator === "delete" && isLocalVariableAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
    } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$12 = this.startNodeAt(startPos, startLoc);
      node$12.operator = this.value;
      node$12.prefix = false;
      node$12.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$12, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node2) {
  return node2.type === "Identifier" || node2.type === "ParenthesizedExpression" && isLocalVariableAccess(node2.expression);
}
function isPrivateFieldAccess(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression) || node2.type === "ParenthesizedExpression" && isPrivateFieldAccess(node2.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base = element;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.object = base;
    if (computed) {
      node2.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node2.property = this.parsePrivateIdent();
    } else {
      node2.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node2.computed = !!computed;
    if (optionalSupported) {
      node2.optional = optional;
    }
    base = this.finishNode(node2, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$12 = this.startNodeAt(startPos, startLoc);
    node$12.callee = base;
    node$12.arguments = exprList;
    if (optionalSupported) {
      node$12.optional = optional;
    }
    base = this.finishNode(node$12, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node2, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node2 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node2.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node2, "Super");
    case types$1._this:
      node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value2 = this.value;
      node2 = this.parseLiteral(value2.value);
      node2.regex = { pattern: value2.pattern, flags: value2.flags };
      return node2;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node2 = this.startNode();
      node2.value = this.type === types$1._null ? null : this.type === types$1._true;
      node2.raw = this.type.keyword;
      this.next();
      return this.finishNode(node2, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node2, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node2 = this.startNode();
      this.next();
      return this.parseFunction(node2, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node2 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node2);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
    meta.name = "import";
    node2.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node2);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node2) {
  this.next();
  node2.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node2.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node2.options = null;
      }
    } else {
      node2.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node2, "ImportExpression");
};
pp$5.parseImportMeta = function(node2) {
  this.next();
  var containsEsc = this.containsEsc;
  node2.property = this.parseIdent(true);
  if (node2.property.name !== "meta") {
    this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node2, "MetaProperty");
};
pp$5.parseLiteral = function(value2) {
  var node2 = this.startNode();
  node2.value = value2;
  node2.raw = this.input.slice(this.start, this.end);
  if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
    node2.bigint = node2.value != null ? node2.value.toString() : node2.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node2, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
    meta.name = "new";
    node2.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "target") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node2, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node2.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node2.arguments = empty;
  }
  return this.finishNode(node2, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node2 = this.startNode();
  this.next();
  node2.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node2.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node2.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node2, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node2 = this.startNode(), first = true, propHash = {};
  node2.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node2.properties.push(prop);
  }
  return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  var kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  prop.kind = kind;
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
    prop.kind = "init";
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.kind = "init";
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node2) {
  node2.id = null;
  if (this.options.ecmaVersion >= 6) {
    node2.generator = node2.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 6) {
    node2.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node2, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node2.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node2, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node2.body = this.parseMaybeAssign(forInit);
    node2.expression = true;
    this.checkParams(node2, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
    if (this.strict && node2.id) {
      this.checkLValSimple(node2.id, BIND_OUTSIDE);
    }
    node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node2.expression = false;
    this.adaptDirectivePrologue(node2.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
    var param = list2[i2];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node2, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i2 = 0, list2 = node2.params; i2 < list2.length; i2 += 1) {
    var param = list2[i2];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close2)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name2 = ref2.name;
  if (this.inGenerator && name2 === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name2 === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name2 === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
    this.raise(start, "Cannot use " + name2 + " in class static initialization block");
  }
  if (this.keywords.test(name2)) {
    this.raise(start, "Unexpected keyword '" + name2 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re2.test(name2)) {
    if (!this.inAsync && name2 === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node2 = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node2, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node2);
    if (node2.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node2.start;
    }
  }
  return node2;
};
pp$5.parseIdentNode = function() {
  var node2 = this.startNode();
  if (this.type === types$1.name) {
    node2.name = this.value;
  } else if (this.type.keyword) {
    node2.name = this.type.keyword;
    if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node2;
};
pp$5.parsePrivateIdent = function() {
  var node2 = this.startNode();
  if (this.type === types$1.privateId) {
    node2.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node2, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
    }
  }
  return node2;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node2.delegate = false;
    node2.argument = null;
  } else {
    node2.delegate = this.eat(types$1.star);
    node2.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node2, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node2, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message += " in " + this.sourceFile;
  }
  var err2 = new SyntaxError(message);
  err2.pos = pos;
  err2.loc = loc;
  err2.raisedAt = this.pos;
  throw err2;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope$1 = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope$1(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope2) {
  return scope2.flags & SCOPE_FUNCTION || !this.inModule && scope2.flags & SCOPE_TOP;
};
pp$3.declareName = function(name2, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope2 = this.currentScope();
    redeclared = scope2.lexical.indexOf(name2) > -1 || scope2.functions.indexOf(name2) > -1 || scope2.var.indexOf(name2) > -1;
    scope2.lexical.push(name2);
    if (this.inModule && scope2.flags & SCOPE_TOP) {
      delete this.undefinedExports[name2];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$12 = this.currentScope();
    scope$12.lexical.push(name2);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name2) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
    }
    scope$2.functions.push(name2);
  } else {
    for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
      var scope$3 = this.scopeStack[i2];
      if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name2);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope2 = this.scopeStack[i2];
    if (scope2.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
      return scope2;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope2 = this.scopeStack[i2];
    if (scope2.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope2.flags & SCOPE_ARROW)) {
      return scope2;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node2, type2, pos, loc) {
  node2.type = type2;
  node2.end = pos;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos;
  }
  return node2;
}
pp$2.finishNode = function(node2, type2) {
  return finishNodeAt.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node2, type2, pos, loc) {
  return finishNodeAt.call(this, node2, type2, pos, loc);
};
pp$2.copyNode = function(node2) {
  var newNode = new Node(this, node2.start, this.startLoc);
  for (var prop in node2) {
    newNode[prop] = node2[prop];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion2) {
  var d = data[ecmaVersion2] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
  var ecmaVersion = list[i];
  buildUnicodeData(ecmaVersion);
}
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base) {
  this.parent = parent;
  this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self = this; self; self = self.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self.base === other.base && self !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i2, forceU) {
  if (forceU === void 0) forceU = false;
  var s2 = this.source;
  var l = s2.length;
  if (i2 >= l) {
    return -1;
  }
  var c = s2.charCodeAt(i2);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
    return c;
  }
  var next2 = s2.charCodeAt(i2 + 1);
  return next2 >= 56320 && next2 <= 57343 ? (c << 10) + next2 - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
  if (forceU === void 0) forceU = false;
  var s2 = this.source;
  var l = s2.length;
  if (i2 >= l) {
    return l;
  }
  var c = s2.charCodeAt(i2), next2;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next2 = s2.charCodeAt(i2 + 1)) < 56320 || next2 > 57343) {
    return i2 + 1;
  }
  return i2 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch2, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch2) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0) forceU = false;
  var pos = this.pos;
  for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
    var ch2 = list2[i2];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch2) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v2 = false;
  for (var i2 = 0; i2 < flags.length; i2++) {
    var flag = flags.charAt(i2);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i2 + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v2 = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v2) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _2 in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = /* @__PURE__ */ Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
    var name2 = list2[i2];
    if (!state.groupNames[name2]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(
          45
          /* - */
        );
        if (addModifiers || hasHyphen) {
          for (var i2 = 0; i2 < addModifiers.length; i2++) {
            var modifier = addModifiers.charAt(i2);
            if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers = "";
  var ch2 = 0;
  while ((ch2 = state.current()) !== -1 && isRegularExpressionModifier(ch2)) {
    modifiers += codePointToString(ch2);
    state.advance();
  }
  return modifiers;
};
function isRegularExpressionModifier(ch2) {
  return ch2 === 105 || ch2 === 109 || ch2 === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch2 = state.current();
  if (isSyntaxCharacter(ch2)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch2) {
  return ch2 === 36 || ch2 >= 40 && ch2 <= 43 || ch2 === 46 || ch2 === 63 || ch2 >= 91 && ch2 <= 94 || ch2 >= 123 && ch2 <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch2 = 0;
  while ((ch2 = state.current()) !== -1 && !isSyntaxCharacter(ch2)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch2 = state.current();
  if (ch2 !== -1 && ch2 !== 36 && !(ch2 >= 40 && ch2 <= 43) && ch2 !== 46 && ch2 !== 63 && ch2 !== 91 && ch2 !== 94 && ch2 !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
          var altID = list2[i2];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch2 = state.current(forceU);
  state.advance(forceU);
  if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch2 = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch2)) {
    state.lastIntValue = ch2;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch2) {
  return isIdentifierStart$1(ch2, true) || ch2 === 36 || ch2 === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch2 = state.current(forceU);
  state.advance(forceU);
  if (ch2 === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch2 = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch2)) {
    state.lastIntValue = ch2;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch2) {
  return isIdentifierChar(ch2, true) || ch2 === 36 || ch2 === 95 || ch2 === 8204 || ch2 === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch2 = state.current();
  if (ch2 === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch2 === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch2 === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch2 === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch2 === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch2 = state.current();
  if (isControlLetter(ch2)) {
    state.lastIntValue = ch2 % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch2) {
  return ch2 >= 65 && ch2 <= 90 || ch2 >= 97 && ch2 <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0) forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch2) {
  return ch2 >= 0 && ch2 <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch2 = state.current();
  if (ch2 !== 99 && (!state.switchN || ch2 !== 107)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch2 = state.current();
  if (ch2 >= 49 && ch2 <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
      state.advance();
    } while ((ch2 = state.current()) >= 48 && ch2 <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch2 = state.current();
  if (isCharacterClassEscape(ch2)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch2 === 80) || ch2 === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch2) {
  return ch2 === 100 || ch2 === 68 || ch2 === 115 || ch2 === 83 || ch2 === 119 || ch2 === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name2 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value2 = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name2, value2);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value2) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name2].test(value2)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch2 = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch2 = state.current())) {
    state.lastStringValue += codePointToString(ch2);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch2) {
  return isControlLetter(ch2) || ch2 === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch2 = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch2 = state.current())) {
    state.lastStringValue += codePointToString(ch2);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch2) {
  return isUnicodePropertyNameCharacter(ch2) || isDecimalDigit(ch2);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch2 = state.current();
  if (ch2 !== 93) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch2 = state.current();
  if (ch2 < 0 || ch2 === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch2)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch2)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch2;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch2) {
  return ch2 === 33 || ch2 >= 35 && ch2 <= 38 || ch2 >= 42 && ch2 <= 44 || ch2 === 46 || ch2 >= 58 && ch2 <= 64 || ch2 === 94 || ch2 === 96 || ch2 === 126;
}
function isClassSetSyntaxCharacter(ch2) {
  return ch2 === 40 || ch2 === 41 || ch2 === 45 || ch2 === 47 || ch2 >= 91 && ch2 <= 93 || ch2 >= 123 && ch2 <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch2 = state.current();
  if (isClassSetReservedPunctuator(ch2)) {
    state.lastIntValue = ch2;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch2) {
  return ch2 === 33 || ch2 === 35 || ch2 === 37 || ch2 === 38 || ch2 === 44 || ch2 === 45 || ch2 >= 58 && ch2 <= 62 || ch2 === 64 || ch2 === 96 || ch2 === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch2 = state.current();
  if (isDecimalDigit(ch2) || ch2 === 95) {
    state.lastIntValue = ch2 % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch2 = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch2 = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch2 - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch2 = 0;
  state.lastIntValue = 0;
  while (isHexDigit$1(ch2 = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit$1(ch2) {
  return ch2 >= 48 && ch2 <= 57 || ch2 >= 65 && ch2 <= 70 || ch2 >= 97 && ch2 <= 102;
}
function hexToInt(ch2) {
  if (ch2 >= 65 && ch2 <= 70) {
    return 10 + (ch2 - 65);
  }
  if (ch2 >= 97 && ch2 <= 102) {
    return 10 + (ch2 - 97);
  }
  return ch2 - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n12 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n12 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n12 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n12 * 8 + n2;
      }
    } else {
      state.lastIntValue = n12;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch2 = state.current();
  if (isOctalDigit(ch2)) {
    state.lastIntValue = ch2 - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length2) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i2 = 0; i2 < length2; ++i2) {
    var ch2 = state.current();
    if (!isHexDigit$1(ch2)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch2);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code2) {
  if (isIdentifierStart$1(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code2);
};
pp.fullCharCodeAtPos = function() {
  var code2 = this.input.charCodeAt(this.pos);
  if (code2 <= 55295 || code2 >= 56320) {
    return code2;
  }
  var next2 = this.input.charCodeAt(this.pos + 1);
  return next2 <= 56319 || next2 >= 57344 ? code2 : (code2 << 10) + next2 - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch2 = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch2)) {
    ch2 = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch2 = this.input.charCodeAt(this.pos);
    switch (ch2) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch2 > 8 && ch2 < 14 || ch2 >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch2))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type2, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type2;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 >= 48 && next2 <= 57) {
    return this.readNumber(true);
  }
  var next22 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next2 === 46 && next22 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code2 === 42 && next2 === 42) {
    ++size;
    tokentype = types$1.starstar;
    next2 = this.input.charCodeAt(this.pos + 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code2) {
    if (this.options.ecmaVersion >= 12) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === code2) {
    if (next2 === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next2 === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next2 === code2) {
    size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next2 === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next2 === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code2) {
  var next2 = this.input.charCodeAt(this.pos + 1);
  if (next2 === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code2 === 61 && next2 === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  if (ecmaVersion2 >= 11) {
    var next2 = this.input.charCodeAt(this.pos + 1);
    if (next2 === 46) {
      var next22 = this.input.charCodeAt(this.pos + 2);
      if (next22 < 48 || next22 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next2 === 63) {
      if (ecmaVersion2 >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  var code2 = 35;
  if (ecmaVersion2 >= 13) {
    ++this.pos;
    code2 = this.fullCharCodeAtPos();
    if (isIdentifierStart$1(code2, true) || code2 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.getTokenFromCode = function(code2) {
  switch (code2) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next2 = this.input.charCodeAt(this.pos + 1);
      if (next2 === 120 || next2 === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next2 === 111 || next2 === 79) {
          return this.readRadixNumber(8);
        }
        if (next2 === 98 || next2 === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code2);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code2);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code2);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code2);
    case 60:
    case 62:
      return this.readToken_lt_gt(code2);
    case 61:
    case 33:
      return this.readToken_eq_excl(code2);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.finishOp = function(type2, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type2, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch2 = this.input.charAt(this.pos);
    if (lineBreak.test(ch2)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch2 === "[") {
        inClass = true;
      } else if (ch2 === "]" && inClass) {
        inClass = false;
      } else if (ch2 === "/" && !inClass) {
        break;
      }
      escaped = ch2 === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value2 = null;
  try {
    value2 = new RegExp(pattern, flags);
  } catch (e2) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i2 = 0, e2 = len == null ? Infinity : len; i2 < e2; ++i2, ++this.pos) {
    var code2 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code2 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i2 === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code2;
      continue;
    }
    if (code2 >= 97) {
      val = code2 - 97 + 10;
    } else if (code2 >= 65) {
      val = code2 - 65 + 10;
    } else if (code2 >= 48 && code2 <= 57) {
      val = code2 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code2;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart$1(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next2 = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next2 === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart$1(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next2 === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next2 = this.input.charCodeAt(this.pos);
  }
  if ((next2 === 69 || next2 === 101) && !octal) {
    next2 = this.input.charCodeAt(++this.pos);
    if (next2 === 43 || next2 === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart$1(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch2 = this.input.charCodeAt(this.pos), code2;
  if (ch2 === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code2 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code2 = this.readHexChar(4);
  }
  return code2;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch2 = this.input.charCodeAt(this.pos);
    if (ch2 === quote) {
      break;
    }
    if (ch2 === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch2 === 8232 || ch2 === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch2)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err2) {
    if (err2 === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err2;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch2 = this.input.charCodeAt(this.pos);
    if (ch2 === 96 || ch2 === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch2 === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch2 === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch2)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch2) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch2);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === "\n") {
          ++this.pos;
        }
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch2 = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch2) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch2 >= 48 && ch2 <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch2 = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch2 === 56 || ch2 === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch2)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch2);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch2 = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch2, astral)) {
      this.pos += ch2 <= 65535 ? 1 : 2;
    } else if (ch2 === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart$1 : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type2 = types$1.name;
  if (this.keywords.test(word)) {
    type2 = keywords$2[word];
  }
  return this.finishToken(type2, word);
};
var version = "8.15.0";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords$2,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart: isIdentifierStart$1,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options2) {
  return Parser.parse(input, options2);
}
let rollupInstance = null;
let loadPromise = null;
async function loadRollup() {
  if (rollupInstance) return rollupInstance;
  if (loadPromise) return loadPromise;
  loadPromise = (async () => {
    try {
      const rollup2 = await import(
        /* @vite-ignore */
        ROLLUP_BROWSER_CDN
      );
      rollupInstance = rollup2;
      console.log("[rollup] Browser version loaded");
      return rollup2;
    } catch (error) {
      console.error("[rollup] Failed to load browser version:", error);
      loadPromise = null;
      throw error;
    }
  })();
  return loadPromise;
}
const VERSION = ROLLUP_BROWSER_VERSION;
async function rollup(options2) {
  const r2 = await loadRollup();
  return r2.rollup(options2);
}
async function watch(options2) {
  const r2 = await loadRollup();
  return r2.watch(options2);
}
function parseAst(input, options2) {
  return parse3(input, {
    ecmaVersion: "latest",
    sourceType: "module",
    allowReturnOutsideFunction: (options2 == null ? void 0 : options2.allowReturnOutsideFunction) ?? false,
    locations: true
  });
}
async function parseAstAsync(input, options2) {
  return parseAst(input, options2);
}
function getPackageBase() {
  return "";
}
var rollup_default = {
  VERSION,
  rollup,
  watch,
  loadRollup,
  parseAst,
  parseAstAsync
};
var rollupShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  VERSION,
  default: rollup_default,
  getPackageBase,
  loadRollup,
  parseAst,
  parseAstAsync,
  rollup,
  watch
});
function getHeapStatistics() {
  return {
    total_heap_size: 0,
    total_heap_size_executable: 0,
    total_physical_size: 0,
    total_available_size: 0,
    used_heap_size: 0,
    heap_size_limit: 0,
    malloced_memory: 0,
    peak_malloced_memory: 0,
    does_zap_garbage: 0,
    number_of_native_contexts: 0,
    number_of_detached_contexts: 0
  };
}
function getHeapSpaceStatistics() {
  return [];
}
function getHeapCodeStatistics() {
  return {
    code_and_metadata_size: 0,
    bytecode_and_metadata_size: 0,
    external_script_source_size: 0
  };
}
function getHeapSnapshot() {
  return null;
}
function writeHeapSnapshot() {
  return "";
}
function setFlagsFromString(_flags) {
}
function takeCoverage() {
}
function stopCoverage() {
}
function serialize(value2) {
  const json = JSON.stringify(value2);
  return Buffer.from(json);
}
function deserialize(buffer) {
  return JSON.parse(buffer.toString());
}
class Serializer {
  writeHeader() {
  }
  writeValue(_value) {
  }
  releaseBuffer() {
    return Buffer.from("");
  }
}
class Deserializer {
  constructor(_buffer) {
  }
  readHeader() {
    return true;
  }
  readValue() {
    return null;
  }
}
class DefaultSerializer extends Serializer {
}
class DefaultDeserializer extends Deserializer {
}
function promiseHooks() {
  return {
    onInit: () => {
    },
    onSettled: () => {
    },
    onBefore: () => {
    },
    onAfter: () => {
    },
    createHook: () => ({ enable: () => {
    }, disable: () => {
    } })
  };
}
var v8 = {
  getHeapStatistics,
  getHeapSpaceStatistics,
  getHeapCodeStatistics,
  getHeapSnapshot,
  writeHeapSnapshot,
  setFlagsFromString,
  takeCoverage,
  stopCoverage,
  serialize,
  deserialize,
  Serializer,
  Deserializer,
  DefaultSerializer,
  DefaultDeserializer,
  promiseHooks
};
var v8Shim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DefaultDeserializer,
  DefaultSerializer,
  Deserializer,
  Serializer,
  default: v8,
  deserialize,
  getHeapCodeStatistics,
  getHeapSnapshot,
  getHeapSpaceStatistics,
  getHeapStatistics,
  promiseHooks,
  serialize,
  setFlagsFromString,
  stopCoverage,
  takeCoverage,
  writeHeapSnapshot
});
class Interface extends EventEmitter {
  constructor(_options3) {
    super();
    __publicField(this, "promptText");
    __publicField(this, "line", "");
    __publicField(this, "cursor", 0);
    this.promptText = (_options3 == null ? void 0 : _options3.prompt) ?? "";
  }
  prompt(_preserveCursor) {
  }
  setPrompt(prompt) {
    this.promptText = prompt;
  }
  getPrompt() {
    return this.promptText;
  }
  question(_query, callback) {
    setTimeout(() => callback(""), 0);
  }
  pause() {
    return this;
  }
  resume() {
    return this;
  }
  close() {
    this.emit("close");
  }
  write(_data, _key) {
  }
  getCursorPos() {
    return { rows: 0, cols: 0 };
  }
}
function createInterface(options2) {
  return new Interface(options2);
}
function clearLine(_stream, _dir, _callback) {
  _callback == null ? void 0 : _callback();
  return true;
}
function clearScreenDown(_stream, _callback) {
  _callback == null ? void 0 : _callback();
  return true;
}
function cursorTo(_stream, _x2, _y2, _callback) {
  _callback == null ? void 0 : _callback();
  return true;
}
function moveCursor(_stream, _dx, _dy, _callback) {
  _callback == null ? void 0 : _callback();
  return true;
}
function emitKeypressEvents(_stream, _interface) {
}
const promises = {
  createInterface: (options2) => {
    const rl2 = createInterface(options2);
    return {
      question: (query) => new Promise((resolve2) => {
        rl2.question(query, resolve2);
      }),
      close: () => rl2.close(),
      [Symbol.asyncIterator]: async function* () {
      }
    };
  }
};
var readline = {
  Interface,
  createInterface,
  clearLine,
  clearScreenDown,
  cursorTo,
  moveCursor,
  emitKeypressEvents,
  promises
};
var readlineShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Interface,
  clearLine,
  clearScreenDown,
  createInterface,
  cursorTo,
  default: readline,
  emitKeypressEvents,
  moveCursor,
  promises
});
class TLSSocket extends EventEmitter {
  constructor(_socket, _options3) {
    super();
    __publicField(this, "authorized", false);
    __publicField(this, "encrypted", true);
  }
  getPeerCertificate(_detailed) {
    return {};
  }
  getCipher() {
    return null;
  }
  getProtocol() {
    return null;
  }
  setServername(_name) {
  }
  renegotiate(_options3, _callback) {
    return false;
  }
}
class Server extends EventEmitter {
  constructor(_options3, _connectionListener) {
    super();
  }
  listen(..._args) {
    return this;
  }
  close(_callback) {
    return this;
  }
  address() {
    return null;
  }
  getTicketKeys() {
    return Buffer.from("");
  }
  setTicketKeys(_keys) {
  }
  setSecureContext(_options3) {
  }
}
function createServer$1(_options3, _connectionListener) {
  return new Server(_options3, _connectionListener);
}
function connect$1(_options3, _callback) {
  const socket = new TLSSocket();
  if (_callback) {
    setTimeout(_callback, 0);
  }
  return socket;
}
const createSecureContext = (_options3) => ({});
const getCiphers = () => ["TLS_AES_256_GCM_SHA384", "TLS_AES_128_GCM_SHA256"];
const DEFAULT_ECDH_CURVE = "auto";
const DEFAULT_MAX_VERSION = "TLSv1.3";
const DEFAULT_MIN_VERSION = "TLSv1.2";
const rootCertificates = [];
var tls = {
  TLSSocket,
  Server,
  createServer: createServer$1,
  connect: connect$1,
  createSecureContext,
  getCiphers,
  DEFAULT_ECDH_CURVE,
  DEFAULT_MAX_VERSION,
  DEFAULT_MIN_VERSION,
  rootCertificates
};
var tlsShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEFAULT_ECDH_CURVE,
  DEFAULT_MAX_VERSION,
  DEFAULT_MIN_VERSION,
  Server,
  TLSSocket,
  connect: connect$1,
  createSecureContext,
  createServer: createServer$1,
  default: tls,
  getCiphers,
  rootCertificates
});
class Http2Session extends EventEmitter {
  close(_callback) {
    if (_callback) setTimeout(_callback, 0);
  }
  destroy(_error, _code) {
  }
  get destroyed() {
    return false;
  }
  get encrypted() {
    return false;
  }
  get closed() {
    return false;
  }
  ping(_callback) {
    return false;
  }
  ref() {
  }
  unref() {
  }
  setTimeout(_msecs, _callback) {
  }
}
class ClientHttp2Session extends Http2Session {
}
class ServerHttp2Session extends Http2Session {
}
class Http2Stream extends EventEmitter {
  close(_code, _callback) {
  }
  get id() {
    return 0;
  }
  get pending() {
    return false;
  }
  get destroyed() {
    return false;
  }
  get closed() {
    return false;
  }
  priority(_options3) {
  }
  setTimeout(_msecs, _callback) {
  }
  end(_data, _encoding, _callback) {
  }
}
class Http2ServerRequest extends EventEmitter {
}
class Http2ServerResponse extends EventEmitter {
  writeHead(_statusCode, _headers) {
    return this;
  }
  end(_data) {
  }
}
function createServer(_options3, _onRequestHandler) {
  return new EventEmitter();
}
function createSecureServer(_options3, _onRequestHandler) {
  return new EventEmitter();
}
function connect(_authority, _options3, _listener) {
  return new ClientHttp2Session();
}
const constants = {
  NGHTTP2_SESSION_SERVER: 0,
  NGHTTP2_SESSION_CLIENT: 1,
  HTTP2_HEADER_STATUS: ":status",
  HTTP2_HEADER_METHOD: ":method",
  HTTP2_HEADER_AUTHORITY: ":authority",
  HTTP2_HEADER_SCHEME: ":scheme",
  HTTP2_HEADER_PATH: ":path",
  HTTP_STATUS_OK: 200,
  HTTP_STATUS_NOT_FOUND: 404
};
function getDefaultSettings() {
  return {};
}
function getPackedSettings(_settings) {
  return Buffer.from("");
}
function getUnpackedSettings(_buf) {
  return {};
}
const sensitiveHeaders = Symbol("sensitiveHeaders");
var http2 = {
  Http2Session,
  ClientHttp2Session,
  ServerHttp2Session,
  Http2Stream,
  Http2ServerRequest,
  Http2ServerResponse,
  createServer,
  createSecureServer,
  connect,
  constants,
  getDefaultSettings,
  getPackedSettings,
  getUnpackedSettings,
  sensitiveHeaders
};
var http2Shim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClientHttp2Session,
  Http2ServerRequest,
  Http2ServerResponse,
  Http2Session,
  Http2Stream,
  ServerHttp2Session,
  connect,
  constants,
  createSecureServer,
  createServer,
  default: http2,
  getDefaultSettings,
  getPackedSettings,
  getUnpackedSettings,
  sensitiveHeaders
});
const isMaster = true;
const isPrimary = true;
const isWorker = false;
class Worker extends EventEmitter {
  constructor() {
    super(...arguments);
    __publicField(this, "id", 0);
    __publicField(this, "process", null);
  }
  send(_message, _callback) {
    return false;
  }
  kill(_signal) {
  }
  disconnect() {
  }
  isDead() {
    return false;
  }
  isConnected() {
    return false;
  }
}
const worker = null;
const workers = {};
function fork$1(_env) {
  return new Worker();
}
function disconnect(_callback) {
  if (_callback) setTimeout(_callback, 0);
}
const settings = {};
const SCHED_NONE = 1;
const SCHED_RR = 2;
let schedulingPolicy = SCHED_RR;
function setupMaster(_settings) {
}
function setupPrimary(_settings) {
}
const clusterEmitter = new EventEmitter();
const on = clusterEmitter.on.bind(clusterEmitter);
const once = clusterEmitter.once.bind(clusterEmitter);
const emit = clusterEmitter.emit.bind(clusterEmitter);
const removeListener = clusterEmitter.removeListener.bind(clusterEmitter);
var cluster = {
  isMaster,
  isPrimary,
  isWorker,
  Worker,
  worker,
  workers,
  fork: fork$1,
  disconnect,
  settings,
  SCHED_NONE,
  SCHED_RR,
  schedulingPolicy,
  setupMaster,
  setupPrimary,
  on,
  once,
  emit,
  removeListener
};
var clusterShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  SCHED_NONE,
  SCHED_RR,
  Worker,
  default: cluster,
  disconnect,
  emit,
  fork: fork$1,
  isMaster,
  isPrimary,
  isWorker,
  on,
  once,
  removeListener,
  schedulingPolicy,
  settings,
  setupMaster,
  setupPrimary,
  worker,
  workers
});
class Socket extends EventEmitter {
  bind(_port, _address, _callback) {
    if (_callback) setTimeout(_callback, 0);
    return this;
  }
  close(_callback) {
    if (_callback) setTimeout(_callback, 0);
  }
  send(_msg, _offset, _length, _port, _address, _callback) {
    if (_callback) setTimeout(() => _callback(null, 0), 0);
  }
  address() {
    return { address: "0.0.0.0", family: "IPv4", port: 0 };
  }
  setBroadcast(_flag) {
  }
  setTTL(_ttl) {
    return _ttl;
  }
  setMulticastTTL(_ttl) {
    return _ttl;
  }
  setMulticastLoopback(_flag) {
    return _flag;
  }
  setMulticastInterface(_multicastInterface) {
  }
  addMembership(_multicastAddress, _multicastInterface) {
  }
  dropMembership(_multicastAddress, _multicastInterface) {
  }
  ref() {
    return this;
  }
  unref() {
    return this;
  }
  setRecvBufferSize(_size) {
  }
  setSendBufferSize(_size) {
  }
  getRecvBufferSize() {
    return 0;
  }
  getSendBufferSize() {
    return 0;
  }
}
function createSocket(_type, _callback) {
  return new Socket();
}
var dgram = {
  Socket,
  createSocket
};
var dgramShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Socket,
  createSocket,
  default: dgram
});
class Script {
  constructor(code2, _options22) {
    __publicField(this, "code");
    this.code = code2;
  }
  runInThisContext(_options) {
    return eval(this.code);
  }
  runInNewContext(contextObject, _options22) {
    const keys = contextObject ? Object.keys(contextObject) : [];
    const values = contextObject ? Object.values(contextObject) : [];
    const fn2 = new Function(...keys, `return eval(${JSON.stringify(this.code)})`);
    return fn2(...values);
  }
  runInContext(_context, _options22) {
    return this.runInNewContext(_context, _options22);
  }
  createCachedData() {
    return Buffer.from("");
  }
}
function createContext(contextObject, _options22) {
  return contextObject || {};
}
function isContext(_sandbox) {
  return true;
}
function runInThisContext(code, _options) {
  return eval(code);
}
function runInNewContext(code2, contextObject, _options22) {
  const script = new Script(code2);
  return script.runInNewContext(contextObject);
}
function runInContext(code2, context2, _options22) {
  return runInNewContext(code2, context2);
}
function compileFunction(code2, params, _options22) {
  return new Function(...params || [], code2);
}
class Module {
  constructor(_code, _options22) {
  }
  link(_linker) {
    return Promise.resolve();
  }
  evaluate(_options22) {
    return Promise.resolve();
  }
  get status() {
    return "unlinked";
  }
  get identifier() {
    return "";
  }
  get context() {
    return {};
  }
  get namespace() {
    return {};
  }
}
class SourceTextModule extends Module {
}
class SyntheticModule extends Module {
  setExport(_name, _value) {
  }
}
var vm = {
  Script,
  createContext,
  isContext,
  runInThisContext,
  runInNewContext,
  runInContext,
  compileFunction,
  Module,
  SourceTextModule,
  SyntheticModule
};
var vmShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Module,
  Script,
  SourceTextModule,
  SyntheticModule,
  compileFunction,
  createContext,
  default: vm,
  isContext,
  runInContext,
  runInNewContext,
  runInThisContext
});
class Session extends EventEmitter {
  connect() {
  }
  connectToMainThread() {
  }
  disconnect() {
  }
  post(_method, _params, _callback) {
    if (_callback) setTimeout(() => _callback(null, {}), 0);
  }
}
function open(_port, _host, _wait) {
}
function close() {
}
function url() {
  return void 0;
}
function waitForDebugger() {
}
const console$1 = globalThis.console;
var inspector = {
  Session,
  open,
  close,
  url,
  waitForDebugger,
  console: console$1
};
var inspectorShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Session,
  close,
  console: console$1,
  default: inspector,
  open,
  url,
  waitForDebugger
});
class AsyncResource {
  constructor(_type, _options3) {
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  runInAsyncScope(fn2, thisArg, ...args) {
    return fn2.apply(thisArg, args);
  }
  emitDestroy() {
    return this;
  }
  asyncId() {
    return 0;
  }
  triggerAsyncId() {
    return 0;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static bind(fn2, _type) {
    return fn2;
  }
}
class AsyncLocalStorage {
  constructor() {
    __publicField(this, "store");
  }
  disable() {
  }
  getStore() {
    return this.store;
  }
  run(store, callback) {
    const prev = this.store;
    this.store = store;
    try {
      return callback();
    } finally {
      this.store = prev;
    }
  }
  exit(callback) {
    const prev = this.store;
    this.store = void 0;
    try {
      return callback();
    } finally {
      this.store = prev;
    }
  }
  enterWith(store) {
    this.store = store;
  }
}
function createHook(_callbacks) {
  return {
    enable() {
      return this;
    },
    disable() {
      return this;
    }
  };
}
function executionAsyncId() {
  return 0;
}
function executionAsyncResource() {
  return {};
}
function triggerAsyncId() {
  return 0;
}
var async_hooks = {
  AsyncResource,
  AsyncLocalStorage,
  createHook,
  executionAsyncId,
  executionAsyncResource,
  triggerAsyncId
};
var asyncHooksShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AsyncLocalStorage,
  AsyncResource,
  createHook,
  default: async_hooks,
  executionAsyncId,
  executionAsyncResource,
  triggerAsyncId
});
class Domain extends EventEmitter {
  constructor() {
    super(...arguments);
    __publicField(this, "members", []);
  }
  add(emitter) {
    this.members.push(emitter);
  }
  remove(emitter) {
    const index2 = this.members.indexOf(emitter);
    if (index2 !== -1) {
      this.members.splice(index2, 1);
    }
  }
  bind(callback) {
    return callback;
  }
  intercept(callback) {
    return callback;
  }
  run(fn2) {
    return fn2();
  }
  dispose() {
    this.members = [];
  }
  enter() {
  }
  exit() {
  }
}
function create() {
  return new Domain();
}
let active = null;
var domain = {
  Domain,
  create,
  active
};
var domainShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Domain,
  active,
  create,
  default: domain
});
class Channel {
  constructor(name2) {
    __publicField(this, "name");
    __publicField(this, "_subscribers", /* @__PURE__ */ new Set());
    this.name = name2;
  }
  get hasSubscribers() {
    return this._subscribers.size > 0;
  }
  publish(message) {
    for (const subscriber of this._subscribers) {
      try {
        subscriber(message, this.name);
      } catch (err2) {
        console.error("Error in diagnostics channel subscriber:", err2);
      }
    }
  }
  subscribe(onMessage) {
    this._subscribers.add(onMessage);
  }
  unsubscribe(onMessage) {
    return this._subscribers.delete(onMessage);
  }
  bindStore(store, transform2) {
  }
  unbindStore(store) {
    return false;
  }
}
const channels = /* @__PURE__ */ new Map();
function channel(name2) {
  let ch2 = channels.get(name2);
  if (!ch2) {
    ch2 = new Channel(name2);
    channels.set(name2, ch2);
  }
  return ch2;
}
function hasSubscribers(name2) {
  const ch2 = channels.get(name2);
  return ch2 ? ch2.hasSubscribers : false;
}
function subscribe(name2, onMessage) {
  channel(name2).subscribe(onMessage);
}
function unsubscribe(name2, onMessage) {
  const ch2 = channels.get(name2);
  return ch2 ? ch2.unsubscribe(onMessage) : false;
}
class TracingChannel {
  constructor(nameOrChannels) {
    __publicField(this, "channels");
    if (typeof nameOrChannels === "string") {
      this.channels = {
        start: channel(`tracing:${nameOrChannels}:start`),
        end: channel(`tracing:${nameOrChannels}:end`),
        asyncStart: channel(`tracing:${nameOrChannels}:asyncStart`),
        asyncEnd: channel(`tracing:${nameOrChannels}:asyncEnd`),
        error: channel(`tracing:${nameOrChannels}:error`)
      };
    } else {
      this.channels = nameOrChannels;
    }
  }
  get hasSubscribers() {
    return Object.values(this.channels).some((ch2) => ch2.hasSubscribers);
  }
  subscribe(handlers) {
    if (handlers.start) this.channels.start.subscribe(handlers.start);
    if (handlers.end) this.channels.end.subscribe(handlers.end);
    if (handlers.asyncStart) this.channels.asyncStart.subscribe(handlers.asyncStart);
    if (handlers.asyncEnd) this.channels.asyncEnd.subscribe(handlers.asyncEnd);
    if (handlers.error) this.channels.error.subscribe(handlers.error);
  }
  unsubscribe(handlers) {
    if (handlers.start) this.channels.start.unsubscribe(handlers.start);
    if (handlers.end) this.channels.end.unsubscribe(handlers.end);
    if (handlers.asyncStart) this.channels.asyncStart.unsubscribe(handlers.asyncStart);
    if (handlers.asyncEnd) this.channels.asyncEnd.unsubscribe(handlers.asyncEnd);
    if (handlers.error) this.channels.error.unsubscribe(handlers.error);
  }
  traceSync(fn2, context2, thisArg) {
    this.channels.start.publish(context2);
    try {
      const result = fn2.call(thisArg);
      this.channels.end.publish(context2);
      return result;
    } catch (error) {
      this.channels.error.publish({ error, ...context2 });
      throw error;
    }
  }
  async tracePromise(fn2, context2, thisArg) {
    this.channels.start.publish(context2);
    try {
      const result = await fn2.call(thisArg);
      this.channels.asyncEnd.publish(context2);
      return result;
    } catch (error) {
      this.channels.error.publish({ error, ...context2 });
      throw error;
    }
  }
  traceCallback(fn2, position, context2, thisArg) {
    return fn2;
  }
}
function tracingChannel(name2) {
  return new TracingChannel(name2);
}
var diagnostics_channel = {
  channel,
  hasSubscribers,
  subscribe,
  unsubscribe,
  tracingChannel,
  Channel,
  TracingChannel
};
var diagnosticsChannelShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Channel,
  TracingChannel,
  channel,
  default: diagnostics_channel,
  hasSubscribers,
  subscribe,
  tracingChannel,
  unsubscribe
});
class AssertionError extends Error {
  constructor(options2) {
    const message = options2.message || `${JSON.stringify(options2.actual)} ${options2.operator || "=="} ${JSON.stringify(options2.expected)}`;
    super(message);
    __publicField(this, "actual");
    __publicField(this, "expected");
    __publicField(this, "operator");
    __publicField(this, "generatedMessage");
    __publicField(this, "code", "ERR_ASSERTION");
    this.name = "AssertionError";
    this.actual = options2.actual;
    this.expected = options2.expected;
    this.operator = options2.operator || "";
    this.generatedMessage = !options2.message;
    if (Error.captureStackTrace && options2.stackStartFn) {
      Error.captureStackTrace(this, options2.stackStartFn);
    }
  }
}
function isDeepStrictEqual(actual, expected) {
  if (actual === expected) {
    return true;
  }
  if (actual === null || expected === null || actual === void 0 || expected === void 0) {
    return actual === expected;
  }
  if (typeof actual !== typeof expected) {
    return false;
  }
  if (typeof actual === "number" && Number.isNaN(actual) && Number.isNaN(expected)) {
    return true;
  }
  if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();
  }
  if (actual instanceof RegExp && expected instanceof RegExp) {
    return actual.source === expected.source && actual.flags === expected.flags;
  }
  if (Array.isArray(actual) && Array.isArray(expected)) {
    if (actual.length !== expected.length) {
      return false;
    }
    for (let i2 = 0; i2 < actual.length; i2++) {
      if (!isDeepStrictEqual(actual[i2], expected[i2])) {
        return false;
      }
    }
    return true;
  }
  if (actual instanceof Uint8Array && expected instanceof Uint8Array) {
    if (actual.length !== expected.length) {
      return false;
    }
    for (let i2 = 0; i2 < actual.length; i2++) {
      if (actual[i2] !== expected[i2]) {
        return false;
      }
    }
    return true;
  }
  if (actual instanceof Map && expected instanceof Map) {
    if (actual.size !== expected.size) {
      return false;
    }
    const actualEntries = Array.from(actual.entries());
    for (let i2 = 0; i2 < actualEntries.length; i2++) {
      const [key, value2] = actualEntries[i2];
      if (!expected.has(key) || !isDeepStrictEqual(value2, expected.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (actual instanceof Set && expected instanceof Set) {
    if (actual.size !== expected.size) {
      return false;
    }
    const actualValues = Array.from(actual.values());
    const expectedValues = Array.from(expected.values());
    for (let i2 = 0; i2 < actualValues.length; i2++) {
      const value2 = actualValues[i2];
      if (!expected.has(value2)) {
        let found = false;
        for (let j2 = 0; j2 < expectedValues.length; j2++) {
          if (isDeepStrictEqual(value2, expectedValues[j2])) {
            found = true;
            break;
          }
        }
        if (!found) return false;
      }
    }
    return true;
  }
  if (typeof actual === "object" && typeof expected === "object") {
    const actualKeys = Object.keys(actual);
    const expectedKeys = Object.keys(expected);
    if (actualKeys.length !== expectedKeys.length) {
      return false;
    }
    for (const key of actualKeys) {
      if (!Object.prototype.hasOwnProperty.call(expected, key)) {
        return false;
      }
      if (!isDeepStrictEqual(
        actual[key],
        expected[key]
      )) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function assert(value2, message) {
  if (!value2) {
    if (message instanceof Error) {
      throw message;
    }
    throw new AssertionError({
      message: message || "The expression evaluated to a falsy value",
      actual: value2,
      expected: true,
      operator: "==",
      stackStartFn: assert
    });
  }
}
assert.ok = function ok2(value2, message) {
  if (!value2) {
    if (message instanceof Error) {
      throw message;
    }
    throw new AssertionError({
      message: message || "The expression evaluated to a falsy value",
      actual: value2,
      expected: true,
      operator: "==",
      stackStartFn: ok2
    });
  }
};
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    if (message instanceof Error) {
      throw message;
    }
    throw new AssertionError({
      message,
      actual,
      expected,
      operator: "===",
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    if (message instanceof Error) {
      throw message;
    }
    throw new AssertionError({
      message,
      actual,
      expected,
      operator: "!==",
      stackStartFn: notStrictEqual
    });
  }
};
assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!isDeepStrictEqual(actual, expected)) {
    if (message instanceof Error) {
      throw message;
    }
    throw new AssertionError({
      message,
      actual,
      expected,
      operator: "deepStrictEqual",
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = function notDeepStrictEqual(actual, expected, message) {
  if (isDeepStrictEqual(actual, expected)) {
    if (message instanceof Error) {
      throw message;
    }
    throw new AssertionError({
      message,
      actual,
      expected,
      operator: "notDeepStrictEqual",
      stackStartFn: notDeepStrictEqual
    });
  }
};
assert.throws = function throws(fn2, errorOrMessage, message) {
  let threw = false;
  let thrownError;
  try {
    fn2();
  } catch (err2) {
    threw = true;
    thrownError = err2;
  }
  if (!threw) {
    throw new AssertionError({
      message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected function to throw",
      actual: void 0,
      expected: errorOrMessage,
      operator: "throws",
      stackStartFn: throws
    });
  }
  if (errorOrMessage !== void 0 && typeof errorOrMessage !== "string") {
    if (errorOrMessage instanceof RegExp) {
      const errMessage = thrownError instanceof Error ? thrownError.message : String(thrownError);
      if (!errorOrMessage.test(errMessage)) {
        throw new AssertionError({
          message: message || `The error message did not match the regular expression`,
          actual: thrownError,
          expected: errorOrMessage,
          operator: "throws",
          stackStartFn: throws
        });
      }
    } else if (typeof errorOrMessage === "function") {
      if (!(thrownError instanceof errorOrMessage)) {
        throw new AssertionError({
          message: message || `The error is not an instance of the expected type`,
          actual: thrownError,
          expected: errorOrMessage,
          operator: "throws",
          stackStartFn: throws
        });
      }
    } else if (typeof errorOrMessage === "object") {
      const expected = errorOrMessage;
      const err2 = thrownError;
      if (expected.message !== void 0) {
        const errMsg = err2.message || String(thrownError);
        if (expected.message instanceof RegExp) {
          if (!expected.message.test(errMsg)) {
            throw new AssertionError({
              message: message || `The error message did not match`,
              actual: errMsg,
              expected: expected.message,
              operator: "throws",
              stackStartFn: throws
            });
          }
        } else if (errMsg !== expected.message) {
          throw new AssertionError({
            message: message || `The error message did not match`,
            actual: errMsg,
            expected: expected.message,
            operator: "throws",
            stackStartFn: throws
          });
        }
      }
      if (expected.code !== void 0 && err2.code !== expected.code) {
        throw new AssertionError({
          message: message || `The error code did not match`,
          actual: err2.code,
          expected: expected.code,
          operator: "throws",
          stackStartFn: throws
        });
      }
    }
  }
};
assert.doesNotThrow = function doesNotThrow(fn2, errorOrMessage, message) {
  try {
    fn2();
  } catch (err2) {
    if (errorOrMessage === void 0 || typeof errorOrMessage === "string") {
      throw new AssertionError({
        message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected function not to throw",
        actual: err2,
        expected: void 0,
        operator: "doesNotThrow",
        stackStartFn: doesNotThrow
      });
    }
    if (errorOrMessage instanceof RegExp) {
      const errMessage = err2 instanceof Error ? err2.message : String(err2);
      if (errorOrMessage.test(errMessage)) {
        throw new AssertionError({
          message: message || "Expected function not to throw matching error",
          actual: err2,
          expected: errorOrMessage,
          operator: "doesNotThrow",
          stackStartFn: doesNotThrow
        });
      }
    } else if (typeof errorOrMessage === "function") {
      if (err2 instanceof errorOrMessage) {
        throw new AssertionError({
          message: message || "Expected function not to throw error of this type",
          actual: err2,
          expected: errorOrMessage,
          operator: "doesNotThrow",
          stackStartFn: doesNotThrow
        });
      }
    }
  }
};
assert.rejects = async function rejects(asyncFn, errorOrMessage, message) {
  const promise = typeof asyncFn === "function" ? asyncFn() : asyncFn;
  let rejected = false;
  let rejectionReason;
  try {
    await promise;
  } catch (err2) {
    rejected = true;
    rejectionReason = err2;
  }
  if (!rejected) {
    throw new AssertionError({
      message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected promise to reject",
      actual: void 0,
      expected: errorOrMessage,
      operator: "rejects",
      stackStartFn: rejects
    });
  }
  if (errorOrMessage !== void 0 && typeof errorOrMessage !== "string") {
    if (errorOrMessage instanceof RegExp) {
      const errMessage = rejectionReason instanceof Error ? rejectionReason.message : String(rejectionReason);
      if (!errorOrMessage.test(errMessage)) {
        throw new AssertionError({
          message: message || "The rejection message did not match the regular expression",
          actual: rejectionReason,
          expected: errorOrMessage,
          operator: "rejects",
          stackStartFn: rejects
        });
      }
    } else if (typeof errorOrMessage === "function") {
      if (!(rejectionReason instanceof errorOrMessage)) {
        throw new AssertionError({
          message: message || "The rejection is not an instance of the expected type",
          actual: rejectionReason,
          expected: errorOrMessage,
          operator: "rejects",
          stackStartFn: rejects
        });
      }
    } else if (typeof errorOrMessage === "object") {
      const expected = errorOrMessage;
      const err2 = rejectionReason;
      if (expected.message !== void 0) {
        const errMsg = err2.message || String(rejectionReason);
        if (expected.message instanceof RegExp) {
          if (!expected.message.test(errMsg)) {
            throw new AssertionError({
              message: message || "The rejection message did not match",
              actual: errMsg,
              expected: expected.message,
              operator: "rejects",
              stackStartFn: rejects
            });
          }
        } else if (errMsg !== expected.message) {
          throw new AssertionError({
            message: message || "The rejection message did not match",
            actual: errMsg,
            expected: expected.message,
            operator: "rejects",
            stackStartFn: rejects
          });
        }
      }
      if (expected.code !== void 0 && err2.code !== expected.code) {
        throw new AssertionError({
          message: message || "The rejection code did not match",
          actual: err2.code,
          expected: expected.code,
          operator: "rejects",
          stackStartFn: rejects
        });
      }
    }
  }
};
assert.doesNotReject = async function doesNotReject(asyncFn, errorOrMessage, message) {
  const promise = typeof asyncFn === "function" ? asyncFn() : asyncFn;
  try {
    await promise;
  } catch (err2) {
    if (errorOrMessage === void 0 || typeof errorOrMessage === "string") {
      throw new AssertionError({
        message: typeof errorOrMessage === "string" ? errorOrMessage : message || "Expected promise not to reject",
        actual: err2,
        expected: void 0,
        operator: "doesNotReject",
        stackStartFn: doesNotReject
      });
    }
    if (errorOrMessage instanceof RegExp) {
      const errMessage = err2 instanceof Error ? err2.message : String(err2);
      if (errorOrMessage.test(errMessage)) {
        throw new AssertionError({
          message: message || "Expected promise not to reject with matching error",
          actual: err2,
          expected: errorOrMessage,
          operator: "doesNotReject",
          stackStartFn: doesNotReject
        });
      }
    } else if (typeof errorOrMessage === "function") {
      if (err2 instanceof errorOrMessage) {
        throw new AssertionError({
          message: message || "Expected promise not to reject with error of this type",
          actual: err2,
          expected: errorOrMessage,
          operator: "doesNotReject",
          stackStartFn: doesNotReject
        });
      }
    }
  }
};
assert.fail = function fail(messageOrActual, expected, message, operator) {
  if (arguments.length === 0 || arguments.length === 1) {
    throw new AssertionError({
      message: typeof messageOrActual === "string" ? messageOrActual : "Failed",
      stackStartFn: fail
    });
  }
  throw new AssertionError({
    message,
    actual: messageOrActual,
    expected,
    operator: operator || "fail",
    stackStartFn: fail
  });
};
assert.match = function match2(string, regexp, message) {
  if (!regexp.test(string)) {
    if (message instanceof Error) {
      throw message;
    }
    throw new AssertionError({
      message: message || `The input did not match the regular expression`,
      actual: string,
      expected: regexp,
      operator: "match",
      stackStartFn: match2
    });
  }
};
assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
  if (regexp.test(string)) {
    if (message instanceof Error) {
      throw message;
    }
    throw new AssertionError({
      message: message || `The input was expected not to match the regular expression`,
      actual: string,
      expected: regexp,
      operator: "doesNotMatch",
      stackStartFn: doesNotMatch
    });
  }
};
assert.ifError = function ifError(value2) {
  if (value2 !== null && value2 !== void 0) {
    if (value2 instanceof Error) {
      throw value2;
    }
    throw new AssertionError({
      message: `ifError got unwanted exception: ${value2}`,
      actual: value2,
      expected: null,
      operator: "ifError",
      stackStartFn: ifError
    });
  }
};
assert.AssertionError = AssertionError;
assert.strict = assert;
function e(e2, n2, r2) {
  throw new Error(r2 ? `No known conditions for "${n2}" specifier in "${e2}" package` : `Missing "${n2}" specifier in "${e2}" package`);
}
function n(n2, i2, o2, f2) {
  let s2, u, l = r(n2, o2), c = function(e2) {
    let n3 = /* @__PURE__ */ new Set(["default", ...e2.conditions || []]);
    return e2.unsafe || n3.add(e2.require ? "require" : "import"), e2.unsafe || n3.add(e2.browser ? "browser" : "node"), n3;
  }(f2 || {}), a = i2[l];
  if (void 0 === a) {
    let e2, n3, r2, t2;
    for (t2 in i2) n3 && t2.length < n3.length || ("/" === t2[t2.length - 1] && l.startsWith(t2) ? (u = l.substring(t2.length), n3 = t2) : t2.length > 1 && (r2 = t2.indexOf("*", 1), ~r2 && (e2 = RegExp("^" + t2.substring(0, r2) + "(.*)" + t2.substring(1 + r2) + "$").exec(l), e2 && e2[1] && (u = e2[1], n3 = t2))));
    a = i2[n3];
  }
  return a || e(n2, l), s2 = t(a, c), s2 || e(n2, l, 1), u && function(e2, n3) {
    let r2, t2 = 0, i3 = e2.length, o3 = /[*]/g, f3 = /[/]$/;
    for (; t2 < i3; t2++) e2[t2] = o3.test(r2 = e2[t2]) ? r2.replace(o3, n3) : f3.test(r2) ? r2 + n3 : r2;
  }(s2, u), s2;
}
function r(e2, n2, r2) {
  if (e2 === n2 || "." === n2) return ".";
  let t2 = e2 + "/", i2 = t2.length, o2 = n2.slice(0, i2) === t2, f2 = o2 ? n2.slice(i2) : n2;
  return "#" === f2[0] ? f2 : "./" === f2.slice(0, 2) ? f2 : "./" + f2;
}
function t(e2, n2, r2) {
  if (e2) {
    if ("string" == typeof e2) return r2 && r2.add(e2), [e2];
    let i2, o2;
    if (Array.isArray(e2)) {
      for (o2 = r2 || /* @__PURE__ */ new Set(), i2 = 0; i2 < e2.length; i2++) t(e2[i2], n2, o2);
      if (!r2 && o2.size) return [...o2];
    } else for (i2 in e2) if (n2.has(i2)) return t(e2[i2], n2, r2);
  }
}
function o(e2, r2, t2) {
  let i2, o2 = e2.exports;
  if (o2) {
    if ("string" == typeof o2) o2 = { ".": o2 };
    else for (i2 in o2) {
      "." !== i2[0] && (o2 = { ".": o2 });
      break;
    }
    return n(e2.name, o2, r2 || ".", t2);
  }
}
function f(e2, r2, t2) {
  if (e2.imports) return n(e2.name, e2.imports, r2, t2);
}
function s(e2, n2, t2) {
  return "#" === (n2 = r(e2.name, n2 || "."))[0] ? f(e2, n2, t2) : o(e2, n2, t2);
}
const EOF$1 = 0;
const Ident = 1;
const Function$2 = 2;
const AtKeyword = 3;
const Hash$1 = 4;
const String$2 = 5;
const BadString = 6;
const Url$1 = 7;
const BadUrl = 8;
const Delim = 9;
const Number$2 = 10;
const Percentage$1 = 11;
const Dimension$1 = 12;
const WhiteSpace$1 = 13;
const CDO$1 = 14;
const CDC$1 = 15;
const Colon = 16;
const Semicolon = 17;
const Comma = 18;
const LeftSquareBracket = 19;
const RightSquareBracket = 20;
const LeftParenthesis = 21;
const RightParenthesis = 22;
const LeftCurlyBracket = 23;
const RightCurlyBracket = 24;
const Comment$1 = 25;
const EOF = 0;
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isHexDigit(code2) {
  return isDigit(code2) || // 0 .. 9
  code2 >= 65 && code2 <= 70 || // A .. F
  code2 >= 97 && code2 <= 102;
}
function isUppercaseLetter(code2) {
  return code2 >= 65 && code2 <= 90;
}
function isLowercaseLetter(code2) {
  return code2 >= 97 && code2 <= 122;
}
function isLetter(code2) {
  return isUppercaseLetter(code2) || isLowercaseLetter(code2);
}
function isNonAscii(code2) {
  return code2 >= 128;
}
function isNameStart(code2) {
  return isLetter(code2) || isNonAscii(code2) || code2 === 95;
}
function isName(code2) {
  return isNameStart(code2) || isDigit(code2) || code2 === 45;
}
function isNonPrintable(code2) {
  return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
}
function isNewline(code2) {
  return code2 === 10 || code2 === 13 || code2 === 12;
}
function isWhiteSpace(code2) {
  return isNewline(code2) || code2 === 32 || code2 === 9;
}
function isValidEscape(first, second) {
  if (first !== 92) {
    return false;
  }
  if (isNewline(second) || second === EOF) {
    return false;
  }
  return true;
}
function isIdentifierStart(first, second, third) {
  if (first === 45) {
    return isNameStart(second) || second === 45 || isValidEscape(second, third);
  }
  if (isNameStart(first)) {
    return true;
  }
  if (first === 92) {
    return isValidEscape(first, second);
  }
  return false;
}
function isNumberStart(first, second, third) {
  if (first === 43 || first === 45) {
    if (isDigit(second)) {
      return 2;
    }
    return second === 46 && isDigit(third) ? 3 : 0;
  }
  if (first === 46) {
    return isDigit(second) ? 2 : 0;
  }
  if (isDigit(first)) {
    return 1;
  }
  return 0;
}
function isBOM(code2) {
  if (code2 === 65279) {
    return 1;
  }
  if (code2 === 65534) {
    return 1;
  }
  return 0;
}
const CATEGORY = new Array(128);
const EofCategory = 128;
const WhiteSpaceCategory = 130;
const DigitCategory = 131;
const NameStartCategory = 132;
const NonPrintableCategory = 133;
for (let i2 = 0; i2 < CATEGORY.length; i2++) {
  CATEGORY[i2] = isWhiteSpace(i2) && WhiteSpaceCategory || isDigit(i2) && DigitCategory || isNameStart(i2) && NameStartCategory || isNonPrintable(i2) && NonPrintableCategory || i2 || EofCategory;
}
function charCodeCategory(code2) {
  return code2 < 128 ? CATEGORY[code2] : NameStartCategory;
}
function getCharCode(source, offset2) {
  return offset2 < source.length ? source.charCodeAt(offset2) : 0;
}
function getNewlineLength(source, offset2, code2) {
  if (code2 === 13 && getCharCode(source, offset2 + 1) === 10) {
    return 2;
  }
  return 1;
}
function cmpChar(testStr, offset2, referenceCode) {
  let code2 = testStr.charCodeAt(offset2);
  if (isUppercaseLetter(code2)) {
    code2 = code2 | 32;
  }
  return code2 === referenceCode;
}
function cmpStr(testStr, start, end, referenceStr) {
  if (end - start !== referenceStr.length) {
    return false;
  }
  if (start < 0 || end > testStr.length) {
    return false;
  }
  for (let i2 = start; i2 < end; i2++) {
    const referenceCode = referenceStr.charCodeAt(i2 - start);
    let testCode = testStr.charCodeAt(i2);
    if (isUppercaseLetter(testCode)) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function findWhiteSpaceStart(source, offset2) {
  for (; offset2 >= 0; offset2--) {
    if (!isWhiteSpace(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2 + 1;
}
function findWhiteSpaceEnd(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    if (!isWhiteSpace(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2;
}
function findDecimalNumberEnd(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    if (!isDigit(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2;
}
function consumeEscaped(source, offset2) {
  offset2 += 2;
  if (isHexDigit(getCharCode(source, offset2 - 1))) {
    for (const maxOffset = Math.min(source.length, offset2 + 5); offset2 < maxOffset; offset2++) {
      if (!isHexDigit(getCharCode(source, offset2))) {
        break;
      }
    }
    const code2 = getCharCode(source, offset2);
    if (isWhiteSpace(code2)) {
      offset2 += getNewlineLength(source, offset2, code2);
    }
  }
  return offset2;
}
function consumeName(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    const code2 = source.charCodeAt(offset2);
    if (isName(code2)) {
      continue;
    }
    if (isValidEscape(code2, getCharCode(source, offset2 + 1))) {
      offset2 = consumeEscaped(source, offset2) - 1;
      continue;
    }
    break;
  }
  return offset2;
}
function consumeNumber(source, offset2) {
  let code2 = source.charCodeAt(offset2);
  if (code2 === 43 || code2 === 45) {
    code2 = source.charCodeAt(offset2 += 1);
  }
  if (isDigit(code2)) {
    offset2 = findDecimalNumberEnd(source, offset2 + 1);
    code2 = source.charCodeAt(offset2);
  }
  if (code2 === 46 && isDigit(source.charCodeAt(offset2 + 1))) {
    offset2 += 2;
    offset2 = findDecimalNumberEnd(source, offset2);
  }
  if (cmpChar(
    source,
    offset2,
    101
    /* e */
  )) {
    let sign2 = 0;
    code2 = source.charCodeAt(offset2 + 1);
    if (code2 === 45 || code2 === 43) {
      sign2 = 1;
      code2 = source.charCodeAt(offset2 + 2);
    }
    if (isDigit(code2)) {
      offset2 = findDecimalNumberEnd(source, offset2 + 1 + sign2 + 1);
    }
  }
  return offset2;
}
function consumeBadUrlRemnants(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    const code2 = source.charCodeAt(offset2);
    if (code2 === 41) {
      offset2++;
      break;
    }
    if (isValidEscape(code2, getCharCode(source, offset2 + 1))) {
      offset2 = consumeEscaped(source, offset2);
    }
  }
  return offset2;
}
function decodeEscaped(escaped) {
  if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {
    return escaped[0];
  }
  let code2 = parseInt(escaped, 16);
  if (code2 === 0 || // If this number is zero,
  code2 >= 55296 && code2 <= 57343 || // or is for a surrogate,
  code2 > 1114111) {
    code2 = 65533;
  }
  return String.fromCodePoint(code2);
}
var tokenNames = [
  "EOF-token",
  "ident-token",
  "function-token",
  "at-keyword-token",
  "hash-token",
  "string-token",
  "bad-string-token",
  "url-token",
  "bad-url-token",
  "delim-token",
  "number-token",
  "percentage-token",
  "dimension-token",
  "whitespace-token",
  "CDO-token",
  "CDC-token",
  "colon-token",
  "semicolon-token",
  "comma-token",
  "[-token",
  "]-token",
  "(-token",
  ")-token",
  "{-token",
  "}-token",
  "comment-token"
];
const MIN_SIZE = 16 * 1024;
function adoptBuffer(buffer = null, size) {
  if (buffer === null || buffer.length < size) {
    return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
  }
  return buffer;
}
const N$4 = 10;
const F$2 = 12;
const R$2 = 13;
function computeLinesAndColumns(host) {
  const source = host.source;
  const sourceLength = source.length;
  const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
  const lines = adoptBuffer(host.lines, sourceLength);
  const columns = adoptBuffer(host.columns, sourceLength);
  let line = host.startLine;
  let column = host.startColumn;
  for (let i2 = startOffset; i2 < sourceLength; i2++) {
    const code2 = source.charCodeAt(i2);
    lines[i2] = line;
    columns[i2] = column++;
    if (code2 === N$4 || code2 === R$2 || code2 === F$2) {
      if (code2 === R$2 && i2 + 1 < sourceLength && source.charCodeAt(i2 + 1) === N$4) {
        i2++;
        lines[i2] = line;
        columns[i2] = column;
      }
      line++;
      column = 1;
    }
  }
  lines[sourceLength] = line;
  columns[sourceLength] = column;
  host.lines = lines;
  host.columns = columns;
  host.computed = true;
}
class OffsetToLocation {
  constructor(source, startOffset, startLine, startColumn) {
    this.setSource(source, startOffset, startLine, startColumn);
    this.lines = null;
    this.columns = null;
  }
  setSource(source = "", startOffset = 0, startLine = 1, startColumn = 1) {
    this.source = source;
    this.startOffset = startOffset;
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.computed = false;
  }
  getLocation(offset2, filename2) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename2,
      offset: this.startOffset + offset2,
      line: this.lines[offset2],
      column: this.columns[offset2]
    };
  }
  getLocationRange(start, end, filename2) {
    if (!this.computed) {
      computeLinesAndColumns(this);
    }
    return {
      source: filename2,
      start: {
        offset: this.startOffset + start,
        line: this.lines[start],
        column: this.columns[start]
      },
      end: {
        offset: this.startOffset + end,
        line: this.lines[end],
        column: this.columns[end]
      }
    };
  }
}
const OFFSET_MASK = 16777215;
const TYPE_SHIFT = 24;
const balancePair$1 = new Uint8Array(32);
balancePair$1[Function$2] = RightParenthesis;
balancePair$1[LeftParenthesis] = RightParenthesis;
balancePair$1[LeftSquareBracket] = RightSquareBracket;
balancePair$1[LeftCurlyBracket] = RightCurlyBracket;
function isBlockOpenerToken(tokenType2) {
  return balancePair$1[tokenType2] !== 0;
}
class TokenStream {
  constructor(source, tokenize2) {
    this.setSource(source, tokenize2);
  }
  reset() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  }
  setSource(source = "", tokenize2 = () => {
  }) {
    source = String(source || "");
    const sourceLength = source.length;
    const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
    const balance = adoptBuffer(this.balance, source.length + 1);
    let tokenCount = 0;
    let firstCharOffset = -1;
    let balanceCloseType = 0;
    let balanceStart = source.length;
    this.offsetAndType = null;
    this.balance = null;
    balance.fill(0);
    tokenize2(source, (type2, start, end) => {
      const index2 = tokenCount++;
      offsetAndType[index2] = type2 << TYPE_SHIFT | end;
      if (firstCharOffset === -1) {
        firstCharOffset = start;
      }
      balance[index2] = balanceStart;
      if (type2 === balanceCloseType) {
        const prevBalanceStart = balance[balanceStart];
        balance[balanceStart] = index2;
        balanceStart = prevBalanceStart;
        balanceCloseType = balancePair$1[offsetAndType[prevBalanceStart] >> TYPE_SHIFT];
      } else if (isBlockOpenerToken(type2)) {
        balanceStart = index2;
        balanceCloseType = balancePair$1[type2];
      }
    });
    offsetAndType[tokenCount] = EOF$1 << TYPE_SHIFT | sourceLength;
    balance[tokenCount] = tokenCount;
    for (let i2 = 0; i2 < tokenCount; i2++) {
      const balanceStart2 = balance[i2];
      if (balanceStart2 <= i2) {
        const balanceEnd = balance[balanceStart2];
        if (balanceEnd !== i2) {
          balance[i2] = balanceEnd;
        }
      } else if (balanceStart2 > tokenCount) {
        balance[i2] = tokenCount;
      }
    }
    this.source = source;
    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
    this.tokenCount = tokenCount;
    this.offsetAndType = offsetAndType;
    this.balance = balance;
    this.reset();
    this.next();
  }
  lookupType(offset2) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return this.offsetAndType[offset2] >> TYPE_SHIFT;
    }
    return EOF$1;
  }
  lookupTypeNonSC(idx) {
    for (let offset2 = this.tokenIndex; offset2 < this.tokenCount; offset2++) {
      const tokenType2 = this.offsetAndType[offset2] >> TYPE_SHIFT;
      if (tokenType2 !== WhiteSpace$1 && tokenType2 !== Comment$1) {
        if (idx-- === 0) {
          return tokenType2;
        }
      }
    }
    return EOF$1;
  }
  lookupOffset(offset2) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return this.offsetAndType[offset2 - 1] & OFFSET_MASK;
    }
    return this.source.length;
  }
  lookupOffsetNonSC(idx) {
    for (let offset2 = this.tokenIndex; offset2 < this.tokenCount; offset2++) {
      const tokenType2 = this.offsetAndType[offset2] >> TYPE_SHIFT;
      if (tokenType2 !== WhiteSpace$1 && tokenType2 !== Comment$1) {
        if (idx-- === 0) {
          return offset2 - this.tokenIndex;
        }
      }
    }
    return EOF$1;
  }
  lookupValue(offset2, referenceStr) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return cmpStr(
        this.source,
        this.offsetAndType[offset2 - 1] & OFFSET_MASK,
        this.offsetAndType[offset2] & OFFSET_MASK,
        referenceStr
      );
    }
    return false;
  }
  getTokenStart(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }
    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    }
    return this.firstCharOffset;
  }
  substrToCursor(start) {
    return this.source.substring(start, this.tokenStart);
  }
  isBalanceEdge(pos) {
    return this.balance[this.tokenIndex] < pos;
  }
  isDelim(code2, offset2) {
    if (offset2) {
      return this.lookupType(offset2) === Delim && this.source.charCodeAt(this.lookupOffset(offset2)) === code2;
    }
    return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code2;
  }
  skip(tokenCount) {
    let next2 = this.tokenIndex + tokenCount;
    if (next2 < this.tokenCount) {
      this.tokenIndex = next2;
      this.tokenStart = this.offsetAndType[next2 - 1] & OFFSET_MASK;
      next2 = this.offsetAndType[next2];
      this.tokenType = next2 >> TYPE_SHIFT;
      this.tokenEnd = next2 & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  }
  next() {
    let next2 = this.tokenIndex + 1;
    if (next2 < this.tokenCount) {
      this.tokenIndex = next2;
      this.tokenStart = this.tokenEnd;
      next2 = this.offsetAndType[next2];
      this.tokenType = next2 >> TYPE_SHIFT;
      this.tokenEnd = next2 & OFFSET_MASK;
    } else {
      this.eof = true;
      this.tokenIndex = this.tokenCount;
      this.tokenType = EOF$1;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  }
  skipSC() {
    while (this.tokenType === WhiteSpace$1 || this.tokenType === Comment$1) {
      this.next();
    }
  }
  skipUntilBalanced(startToken, stopConsume) {
    let cursor = startToken;
    let balanceEnd = 0;
    let offset2 = 0;
    loop:
      for (; cursor < this.tokenCount; cursor++) {
        balanceEnd = this.balance[cursor];
        if (balanceEnd < startToken) {
          break loop;
        }
        offset2 = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
        switch (stopConsume(this.source.charCodeAt(offset2))) {
          case 1:
            break loop;
          case 2:
            cursor++;
            break loop;
          default:
            if (isBlockOpenerToken(this.offsetAndType[cursor] >> TYPE_SHIFT)) {
              cursor = balanceEnd;
            }
        }
      }
    this.skip(cursor - this.tokenIndex);
  }
  forEachToken(fn2) {
    for (let i2 = 0, offset2 = this.firstCharOffset; i2 < this.tokenCount; i2++) {
      const start = offset2;
      const item = this.offsetAndType[i2];
      const end = item & OFFSET_MASK;
      const type2 = item >> TYPE_SHIFT;
      offset2 = end;
      fn2(type2, start, end, i2);
    }
  }
  dump() {
    const tokens = new Array(this.tokenCount);
    this.forEachToken((type2, start, end, index2) => {
      tokens[index2] = {
        idx: index2,
        type: tokenNames[type2],
        chunk: this.source.substring(start, end),
        balance: this.balance[index2]
      };
    });
    return tokens;
  }
}
function tokenize$1(source, onToken) {
  function getCharCode2(offset3) {
    return offset3 < sourceLength ? source.charCodeAt(offset3) : 0;
  }
  function consumeNumericToken() {
    offset2 = consumeNumber(source, offset2);
    if (isIdentifierStart(getCharCode2(offset2), getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
      type2 = Dimension$1;
      offset2 = consumeName(source, offset2);
      return;
    }
    if (getCharCode2(offset2) === 37) {
      type2 = Percentage$1;
      offset2++;
      return;
    }
    type2 = Number$2;
  }
  function consumeIdentLikeToken() {
    const nameStartOffset = offset2;
    offset2 = consumeName(source, offset2);
    if (cmpStr(source, nameStartOffset, offset2, "url") && getCharCode2(offset2) === 40) {
      offset2 = findWhiteSpaceEnd(source, offset2 + 1);
      if (getCharCode2(offset2) === 34 || getCharCode2(offset2) === 39) {
        type2 = Function$2;
        offset2 = nameStartOffset + 4;
        return;
      }
      consumeUrlToken();
      return;
    }
    if (getCharCode2(offset2) === 40) {
      type2 = Function$2;
      offset2++;
      return;
    }
    type2 = Ident;
  }
  function consumeStringToken(endingCodePoint) {
    if (!endingCodePoint) {
      endingCodePoint = getCharCode2(offset2++);
    }
    type2 = String$2;
    for (; offset2 < source.length; offset2++) {
      const code2 = source.charCodeAt(offset2);
      switch (charCodeCategory(code2)) {
        case endingCodePoint:
          offset2++;
          return;
        case WhiteSpaceCategory:
          if (isNewline(code2)) {
            offset2 += getNewlineLength(source, offset2, code2);
            type2 = BadString;
            return;
          }
          break;
        case 92:
          if (offset2 === source.length - 1) {
            break;
          }
          const nextCode = getCharCode2(offset2 + 1);
          if (isNewline(nextCode)) {
            offset2 += getNewlineLength(source, offset2 + 1, nextCode);
          } else if (isValidEscape(code2, nextCode)) {
            offset2 = consumeEscaped(source, offset2) - 1;
          }
          break;
      }
    }
  }
  function consumeUrlToken() {
    type2 = Url$1;
    offset2 = findWhiteSpaceEnd(source, offset2);
    for (; offset2 < source.length; offset2++) {
      const code2 = source.charCodeAt(offset2);
      switch (charCodeCategory(code2)) {
        case 41:
          offset2++;
          return;
        case WhiteSpaceCategory:
          offset2 = findWhiteSpaceEnd(source, offset2);
          if (getCharCode2(offset2) === 41 || offset2 >= source.length) {
            if (offset2 < source.length) {
              offset2++;
            }
            return;
          }
          offset2 = consumeBadUrlRemnants(source, offset2);
          type2 = BadUrl;
          return;
        case 34:
        case 39:
        case 40:
        case NonPrintableCategory:
          offset2 = consumeBadUrlRemnants(source, offset2);
          type2 = BadUrl;
          return;
        case 92:
          if (isValidEscape(code2, getCharCode2(offset2 + 1))) {
            offset2 = consumeEscaped(source, offset2) - 1;
            break;
          }
          offset2 = consumeBadUrlRemnants(source, offset2);
          type2 = BadUrl;
          return;
      }
    }
  }
  source = String(source || "");
  const sourceLength = source.length;
  let start = isBOM(getCharCode2(0));
  let offset2 = start;
  let type2;
  while (offset2 < sourceLength) {
    const code2 = source.charCodeAt(offset2);
    switch (charCodeCategory(code2)) {
      case WhiteSpaceCategory:
        type2 = WhiteSpace$1;
        offset2 = findWhiteSpaceEnd(source, offset2 + 1);
        break;
      case 34:
        consumeStringToken();
        break;
      case 35:
        if (isName(getCharCode2(offset2 + 1)) || isValidEscape(getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          type2 = Hash$1;
          offset2 = consumeName(source, offset2 + 1);
        } else {
          type2 = Delim;
          offset2++;
        }
        break;
      case 39:
        consumeStringToken();
        break;
      case 40:
        type2 = LeftParenthesis;
        offset2++;
        break;
      case 41:
        type2 = RightParenthesis;
        offset2++;
        break;
      case 43:
        if (isNumberStart(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken();
        } else {
          type2 = Delim;
          offset2++;
        }
        break;
      case 44:
        type2 = Comma;
        offset2++;
        break;
      case 45:
        if (isNumberStart(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken();
        } else {
          if (getCharCode2(offset2 + 1) === 45 && getCharCode2(offset2 + 2) === 62) {
            type2 = CDC$1;
            offset2 = offset2 + 3;
          } else {
            if (isIdentifierStart(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
              consumeIdentLikeToken();
            } else {
              type2 = Delim;
              offset2++;
            }
          }
        }
        break;
      case 46:
        if (isNumberStart(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken();
        } else {
          type2 = Delim;
          offset2++;
        }
        break;
      case 47:
        if (getCharCode2(offset2 + 1) === 42) {
          type2 = Comment$1;
          offset2 = source.indexOf("*/", offset2 + 2);
          offset2 = offset2 === -1 ? source.length : offset2 + 2;
        } else {
          type2 = Delim;
          offset2++;
        }
        break;
      case 58:
        type2 = Colon;
        offset2++;
        break;
      case 59:
        type2 = Semicolon;
        offset2++;
        break;
      case 60:
        if (getCharCode2(offset2 + 1) === 33 && getCharCode2(offset2 + 2) === 45 && getCharCode2(offset2 + 3) === 45) {
          type2 = CDO$1;
          offset2 = offset2 + 4;
        } else {
          type2 = Delim;
          offset2++;
        }
        break;
      case 64:
        if (isIdentifierStart(getCharCode2(offset2 + 1), getCharCode2(offset2 + 2), getCharCode2(offset2 + 3))) {
          type2 = AtKeyword;
          offset2 = consumeName(source, offset2 + 1);
        } else {
          type2 = Delim;
          offset2++;
        }
        break;
      case 91:
        type2 = LeftSquareBracket;
        offset2++;
        break;
      case 92:
        if (isValidEscape(code2, getCharCode2(offset2 + 1))) {
          consumeIdentLikeToken();
        } else {
          type2 = Delim;
          offset2++;
        }
        break;
      case 93:
        type2 = RightSquareBracket;
        offset2++;
        break;
      case 123:
        type2 = LeftCurlyBracket;
        offset2++;
        break;
      case 125:
        type2 = RightCurlyBracket;
        offset2++;
        break;
      case DigitCategory:
        consumeNumericToken();
        break;
      case NameStartCategory:
        consumeIdentLikeToken();
        break;
      default:
        type2 = Delim;
        offset2++;
    }
    onToken(type2, start, start = offset2);
  }
}
let releasedCursors = null;
class List {
  static createItem(data2) {
    return {
      prev: null,
      next: null,
      data: data2
    };
  }
  constructor() {
    this.head = null;
    this.tail = null;
    this.cursor = null;
  }
  createItem(data2) {
    return List.createItem(data2);
  }
  // cursor helpers
  allocateCursor(prev, next2) {
    let cursor;
    if (releasedCursors !== null) {
      cursor = releasedCursors;
      releasedCursors = releasedCursors.cursor;
      cursor.prev = prev;
      cursor.next = next2;
      cursor.cursor = this.cursor;
    } else {
      cursor = {
        prev,
        next: next2,
        cursor: this.cursor
      };
    }
    this.cursor = cursor;
    return cursor;
  }
  releaseCursor() {
    const { cursor } = this;
    this.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = releasedCursors;
    releasedCursors = cursor;
  }
  updateCursors(prevOld, prevNew, nextOld, nextNew) {
    let { cursor } = this;
    while (cursor !== null) {
      if (cursor.prev === prevOld) {
        cursor.prev = prevNew;
      }
      if (cursor.next === nextOld) {
        cursor.next = nextNew;
      }
      cursor = cursor.cursor;
    }
  }
  *[Symbol.iterator]() {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      yield cursor.data;
    }
  }
  // getters
  get size() {
    let size = 0;
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      size++;
    }
    return size;
  }
  get isEmpty() {
    return this.head === null;
  }
  get first() {
    return this.head && this.head.data;
  }
  get last() {
    return this.tail && this.tail.data;
  }
  // convertors
  fromArray(array) {
    let cursor = null;
    this.head = null;
    for (let data2 of array) {
      const item = List.createItem(data2);
      if (cursor !== null) {
        cursor.next = item;
      } else {
        this.head = item;
      }
      item.prev = cursor;
      cursor = item;
    }
    this.tail = cursor;
    return this;
  }
  toArray() {
    return [...this];
  }
  toJSON() {
    return [...this];
  }
  // array-like methods
  forEach(fn2, thisArg = this) {
    const cursor = this.allocateCursor(null, this.head);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      fn2.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  forEachRight(fn2, thisArg = this) {
    const cursor = this.allocateCursor(this.tail, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      fn2.call(thisArg, item.data, item, this);
    }
    this.releaseCursor();
  }
  reduce(fn2, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(null, this.head);
    let acc = initialValue;
    let item;
    while (cursor.next !== null) {
      item = cursor.next;
      cursor.next = item.next;
      acc = fn2.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  reduceRight(fn2, initialValue, thisArg = this) {
    let cursor = this.allocateCursor(this.tail, null);
    let acc = initialValue;
    let item;
    while (cursor.prev !== null) {
      item = cursor.prev;
      cursor.prev = item.prev;
      acc = fn2.call(thisArg, acc, item.data, item, this);
    }
    this.releaseCursor();
    return acc;
  }
  some(fn2, thisArg = this) {
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn2.call(thisArg, cursor.data, cursor, this)) {
        return true;
      }
    }
    return false;
  }
  map(fn2, thisArg = this) {
    const result = new List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      result.appendData(fn2.call(thisArg, cursor.data, cursor, this));
    }
    return result;
  }
  filter(fn2, thisArg = this) {
    const result = new List();
    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
      if (fn2.call(thisArg, cursor.data, cursor, this)) {
        result.appendData(cursor.data);
      }
    }
    return result;
  }
  nextUntil(start, fn2, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(null, start);
    while (cursor.next !== null) {
      const item = cursor.next;
      cursor.next = item.next;
      if (fn2.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  prevUntil(start, fn2, thisArg = this) {
    if (start === null) {
      return;
    }
    const cursor = this.allocateCursor(start, null);
    while (cursor.prev !== null) {
      const item = cursor.prev;
      cursor.prev = item.prev;
      if (fn2.call(thisArg, item.data, item, this)) {
        break;
      }
    }
    this.releaseCursor();
  }
  // mutation
  clear() {
    this.head = null;
    this.tail = null;
  }
  copy() {
    const result = new List();
    for (let data2 of this) {
      result.appendData(data2);
    }
    return result;
  }
  prepend(item) {
    this.updateCursors(null, item, this.head, item);
    if (this.head !== null) {
      this.head.prev = item;
      item.next = this.head;
    } else {
      this.tail = item;
    }
    this.head = item;
    return this;
  }
  prependData(data2) {
    return this.prepend(List.createItem(data2));
  }
  append(item) {
    return this.insert(item);
  }
  appendData(data2) {
    return this.insert(List.createItem(data2));
  }
  insert(item, before = null) {
    if (before !== null) {
      this.updateCursors(before.prev, item, before, item);
      if (before.prev === null) {
        if (this.head !== before) {
          throw new Error("before doesn't belong to list");
        }
        this.head = item;
        before.prev = item;
        item.next = before;
        this.updateCursors(null, item);
      } else {
        before.prev.next = item;
        item.prev = before.prev;
        before.prev = item;
        item.next = before;
      }
    } else {
      this.updateCursors(this.tail, item, null, item);
      if (this.tail !== null) {
        this.tail.next = item;
        item.prev = this.tail;
      } else {
        this.head = item;
      }
      this.tail = item;
    }
    return this;
  }
  insertData(data2, before) {
    return this.insert(List.createItem(data2), before);
  }
  remove(item) {
    this.updateCursors(item, item.prev, item, item.next);
    if (item.prev !== null) {
      item.prev.next = item.next;
    } else {
      if (this.head !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.head = item.next;
    }
    if (item.next !== null) {
      item.next.prev = item.prev;
    } else {
      if (this.tail !== item) {
        throw new Error("item doesn't belong to list");
      }
      this.tail = item.prev;
    }
    item.prev = null;
    item.next = null;
    return item;
  }
  push(data2) {
    this.insert(List.createItem(data2));
  }
  pop() {
    return this.tail !== null ? this.remove(this.tail) : null;
  }
  unshift(data2) {
    this.prepend(List.createItem(data2));
  }
  shift() {
    return this.head !== null ? this.remove(this.head) : null;
  }
  prependList(list2) {
    return this.insertList(list2, this.head);
  }
  appendList(list2) {
    return this.insertList(list2);
  }
  insertList(list2, before) {
    if (list2.head === null) {
      return this;
    }
    if (before !== void 0 && before !== null) {
      this.updateCursors(before.prev, list2.tail, before, list2.head);
      if (before.prev !== null) {
        before.prev.next = list2.head;
        list2.head.prev = before.prev;
      } else {
        this.head = list2.head;
      }
      before.prev = list2.tail;
      list2.tail.next = before;
    } else {
      this.updateCursors(this.tail, list2.tail, null, list2.head);
      if (this.tail !== null) {
        this.tail.next = list2.head;
        list2.head.prev = this.tail;
      } else {
        this.head = list2.head;
      }
      this.tail = list2.tail;
    }
    list2.head = null;
    list2.tail = null;
    return this;
  }
  replace(oldItem, newItemOrList) {
    if ("head" in newItemOrList) {
      this.insertList(newItemOrList, oldItem);
    } else {
      this.insert(newItemOrList, oldItem);
    }
    this.remove(oldItem);
  }
}
function createCustomError(name2, message) {
  const error = Object.create(SyntaxError.prototype);
  const errorStack = new Error();
  return Object.assign(error, {
    name: name2,
    message,
    get stack() {
      return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name2}: ${message}
`);
    }
  });
}
const MAX_LINE_LENGTH = 100;
const OFFSET_CORRECTION = 60;
const TAB_REPLACEMENT = "    ";
function sourceFragment({ source, line, column, baseLine, baseColumn }, extraLines) {
  function processLines(start, end) {
    return lines.slice(start, end).map(
      (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
    ).join("\n");
  }
  const prelines = "\n".repeat(Math.max(baseLine - 1, 0));
  const precolumns = " ".repeat(Math.max(baseColumn - 1, 0));
  const lines = (prelines + precolumns + source).split(/\r\n?|\n|\f/);
  const startLine = Math.max(1, line - extraLines) - 1;
  const endLine = Math.min(line + extraLines, lines.length + 1);
  const maxNumLength = Math.max(4, String(endLine).length) + 1;
  let cutLeft = 0;
  column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
  if (column > MAX_LINE_LENGTH) {
    cutLeft = column - OFFSET_CORRECTION + 3;
    column = OFFSET_CORRECTION - 2;
  }
  for (let i2 = startLine; i2 <= endLine; i2++) {
    if (i2 >= 0 && i2 < lines.length) {
      lines[i2] = lines[i2].replace(/\t/g, TAB_REPLACEMENT);
      lines[i2] = (cutLeft > 0 && lines[i2].length > cutLeft ? "" : "") + lines[i2].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i2].length > cutLeft + MAX_LINE_LENGTH - 1 ? "" : "");
    }
  }
  return [
    processLines(startLine, line),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line, endLine)
  ].filter(Boolean).join("\n").replace(/^(\s+\d+\s+\|\n)+/, "").replace(/\n(\s+\d+\s+\|)+$/, "");
}
function SyntaxError$2(message, source, offset2, line, column, baseLine = 1, baseColumn = 1) {
  const error = Object.assign(createCustomError("SyntaxError", message), {
    source,
    offset: offset2,
    line,
    column,
    sourceFragment(extraLines) {
      return sourceFragment({ source, line, column, baseLine, baseColumn }, isNaN(extraLines) ? 0 : extraLines);
    },
    get formattedMessage() {
      return `Parse error: ${message}
` + sourceFragment({ source, line, column, baseLine, baseColumn }, 2);
    }
  });
  return error;
}
function readSequence(recognizer) {
  const children = this.createList();
  let space = false;
  const context2 = {
    recognizer
  };
  while (!this.eof) {
    switch (this.tokenType) {
      case Comment$1:
        this.next();
        continue;
      case WhiteSpace$1:
        space = true;
        this.next();
        continue;
    }
    let child = recognizer.getNode.call(this, context2);
    if (child === void 0) {
      break;
    }
    if (space) {
      if (recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, child, children, context2);
      }
      space = false;
    }
    children.push(child);
  }
  if (space && recognizer.onWhiteSpace) {
    recognizer.onWhiteSpace.call(this, null, children, context2);
  }
  return children;
}
const NOOP = () => {
};
const EXCLAMATIONMARK$3 = 33;
const NUMBERSIGN$4 = 35;
const SEMICOLON = 59;
const LEFTCURLYBRACKET$1 = 123;
const NULL = 0;
function createParseContext(name2) {
  return function() {
    return this[name2]();
  };
}
function fetchParseValues(dict) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const name2 of Object.keys(dict)) {
    const item = dict[name2];
    const fn2 = item.parse || item;
    if (fn2) {
      result[name2] = fn2;
    }
  }
  return result;
}
function processConfig(config) {
  const parseConfig = {
    context: /* @__PURE__ */ Object.create(null),
    features: Object.assign(/* @__PURE__ */ Object.create(null), config.features),
    scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
    atrule: fetchParseValues(config.atrule),
    pseudo: fetchParseValues(config.pseudo),
    node: fetchParseValues(config.node)
  };
  for (const [name2, context2] of Object.entries(config.parseContext)) {
    switch (typeof context2) {
      case "function":
        parseConfig.context[name2] = context2;
        break;
      case "string":
        parseConfig.context[name2] = createParseContext(context2);
        break;
    }
  }
  return {
    config: parseConfig,
    ...parseConfig,
    ...parseConfig.node
  };
}
function createParser(config) {
  let source = "";
  let filename2 = "<unknown>";
  let needPositions = false;
  let onParseError = NOOP;
  let onParseErrorThrow = false;
  const locationMap = new OffsetToLocation();
  const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseValue: true,
    parseCustomProperty: false,
    readSequence,
    consumeUntilBalanceEnd: () => 0,
    consumeUntilLeftCurlyBracket(code2) {
      return code2 === LEFTCURLYBRACKET$1 ? 1 : 0;
    },
    consumeUntilLeftCurlyBracketOrSemicolon(code2) {
      return code2 === LEFTCURLYBRACKET$1 || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilExclamationMarkOrSemicolon(code2) {
      return code2 === EXCLAMATIONMARK$3 || code2 === SEMICOLON ? 1 : 0;
    },
    consumeUntilSemicolonIncluded(code2) {
      return code2 === SEMICOLON ? 2 : 0;
    },
    createList() {
      return new List();
    },
    createSingleNodeList(node2) {
      return new List().appendData(node2);
    },
    getFirstListNode(list2) {
      return list2 && list2.first;
    },
    getLastListNode(list2) {
      return list2 && list2.last;
    },
    parseWithFallback(consumer, fallback) {
      const startIndex = this.tokenIndex;
      try {
        return consumer.call(this);
      } catch (e2) {
        if (onParseErrorThrow) {
          throw e2;
        }
        this.skip(startIndex - this.tokenIndex);
        const fallbackNode = fallback.call(this);
        onParseErrorThrow = true;
        onParseError(e2, fallbackNode);
        onParseErrorThrow = false;
        return fallbackNode;
      }
    },
    lookupNonWSType(offset2) {
      let type2;
      do {
        type2 = this.lookupType(offset2++);
        if (type2 !== WhiteSpace$1 && type2 !== Comment$1) {
          return type2;
        }
      } while (type2 !== NULL);
      return NULL;
    },
    charCodeAt(offset2) {
      return offset2 >= 0 && offset2 < source.length ? source.charCodeAt(offset2) : 0;
    },
    substring(offsetStart, offsetEnd) {
      return source.substring(offsetStart, offsetEnd);
    },
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    },
    cmpChar(offset2, charCode) {
      return cmpChar(source, offset2, charCode);
    },
    cmpStr(offsetStart, offsetEnd, str) {
      return cmpStr(source, offsetStart, offsetEnd, str);
    },
    consume(tokenType2) {
      const start = this.tokenStart;
      this.eat(tokenType2);
      return this.substrToCursor(start);
    },
    consumeFunctionName() {
      const name2 = source.substring(this.tokenStart, this.tokenEnd - 1);
      this.eat(Function$2);
      return name2;
    },
    consumeNumber(type2) {
      const number2 = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));
      this.eat(type2);
      return number2;
    },
    eat(tokenType2) {
      if (this.tokenType !== tokenType2) {
        const tokenName = tokenNames[tokenType2].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
        let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
        let offset2 = this.tokenStart;
        switch (tokenType2) {
          case Ident:
            if (this.tokenType === Function$2 || this.tokenType === Url$1) {
              offset2 = this.tokenEnd - 1;
              message = "Identifier is expected but function found";
            } else {
              message = "Identifier is expected";
            }
            break;
          case Hash$1:
            if (this.isDelim(NUMBERSIGN$4)) {
              this.next();
              offset2++;
              message = "Name is expected";
            }
            break;
          case Percentage$1:
            if (this.tokenType === Number$2) {
              offset2 = this.tokenEnd;
              message = "Percent sign is expected";
            }
            break;
        }
        this.error(message, offset2);
      }
      this.next();
    },
    eatIdent(name2) {
      if (this.tokenType !== Ident || this.lookupValue(0, name2) === false) {
        this.error(`Identifier "${name2}" is expected`);
      }
      this.next();
    },
    eatDelim(code2) {
      if (!this.isDelim(code2)) {
        this.error(`Delim "${String.fromCharCode(code2)}" is expected`);
      }
      this.next();
    },
    getLocation(start, end) {
      if (needPositions) {
        return locationMap.getLocationRange(
          start,
          end,
          filename2
        );
      }
      return null;
    },
    getLocationFromList(list2) {
      if (needPositions) {
        const head = this.getFirstListNode(list2);
        const tail = this.getLastListNode(list2);
        return locationMap.getLocationRange(
          head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
          tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
          filename2
        );
      }
      return null;
    },
    error(message, offset2) {
      const location = typeof offset2 !== "undefined" && offset2 < source.length ? locationMap.getLocation(offset2) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
      throw new SyntaxError$2(
        message || "Unexpected input",
        source,
        location.offset,
        location.line,
        location.column,
        locationMap.startLine,
        locationMap.startColumn
      );
    }
  });
  const parse4 = function(source_, options2) {
    source = source_;
    options2 = options2 || {};
    parser.setSource(source, tokenize$1);
    locationMap.setSource(
      source,
      options2.offset,
      options2.line,
      options2.column
    );
    filename2 = options2.filename || "<unknown>";
    needPositions = Boolean(options2.positions);
    onParseError = typeof options2.onParseError === "function" ? options2.onParseError : NOOP;
    onParseErrorThrow = false;
    parser.parseAtrulePrelude = "parseAtrulePrelude" in options2 ? Boolean(options2.parseAtrulePrelude) : true;
    parser.parseRulePrelude = "parseRulePrelude" in options2 ? Boolean(options2.parseRulePrelude) : true;
    parser.parseValue = "parseValue" in options2 ? Boolean(options2.parseValue) : true;
    parser.parseCustomProperty = "parseCustomProperty" in options2 ? Boolean(options2.parseCustomProperty) : false;
    const { context: context2 = "default", onComment } = options2;
    if (context2 in parser.context === false) {
      throw new Error("Unknown context `" + context2 + "`");
    }
    if (typeof onComment === "function") {
      parser.forEachToken((type2, start, end) => {
        if (type2 === Comment$1) {
          const loc = parser.getLocation(start, end);
          const value2 = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
          onComment(value2, loc);
        }
      });
    }
    const ast = parser.context[context2].call(parser, options2);
    if (!parser.eof) {
      parser.error();
    }
    return ast;
  };
  return Object.assign(parse4, {
    SyntaxError: SyntaxError$2,
    config: parser.config
  });
}
var base64Vlq = {};
var base64$1 = {};
var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
base64$1.encode = function(number2) {
  if (0 <= number2 && number2 < intToCharMap.length) {
    return intToCharMap[number2];
  }
  throw new TypeError("Must be between 0 and 63: " + number2);
};
base64$1.decode = function(charCode) {
  var bigA = 65;
  var bigZ = 90;
  var littleA = 97;
  var littleZ = 122;
  var zero2 = 48;
  var nine = 57;
  var plus = 43;
  var slash = 47;
  var littleOffset = 26;
  var numberOffset = 52;
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }
  if (zero2 <= charCode && charCode <= nine) {
    return charCode - zero2 + numberOffset;
  }
  if (charCode == plus) {
    return 62;
  }
  if (charCode == slash) {
    return 63;
  }
  return -1;
};
var base64 = base64$1;
var VLQ_BASE_SHIFT = 5;
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
var VLQ_BASE_MASK = VLQ_BASE - 1;
var VLQ_CONTINUATION_BIT = VLQ_BASE;
function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}
base64Vlq.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned(aValue);
  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);
  return encoded;
};
base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;
  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }
    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }
    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);
  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};
var util$3 = {};
(function(exports$1) {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports$1.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match3 = aUrl.match(urlRegexp);
    if (!match3) {
      return null;
    }
    return {
      scheme: match3[1],
      auth: match3[2],
      host: match3[3],
      port: match3[4],
      path: match3[5]
    };
  }
  exports$1.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url2 = "";
    if (aParsedUrl.scheme) {
      url2 += aParsedUrl.scheme + ":";
    }
    url2 += "//";
    if (aParsedUrl.auth) {
      url2 += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url2 += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url2 += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url2 += aParsedUrl.path;
    }
    return url2;
  }
  exports$1.urlGenerate = urlGenerate;
  var MAX_CACHED_INPUTS = 32;
  function lruMemoize(f2) {
    var cache = [];
    return function(input) {
      for (var i2 = 0; i2 < cache.length; i2++) {
        if (cache[i2].input === input) {
          var temp = cache[0];
          cache[0] = cache[i2];
          cache[i2] = temp;
          return cache[0].result;
        }
      }
      var result = f2(input);
      cache.unshift({
        input,
        result
      });
      if (cache.length > MAX_CACHED_INPUTS) {
        cache.pop();
      }
      return result;
    };
  }
  var normalize2 = lruMemoize(function normalize3(aPath) {
    var path2 = aPath;
    var url2 = urlParse(aPath);
    if (url2) {
      if (!url2.path) {
        return aPath;
      }
      path2 = url2.path;
    }
    var isAbsolute2 = exports$1.isAbsolute(path2);
    var parts = [];
    var start = 0;
    var i2 = 0;
    while (true) {
      start = i2;
      i2 = path2.indexOf("/", start);
      if (i2 === -1) {
        parts.push(path2.slice(start));
        break;
      } else {
        parts.push(path2.slice(start, i2));
        while (i2 < path2.length && path2[i2] === "/") {
          i2++;
        }
      }
    }
    for (var part, up2 = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
      part = parts[i2];
      if (part === ".") {
        parts.splice(i2, 1);
      } else if (part === "..") {
        up2++;
      } else if (up2 > 0) {
        if (part === "") {
          parts.splice(i2 + 1, up2);
          up2 = 0;
        } else {
          parts.splice(i2, 2);
          up2--;
        }
      }
    }
    path2 = parts.join("/");
    if (path2 === "") {
      path2 = isAbsolute2 ? "/" : ".";
    }
    if (url2) {
      url2.path = path2;
      return urlGenerate(url2);
    }
    return path2;
  });
  exports$1.normalize = normalize2;
  function join2(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports$1.join = join2;
  exports$1.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative2(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index2 = aRoot.lastIndexOf("/");
      if (index2 < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index2);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports$1.relative = relative2;
  var supportsNullProto = function() {
    var obj = /* @__PURE__ */ Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s2) {
    return s2;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports$1.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports$1.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s2) {
    if (!s2) {
      return false;
    }
    var length2 = s2.length;
    if (length2 < 9) {
      return false;
    }
    if (s2.charCodeAt(length2 - 1) !== 95 || s2.charCodeAt(length2 - 2) !== 95 || s2.charCodeAt(length2 - 3) !== 111 || s2.charCodeAt(length2 - 4) !== 116 || s2.charCodeAt(length2 - 5) !== 111 || s2.charCodeAt(length2 - 6) !== 114 || s2.charCodeAt(length2 - 7) !== 112 || s2.charCodeAt(length2 - 8) !== 95 || s2.charCodeAt(length2 - 9) !== 95) {
      return false;
    }
    for (var i2 = length2 - 10; i2 >= 0; i2--) {
      if (s2.charCodeAt(i2) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports$1.compareByOriginalPositions = compareByOriginalPositions;
  function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports$1.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports$1.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports$1.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports$1.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports$1.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index2 = parsed.path.lastIndexOf("/");
        if (index2 >= 0) {
          parsed.path = parsed.path.substring(0, index2 + 1);
        }
      }
      sourceURL = join2(urlGenerate(parsed), sourceURL);
    }
    return normalize2(sourceURL);
  }
  exports$1.computeSourceURL = computeSourceURL;
})(util$3);
var arraySet = {};
var util$2 = util$3;
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
function ArraySet$1() {
  this._array = [];
  this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
}
ArraySet$1.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet$1();
  for (var i2 = 0, len = aArray.length; i2 < len; i2++) {
    set.add(aArray[i2], aAllowDuplicates);
  }
  return set;
};
ArraySet$1.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
ArraySet$1.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util$2.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};
ArraySet$1.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util$2.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};
ArraySet$1.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util$2.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }
  throw new Error('"' + aStr + '" is not in the set.');
};
ArraySet$1.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error("No element indexed by " + aIdx);
};
ArraySet$1.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};
arraySet.ArraySet = ArraySet$1;
var mappingList = {};
var util$1 = util$3;
function generatedPositionAfter(mappingA, mappingB) {
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util$1.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
function MappingList$1() {
  this._array = [];
  this._sorted = true;
  this._last = { generatedLine: -1, generatedColumn: 0 };
}
MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};
MappingList$1.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};
MappingList$1.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util$1.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};
mappingList.MappingList = MappingList$1;
var base64VLQ = base64Vlq;
var util = util$3;
var ArraySet = arraySet.ArraySet;
var MappingList = mappingList.MappingList;
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, "file", null);
  this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
  this._skipValidation = util.getArg(aArgs, "skipValidation", false);
  this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}
SourceMapGenerator.prototype._version = 3;
SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
    file: aSourceMapConsumer.file,
    sourceRoot
  }));
  aSourceMapConsumer.eachMapping(function(mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };
    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }
      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };
      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }
    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function(sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }
    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, "generated");
  var original = util.getArg(aArgs, "original", null);
  var source = util.getArg(aArgs, "source", null);
  var name2 = util.getArg(aArgs, "name", null);
  if (!this._skipValidation) {
    if (this._validateMapping(generated, original, source, name2) === false) {
      return;
    }
  }
  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }
  if (name2 != null) {
    name2 = String(name2);
    if (!this._names.has(name2)) {
      this._names.add(name2);
    }
  }
  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source,
    name: name2
  });
};
SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }
  if (aSourceContent != null) {
    if (!this._sourcesContents) {
      this._sourcesContents = /* @__PURE__ */ Object.create(null);
    }
    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    delete this._sourcesContents[util.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error(
        `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
      );
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  }
  var newSources = new ArraySet();
  var newNames = new ArraySet();
  this._mappings.unsortedForEach(function(mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }
    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }
    var name2 = mapping.name;
    if (name2 != null && !newNames.has(name2)) {
      newNames.add(name2);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;
  aSourceMapConsumer.sources.forEach(function(sourceFile2) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile2 = util.join(aSourceMapPath, sourceFile2);
      }
      if (sourceRoot != null) {
        sourceFile2 = util.relative(sourceRoot, sourceFile2);
      }
      this.setSourceContent(sourceFile2, content);
    }
  }, this);
};
SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
    var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
    if (this._ignoreInvalidMapping) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
      return false;
    } else {
      throw new Error(message);
    }
  }
  if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    return;
  } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    return;
  } else {
    var message = "Invalid mapping: " + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    });
    if (this._ignoreInvalidMapping) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
      return false;
    } else {
      throw new Error(message);
    }
  }
};
SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = "";
  var next2;
  var mapping;
  var nameIdx;
  var sourceIdx;
  var mappings = this._mappings.toArray();
  for (var i2 = 0, len = mappings.length; i2 < len; i2++) {
    mapping = mappings[i2];
    next2 = "";
    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next2 += ";";
        previousGeneratedLine++;
      }
    } else {
      if (i2 > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
          continue;
        }
        next2 += ",";
      }
    }
    next2 += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;
    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next2 += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;
      next2 += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next2 += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;
      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next2 += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }
    result += next2;
  }
  return result;
};
SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function(source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }
    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }
  return map;
};
SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};
var SourceMapGenerator_1 = SourceMapGenerator;
const trackNodes = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
function generateSourceMap(handlers) {
  const map = new SourceMapGenerator_1();
  const generated = {
    line: 1,
    column: 0
  };
  const original = {
    line: 0,
    // should be zero to add first mapping
    column: 0
  };
  const activatedGenerated = {
    line: 1,
    column: 0
  };
  const activatedMapping = {
    generated: activatedGenerated
  };
  let line = 1;
  let column = 0;
  let sourceMappingActive = false;
  const origHandlersNode = handlers.node;
  handlers.node = function(node2) {
    if (node2.loc && node2.loc.start && trackNodes.has(node2.type)) {
      const nodeLine = node2.loc.start.line;
      const nodeColumn = node2.loc.start.column - 1;
      if (original.line !== nodeLine || original.column !== nodeColumn) {
        original.line = nodeLine;
        original.column = nodeColumn;
        generated.line = line;
        generated.column = column;
        if (sourceMappingActive) {
          sourceMappingActive = false;
          if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
            map.addMapping(activatedMapping);
          }
        }
        sourceMappingActive = true;
        map.addMapping({
          source: node2.loc.source,
          original,
          generated
        });
      }
    }
    origHandlersNode.call(this, node2);
    if (sourceMappingActive && trackNodes.has(node2.type)) {
      activatedGenerated.line = line;
      activatedGenerated.column = column;
    }
  };
  const origHandlersEmit = handlers.emit;
  handlers.emit = function(value2, type2, auto) {
    for (let i2 = 0; i2 < value2.length; i2++) {
      if (value2.charCodeAt(i2) === 10) {
        line++;
        column = 0;
      } else {
        column++;
      }
    }
    origHandlersEmit(value2, type2, auto);
  };
  const origHandlersResult = handlers.result;
  handlers.result = function() {
    if (sourceMappingActive) {
      map.addMapping(activatedMapping);
    }
    return {
      css: origHandlersResult(),
      map
    };
  };
  return handlers;
}
const PLUSSIGN$9 = 43;
const HYPHENMINUS$6 = 45;
const code = (type2, value2) => {
  if (type2 === Delim) {
    type2 = value2;
  }
  if (typeof type2 === "string") {
    const charCode = type2.charCodeAt(0);
    return charCode > 127 ? 32768 : charCode << 8;
  }
  return type2;
};
const specPairs = [
  [Ident, Ident],
  [Ident, Function$2],
  [Ident, Url$1],
  [Ident, BadUrl],
  [Ident, "-"],
  [Ident, Number$2],
  [Ident, Percentage$1],
  [Ident, Dimension$1],
  [Ident, CDC$1],
  [Ident, LeftParenthesis],
  [AtKeyword, Ident],
  [AtKeyword, Function$2],
  [AtKeyword, Url$1],
  [AtKeyword, BadUrl],
  [AtKeyword, "-"],
  [AtKeyword, Number$2],
  [AtKeyword, Percentage$1],
  [AtKeyword, Dimension$1],
  [AtKeyword, CDC$1],
  [Hash$1, Ident],
  [Hash$1, Function$2],
  [Hash$1, Url$1],
  [Hash$1, BadUrl],
  [Hash$1, "-"],
  [Hash$1, Number$2],
  [Hash$1, Percentage$1],
  [Hash$1, Dimension$1],
  [Hash$1, CDC$1],
  [Dimension$1, Ident],
  [Dimension$1, Function$2],
  [Dimension$1, Url$1],
  [Dimension$1, BadUrl],
  [Dimension$1, "-"],
  [Dimension$1, Number$2],
  [Dimension$1, Percentage$1],
  [Dimension$1, Dimension$1],
  [Dimension$1, CDC$1],
  ["#", Ident],
  ["#", Function$2],
  ["#", Url$1],
  ["#", BadUrl],
  ["#", "-"],
  ["#", Number$2],
  ["#", Percentage$1],
  ["#", Dimension$1],
  ["#", CDC$1],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["-", Ident],
  ["-", Function$2],
  ["-", Url$1],
  ["-", BadUrl],
  ["-", "-"],
  ["-", Number$2],
  ["-", Percentage$1],
  ["-", Dimension$1],
  ["-", CDC$1],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [Number$2, Ident],
  [Number$2, Function$2],
  [Number$2, Url$1],
  [Number$2, BadUrl],
  [Number$2, Number$2],
  [Number$2, Percentage$1],
  [Number$2, Dimension$1],
  [Number$2, "%"],
  [Number$2, CDC$1],
  // https://github.com/w3c/csswg-drafts/pull/6874
  ["@", Ident],
  ["@", Function$2],
  ["@", Url$1],
  ["@", BadUrl],
  ["@", "-"],
  ["@", CDC$1],
  // https://github.com/w3c/csswg-drafts/pull/6874
  [".", Number$2],
  [".", Percentage$1],
  [".", Dimension$1],
  ["+", Number$2],
  ["+", Percentage$1],
  ["+", Dimension$1],
  ["/", "*"]
];
const safePairs = specPairs.concat([
  [Ident, Hash$1],
  [Dimension$1, Hash$1],
  [Hash$1, Hash$1],
  [AtKeyword, LeftParenthesis],
  [AtKeyword, String$2],
  [AtKeyword, Colon],
  [Percentage$1, Percentage$1],
  [Percentage$1, Dimension$1],
  [Percentage$1, Function$2],
  [Percentage$1, "-"],
  [RightParenthesis, Ident],
  [RightParenthesis, Function$2],
  [RightParenthesis, Percentage$1],
  [RightParenthesis, Dimension$1],
  [RightParenthesis, Hash$1],
  [RightParenthesis, "-"]
]);
function createMap(pairs) {
  const isWhiteSpaceRequired = new Set(
    pairs.map(([prev, next2]) => code(prev) << 16 | code(next2))
  );
  return function(prevCode, type2, value2) {
    const nextCode = code(type2, value2);
    const nextCharCode = value2.charCodeAt(0);
    const emitWs = nextCharCode === HYPHENMINUS$6 && type2 !== Ident && type2 !== Function$2 && type2 !== CDC$1 || nextCharCode === PLUSSIGN$9 ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
    if (emitWs) {
      this.emit(" ", WhiteSpace$1, true);
    }
    return nextCode;
  };
}
const spec = createMap(specPairs);
const safe = createMap(safePairs);
var tokenBefore = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  safe,
  spec
});
const REVERSESOLIDUS = 92;
function processChildren(node2, delimeter) {
  if (typeof delimeter === "function") {
    let prev = null;
    node2.children.forEach((node3) => {
      if (prev !== null) {
        delimeter.call(this, prev);
      }
      this.node(node3);
      prev = node3;
    });
    return;
  }
  node2.children.forEach(this.node, this);
}
function processChunk(chunk) {
  tokenize$1(chunk, (type2, start, end) => {
    this.token(type2, chunk.slice(start, end));
  });
}
function createGenerator(config) {
  const types2 = /* @__PURE__ */ new Map();
  for (let [name2, item] of Object.entries(config.node)) {
    const fn2 = item.generate || item;
    if (typeof fn2 === "function") {
      types2.set(name2, item.generate || item);
    }
  }
  return function(node2, options2) {
    let buffer = "";
    let prevCode = 0;
    let handlers = {
      node(node3) {
        if (types2.has(node3.type)) {
          types2.get(node3.type).call(publicApi, node3);
        } else {
          throw new Error("Unknown node type: " + node3.type);
        }
      },
      tokenBefore: safe,
      token(type2, value2) {
        prevCode = this.tokenBefore(prevCode, type2, value2);
        this.emit(value2, type2, false);
        if (type2 === Delim && value2.charCodeAt(0) === REVERSESOLIDUS) {
          this.emit("\n", WhiteSpace$1, true);
        }
      },
      emit(value2) {
        buffer += value2;
      },
      result() {
        return buffer;
      }
    };
    if (options2) {
      if (typeof options2.decorator === "function") {
        handlers = options2.decorator(handlers);
      }
      if (options2.sourceMap) {
        handlers = generateSourceMap(handlers);
      }
      if (options2.mode in tokenBefore) {
        handlers.tokenBefore = tokenBefore[options2.mode];
      }
    }
    const publicApi = {
      node: (node3) => handlers.node(node3),
      children: processChildren,
      token: (type2, value2) => handlers.token(type2, value2),
      tokenize: processChunk
    };
    handlers.node(node2);
    return handlers.result();
  };
}
function createConvertor(walk2) {
  return {
    fromPlainObject(ast) {
      walk2(ast, {
        enter(node2) {
          if (node2.children && node2.children instanceof List === false) {
            node2.children = new List().fromArray(node2.children);
          }
        }
      });
      return ast;
    },
    toPlainObject(ast) {
      walk2(ast, {
        leave(node2) {
          if (node2.children && node2.children instanceof List) {
            node2.children = node2.children.toArray();
          }
        }
      });
      return ast;
    }
  };
}
const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype;
const noop$2 = function() {
};
function ensureFunction$1(value2) {
  return typeof value2 === "function" ? value2 : noop$2;
}
function invokeForType(fn2, type2) {
  return function(node2, item, list2) {
    if (node2.type === type2) {
      fn2.call(this, node2, item, list2);
    }
  };
}
function getWalkersFromStructure(name2, nodeType) {
  const structure2 = nodeType.structure;
  const walkers = [];
  for (const key in structure2) {
    if (hasOwnProperty$3.call(structure2, key) === false) {
      continue;
    }
    let fieldTypes = structure2[key];
    const walker = {
      name: key,
      type: false,
      nullable: false
    };
    if (!Array.isArray(fieldTypes)) {
      fieldTypes = [fieldTypes];
    }
    for (const fieldType of fieldTypes) {
      if (fieldType === null) {
        walker.nullable = true;
      } else if (typeof fieldType === "string") {
        walker.type = "node";
      } else if (Array.isArray(fieldType)) {
        walker.type = "list";
      }
    }
    if (walker.type) {
      walkers.push(walker);
    }
  }
  if (walkers.length) {
    return {
      context: nodeType.walkContext,
      fields: walkers
    };
  }
  return null;
}
function getTypesFromConfig(config) {
  const types2 = {};
  for (const name2 in config.node) {
    if (hasOwnProperty$3.call(config.node, name2)) {
      const nodeType = config.node[name2];
      if (!nodeType.structure) {
        throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
      }
      types2[name2] = getWalkersFromStructure(name2, nodeType);
    }
  }
  return types2;
}
function createTypeIterator(config, reverse2) {
  const fields = config.fields.slice();
  const contextName = config.context;
  const useContext = typeof contextName === "string";
  if (reverse2) {
    fields.reverse();
  }
  return function(node2, context2, walk2, walkReducer) {
    let prevContextValue;
    if (useContext) {
      prevContextValue = context2[contextName];
      context2[contextName] = node2;
    }
    for (const field of fields) {
      const ref2 = node2[field.name];
      if (!field.nullable || ref2) {
        if (field.type === "list") {
          const breakWalk = reverse2 ? ref2.reduceRight(walkReducer, false) : ref2.reduce(walkReducer, false);
          if (breakWalk) {
            return true;
          }
        } else if (walk2(ref2)) {
          return true;
        }
      }
    }
    if (useContext) {
      context2[contextName] = prevContextValue;
    }
  };
}
function createFastTraveralMap({
  StyleSheet: StyleSheet2,
  Atrule: Atrule2,
  Rule: Rule2,
  Block: Block2,
  DeclarationList: DeclarationList2
}) {
  return {
    Atrule: {
      StyleSheet: StyleSheet2,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block2
    },
    Rule: {
      StyleSheet: StyleSheet2,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block2
    },
    Declaration: {
      StyleSheet: StyleSheet2,
      Atrule: Atrule2,
      Rule: Rule2,
      Block: Block2,
      DeclarationList: DeclarationList2
    }
  };
}
function createWalker(config) {
  const types2 = getTypesFromConfig(config);
  const iteratorsNatural = {};
  const iteratorsReverse = {};
  const breakWalk = Symbol("break-walk");
  const skipNode = Symbol("skip-node");
  for (const name2 in types2) {
    if (hasOwnProperty$3.call(types2, name2) && types2[name2] !== null) {
      iteratorsNatural[name2] = createTypeIterator(types2[name2], false);
      iteratorsReverse[name2] = createTypeIterator(types2[name2], true);
    }
  }
  const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
  const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
  const walk2 = function(root2, options2) {
    function walkNode(node2, item, list2) {
      const enterRet = enter.call(context2, node2, item, list2);
      if (enterRet === breakWalk) {
        return true;
      }
      if (enterRet === skipNode) {
        return false;
      }
      if (iterators.hasOwnProperty(node2.type)) {
        if (iterators[node2.type](node2, context2, walkNode, walkReducer)) {
          return true;
        }
      }
      if (leave.call(context2, node2, item, list2) === breakWalk) {
        return true;
      }
      return false;
    }
    let enter = noop$2;
    let leave = noop$2;
    let iterators = iteratorsNatural;
    let walkReducer = (ret, data2, item, list2) => ret || walkNode(data2, item, list2);
    const context2 = {
      break: breakWalk,
      skip: skipNode,
      root: root2,
      stylesheet: null,
      atrule: null,
      atrulePrelude: null,
      rule: null,
      selector: null,
      block: null,
      declaration: null,
      function: null
    };
    if (typeof options2 === "function") {
      enter = options2;
    } else if (options2) {
      enter = ensureFunction$1(options2.enter);
      leave = ensureFunction$1(options2.leave);
      if (options2.reverse) {
        iterators = iteratorsReverse;
      }
      if (options2.visit) {
        if (fastTraversalIteratorsNatural.hasOwnProperty(options2.visit)) {
          iterators = options2.reverse ? fastTraversalIteratorsReverse[options2.visit] : fastTraversalIteratorsNatural[options2.visit];
        } else if (!types2.hasOwnProperty(options2.visit)) {
          throw new Error("Bad value `" + options2.visit + "` for `visit` option (should be: " + Object.keys(types2).sort().join(", ") + ")");
        }
        enter = invokeForType(enter, options2.visit);
        leave = invokeForType(leave, options2.visit);
      }
    }
    if (enter === noop$2 && leave === noop$2) {
      throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
    }
    walkNode(root2);
  };
  walk2.break = breakWalk;
  walk2.skip = skipNode;
  walk2.find = function(ast, fn2) {
    let found = null;
    walk2(ast, function(node2, item, list2) {
      if (fn2.call(this, node2, item, list2)) {
        found = node2;
        return breakWalk;
      }
    });
    return found;
  };
  walk2.findLast = function(ast, fn2) {
    let found = null;
    walk2(ast, {
      reverse: true,
      enter(node2, item, list2) {
        if (fn2.call(this, node2, item, list2)) {
          found = node2;
          return breakWalk;
        }
      }
    });
    return found;
  };
  walk2.findAll = function(ast, fn2) {
    const found = [];
    walk2(ast, function(node2, item, list2) {
      if (fn2.call(this, node2, item, list2)) {
        found.push(node2);
      }
    });
    return found;
  };
  return walk2;
}
function noop$1(value2) {
  return value2;
}
function generateMultiplier(multiplier) {
  const { min, max, comma } = multiplier;
  if (min === 0 && max === 0) {
    return comma ? "#?" : "*";
  }
  if (min === 0 && max === 1) {
    return "?";
  }
  if (min === 1 && max === 0) {
    return comma ? "#" : "+";
  }
  if (min === 1 && max === 1) {
    return "";
  }
  return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
}
function generateTypeOpts(node2) {
  switch (node2.type) {
    case "Range":
      return " [" + (node2.min === null ? "-" : node2.min) + "," + (node2.max === null ? "" : node2.max) + "]";
    default:
      throw new Error("Unknown node type `" + node2.type + "`");
  }
}
function generateSequence(node2, decorate, forceBraces, compact) {
  const combinator = node2.combinator === " " || compact ? node2.combinator : " " + node2.combinator + " ";
  const result = node2.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
  if (node2.explicit || forceBraces) {
    return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
  }
  return result;
}
function internalGenerate(node2, decorate, forceBraces, compact) {
  let result;
  switch (node2.type) {
    case "Group":
      result = generateSequence(node2, decorate, forceBraces, compact) + (node2.disallowEmpty ? "!" : "");
      break;
    case "Multiplier":
      return internalGenerate(node2.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node2), node2);
    case "Boolean":
      result = "<boolean-expr[" + internalGenerate(node2.term, decorate, forceBraces, compact) + "]>";
      break;
    case "Type":
      result = "<" + node2.name + (node2.opts ? decorate(generateTypeOpts(node2.opts), node2.opts) : "") + ">";
      break;
    case "Property":
      result = "<'" + node2.name + "'>";
      break;
    case "Keyword":
      result = node2.name;
      break;
    case "AtKeyword":
      result = "@" + node2.name;
      break;
    case "Function":
      result = node2.name + "(";
      break;
    case "String":
    case "Token":
      result = node2.value;
      break;
    case "Comma":
      result = ",";
      break;
    default:
      throw new Error("Unknown node type `" + node2.type + "`");
  }
  return decorate(result, node2);
}
function generate$O(node2, options2) {
  let decorate = noop$1;
  let forceBraces = false;
  let compact = false;
  if (typeof options2 === "function") {
    decorate = options2;
  } else if (options2) {
    forceBraces = Boolean(options2.forceBraces);
    compact = Boolean(options2.compact);
    if (typeof options2.decorate === "function") {
      decorate = options2.decorate;
    }
  }
  return internalGenerate(node2, decorate, forceBraces, compact);
}
const defaultLoc = { offset: 0, line: 1, column: 1 };
function locateMismatch(matchResult, node2) {
  const tokens = matchResult.tokens;
  const longestMatch = matchResult.longestMatch;
  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
  const badNode = mismatchNode !== node2 ? mismatchNode : null;
  let mismatchOffset = 0;
  let mismatchLength = 0;
  let entries = 0;
  let css = "";
  let start;
  let end;
  for (let i2 = 0; i2 < tokens.length; i2++) {
    const token = tokens[i2].value;
    if (i2 === longestMatch) {
      mismatchLength = token.length;
      mismatchOffset = css.length;
    }
    if (badNode !== null && tokens[i2].node === badNode) {
      if (i2 <= longestMatch) {
        entries++;
      } else {
        entries = 0;
      }
    }
    css += token;
  }
  if (longestMatch === tokens.length || entries > 1) {
    start = fromLoc(badNode || node2, "end") || buildLoc(defaultLoc, css);
    end = buildLoc(start);
  } else {
    start = fromLoc(badNode, "start") || buildLoc(fromLoc(node2, "start") || defaultLoc, css.slice(0, mismatchOffset));
    end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
  }
  return {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  };
}
function fromLoc(node2, point) {
  const value2 = node2 && node2.loc && node2.loc[point];
  if (value2) {
    return "line" in value2 ? buildLoc(value2) : value2;
  }
  return null;
}
function buildLoc({ offset: offset2, line, column }, extra) {
  const loc = {
    offset: offset2,
    line,
    column
  };
  if (extra) {
    const lines = extra.split(/\n|\r\n?|\f/);
    loc.offset += extra.length;
    loc.line += lines.length - 1;
    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
  }
  return loc;
}
const SyntaxReferenceError = function(type2, referenceName) {
  const error = createCustomError(
    "SyntaxReferenceError",
    type2 + (referenceName ? " `" + referenceName + "`" : "")
  );
  error.reference = referenceName;
  return error;
};
const SyntaxMatchError = function(message, syntax2, node2, matchResult) {
  const error = createCustomError("SyntaxMatchError", message);
  const {
    css,
    mismatchOffset,
    mismatchLength,
    start,
    end
  } = locateMismatch(matchResult, node2);
  error.rawMessage = message;
  error.syntax = syntax2 ? generate$O(syntax2) : "<generic>";
  error.css = css;
  error.mismatchOffset = mismatchOffset;
  error.mismatchLength = mismatchLength;
  error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
  Object.assign(error, start);
  error.loc = {
    source: node2 && node2.loc && node2.loc.source || "<unknown>",
    start,
    end
  };
  return error;
};
const keywords = /* @__PURE__ */ new Map();
const properties = /* @__PURE__ */ new Map();
const HYPHENMINUS$5 = 45;
const keyword = getKeywordDescriptor;
const property = getPropertyDescriptor;
function isCustomProperty(str, offset2) {
  offset2 = offset2 || 0;
  return str.length - offset2 >= 2 && str.charCodeAt(offset2) === HYPHENMINUS$5 && str.charCodeAt(offset2 + 1) === HYPHENMINUS$5;
}
function getVendorPrefix(str, offset2) {
  offset2 = offset2 || 0;
  if (str.length - offset2 >= 3) {
    if (str.charCodeAt(offset2) === HYPHENMINUS$5 && str.charCodeAt(offset2 + 1) !== HYPHENMINUS$5) {
      const secondDashIndex = str.indexOf("-", offset2 + 2);
      if (secondDashIndex !== -1) {
        return str.substring(offset2, secondDashIndex + 1);
      }
    }
  }
  return "";
}
function getKeywordDescriptor(keyword2) {
  if (keywords.has(keyword2)) {
    return keywords.get(keyword2);
  }
  const name2 = keyword2.toLowerCase();
  let descriptor = keywords.get(name2);
  if (descriptor === void 0) {
    const custom = isCustomProperty(name2, 0);
    const vendor = !custom ? getVendorPrefix(name2, 0) : "";
    descriptor = Object.freeze({
      basename: name2.substr(vendor.length),
      name: name2,
      prefix: vendor,
      vendor,
      custom
    });
  }
  keywords.set(keyword2, descriptor);
  return descriptor;
}
function getPropertyDescriptor(property2) {
  if (properties.has(property2)) {
    return properties.get(property2);
  }
  let name2 = property2;
  let hack = property2[0];
  if (hack === "/") {
    hack = property2[1] === "/" ? "//" : "/";
  } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
    hack = "";
  }
  const custom = isCustomProperty(name2, hack.length);
  if (!custom) {
    name2 = name2.toLowerCase();
    if (properties.has(name2)) {
      const descriptor2 = properties.get(name2);
      properties.set(property2, descriptor2);
      return descriptor2;
    }
  }
  const vendor = !custom ? getVendorPrefix(name2, hack.length) : "";
  const prefix = name2.substr(0, hack.length + vendor.length);
  const descriptor = Object.freeze({
    basename: name2.substr(prefix.length),
    name: name2.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom
  });
  properties.set(property2, descriptor);
  return descriptor;
}
const cssWideKeywords = [
  "initial",
  "inherit",
  "unset",
  "revert",
  "revert-layer"
];
const PLUSSIGN$8 = 43;
const HYPHENMINUS$4 = 45;
const N$3 = 110;
const DISALLOW_SIGN$1 = true;
const ALLOW_SIGN$1 = false;
function isDelim$1(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function skipSC(token, offset2, getNextToken) {
  while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1)) {
    token = getNextToken(++offset2);
  }
  return offset2;
}
function checkInteger$1(token, valueOffset, disallowSign, offset2) {
  if (!token) {
    return 0;
  }
  const code2 = token.value.charCodeAt(valueOffset);
  if (code2 === PLUSSIGN$8 || code2 === HYPHENMINUS$4) {
    if (disallowSign) {
      return 0;
    }
    valueOffset++;
  }
  for (; valueOffset < token.value.length; valueOffset++) {
    if (!isDigit(token.value.charCodeAt(valueOffset))) {
      return 0;
    }
  }
  return offset2 + 1;
}
function consumeB$1(token, offset_, getNextToken) {
  let sign2 = false;
  let offset2 = skipSC(token, offset_, getNextToken);
  token = getNextToken(offset2);
  if (token === null) {
    return offset_;
  }
  if (token.type !== Number$2) {
    if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
      sign2 = true;
      offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
      token = getNextToken(offset2);
      if (token === null || token.type !== Number$2) {
        return 0;
      }
    } else {
      return offset_;
    }
  }
  if (!sign2) {
    const code2 = token.value.charCodeAt(0);
    if (code2 !== PLUSSIGN$8 && code2 !== HYPHENMINUS$4) {
      return 0;
    }
  }
  return checkInteger$1(token, sign2 ? 0 : 1, sign2, offset2);
}
function anPlusB(token, getNextToken) {
  let offset2 = 0;
  if (!token) {
    return 0;
  }
  if (token.type === Number$2) {
    return checkInteger$1(token, 0, ALLOW_SIGN$1, offset2);
  } else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS$4) {
    if (!cmpChar(token.value, 1, N$3)) {
      return 0;
    }
    switch (token.value.length) {
      case 2:
        return consumeB$1(getNextToken(++offset2), offset2, getNextToken);
      case 3:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
          return 0;
        }
        offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
        token = getNextToken(offset2);
        return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset2);
      default:
        if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
          return 0;
        }
        return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset2);
    }
  } else if (token.type === Ident || isDelim$1(token, PLUSSIGN$8) && getNextToken(offset2 + 1).type === Ident) {
    if (token.type !== Ident) {
      token = getNextToken(++offset2);
    }
    if (token === null || !cmpChar(token.value, 0, N$3)) {
      return 0;
    }
    switch (token.value.length) {
      case 1:
        return consumeB$1(getNextToken(++offset2), offset2, getNextToken);
      case 2:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
          return 0;
        }
        offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
        token = getNextToken(offset2);
        return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset2);
      default:
        if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
          return 0;
        }
        return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset2);
    }
  } else if (token.type === Dimension$1) {
    let code2 = token.value.charCodeAt(0);
    let sign2 = code2 === PLUSSIGN$8 || code2 === HYPHENMINUS$4 ? 1 : 0;
    let i2 = sign2;
    for (; i2 < token.value.length; i2++) {
      if (!isDigit(token.value.charCodeAt(i2))) {
        break;
      }
    }
    if (i2 === sign2) {
      return 0;
    }
    if (!cmpChar(token.value, i2, N$3)) {
      return 0;
    }
    if (i2 + 1 === token.value.length) {
      return consumeB$1(getNextToken(++offset2), offset2, getNextToken);
    } else {
      if (token.value.charCodeAt(i2 + 1) !== HYPHENMINUS$4) {
        return 0;
      }
      if (i2 + 2 === token.value.length) {
        offset2 = skipSC(getNextToken(++offset2), offset2, getNextToken);
        token = getNextToken(offset2);
        return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset2);
      } else {
        return checkInteger$1(token, i2 + 2, DISALLOW_SIGN$1, offset2);
      }
    }
  }
  return 0;
}
const PLUSSIGN$7 = 43;
const HYPHENMINUS$3 = 45;
const QUESTIONMARK$2 = 63;
const U$1 = 117;
function isDelim(token, code2) {
  return token !== null && token.type === Delim && token.value.charCodeAt(0) === code2;
}
function startsWith$1(token, code2) {
  return token.value.charCodeAt(0) === code2;
}
function hexSequence(token, offset2, allowDash) {
  let hexlen = 0;
  for (let pos = offset2; pos < token.value.length; pos++) {
    const code2 = token.value.charCodeAt(pos);
    if (code2 === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
      hexSequence(token, offset2 + hexlen + 1, false);
      return 6;
    }
    if (!isHexDigit(code2)) {
      return 0;
    }
    if (++hexlen > 6) {
      return 0;
    }
  }
  return hexlen;
}
function withQuestionMarkSequence(consumed, length2, getNextToken) {
  if (!consumed) {
    return 0;
  }
  while (isDelim(getNextToken(length2), QUESTIONMARK$2)) {
    if (++consumed > 6) {
      return 0;
    }
    length2++;
  }
  return length2;
}
function urange(token, getNextToken) {
  let length2 = 0;
  if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U$1)) {
    return 0;
  }
  token = getNextToken(++length2);
  if (token === null) {
    return 0;
  }
  if (isDelim(token, PLUSSIGN$7)) {
    token = getNextToken(++length2);
    if (token === null) {
      return 0;
    }
    if (token.type === Ident) {
      return withQuestionMarkSequence(hexSequence(token, 0, true), ++length2, getNextToken);
    }
    if (isDelim(token, QUESTIONMARK$2)) {
      return withQuestionMarkSequence(1, ++length2, getNextToken);
    }
    return 0;
  }
  if (token.type === Number$2) {
    const consumedHexLength = hexSequence(token, 1, true);
    if (consumedHexLength === 0) {
      return 0;
    }
    token = getNextToken(++length2);
    if (token === null) {
      return length2;
    }
    if (token.type === Dimension$1 || token.type === Number$2) {
      if (!startsWith$1(token, HYPHENMINUS$3) || !hexSequence(token, 1, false)) {
        return 0;
      }
      return length2 + 1;
    }
    return withQuestionMarkSequence(consumedHexLength, length2, getNextToken);
  }
  if (token.type === Dimension$1) {
    return withQuestionMarkSequence(hexSequence(token, 1, true), ++length2, getNextToken);
  }
  return 0;
}
const calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
const balancePair = /* @__PURE__ */ new Map([
  [Function$2, RightParenthesis],
  [LeftParenthesis, RightParenthesis],
  [LeftSquareBracket, RightSquareBracket],
  [LeftCurlyBracket, RightCurlyBracket]
]);
function charCodeAt(str, index2) {
  return index2 < str.length ? str.charCodeAt(index2) : 0;
}
function eqStr(actual, expected) {
  return cmpStr(actual, 0, actual.length, expected);
}
function eqStrAny(actual, expected) {
  for (let i2 = 0; i2 < expected.length; i2++) {
    if (eqStr(actual, expected[i2])) {
      return true;
    }
  }
  return false;
}
function isPostfixIeHack(str, offset2) {
  if (offset2 !== str.length - 2) {
    return false;
  }
  return charCodeAt(str, offset2) === 92 && // U+005C REVERSE SOLIDUS (\)
  isDigit(charCodeAt(str, offset2 + 1));
}
function outOfRange(opts, value2, numEnd) {
  if (opts && opts.type === "Range") {
    const num = Number(
      numEnd !== void 0 && numEnd !== value2.length ? value2.substr(0, numEnd) : value2
    );
    if (isNaN(num)) {
      return true;
    }
    if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
      return true;
    }
    if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
      return true;
    }
  }
  return false;
}
function consumeFunction(token, getNextToken) {
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          if (balanceStash.length === 0) {
            length2++;
            break scan;
          }
          break;
        case Function$2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function calc(next2) {
  return function(token, getNextToken, opts) {
    if (token === null) {
      return 0;
    }
    if (token.type === Function$2 && eqStrAny(token.value, calcFunctionNames)) {
      return consumeFunction(token, getNextToken);
    }
    return next2(token, getNextToken, opts);
  };
}
function tokenType(expectedTokenType) {
  return function(token) {
    if (token === null || token.type !== expectedTokenType) {
      return 0;
    }
    return 1;
  };
}
function customIdent(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  const name2 = token.value.toLowerCase();
  if (eqStrAny(name2, cssWideKeywords)) {
    return 0;
  }
  if (eqStr(name2, "default")) {
    return 0;
  }
  return 1;
}
function dashedIdent(token) {
  if (token === null || token.type !== Ident) {
    return 0;
  }
  if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
    return 0;
  }
  return 1;
}
function customPropertyName(token) {
  if (!dashedIdent(token)) {
    return 0;
  }
  if (token.value === "--") {
    return 0;
  }
  return 1;
}
function hexColor(token) {
  if (token === null || token.type !== Hash$1) {
    return 0;
  }
  const length2 = token.value.length;
  if (length2 !== 4 && length2 !== 5 && length2 !== 7 && length2 !== 9) {
    return 0;
  }
  for (let i2 = 1; i2 < length2; i2++) {
    if (!isHexDigit(charCodeAt(token.value, i2))) {
      return 0;
    }
  }
  return 1;
}
function idSelector(token) {
  if (token === null || token.type !== Hash$1) {
    return 0;
  }
  if (!isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
    return 0;
  }
  return 1;
}
function declarationValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Semicolon:
          if (balanceCloseType === 0) {
            break scan;
          }
          break;
        case Delim:
          if (balanceCloseType === 0 && token.value === "!") {
            break scan;
          }
          break;
        case Function$2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function anyValue(token, getNextToken) {
  if (!token) {
    return 0;
  }
  let balanceCloseType = 0;
  let balanceStash = [];
  let length2 = 0;
  scan:
    do {
      switch (token.type) {
        case BadString:
        case BadUrl:
          break scan;
        case RightCurlyBracket:
        case RightParenthesis:
        case RightSquareBracket:
          if (token.type !== balanceCloseType) {
            break scan;
          }
          balanceCloseType = balanceStash.pop();
          break;
        case Function$2:
        case LeftParenthesis:
        case LeftSquareBracket:
        case LeftCurlyBracket:
          balanceStash.push(balanceCloseType);
          balanceCloseType = balancePair.get(token.type);
          break;
      }
      length2++;
    } while (token = getNextToken(length2));
  return length2;
}
function dimension(type2) {
  if (type2) {
    type2 = new Set(type2);
  }
  return function(token, getNextToken, opts) {
    if (token === null || token.type !== Dimension$1) {
      return 0;
    }
    const numberEnd = consumeNumber(token.value, 0);
    if (type2 !== null) {
      const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
      const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
      if (type2.has(unit.toLowerCase()) === false) {
        return 0;
      }
    }
    if (outOfRange(opts, token.value, numberEnd)) {
      return 0;
    }
    return 1;
  };
}
function percentage(token, getNextToken, opts) {
  if (token === null || token.type !== Percentage$1) {
    return 0;
  }
  if (outOfRange(opts, token.value, token.value.length - 1)) {
    return 0;
  }
  return 1;
}
function zero(next2) {
  if (typeof next2 !== "function") {
    next2 = function() {
      return 0;
    };
  }
  return function(token, getNextToken, opts) {
    if (token !== null && token.type === Number$2) {
      if (Number(token.value) === 0) {
        return 1;
      }
    }
    return next2(token, getNextToken, opts);
  };
}
function number(token, getNextToken, opts) {
  if (token === null) {
    return 0;
  }
  const numberEnd = consumeNumber(token.value, 0);
  const isNumber2 = numberEnd === token.value.length;
  if (!isNumber2 && !isPostfixIeHack(token.value, numberEnd)) {
    return 0;
  }
  if (outOfRange(opts, token.value, numberEnd)) {
    return 0;
  }
  return 1;
}
function integer(token, getNextToken, opts) {
  if (token === null || token.type !== Number$2) {
    return 0;
  }
  let i2 = charCodeAt(token.value, 0) === 43 || // U+002B PLUS SIGN (+)
  charCodeAt(token.value, 0) === 45 ? 1 : 0;
  for (; i2 < token.value.length; i2++) {
    if (!isDigit(charCodeAt(token.value, i2))) {
      return 0;
    }
  }
  if (outOfRange(opts, token.value, i2)) {
    return 0;
  }
  return 1;
}
const tokenTypes = {
  "ident-token": tokenType(Ident),
  "function-token": tokenType(Function$2),
  "at-keyword-token": tokenType(AtKeyword),
  "hash-token": tokenType(Hash$1),
  "string-token": tokenType(String$2),
  "bad-string-token": tokenType(BadString),
  "url-token": tokenType(Url$1),
  "bad-url-token": tokenType(BadUrl),
  "delim-token": tokenType(Delim),
  "number-token": tokenType(Number$2),
  "percentage-token": tokenType(Percentage$1),
  "dimension-token": tokenType(Dimension$1),
  "whitespace-token": tokenType(WhiteSpace$1),
  "CDO-token": tokenType(CDO$1),
  "CDC-token": tokenType(CDC$1),
  "colon-token": tokenType(Colon),
  "semicolon-token": tokenType(Semicolon),
  "comma-token": tokenType(Comma),
  "[-token": tokenType(LeftSquareBracket),
  "]-token": tokenType(RightSquareBracket),
  "(-token": tokenType(LeftParenthesis),
  ")-token": tokenType(RightParenthesis),
  "{-token": tokenType(LeftCurlyBracket),
  "}-token": tokenType(RightCurlyBracket)
};
const productionTypes = {
  // token type aliases
  "string": tokenType(String$2),
  "ident": tokenType(Ident),
  // percentage
  "percentage": calc(percentage),
  // numeric
  "zero": zero(),
  "number": calc(number),
  "integer": calc(integer),
  // complex types
  "custom-ident": customIdent,
  "dashed-ident": dashedIdent,
  "custom-property-name": customPropertyName,
  "hex-color": hexColor,
  "id-selector": idSelector,
  // element( <id-selector> )
  "an-plus-b": anPlusB,
  "urange": urange,
  "declaration-value": declarationValue,
  "any-value": anyValue
};
function createDemensionTypes(units2) {
  const {
    angle: angle2,
    decibel: decibel2,
    frequency: frequency2,
    flex: flex2,
    length: length2,
    resolution: resolution2,
    semitones: semitones2,
    time: time2
  } = units2 || {};
  return {
    "dimension": calc(dimension(null)),
    "angle": calc(dimension(angle2)),
    "decibel": calc(dimension(decibel2)),
    "frequency": calc(dimension(frequency2)),
    "flex": calc(dimension(flex2)),
    "length": calc(zero(dimension(length2))),
    "resolution": calc(dimension(resolution2)),
    "semitones": calc(dimension(semitones2)),
    "time": calc(dimension(time2))
  };
}
function createGenericTypes(units2) {
  return {
    ...tokenTypes,
    ...productionTypes,
    ...createDemensionTypes(units2)
  };
}
const length = [
  // absolute length units https://www.w3.org/TR/css-values-3/#lengths
  "cm",
  "mm",
  "q",
  "in",
  "pt",
  "pc",
  "px",
  // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
  "em",
  "rem",
  "ex",
  "rex",
  "cap",
  "rcap",
  "ch",
  "rch",
  "ic",
  "ric",
  "lh",
  "rlh",
  // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  "vw",
  "svw",
  "lvw",
  "dvw",
  "vh",
  "svh",
  "lvh",
  "dvh",
  "vi",
  "svi",
  "lvi",
  "dvi",
  "vb",
  "svb",
  "lvb",
  "dvb",
  "vmin",
  "svmin",
  "lvmin",
  "dvmin",
  "vmax",
  "svmax",
  "lvmax",
  "dvmax",
  // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
  "cqw",
  "cqh",
  "cqi",
  "cqb",
  "cqmin",
  "cqmax"
];
const angle = ["deg", "grad", "rad", "turn"];
const time = ["s", "ms"];
const frequency = ["hz", "khz"];
const resolution = ["dpi", "dpcm", "dppx", "x"];
const flex = ["fr"];
const decibel = ["db"];
const semitones = ["st"];
var units = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  angle,
  decibel,
  flex,
  frequency,
  length,
  resolution,
  semitones,
  time
});
function SyntaxError$1(message, input, offset2) {
  return Object.assign(createCustomError("SyntaxError", message), {
    input,
    offset: offset2,
    rawMessage: message,
    message: message + "\n  " + input + "\n--" + new Array((offset2 || input.length) + 1).join("-") + "^"
  });
}
const TAB$1 = 9;
const N$2 = 10;
const F$1 = 12;
const R$1 = 13;
const SPACE$3 = 32;
const NAME_CHAR = new Uint8Array(128).map(
  (_2, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
);
class Scanner {
  constructor(str) {
    this.str = str;
    this.pos = 0;
  }
  charCodeAt(pos) {
    return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
  }
  charCode() {
    return this.charCodeAt(this.pos);
  }
  isNameCharCode(code2 = this.charCode()) {
    return code2 < 128 && NAME_CHAR[code2] === 1;
  }
  nextCharCode() {
    return this.charCodeAt(this.pos + 1);
  }
  nextNonWsCode(pos) {
    return this.charCodeAt(this.findWsEnd(pos));
  }
  skipWs() {
    this.pos = this.findWsEnd(this.pos);
  }
  findWsEnd(pos) {
    for (; pos < this.str.length; pos++) {
      const code2 = this.str.charCodeAt(pos);
      if (code2 !== R$1 && code2 !== N$2 && code2 !== F$1 && code2 !== SPACE$3 && code2 !== TAB$1) {
        break;
      }
    }
    return pos;
  }
  substringToPos(end) {
    return this.str.substring(this.pos, this.pos = end);
  }
  eat(code2) {
    if (this.charCode() !== code2) {
      this.error("Expect `" + String.fromCharCode(code2) + "`");
    }
    this.pos++;
  }
  peek() {
    return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
  }
  error(message) {
    throw new SyntaxError$1(message, this.str, this.pos);
  }
  scanSpaces() {
    return this.substringToPos(this.findWsEnd(this.pos));
  }
  scanWord() {
    let end = this.pos;
    for (; end < this.str.length; end++) {
      const code2 = this.str.charCodeAt(end);
      if (code2 >= 128 || NAME_CHAR[code2] === 0) {
        break;
      }
    }
    if (this.pos === end) {
      this.error("Expect a keyword");
    }
    return this.substringToPos(end);
  }
  scanNumber() {
    let end = this.pos;
    for (; end < this.str.length; end++) {
      const code2 = this.str.charCodeAt(end);
      if (code2 < 48 || code2 > 57) {
        break;
      }
    }
    if (this.pos === end) {
      this.error("Expect a number");
    }
    return this.substringToPos(end);
  }
  scanString() {
    const end = this.str.indexOf("'", this.pos + 1);
    if (end === -1) {
      this.pos = this.str.length;
      this.error("Expect an apostrophe");
    }
    return this.substringToPos(end + 1);
  }
}
const TAB = 9;
const N$1 = 10;
const F = 12;
const R = 13;
const SPACE$2 = 32;
const EXCLAMATIONMARK$2 = 33;
const NUMBERSIGN$3 = 35;
const AMPERSAND$5 = 38;
const APOSTROPHE$2 = 39;
const LEFTPARENTHESIS$2 = 40;
const RIGHTPARENTHESIS$2 = 41;
const ASTERISK$6 = 42;
const PLUSSIGN$6 = 43;
const COMMA = 44;
const HYPERMINUS = 45;
const LESSTHANSIGN$1 = 60;
const GREATERTHANSIGN$3 = 62;
const QUESTIONMARK$1 = 63;
const COMMERCIALAT = 64;
const LEFTSQUAREBRACKET = 91;
const RIGHTSQUAREBRACKET = 93;
const LEFTCURLYBRACKET = 123;
const VERTICALLINE$3 = 124;
const RIGHTCURLYBRACKET = 125;
const INFINITY = 8734;
const COMBINATOR_PRECEDENCE = {
  " ": 1,
  "&&": 2,
  "||": 3,
  "|": 4
};
function readMultiplierRange(scanner) {
  let min = null;
  let max = null;
  scanner.eat(LEFTCURLYBRACKET);
  scanner.skipWs();
  min = scanner.scanNumber(scanner);
  scanner.skipWs();
  if (scanner.charCode() === COMMA) {
    scanner.pos++;
    scanner.skipWs();
    if (scanner.charCode() !== RIGHTCURLYBRACKET) {
      max = scanner.scanNumber(scanner);
      scanner.skipWs();
    }
  } else {
    max = min;
  }
  scanner.eat(RIGHTCURLYBRACKET);
  return {
    min: Number(min),
    max: max ? Number(max) : 0
  };
}
function readMultiplier(scanner) {
  let range2 = null;
  let comma = false;
  switch (scanner.charCode()) {
    case ASTERISK$6:
      scanner.pos++;
      range2 = {
        min: 0,
        max: 0
      };
      break;
    case PLUSSIGN$6:
      scanner.pos++;
      range2 = {
        min: 1,
        max: 0
      };
      break;
    case QUESTIONMARK$1:
      scanner.pos++;
      range2 = {
        min: 0,
        max: 1
      };
      break;
    case NUMBERSIGN$3:
      scanner.pos++;
      comma = true;
      if (scanner.charCode() === LEFTCURLYBRACKET) {
        range2 = readMultiplierRange(scanner);
      } else if (scanner.charCode() === QUESTIONMARK$1) {
        scanner.pos++;
        range2 = {
          min: 0,
          max: 0
        };
      } else {
        range2 = {
          min: 1,
          max: 0
        };
      }
      break;
    case LEFTCURLYBRACKET:
      range2 = readMultiplierRange(scanner);
      break;
    default:
      return null;
  }
  return {
    type: "Multiplier",
    comma,
    min: range2.min,
    max: range2.max,
    term: null
  };
}
function maybeMultiplied(scanner, node2) {
  const multiplier = readMultiplier(scanner);
  if (multiplier !== null) {
    multiplier.term = node2;
    if (scanner.charCode() === NUMBERSIGN$3 && scanner.charCodeAt(scanner.pos - 1) === PLUSSIGN$6) {
      return maybeMultiplied(scanner, multiplier);
    }
    return multiplier;
  }
  return node2;
}
function maybeToken(scanner) {
  const ch2 = scanner.peek();
  if (ch2 === "") {
    return null;
  }
  return maybeMultiplied(scanner, {
    type: "Token",
    value: ch2
  });
}
function readProperty$1(scanner) {
  let name2;
  scanner.eat(LESSTHANSIGN$1);
  scanner.eat(APOSTROPHE$2);
  name2 = scanner.scanWord();
  scanner.eat(APOSTROPHE$2);
  scanner.eat(GREATERTHANSIGN$3);
  return maybeMultiplied(scanner, {
    type: "Property",
    name: name2
  });
}
function readTypeRange(scanner) {
  let min = null;
  let max = null;
  let sign2 = 1;
  scanner.eat(LEFTSQUAREBRACKET);
  if (scanner.charCode() === HYPERMINUS) {
    scanner.peek();
    sign2 = -1;
  }
  if (sign2 == -1 && scanner.charCode() === INFINITY) {
    scanner.peek();
  } else {
    min = sign2 * Number(scanner.scanNumber(scanner));
    if (scanner.isNameCharCode()) {
      min += scanner.scanWord();
    }
  }
  scanner.skipWs();
  scanner.eat(COMMA);
  scanner.skipWs();
  if (scanner.charCode() === INFINITY) {
    scanner.peek();
  } else {
    sign2 = 1;
    if (scanner.charCode() === HYPERMINUS) {
      scanner.peek();
      sign2 = -1;
    }
    max = sign2 * Number(scanner.scanNumber(scanner));
    if (scanner.isNameCharCode()) {
      max += scanner.scanWord();
    }
  }
  scanner.eat(RIGHTSQUAREBRACKET);
  return {
    type: "Range",
    min,
    max
  };
}
function readType(scanner) {
  let name2;
  let opts = null;
  scanner.eat(LESSTHANSIGN$1);
  name2 = scanner.scanWord();
  if (name2 === "boolean-expr") {
    scanner.eat(LEFTSQUAREBRACKET);
    const implicitGroup = readImplicitGroup(scanner, RIGHTSQUAREBRACKET);
    scanner.eat(RIGHTSQUAREBRACKET);
    scanner.eat(GREATERTHANSIGN$3);
    return maybeMultiplied(scanner, {
      type: "Boolean",
      term: implicitGroup.terms.length === 1 ? implicitGroup.terms[0] : implicitGroup
    });
  }
  if (scanner.charCode() === LEFTPARENTHESIS$2 && scanner.nextCharCode() === RIGHTPARENTHESIS$2) {
    scanner.pos += 2;
    name2 += "()";
  }
  if (scanner.charCodeAt(scanner.findWsEnd(scanner.pos)) === LEFTSQUAREBRACKET) {
    scanner.skipWs();
    opts = readTypeRange(scanner);
  }
  scanner.eat(GREATERTHANSIGN$3);
  return maybeMultiplied(scanner, {
    type: "Type",
    name: name2,
    opts
  });
}
function readKeywordOrFunction(scanner) {
  const name2 = scanner.scanWord();
  if (scanner.charCode() === LEFTPARENTHESIS$2) {
    scanner.pos++;
    return {
      type: "Function",
      name: name2
    };
  }
  return maybeMultiplied(scanner, {
    type: "Keyword",
    name: name2
  });
}
function regroupTerms(terms, combinators) {
  function createGroup(terms2, combinator2) {
    return {
      type: "Group",
      terms: terms2,
      combinator: combinator2,
      disallowEmpty: false,
      explicit: false
    };
  }
  let combinator;
  combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
  while (combinators.length > 0) {
    combinator = combinators.shift();
    let i2 = 0;
    let subgroupStart = 0;
    for (; i2 < terms.length; i2++) {
      const term = terms[i2];
      if (term.type === "Combinator") {
        if (term.value === combinator) {
          if (subgroupStart === -1) {
            subgroupStart = i2 - 1;
          }
          terms.splice(i2, 1);
          i2--;
        } else {
          if (subgroupStart !== -1 && i2 - subgroupStart > 1) {
            terms.splice(
              subgroupStart,
              i2 - subgroupStart,
              createGroup(terms.slice(subgroupStart, i2), combinator)
            );
            i2 = subgroupStart + 1;
          }
          subgroupStart = -1;
        }
      }
    }
    if (subgroupStart !== -1 && combinators.length) {
      terms.splice(
        subgroupStart,
        i2 - subgroupStart,
        createGroup(terms.slice(subgroupStart, i2), combinator)
      );
    }
  }
  return combinator;
}
function readImplicitGroup(scanner, stopCharCode) {
  const combinators = /* @__PURE__ */ Object.create(null);
  const terms = [];
  let token;
  let prevToken = null;
  let prevTokenPos = scanner.pos;
  while (scanner.charCode() !== stopCharCode && (token = peek(scanner, stopCharCode))) {
    if (token.type !== "Spaces") {
      if (token.type === "Combinator") {
        if (prevToken === null || prevToken.type === "Combinator") {
          scanner.pos = prevTokenPos;
          scanner.error("Unexpected combinator");
        }
        combinators[token.value] = true;
      } else if (prevToken !== null && prevToken.type !== "Combinator") {
        combinators[" "] = true;
        terms.push({
          type: "Combinator",
          value: " "
        });
      }
      terms.push(token);
      prevToken = token;
      prevTokenPos = scanner.pos;
    }
  }
  if (prevToken !== null && prevToken.type === "Combinator") {
    scanner.pos -= prevTokenPos;
    scanner.error("Unexpected combinator");
  }
  return {
    type: "Group",
    terms,
    combinator: regroupTerms(terms, combinators) || " ",
    disallowEmpty: false,
    explicit: false
  };
}
function readGroup(scanner, stopCharCode) {
  let result;
  scanner.eat(LEFTSQUAREBRACKET);
  result = readImplicitGroup(scanner, stopCharCode);
  scanner.eat(RIGHTSQUAREBRACKET);
  result.explicit = true;
  if (scanner.charCode() === EXCLAMATIONMARK$2) {
    scanner.pos++;
    result.disallowEmpty = true;
  }
  return result;
}
function peek(scanner, stopCharCode) {
  let code2 = scanner.charCode();
  switch (code2) {
    case RIGHTSQUAREBRACKET:
      break;
    case LEFTSQUAREBRACKET:
      return maybeMultiplied(scanner, readGroup(scanner, stopCharCode));
    case LESSTHANSIGN$1:
      return scanner.nextCharCode() === APOSTROPHE$2 ? readProperty$1(scanner) : readType(scanner);
    case VERTICALLINE$3:
      return {
        type: "Combinator",
        value: scanner.substringToPos(
          scanner.pos + (scanner.nextCharCode() === VERTICALLINE$3 ? 2 : 1)
        )
      };
    case AMPERSAND$5:
      scanner.pos++;
      scanner.eat(AMPERSAND$5);
      return {
        type: "Combinator",
        value: "&&"
      };
    case COMMA:
      scanner.pos++;
      return {
        type: "Comma"
      };
    case APOSTROPHE$2:
      return maybeMultiplied(scanner, {
        type: "String",
        value: scanner.scanString()
      });
    case SPACE$2:
    case TAB:
    case N$1:
    case R:
    case F:
      return {
        type: "Spaces",
        value: scanner.scanSpaces()
      };
    case COMMERCIALAT:
      code2 = scanner.nextCharCode();
      if (scanner.isNameCharCode(code2)) {
        scanner.pos++;
        return {
          type: "AtKeyword",
          name: scanner.scanWord()
        };
      }
      return maybeToken(scanner);
    case ASTERISK$6:
    case PLUSSIGN$6:
    case QUESTIONMARK$1:
    case NUMBERSIGN$3:
    case EXCLAMATIONMARK$2:
      break;
    case LEFTCURLYBRACKET:
      code2 = scanner.nextCharCode();
      if (code2 < 48 || code2 > 57) {
        return maybeToken(scanner);
      }
      break;
    default:
      if (scanner.isNameCharCode(code2)) {
        return readKeywordOrFunction(scanner);
      }
      return maybeToken(scanner);
  }
}
function parse$O(source) {
  const scanner = new Scanner(source);
  const result = readImplicitGroup(scanner);
  if (scanner.pos !== source.length) {
    scanner.error("Unexpected input");
  }
  if (result.terms.length === 1 && result.terms[0].type === "Group") {
    return result.terms[0];
  }
  return result;
}
const noop = function() {
};
function ensureFunction(value2) {
  return typeof value2 === "function" ? value2 : noop;
}
function walk$1(node2, options2, context2) {
  function walk2(node3) {
    enter.call(context2, node3);
    switch (node3.type) {
      case "Group":
        node3.terms.forEach(walk2);
        break;
      case "Multiplier":
      case "Boolean":
        walk2(node3.term);
        break;
      case "Type":
      case "Property":
      case "Keyword":
      case "AtKeyword":
      case "Function":
      case "String":
      case "Token":
      case "Comma":
        break;
      default:
        throw new Error("Unknown type: " + node3.type);
    }
    leave.call(context2, node3);
  }
  let enter = noop;
  let leave = noop;
  if (typeof options2 === "function") {
    enter = options2;
  } else if (options2) {
    enter = ensureFunction(options2.enter);
    leave = ensureFunction(options2.leave);
  }
  if (enter === noop && leave === noop) {
    throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
  }
  walk2(node2);
}
const astToTokens = {
  decorator(handlers) {
    const tokens = [];
    let curNode = null;
    return {
      ...handlers,
      node(node2) {
        const tmp = curNode;
        curNode = node2;
        handlers.node.call(this, node2);
        curNode = tmp;
      },
      emit(value2, type2, auto) {
        tokens.push({
          type: type2,
          value: value2,
          node: auto ? null : curNode
        });
      },
      result() {
        return tokens;
      }
    };
  }
};
function stringToTokens(str) {
  const tokens = [];
  tokenize$1(
    str,
    (type2, start, end) => tokens.push({
      type: type2,
      value: str.slice(start, end),
      node: null
    })
  );
  return tokens;
}
function prepareTokens(value2, syntax2) {
  if (typeof value2 === "string") {
    return stringToTokens(value2);
  }
  return syntax2.generate(value2, astToTokens);
}
const MATCH = { type: "Match" };
const MISMATCH = { type: "Mismatch" };
const DISALLOW_EMPTY = { type: "DisallowEmpty" };
const LEFTPARENTHESIS$1 = 40;
const RIGHTPARENTHESIS$1 = 41;
function createCondition(match3, thenBranch, elseBranch) {
  if (thenBranch === MATCH && elseBranch === MISMATCH) {
    return match3;
  }
  if (match3 === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
    return match3;
  }
  if (match3.type === "If" && match3.else === MISMATCH && thenBranch === MATCH) {
    thenBranch = match3.then;
    match3 = match3.match;
  }
  return {
    type: "If",
    match: match3,
    then: thenBranch,
    else: elseBranch
  };
}
function isFunctionType(name2) {
  return name2.length > 2 && name2.charCodeAt(name2.length - 2) === LEFTPARENTHESIS$1 && name2.charCodeAt(name2.length - 1) === RIGHTPARENTHESIS$1;
}
function isEnumCapatible(term) {
  return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
}
function groupNode(terms, combinator = " ", explicit = false) {
  return {
    type: "Group",
    terms,
    combinator,
    disallowEmpty: false,
    explicit
  };
}
function replaceTypeInGraph(node2, replacements, visited = /* @__PURE__ */ new Set()) {
  if (!visited.has(node2)) {
    visited.add(node2);
    switch (node2.type) {
      case "If":
        node2.match = replaceTypeInGraph(node2.match, replacements, visited);
        node2.then = replaceTypeInGraph(node2.then, replacements, visited);
        node2.else = replaceTypeInGraph(node2.else, replacements, visited);
        break;
      case "Type":
        return replacements[node2.name] || node2;
    }
  }
  return node2;
}
function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
  switch (combinator) {
    case " ": {
      let result = MATCH;
      for (let i2 = terms.length - 1; i2 >= 0; i2--) {
        const term = terms[i2];
        result = createCondition(
          term,
          result,
          MISMATCH
        );
      }
      return result;
    }
    case "|": {
      let result = MISMATCH;
      let map = null;
      for (let i2 = terms.length - 1; i2 >= 0; i2--) {
        let term = terms[i2];
        if (isEnumCapatible(term)) {
          if (map === null && i2 > 0 && isEnumCapatible(terms[i2 - 1])) {
            map = /* @__PURE__ */ Object.create(null);
            result = createCondition(
              {
                type: "Enum",
                map
              },
              MATCH,
              result
            );
          }
          if (map !== null) {
            const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
            if (key in map === false) {
              map[key] = term;
              continue;
            }
          }
        }
        map = null;
        result = createCondition(
          term,
          MATCH,
          result
        );
      }
      return result;
    }
    case "&&": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: true
        };
      }
      let result = MISMATCH;
      for (let i2 = terms.length - 1; i2 >= 0; i2--) {
        const term = terms[i2];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            false
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      return result;
    }
    case "||": {
      if (terms.length > 5) {
        return {
          type: "MatchOnce",
          terms,
          all: false
        };
      }
      let result = atLeastOneTermMatched ? MATCH : MISMATCH;
      for (let i2 = terms.length - 1; i2 >= 0; i2--) {
        const term = terms[i2];
        let thenClause;
        if (terms.length > 1) {
          thenClause = buildGroupMatchGraph(
            combinator,
            terms.filter(function(newGroupTerm) {
              return newGroupTerm !== term;
            }),
            true
          );
        } else {
          thenClause = MATCH;
        }
        result = createCondition(
          term,
          thenClause,
          result
        );
      }
      return result;
    }
  }
}
function buildMultiplierMatchGraph(node2) {
  let result = MATCH;
  let matchTerm = buildMatchGraphInternal(node2.term);
  if (node2.max === 0) {
    matchTerm = createCondition(
      matchTerm,
      DISALLOW_EMPTY,
      MISMATCH
    );
    result = createCondition(
      matchTerm,
      null,
      // will be a loop
      MISMATCH
    );
    result.then = createCondition(
      MATCH,
      MATCH,
      result
      // make a loop
    );
    if (node2.comma) {
      result.then.else = createCondition(
        { type: "Comma", syntax: node2 },
        result,
        MISMATCH
      );
    }
  } else {
    for (let i2 = node2.min || 1; i2 <= node2.max; i2++) {
      if (node2.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node2 },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        createCondition(
          MATCH,
          MATCH,
          result
        ),
        MISMATCH
      );
    }
  }
  if (node2.min === 0) {
    result = createCondition(
      MATCH,
      MATCH,
      result
    );
  } else {
    for (let i2 = 0; i2 < node2.min - 1; i2++) {
      if (node2.comma && result !== MATCH) {
        result = createCondition(
          { type: "Comma", syntax: node2 },
          result,
          MISMATCH
        );
      }
      result = createCondition(
        matchTerm,
        result,
        MISMATCH
      );
    }
  }
  return result;
}
function buildMatchGraphInternal(node2) {
  if (typeof node2 === "function") {
    return {
      type: "Generic",
      fn: node2
    };
  }
  switch (node2.type) {
    case "Group": {
      let result = buildGroupMatchGraph(
        node2.combinator,
        node2.terms.map(buildMatchGraphInternal),
        false
      );
      if (node2.disallowEmpty) {
        result = createCondition(
          result,
          DISALLOW_EMPTY,
          MISMATCH
        );
      }
      return result;
    }
    case "Multiplier":
      return buildMultiplierMatchGraph(node2);
    case "Boolean": {
      const term = buildMatchGraphInternal(node2.term);
      const matchNode = buildMatchGraphInternal(groupNode([
        groupNode([
          { type: "Keyword", name: "not" },
          { type: "Type", name: "!boolean-group" }
        ]),
        groupNode([
          { type: "Type", name: "!boolean-group" },
          groupNode([
            { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
              { type: "Keyword", name: "and" },
              { type: "Type", name: "!boolean-group" }
            ]) },
            { type: "Multiplier", comma: false, min: 0, max: 0, term: groupNode([
              { type: "Keyword", name: "or" },
              { type: "Type", name: "!boolean-group" }
            ]) }
          ], "|")
        ])
      ], "|"));
      const booleanGroup = buildMatchGraphInternal(
        groupNode([
          { type: "Type", name: "!term" },
          groupNode([
            { type: "Token", value: "(" },
            { type: "Type", name: "!self" },
            { type: "Token", value: ")" }
          ]),
          { type: "Type", name: "general-enclosed" }
        ], "|")
      );
      replaceTypeInGraph(booleanGroup, { "!term": term, "!self": matchNode });
      replaceTypeInGraph(matchNode, { "!boolean-group": booleanGroup });
      return matchNode;
    }
    case "Type":
    case "Property":
      return {
        type: node2.type,
        name: node2.name,
        syntax: node2
      };
    case "Keyword":
      return {
        type: node2.type,
        name: node2.name.toLowerCase(),
        syntax: node2
      };
    case "AtKeyword":
      return {
        type: node2.type,
        name: "@" + node2.name.toLowerCase(),
        syntax: node2
      };
    case "Function":
      return {
        type: node2.type,
        name: node2.name.toLowerCase() + "(",
        syntax: node2
      };
    case "String":
      if (node2.value.length === 3) {
        return {
          type: "Token",
          value: node2.value.charAt(1),
          syntax: node2
        };
      }
      return {
        type: node2.type,
        value: node2.value.substr(1, node2.value.length - 2).replace(/\\'/g, "'"),
        syntax: node2
      };
    case "Token":
      return {
        type: node2.type,
        value: node2.value,
        syntax: node2
      };
    case "Comma":
      return {
        type: node2.type,
        syntax: node2
      };
    default:
      throw new Error("Unknown node type:", node2.type);
  }
}
function buildMatchGraph(syntaxTree, ref2) {
  if (typeof syntaxTree === "string") {
    syntaxTree = parse$O(syntaxTree);
  }
  return {
    type: "MatchGraph",
    match: buildMatchGraphInternal(syntaxTree),
    syntax: ref2 || null,
    source: syntaxTree
  };
}
const { hasOwnProperty: hasOwnProperty$2 } = Object.prototype;
const STUB = 0;
const TOKEN = 1;
const OPEN_SYNTAX = 2;
const CLOSE_SYNTAX = 3;
const EXIT_REASON_MATCH = "Match";
const EXIT_REASON_MISMATCH = "Mismatch";
const EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
const ITERATION_LIMIT = 15e3;
function reverseList(list2) {
  let prev = null;
  let next2 = null;
  let item = list2;
  while (item !== null) {
    next2 = item.prev;
    item.prev = prev;
    prev = item;
    item = next2;
  }
  return prev;
}
function areStringsEqualCaseInsensitive(testStr, referenceStr) {
  if (testStr.length !== referenceStr.length) {
    return false;
  }
  for (let i2 = 0; i2 < testStr.length; i2++) {
    const referenceCode = referenceStr.charCodeAt(i2);
    let testCode = testStr.charCodeAt(i2);
    if (testCode >= 65 && testCode <= 90) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function isContextEdgeDelim(token) {
  if (token.type !== Delim) {
    return false;
  }
  return token.value !== "?";
}
function isCommaContextStart(token) {
  if (token === null) {
    return true;
  }
  return token.type === Comma || token.type === Function$2 || token.type === LeftParenthesis || token.type === LeftSquareBracket || token.type === LeftCurlyBracket || isContextEdgeDelim(token);
}
function isCommaContextEnd(token) {
  if (token === null) {
    return true;
  }
  return token.type === RightParenthesis || token.type === RightSquareBracket || token.type === RightCurlyBracket || token.type === Delim && token.value === "/";
}
function internalMatch(tokens, state, syntaxes) {
  function moveToNextToken() {
    do {
      tokenIndex++;
      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
    } while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1));
  }
  function getNextToken(offset2) {
    const nextIndex2 = tokenIndex + offset2;
    return nextIndex2 < tokens.length ? tokens[nextIndex2] : null;
  }
  function stateSnapshotFromSyntax(nextState, prev) {
    return {
      nextState,
      matchStack,
      syntaxStack,
      thenStack,
      tokenIndex,
      prev
    };
  }
  function pushThenStack(nextState) {
    thenStack = {
      nextState,
      matchStack,
      syntaxStack,
      prev: thenStack
    };
  }
  function pushElseStack(nextState) {
    elseStack = stateSnapshotFromSyntax(nextState, elseStack);
  }
  function addTokenToMatch() {
    matchStack = {
      type: TOKEN,
      syntax: state.syntax,
      token,
      prev: matchStack
    };
    moveToNextToken();
    syntaxStash = null;
    if (tokenIndex > longestMatch) {
      longestMatch = tokenIndex;
    }
  }
  function openSyntax() {
    syntaxStack = {
      syntax: state.syntax,
      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
      prev: syntaxStack
    };
    matchStack = {
      type: OPEN_SYNTAX,
      syntax: state.syntax,
      token: matchStack.token,
      prev: matchStack
    };
  }
  function closeSyntax() {
    if (matchStack.type === OPEN_SYNTAX) {
      matchStack = matchStack.prev;
    } else {
      matchStack = {
        type: CLOSE_SYNTAX,
        syntax: syntaxStack.syntax,
        token: matchStack.token,
        prev: matchStack
      };
    }
    syntaxStack = syntaxStack.prev;
  }
  let syntaxStack = null;
  let thenStack = null;
  let elseStack = null;
  let syntaxStash = null;
  let iterationCount = 0;
  let exitReason = null;
  let token = null;
  let tokenIndex = -1;
  let longestMatch = 0;
  let matchStack = {
    type: STUB,
    syntax: null,
    token: null,
    prev: null
  };
  moveToNextToken();
  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
    switch (state.type) {
      case "Match":
        if (thenStack === null) {
          if (token !== null) {
            if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
              state = MISMATCH;
              break;
            }
          }
          exitReason = EXIT_REASON_MATCH;
          break;
        }
        state = thenStack.nextState;
        if (state === DISALLOW_EMPTY) {
          if (thenStack.matchStack === matchStack) {
            state = MISMATCH;
            break;
          } else {
            state = MATCH;
          }
        }
        while (thenStack.syntaxStack !== syntaxStack) {
          closeSyntax();
        }
        thenStack = thenStack.prev;
        break;
      case "Mismatch":
        if (syntaxStash !== null && syntaxStash !== false) {
          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
            elseStack = syntaxStash;
            syntaxStash = false;
          }
        } else if (elseStack === null) {
          exitReason = EXIT_REASON_MISMATCH;
          break;
        }
        state = elseStack.nextState;
        thenStack = elseStack.thenStack;
        syntaxStack = elseStack.syntaxStack;
        matchStack = elseStack.matchStack;
        tokenIndex = elseStack.tokenIndex;
        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        elseStack = elseStack.prev;
        break;
      case "MatchGraph":
        state = state.match;
        break;
      case "If":
        if (state.else !== MISMATCH) {
          pushElseStack(state.else);
        }
        if (state.then !== MATCH) {
          pushThenStack(state.then);
        }
        state = state.match;
        break;
      case "MatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state,
          index: 0,
          mask: 0
        };
        break;
      case "MatchOnceBuffer": {
        const terms = state.syntax.terms;
        if (state.index === terms.length) {
          if (state.mask === 0 || state.syntax.all) {
            state = MISMATCH;
            break;
          }
          state = MATCH;
          break;
        }
        if (state.mask === (1 << terms.length) - 1) {
          state = MATCH;
          break;
        }
        for (; state.index < terms.length; state.index++) {
          const matchFlag = 1 << state.index;
          if ((state.mask & matchFlag) === 0) {
            pushElseStack(state);
            pushThenStack({
              type: "AddMatchOnce",
              syntax: state.syntax,
              mask: state.mask | matchFlag
            });
            state = terms[state.index++];
            break;
          }
        }
        break;
      }
      case "AddMatchOnce":
        state = {
          type: "MatchOnceBuffer",
          syntax: state.syntax,
          index: 0,
          mask: state.mask
        };
        break;
      case "Enum":
        if (token !== null) {
          let name2 = token.value.toLowerCase();
          if (name2.indexOf("\\") !== -1) {
            name2 = name2.replace(/\\[09].*$/, "");
          }
          if (hasOwnProperty$2.call(state.map, name2)) {
            state = state.map[name2];
            break;
          }
        }
        state = MISMATCH;
        break;
      case "Generic": {
        const opts = syntaxStack !== null ? syntaxStack.opts : null;
        const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
        if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
          while (tokenIndex < lastTokenIndex2) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      }
      case "Type":
      case "Property": {
        const syntaxDict = state.type === "Type" ? "types" : "properties";
        const dictSyntax = hasOwnProperty$2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
        if (!dictSyntax || !dictSyntax.match) {
          throw new Error(
            "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
          );
        }
        if (syntaxStash !== false && token !== null && state.type === "Type") {
          const lowPriorityMatching = (
            // https://drafts.csswg.org/css-values-4/#custom-idents
            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
            // can only claim the keyword if no other unfulfilled production can claim it.
            state.name === "custom-ident" && token.type === Ident || // https://drafts.csswg.org/css-values-4/#lengths
            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
            // it must parse as a <number>
            state.name === "length" && token.value === "0"
          );
          if (lowPriorityMatching) {
            if (syntaxStash === null) {
              syntaxStash = stateSnapshotFromSyntax(state, elseStack);
            }
            state = MISMATCH;
            break;
          }
        }
        openSyntax();
        state = dictSyntax.matchRef || dictSyntax.match;
        break;
      }
      case "Keyword": {
        const name2 = state.name;
        if (token !== null) {
          let keywordName = token.value;
          if (keywordName.indexOf("\\") !== -1) {
            keywordName = keywordName.replace(/\\[09].*$/, "");
          }
          if (areStringsEqualCaseInsensitive(keywordName, name2)) {
            addTokenToMatch();
            state = MATCH;
            break;
          }
        }
        state = MISMATCH;
        break;
      }
      case "AtKeyword":
      case "Function":
        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Token":
        if (token !== null && token.value === state.value) {
          addTokenToMatch();
          state = MATCH;
          break;
        }
        state = MISMATCH;
        break;
      case "Comma":
        if (token !== null && token.type === Comma) {
          if (isCommaContextStart(matchStack.token)) {
            state = MISMATCH;
          } else {
            addTokenToMatch();
            state = isCommaContextEnd(token) ? MISMATCH : MATCH;
          }
        } else {
          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
        }
        break;
      case "String":
        let string = "";
        let lastTokenIndex = tokenIndex;
        for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
          string += tokens[lastTokenIndex].value;
        }
        if (areStringsEqualCaseInsensitive(string, state.value)) {
          while (tokenIndex < lastTokenIndex) {
            addTokenToMatch();
          }
          state = MATCH;
        } else {
          state = MISMATCH;
        }
        break;
      default:
        throw new Error("Unknown node type: " + state.type);
    }
  }
  switch (exitReason) {
    case null:
      console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
      exitReason = EXIT_REASON_ITERATION_LIMIT;
      matchStack = null;
      break;
    case EXIT_REASON_MATCH:
      while (syntaxStack !== null) {
        closeSyntax();
      }
      break;
    default:
      matchStack = null;
  }
  return {
    tokens,
    reason: exitReason,
    iterations: iterationCount,
    match: matchStack,
    longestMatch
  };
}
function matchAsTree(tokens, matchGraph, syntaxes) {
  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});
  if (matchResult.match === null) {
    return matchResult;
  }
  let item = matchResult.match;
  let host = matchResult.match = {
    syntax: matchGraph.syntax || null,
    match: []
  };
  const hostStack = [host];
  item = reverseList(item).prev;
  while (item !== null) {
    switch (item.type) {
      case OPEN_SYNTAX:
        host.match.push(host = {
          syntax: item.syntax,
          match: []
        });
        hostStack.push(host);
        break;
      case CLOSE_SYNTAX:
        hostStack.pop();
        host = hostStack[hostStack.length - 1];
        break;
      default:
        host.match.push({
          syntax: item.syntax || null,
          token: item.token.value,
          node: item.token.node
        });
    }
    item = item.prev;
  }
  return matchResult;
}
function getTrace(node2) {
  function shouldPutToTrace(syntax2) {
    if (syntax2 === null) {
      return false;
    }
    return syntax2.type === "Type" || syntax2.type === "Property" || syntax2.type === "Keyword";
  }
  function hasMatch(matchNode) {
    if (Array.isArray(matchNode.match)) {
      for (let i2 = 0; i2 < matchNode.match.length; i2++) {
        if (hasMatch(matchNode.match[i2])) {
          if (shouldPutToTrace(matchNode.syntax)) {
            result.unshift(matchNode.syntax);
          }
          return true;
        }
      }
    } else if (matchNode.node === node2) {
      result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
      return true;
    }
    return false;
  }
  let result = null;
  if (this.matched !== null) {
    hasMatch(this.matched);
  }
  return result;
}
function isType(node2, type2) {
  return testNode(this, node2, (match3) => match3.type === "Type" && match3.name === type2);
}
function isProperty(node2, property2) {
  return testNode(this, node2, (match3) => match3.type === "Property" && match3.name === property2);
}
function isKeyword(node2) {
  return testNode(this, node2, (match3) => match3.type === "Keyword");
}
function testNode(match3, node2, fn2) {
  const trace2 = getTrace.call(match3, node2);
  if (trace2 === null) {
    return false;
  }
  return trace2.some(fn2);
}
var trace = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getTrace,
  isKeyword,
  isProperty,
  isType
});
function getFirstMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getFirstMatchNode(matchNode.match[0]);
}
function getLastMatchNode(matchNode) {
  if ("node" in matchNode) {
    return matchNode.node;
  }
  return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}
function matchFragments(lexer2, ast, match3, type2, name2) {
  function findFragments(matchNode) {
    if (matchNode.syntax !== null && matchNode.syntax.type === type2 && matchNode.syntax.name === name2) {
      const start = getFirstMatchNode(matchNode);
      const end = getLastMatchNode(matchNode);
      lexer2.syntax.walk(ast, function(node2, item, list2) {
        if (node2 === start) {
          const nodes = new List();
          do {
            nodes.appendData(item.data);
            if (item.data === end) {
              break;
            }
            item = item.next;
          } while (item !== null);
          fragments.push({
            parent: list2,
            nodes
          });
        }
      });
    }
    if (Array.isArray(matchNode.match)) {
      matchNode.match.forEach(findFragments);
    }
  }
  const fragments = [];
  if (match3.matched !== null) {
    findFragments(match3.matched);
  }
  return fragments;
}
const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
function isValidNumber(value2) {
  return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2 && value2 >= 0;
}
function isValidLocation(loc) {
  return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
}
function createNodeStructureChecker(type2, fields) {
  return function checkNode(node2, warn) {
    if (!node2 || node2.constructor !== Object) {
      return warn(node2, "Type of node should be an Object");
    }
    for (let key in node2) {
      let valid = true;
      if (hasOwnProperty$1.call(node2, key) === false) {
        continue;
      }
      if (key === "type") {
        if (node2.type !== type2) {
          warn(node2, "Wrong node type `" + node2.type + "`, expected `" + type2 + "`");
        }
      } else if (key === "loc") {
        if (node2.loc === null) {
          continue;
        } else if (node2.loc && node2.loc.constructor === Object) {
          if (typeof node2.loc.source !== "string") {
            key += ".source";
          } else if (!isValidLocation(node2.loc.start)) {
            key += ".start";
          } else if (!isValidLocation(node2.loc.end)) {
            key += ".end";
          } else {
            continue;
          }
        }
        valid = false;
      } else if (fields.hasOwnProperty(key)) {
        valid = false;
        for (let i2 = 0; !valid && i2 < fields[key].length; i2++) {
          const fieldType = fields[key][i2];
          switch (fieldType) {
            case String:
              valid = typeof node2[key] === "string";
              break;
            case Boolean:
              valid = typeof node2[key] === "boolean";
              break;
            case null:
              valid = node2[key] === null;
              break;
            default:
              if (typeof fieldType === "string") {
                valid = node2[key] && node2[key].type === fieldType;
              } else if (Array.isArray(fieldType)) {
                valid = node2[key] instanceof List;
              }
          }
        }
      } else {
        warn(node2, "Unknown field `" + key + "` for " + type2 + " node type");
      }
      if (!valid) {
        warn(node2, "Bad value for `" + type2 + "." + key + "`");
      }
    }
    for (const key in fields) {
      if (hasOwnProperty$1.call(fields, key) && hasOwnProperty$1.call(node2, key) === false) {
        warn(node2, "Field `" + type2 + "." + key + "` is missed");
      }
    }
  };
}
function genTypesList(fieldTypes, path2) {
  const docsTypes = [];
  for (let i2 = 0; i2 < fieldTypes.length; i2++) {
    const fieldType = fieldTypes[i2];
    if (fieldType === String || fieldType === Boolean) {
      docsTypes.push(fieldType.name.toLowerCase());
    } else if (fieldType === null) {
      docsTypes.push("null");
    } else if (typeof fieldType === "string") {
      docsTypes.push(fieldType);
    } else if (Array.isArray(fieldType)) {
      docsTypes.push("List<" + (genTypesList(fieldType, path2) || "any") + ">");
    } else {
      throw new Error("Wrong value `" + fieldType + "` in `" + path2 + "` structure definition");
    }
  }
  return docsTypes.join(" | ");
}
function processStructure(name2, nodeType) {
  const structure2 = nodeType.structure;
  const fields = {
    type: String,
    loc: true
  };
  const docs = {
    type: '"' + name2 + '"'
  };
  for (const key in structure2) {
    if (hasOwnProperty$1.call(structure2, key) === false) {
      continue;
    }
    const fieldTypes = fields[key] = Array.isArray(structure2[key]) ? structure2[key].slice() : [structure2[key]];
    docs[key] = genTypesList(fieldTypes, name2 + "." + key);
  }
  return {
    docs,
    check: createNodeStructureChecker(name2, fields)
  };
}
function getStructureFromConfig(config) {
  const structure2 = {};
  if (config.node) {
    for (const name2 in config.node) {
      if (hasOwnProperty$1.call(config.node, name2)) {
        const nodeType = config.node[name2];
        if (nodeType.structure) {
          structure2[name2] = processStructure(name2, nodeType);
        } else {
          throw new Error("Missed `structure` field in `" + name2 + "` node type definition");
        }
      }
    }
  }
  return structure2;
}
function dumpMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const name2 in map) {
    if (map[name2].syntax) {
      result[name2] = syntaxAsAst ? map[name2].syntax : generate$O(map[name2].syntax, { compact });
    }
  }
  return result;
}
function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
  const result = {};
  for (const [name2, atrule2] of Object.entries(map)) {
    result[name2] = {
      prelude: atrule2.prelude && (syntaxAsAst ? atrule2.prelude.syntax : generate$O(atrule2.prelude.syntax, { compact })),
      descriptors: atrule2.descriptors && dumpMapSyntax(atrule2.descriptors, compact, syntaxAsAst)
    };
  }
  return result;
}
function valueHasVar(tokens) {
  for (let i2 = 0; i2 < tokens.length; i2++) {
    if (tokens[i2].value.toLowerCase() === "var(") {
      return true;
    }
  }
  return false;
}
function syntaxHasTopLevelCommaMultiplier(syntax2) {
  const singleTerm = syntax2.terms[0];
  return syntax2.explicit === false && syntax2.terms.length === 1 && singleTerm.type === "Multiplier" && singleTerm.comma === true;
}
function buildMatchResult(matched, error, iterations) {
  return {
    matched,
    iterations,
    error,
    ...trace
  };
}
function matchSyntax(lexer2, syntax2, value2, useCssWideKeywords) {
  const tokens = prepareTokens(value2, lexer2.syntax);
  let result;
  if (valueHasVar(tokens)) {
    return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
  }
  if (useCssWideKeywords) {
    result = matchAsTree(tokens, lexer2.cssWideKeywordsSyntax, lexer2);
  }
  if (!useCssWideKeywords || !result.match) {
    result = matchAsTree(tokens, syntax2.match, lexer2);
    if (!result.match) {
      return buildMatchResult(
        null,
        new SyntaxMatchError(result.reason, syntax2.syntax, value2, result),
        result.iterations
      );
    }
  }
  return buildMatchResult(result.match, null, result.iterations);
}
class Lexer {
  constructor(config, syntax2, structure2) {
    this.cssWideKeywords = cssWideKeywords;
    this.syntax = syntax2;
    this.generic = false;
    this.units = { ...units };
    this.atrules = /* @__PURE__ */ Object.create(null);
    this.properties = /* @__PURE__ */ Object.create(null);
    this.types = /* @__PURE__ */ Object.create(null);
    this.structure = structure2 || getStructureFromConfig(config);
    if (config) {
      if (config.cssWideKeywords) {
        this.cssWideKeywords = config.cssWideKeywords;
      }
      if (config.units) {
        for (const group of Object.keys(units)) {
          if (Array.isArray(config.units[group])) {
            this.units[group] = config.units[group];
          }
        }
      }
      if (config.types) {
        for (const [name2, type2] of Object.entries(config.types)) {
          this.addType_(name2, type2);
        }
      }
      if (config.generic) {
        this.generic = true;
        for (const [name2, value2] of Object.entries(createGenericTypes(this.units))) {
          this.addType_(name2, value2);
        }
      }
      if (config.atrules) {
        for (const [name2, atrule2] of Object.entries(config.atrules)) {
          this.addAtrule_(name2, atrule2);
        }
      }
      if (config.properties) {
        for (const [name2, property2] of Object.entries(config.properties)) {
          this.addProperty_(name2, property2);
        }
      }
    }
    this.cssWideKeywordsSyntax = buildMatchGraph(this.cssWideKeywords.join(" |  "));
  }
  checkStructure(ast) {
    function collectWarning(node2, message) {
      warns.push({ node: node2, message });
    }
    const structure2 = this.structure;
    const warns = [];
    this.syntax.walk(ast, function(node2) {
      if (structure2.hasOwnProperty(node2.type)) {
        structure2[node2.type].check(node2, collectWarning);
      } else {
        collectWarning(node2, "Unknown node type `" + node2.type + "`");
      }
    });
    return warns.length ? warns : false;
  }
  createDescriptor(syntax2, type2, name2, parent = null) {
    const ref2 = {
      type: type2,
      name: name2
    };
    const descriptor = {
      type: type2,
      name: name2,
      parent,
      serializable: typeof syntax2 === "string" || syntax2 && typeof syntax2.type === "string",
      syntax: null,
      match: null,
      matchRef: null
      // used for properties when a syntax referenced as <'property'> in other syntax definitions
    };
    if (typeof syntax2 === "function") {
      descriptor.match = buildMatchGraph(syntax2, ref2);
    } else {
      if (typeof syntax2 === "string") {
        Object.defineProperty(descriptor, "syntax", {
          get() {
            Object.defineProperty(descriptor, "syntax", {
              value: parse$O(syntax2)
            });
            return descriptor.syntax;
          }
        });
      } else {
        descriptor.syntax = syntax2;
      }
      Object.defineProperty(descriptor, "match", {
        get() {
          Object.defineProperty(descriptor, "match", {
            value: buildMatchGraph(descriptor.syntax, ref2)
          });
          return descriptor.match;
        }
      });
      if (type2 === "Property") {
        Object.defineProperty(descriptor, "matchRef", {
          get() {
            const syntax3 = descriptor.syntax;
            const value2 = syntaxHasTopLevelCommaMultiplier(syntax3) ? buildMatchGraph({
              ...syntax3,
              terms: [syntax3.terms[0].term]
            }, ref2) : null;
            Object.defineProperty(descriptor, "matchRef", {
              value: value2
            });
            return value2;
          }
        });
      }
    }
    return descriptor;
  }
  addAtrule_(name2, syntax2) {
    if (!syntax2) {
      return;
    }
    this.atrules[name2] = {
      type: "Atrule",
      name: name2,
      prelude: syntax2.prelude ? this.createDescriptor(syntax2.prelude, "AtrulePrelude", name2) : null,
      descriptors: syntax2.descriptors ? Object.keys(syntax2.descriptors).reduce(
        (map, descName) => {
          map[descName] = this.createDescriptor(syntax2.descriptors[descName], "AtruleDescriptor", descName, name2);
          return map;
        },
        /* @__PURE__ */ Object.create(null)
      ) : null
    };
  }
  addProperty_(name2, syntax2) {
    if (!syntax2) {
      return;
    }
    this.properties[name2] = this.createDescriptor(syntax2, "Property", name2);
  }
  addType_(name2, syntax2) {
    if (!syntax2) {
      return;
    }
    this.types[name2] = this.createDescriptor(syntax2, "Type", name2);
  }
  checkAtruleName(atruleName) {
    if (!this.getAtrule(atruleName)) {
      return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
    }
  }
  checkAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtruleName(atruleName);
    if (error) {
      return error;
    }
    const atrule2 = this.getAtrule(atruleName);
    if (!atrule2.prelude && prelude) {
      return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
    }
    if (atrule2.prelude && !prelude) {
      if (!matchSyntax(this, atrule2.prelude, "", false).matched) {
        return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
      }
    }
  }
  checkAtruleDescriptorName(atruleName, descriptorName) {
    const error = this.checkAtruleName(atruleName);
    if (error) {
      return error;
    }
    const atrule2 = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    if (!atrule2.descriptors) {
      return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
    }
    if (!atrule2.descriptors[descriptor.name] && !atrule2.descriptors[descriptor.basename]) {
      return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
    }
  }
  checkPropertyName(propertyName) {
    if (!this.getProperty(propertyName)) {
      return new SyntaxReferenceError("Unknown property", propertyName);
    }
  }
  matchAtrulePrelude(atruleName, prelude) {
    const error = this.checkAtrulePrelude(atruleName, prelude);
    if (error) {
      return buildMatchResult(null, error);
    }
    const atrule2 = this.getAtrule(atruleName);
    if (!atrule2.prelude) {
      return buildMatchResult(null, null);
    }
    return matchSyntax(this, atrule2.prelude, prelude || "", false);
  }
  matchAtruleDescriptor(atruleName, descriptorName, value2) {
    const error = this.checkAtruleDescriptorName(atruleName, descriptorName);
    if (error) {
      return buildMatchResult(null, error);
    }
    const atrule2 = this.getAtrule(atruleName);
    const descriptor = keyword(descriptorName);
    return matchSyntax(this, atrule2.descriptors[descriptor.name] || atrule2.descriptors[descriptor.basename], value2, false);
  }
  matchDeclaration(node2) {
    if (node2.type !== "Declaration") {
      return buildMatchResult(null, new Error("Not a Declaration node"));
    }
    return this.matchProperty(node2.property, node2.value);
  }
  matchProperty(propertyName, value2) {
    if (property(propertyName).custom) {
      return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
    }
    const error = this.checkPropertyName(propertyName);
    if (error) {
      return buildMatchResult(null, error);
    }
    return matchSyntax(this, this.getProperty(propertyName), value2, true);
  }
  matchType(typeName, value2) {
    const typeSyntax = this.getType(typeName);
    if (!typeSyntax) {
      return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
    }
    return matchSyntax(this, typeSyntax, value2, false);
  }
  match(syntax2, value2) {
    if (typeof syntax2 !== "string" && (!syntax2 || !syntax2.type)) {
      return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
    }
    if (typeof syntax2 === "string" || !syntax2.match) {
      syntax2 = this.createDescriptor(syntax2, "Type", "anonymous");
    }
    return matchSyntax(this, syntax2, value2, false);
  }
  findValueFragments(propertyName, value2, type2, name2) {
    return matchFragments(this, value2, this.matchProperty(propertyName, value2), type2, name2);
  }
  findDeclarationValueFragments(declaration, type2, name2) {
    return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type2, name2);
  }
  findAllFragments(ast, type2, name2) {
    const result = [];
    this.syntax.walk(ast, {
      visit: "Declaration",
      enter: (declaration) => {
        result.push.apply(result, this.findDeclarationValueFragments(declaration, type2, name2));
      }
    });
    return result;
  }
  getAtrule(atruleName, fallbackBasename = true) {
    const atrule2 = keyword(atruleName);
    const atruleEntry = atrule2.vendor && fallbackBasename ? this.atrules[atrule2.name] || this.atrules[atrule2.basename] : this.atrules[atrule2.name];
    return atruleEntry || null;
  }
  getAtrulePrelude(atruleName, fallbackBasename = true) {
    const atrule2 = this.getAtrule(atruleName, fallbackBasename);
    return atrule2 && atrule2.prelude || null;
  }
  getAtruleDescriptor(atruleName, name2) {
    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name2] || null : null;
  }
  getProperty(propertyName, fallbackBasename = true) {
    const property$1 = property(propertyName);
    const propertyEntry = property$1.vendor && fallbackBasename ? this.properties[property$1.name] || this.properties[property$1.basename] : this.properties[property$1.name];
    return propertyEntry || null;
  }
  getType(name2) {
    return hasOwnProperty.call(this.types, name2) ? this.types[name2] : null;
  }
  validate() {
    function syntaxRef(name2, isType2) {
      return isType2 ? `<${name2}>` : `<'${name2}'>`;
    }
    function validate(syntax2, name2, broken, descriptor) {
      if (broken.has(name2)) {
        return broken.get(name2);
      }
      broken.set(name2, false);
      if (descriptor.syntax !== null) {
        walk$1(descriptor.syntax, function(node2) {
          if (node2.type !== "Type" && node2.type !== "Property") {
            return;
          }
          const map = node2.type === "Type" ? syntax2.types : syntax2.properties;
          const brokenMap = node2.type === "Type" ? brokenTypes : brokenProperties;
          if (!hasOwnProperty.call(map, node2.name)) {
            errors.push(`${syntaxRef(name2, broken === brokenTypes)} used missed syntax definition ${syntaxRef(node2.name, node2.type === "Type")}`);
            broken.set(name2, true);
          } else if (validate(syntax2, node2.name, brokenMap, map[node2.name])) {
            errors.push(`${syntaxRef(name2, broken === brokenTypes)} used broken syntax definition ${syntaxRef(node2.name, node2.type === "Type")}`);
            broken.set(name2, true);
          }
        }, this);
      }
    }
    const errors = [];
    let brokenTypes = /* @__PURE__ */ new Map();
    let brokenProperties = /* @__PURE__ */ new Map();
    for (const key in this.types) {
      validate(this, key, brokenTypes, this.types[key]);
    }
    for (const key in this.properties) {
      validate(this, key, brokenProperties, this.properties[key]);
    }
    const brokenTypesArray = [...brokenTypes.keys()].filter((name2) => brokenTypes.get(name2));
    const brokenPropertiesArray = [...brokenProperties.keys()].filter((name2) => brokenProperties.get(name2));
    if (brokenTypesArray.length || brokenPropertiesArray.length) {
      return {
        errors,
        types: brokenTypesArray,
        properties: brokenPropertiesArray
      };
    }
    return null;
  }
  dump(syntaxAsAst, pretty) {
    return {
      generic: this.generic,
      cssWideKeywords: this.cssWideKeywords,
      units: this.units,
      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
    };
  }
  toString() {
    return JSON.stringify(this.dump());
  }
}
function appendOrSet(a, b) {
  if (typeof b === "string" && /^\s*\|/.test(b)) {
    return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
  }
  return b || null;
}
function sliceProps(obj, props) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const [key, value2] of Object.entries(obj)) {
    if (value2) {
      result[key] = {};
      for (const prop of Object.keys(value2)) {
        if (props.includes(prop)) {
          result[key][prop] = value2[prop];
        }
      }
    }
  }
  return result;
}
function mix(dest, src) {
  const result = { ...dest };
  for (const [prop, value2] of Object.entries(src)) {
    switch (prop) {
      case "generic":
        result[prop] = Boolean(value2);
        break;
      case "cssWideKeywords":
        result[prop] = dest[prop] ? [...dest[prop], ...value2] : value2 || [];
        break;
      case "units":
        result[prop] = { ...dest[prop] };
        for (const [name2, patch] of Object.entries(value2)) {
          result[prop][name2] = Array.isArray(patch) ? patch : [];
        }
        break;
      case "atrules":
        result[prop] = { ...dest[prop] };
        for (const [name2, atrule2] of Object.entries(value2)) {
          const exists = result[prop][name2] || {};
          const current2 = result[prop][name2] = {
            prelude: exists.prelude || null,
            descriptors: {
              ...exists.descriptors
            }
          };
          if (!atrule2) {
            continue;
          }
          current2.prelude = atrule2.prelude ? appendOrSet(current2.prelude, atrule2.prelude) : current2.prelude || null;
          for (const [descriptorName, descriptorValue] of Object.entries(atrule2.descriptors || {})) {
            current2.descriptors[descriptorName] = descriptorValue ? appendOrSet(current2.descriptors[descriptorName], descriptorValue) : null;
          }
          if (!Object.keys(current2.descriptors).length) {
            current2.descriptors = null;
          }
        }
        break;
      case "types":
      case "properties":
        result[prop] = { ...dest[prop] };
        for (const [name2, syntax2] of Object.entries(value2)) {
          result[prop][name2] = appendOrSet(result[prop][name2], syntax2);
        }
        break;
      case "scope":
      case "features":
        result[prop] = { ...dest[prop] };
        for (const [name2, props] of Object.entries(value2)) {
          result[prop][name2] = { ...result[prop][name2], ...props };
        }
        break;
      case "parseContext":
        result[prop] = {
          ...dest[prop],
          ...value2
        };
        break;
      case "atrule":
      case "pseudo":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value2, ["parse"])
        };
        break;
      case "node":
        result[prop] = {
          ...dest[prop],
          ...sliceProps(value2, ["name", "structure", "parse", "generate", "walkContext"])
        };
        break;
    }
  }
  return result;
}
function createSyntax(config) {
  const parse4 = createParser(config);
  const walk2 = createWalker(config);
  const generate2 = createGenerator(config);
  const { fromPlainObject: fromPlainObject2, toPlainObject: toPlainObject2 } = createConvertor(walk2);
  const syntax2 = {
    lexer: null,
    createLexer: (config2) => new Lexer(config2, syntax2, syntax2.lexer.structure),
    tokenize: tokenize$1,
    parse: parse4,
    generate: generate2,
    walk: walk2,
    find: walk2.find,
    findLast: walk2.findLast,
    findAll: walk2.findAll,
    fromPlainObject: fromPlainObject2,
    toPlainObject: toPlainObject2,
    fork(extension) {
      const base = mix({}, config);
      return createSyntax(
        typeof extension === "function" ? extension(base) : mix(base, extension)
      );
    }
  };
  syntax2.lexer = new Lexer({
    generic: config.generic,
    cssWideKeywords: config.cssWideKeywords,
    units: config.units,
    types: config.types,
    atrules: config.atrules,
    properties: config.properties,
    node: config.node
  }, syntax2);
  return syntax2;
}
var createSyntax$1 = (config) => createSyntax(mix({}, config));
var definitions = {
  "generic": true,
  "cssWideKeywords": [
    "initial",
    "inherit",
    "unset",
    "revert",
    "revert-layer"
  ],
  "units": {
    "angle": [
      "deg",
      "grad",
      "rad",
      "turn"
    ],
    "decibel": [
      "db"
    ],
    "flex": [
      "fr"
    ],
    "frequency": [
      "hz",
      "khz"
    ],
    "length": [
      "cm",
      "mm",
      "q",
      "in",
      "pt",
      "pc",
      "px",
      "em",
      "rem",
      "ex",
      "rex",
      "cap",
      "rcap",
      "ch",
      "rch",
      "ic",
      "ric",
      "lh",
      "rlh",
      "vw",
      "svw",
      "lvw",
      "dvw",
      "vh",
      "svh",
      "lvh",
      "dvh",
      "vi",
      "svi",
      "lvi",
      "dvi",
      "vb",
      "svb",
      "lvb",
      "dvb",
      "vmin",
      "svmin",
      "lvmin",
      "dvmin",
      "vmax",
      "svmax",
      "lvmax",
      "dvmax",
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ],
    "resolution": [
      "dpi",
      "dpcm",
      "dppx",
      "x"
    ],
    "semitones": [
      "st"
    ],
    "time": [
      "s",
      "ms"
    ]
  },
  "types": {
    "abs()": "abs( <calc-sum> )",
    "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
    "acos()": "acos( <calc-sum> )",
    "alpha-value": "<number>|<percentage>",
    "angle-percentage": "<angle>|<percentage>",
    "angular-color-hint": "<angle-percentage>",
    "angular-color-stop": "<color>&&<color-stop-angle>?",
    "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
    "animateable-feature": "scroll-position|contents|<custom-ident>",
    "asin()": "asin( <calc-sum> )",
    "atan()": "atan( <calc-sum> )",
    "atan2()": "atan2( <calc-sum> , <calc-sum> )",
    "attachment": "scroll|fixed|local",
    "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
    "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
    "attr-modifier": "i|s",
    "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
    "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
    "axis": "block|inline|x|y",
    "baseline-position": "[first|last]? baseline",
    "basic-shape": "<inset()>|<xywh()>|<rect()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
    "bg-image": "none|<image>",
    "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
    "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
    "blur()": "blur( <length> )",
    "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
    "box": "border-box|padding-box|content-box",
    "brightness()": "brightness( <number-percentage> )",
    "calc()": "calc( <calc-sum> )",
    "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
    "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
    "calc-value": "<number>|<dimension>|<percentage>|<calc-constant>|( <calc-sum> )",
    "calc-constant": "e|pi|infinity|-infinity|NaN",
    "cf-final-image": "<image>|<color>",
    "cf-mixing-image": "<percentage>?&&<image>",
    "circle()": "circle( [<shape-radius>]? [at <position>]? )",
    "clamp()": "clamp( <calc-sum>#{3} )",
    "class-selector": "'.' <ident-token>",
    "clip-source": "<url>",
    "color": "<color-base>|currentColor|<system-color>|<device-cmyk()>|<light-dark()>|<-non-standard-color>",
    "color-stop": "<color-stop-length>|<color-stop-angle>",
    "color-stop-angle": "<angle-percentage>{1,2}",
    "color-stop-length": "<length-percentage>{1,2}",
    "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
    "color-interpolation-method": "in [<rectangular-color-space>|<polar-color-space> <hue-interpolation-method>?|<custom-color-space>]",
    "combinator": "'>'|'+'|'~'|['|' '|']",
    "common-lig-values": "[common-ligatures|no-common-ligatures]",
    "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
    "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
    "compositing-operator": "add|subtract|intersect|exclude",
    "compound-selector": "[<type-selector>? <subclass-selector>*]!",
    "compound-selector-list": "<compound-selector>#",
    "complex-selector": "<complex-selector-unit> [<combinator>? <complex-selector-unit>]*",
    "complex-selector-list": "<complex-selector>#",
    "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "contextual-alt-values": "[contextual|no-contextual]",
    "content-distribution": "space-between|space-around|space-evenly|stretch",
    "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
    "content-position": "center|start|end|flex-start|flex-end",
    "content-replacement": "<image>",
    "contrast()": "contrast( [<number-percentage>] )",
    "cos()": "cos( <calc-sum> )",
    "counter": "<counter()>|<counters()>",
    "counter()": "counter( <counter-name> , <counter-style>? )",
    "counter-name": "<custom-ident>",
    "counter-style": "<counter-style-name>|symbols( )",
    "counter-style-name": "<custom-ident>",
    "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
    "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
    "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
    "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
    "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
    "display-box": "contents|none",
    "display-inside": "flow|flow-root|table|flex|grid|ruby",
    "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
    "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
    "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
    "display-outside": "block|inline|run-in",
    "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
    "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
    "east-asian-width-values": "[full-width|proportional-width]",
    "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
    "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
    "ending-shape": "circle|ellipse",
    "env()": "env( <custom-ident> , <declaration-value>? )",
    "exp()": "exp( <calc-sum> )",
    "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
    "family-name": "<string>|<custom-ident>+",
    "feature-tag-value": "<string> [<integer>|on|off]?",
    "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
    "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
    "feature-value-block-list": "<feature-value-block>+",
    "feature-value-declaration": "<custom-ident> : <integer>+ ;",
    "feature-value-declaration-list": "<feature-value-declaration>",
    "feature-value-name": "<custom-ident>",
    "fill-rule": "nonzero|evenodd",
    "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
    "filter-function-list": "[<filter-function>|<url>]+",
    "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
    "fixed-breadth": "<length-percentage>",
    "fixed-repeat": "repeat( [<integer [1,]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
    "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
    "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
    "font-variant-css21": "[normal|small-caps]",
    "font-weight-absolute": "normal|bold|<number [1,1000]>",
    "frequency-percentage": "<frequency>|<percentage>",
    "general-enclosed": "[<function-token> <any-value>? )]|[( <any-value>? )]",
    "generic-family": "<generic-script-specific>|<generic-complete>|<generic-incomplete>|<-non-standard-generic-family>",
    "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
    "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
    "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
    "grayscale()": "grayscale( <number-percentage> )",
    "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
    "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
    "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
    "hue": "<number>|<angle>",
    "hue-rotate()": "hue-rotate( <angle> )",
    "hue-interpolation-method": "[shorter|longer|increasing|decreasing] hue",
    "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
    "hypot()": "hypot( <calc-sum># )",
    "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
    "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
    "image-set()": "image-set( <image-set-option># )",
    "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
    "image-src": "<url>|<string>",
    "image-tags": "ltr|rtl",
    "inflexible-breadth": "<length-percentage>|min-content|max-content|auto",
    "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
    "invert()": "invert( <number-percentage> )",
    "keyframes-name": "<custom-ident>|<string>",
    "keyframe-block": "<keyframe-selector># { <declaration-list> }",
    "keyframe-block-list": "<keyframe-block>+",
    "keyframe-selector": "from|to|<percentage>|<timeline-range-name> <percentage>",
    "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
    "layer()": "layer( <layer-name> )",
    "layer-name": "<ident> ['.' <ident>]*",
    "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
    "leader()": "leader( <leader-type> )",
    "leader-type": "dotted|solid|space|<string>",
    "length-percentage": "<length>|<percentage>",
    "light-dark()": "light-dark( <color> , <color> )",
    "line-names": "'[' <custom-ident>* ']'",
    "line-name-list": "[<line-names>|<name-repeat>]+",
    "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
    "line-width": "<length>|thin|medium|thick",
    "linear-color-hint": "<length-percentage>",
    "linear-color-stop": "<color> <color-stop-length>?",
    "linear-gradient()": "linear-gradient( [[<angle>|to <side-or-corner>]||<color-interpolation-method>]? , <color-stop-list> )",
    "log()": "log( <calc-sum> , <calc-sum>? )",
    "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
    "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
    "mask-reference": "none|<image>|<mask-source>",
    "mask-source": "<url>",
    "masking-mode": "alpha|luminance|match-source",
    "matrix()": "matrix( <number>#{6} )",
    "matrix3d()": "matrix3d( <number>#{16} )",
    "max()": "max( <calc-sum># )",
    "media-and": "<media-in-parens> [and <media-in-parens>]+",
    "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
    "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
    "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
    "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
    "media-not": "not <media-in-parens>",
    "media-or": "<media-in-parens> [or <media-in-parens>]+",
    "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
    "media-query-list": "<media-query>#",
    "media-type": "<ident>",
    "mf-boolean": "<mf-name>",
    "mf-name": "<ident>",
    "mf-plain": "<mf-name> : <mf-value>",
    "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
    "mf-value": "<number>|<dimension>|<ident>|<ratio>",
    "min()": "min( <calc-sum># )",
    "minmax()": "minmax( [<length-percentage>|min-content|max-content|auto] , [<length-percentage>|<flex>|min-content|max-content|auto] )",
    "mod()": "mod( <calc-sum> , <calc-sum> )",
    "name-repeat": "repeat( [<integer [1,]>|auto-fill] , <line-names>+ )",
    "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen",
    "namespace-prefix": "<ident>",
    "ns-prefix": "[<ident-token>|'*']? '|'",
    "number-percentage": "<number>|<percentage>",
    "numeric-figure-values": "[lining-nums|oldstyle-nums]",
    "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
    "numeric-spacing-values": "[proportional-nums|tabular-nums]",
    "nth": "<an-plus-b>|even|odd",
    "opacity()": "opacity( [<number-percentage>] )",
    "overflow-position": "unsafe|safe",
    "outline-radius": "<length>|<percentage>",
    "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
    "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
    "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
    "page-selector-list": "[<page-selector>#]?",
    "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
    "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
    "path()": "path( [<fill-rule> ,]? <string> )",
    "paint()": "paint( <ident> , <declaration-value>? )",
    "perspective()": "perspective( [<length [0,]>|none] )",
    "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
    "polar-color-space": "hsl|hwb|lch|oklch",
    "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
    "pow()": "pow( <calc-sum> , <calc-sum> )",
    "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
    "pseudo-element-selector": "':' <pseudo-class-selector>|<legacy-pseudo-element-selector>",
    "pseudo-page": ": [left|right|first|blank]",
    "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
    "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "ratio": "<number [0,]> [/ <number [0,]>]?",
    "ray()": "ray( <angle>&&<ray-size>?&&contain?&&[at <position>]? )",
    "ray-size": "closest-side|closest-corner|farthest-side|farthest-corner|sides",
    "rectangular-color-space": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020|lab|oklab|xyz|xyz-d50|xyz-d65",
    "relative-selector": "<combinator>? <complex-selector>",
    "relative-selector-list": "<relative-selector>#",
    "relative-size": "larger|smaller",
    "rem()": "rem( <calc-sum> , <calc-sum> )",
    "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
    "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
    "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
    "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
    "reversed-counter-name": "reversed( <counter-name> )",
    "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
    "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
    "rotate()": "rotate( [<angle>|<zero>] )",
    "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
    "rotateX()": "rotateX( [<angle>|<zero>] )",
    "rotateY()": "rotateY( [<angle>|<zero>] )",
    "rotateZ()": "rotateZ( [<angle>|<zero>] )",
    "round()": "round( <rounding-strategy>? , <calc-sum> , <calc-sum> )",
    "rounding-strategy": "nearest|up|down|to-zero",
    "saturate()": "saturate( <number-percentage> )",
    "scale()": "scale( [<number>|<percentage>]#{1,2} )",
    "scale3d()": "scale3d( [<number>|<percentage>]#{3} )",
    "scaleX()": "scaleX( [<number>|<percentage>] )",
    "scaleY()": "scaleY( [<number>|<percentage>] )",
    "scaleZ()": "scaleZ( [<number>|<percentage>] )",
    "scroll()": "scroll( [<axis>||<scroller>]? )",
    "scroller": "root|nearest|self",
    "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
    "shape-radius": "<length-percentage>|closest-side|farthest-side",
    "sign()": "sign( <calc-sum> )",
    "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
    "skewX()": "skewX( [<angle>|<zero>] )",
    "skewY()": "skewY( [<angle>|<zero>] )",
    "sepia()": "sepia( <number-percentage> )",
    "shadow": "inset?&&<length>{2,4}&&<color>?",
    "shadow-t": "[<length>{2,3}&&<color>?]",
    "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
    "shape-box": "<box>|margin-box",
    "side-or-corner": "[left|right]||[top|bottom]",
    "sin()": "sin( <calc-sum> )",
    "single-animation": "<'animation-duration'>||<easing-function>||<'animation-delay'>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]||<single-animation-timeline>",
    "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
    "single-animation-fill-mode": "none|forwards|backwards|both",
    "single-animation-iteration-count": "infinite|<number>",
    "single-animation-play-state": "running|paused",
    "single-animation-timeline": "auto|none|<dashed-ident>|<scroll()>|<view()>",
    "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>||<transition-behavior-value>",
    "single-transition-property": "all|<custom-ident>",
    "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
    "sqrt()": "sqrt( <calc-sum> )",
    "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
    "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
    "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
    "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
    "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
    "supports-feature": "<supports-decl>|<supports-selector-fn>",
    "supports-decl": "( <declaration> )",
    "supports-selector-fn": "selector( <complex-selector> )",
    "symbol": "<string>|<image>|<custom-ident>",
    "system-color": "AccentColor|AccentColorText|ActiveText|ButtonBorder|ButtonFace|ButtonText|Canvas|CanvasText|Field|FieldText|GrayText|Highlight|HighlightText|LinkText|Mark|MarkText|SelectedItem|SelectedItemText|VisitedText",
    "tan()": "tan( <calc-sum> )",
    "target": "<target-counter()>|<target-counters()>|<target-text()>",
    "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
    "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
    "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
    "time-percentage": "<time>|<percentage>",
    "timeline-range-name": "cover|contain|entry|exit|entry-crossing|exit-crossing",
    "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
    "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
    "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
    "track-repeat": "repeat( [<integer [1,]>] , [<line-names>? <track-size>]+ <line-names>? )",
    "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( <length-percentage> )",
    "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
    "transform-list": "<transform-function>+",
    "transition-behavior-value": "normal|allow-discrete",
    "translate()": "translate( <length-percentage> , <length-percentage>? )",
    "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
    "translateX()": "translateX( <length-percentage> )",
    "translateY()": "translateY( <length-percentage> )",
    "translateZ()": "translateZ( <length> )",
    "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
    "type-selector": "<wq-name>|<ns-prefix>? '*'",
    "var()": "var( <custom-property-name> , <declaration-value>? )",
    "view()": "view( [<axis>||<'view-timeline-inset'>]? )",
    "viewport-length": "auto|<length-percentage>",
    "visual-box": "content-box|padding-box|border-box",
    "wq-name": "<ns-prefix>? <ident-token>",
    "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
    "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
    "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
    "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
    "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
    "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
    "-legacy-radial-gradient-shape": "circle|ellipse",
    "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
    "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
    "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
    "-non-standard-overflow": "overlay|-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
    "-non-standard-size": "intrinsic|min-intrinsic|-webkit-fill-available|-webkit-fit-content|-webkit-min-content|-webkit-max-content|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content",
    "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
    "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
    "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
    "-webkit-gradient-radius": "<length>|<percentage>",
    "-webkit-gradient-type": "linear|radial",
    "-webkit-mask-box-repeat": "repeat|stretch|round",
    "-ms-filter-function-list": "<-ms-filter-function>+",
    "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
    "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
    "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
    "absolute-color-base": "<hex-color>|<absolute-color-function>|<named-color>|transparent",
    "absolute-color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
    "age": "child|young|old",
    "anchor-name": "<dashed-ident>",
    "attr-name": "<wq-name>",
    "attr-fallback": "<any-value>",
    "bg-clip": "<box>|border|text",
    "bottom": "<length>|auto",
    "container-name": "<custom-ident>",
    "container-condition": "not <query-in-parens>|<query-in-parens> [[and <query-in-parens>]*|[or <query-in-parens>]*]",
    "coord-box": "content-box|padding-box|border-box|fill-box|stroke-box|view-box",
    "generic-voice": "[<age>? <gender> <integer>?]",
    "gender": "male|female|neutral",
    "generic-script-specific": "generic( kai )|generic( fangsong )|generic( nastaliq )",
    "generic-complete": "serif|sans-serif|system-ui|cursive|fantasy|math|monospace",
    "generic-incomplete": "ui-serif|ui-sans-serif|ui-monospace|ui-rounded",
    "-non-standard-generic-family": "-apple-system|BlinkMacSystemFont",
    "left": "<length>|auto",
    "color-base": "<hex-color>|<color-function>|<named-color>|<color-mix()>|transparent",
    "color-function": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<oklab()>|<oklch()>|<color()>",
    "device-cmyk()": "<legacy-device-cmyk-syntax>|<modern-device-cmyk-syntax>",
    "legacy-device-cmyk-syntax": "device-cmyk( <number>#{4} )",
    "modern-device-cmyk-syntax": "device-cmyk( <cmyk-component>{4} [/ [<alpha-value>|none]]? )",
    "cmyk-component": "<number>|<percentage>|none",
    "color-mix()": "color-mix( <color-interpolation-method> , [<color>&&<percentage [0,100]>?]#{2} )",
    "color-space": "<rectangular-color-space>|<polar-color-space>|<custom-color-space>",
    "custom-color-space": "<dashed-ident>",
    "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
    "palette-identifier": "<dashed-ident>",
    "right": "<length>|auto",
    "scope-start": "<forgiving-selector-list>",
    "scope-end": "<forgiving-selector-list>",
    "forgiving-selector-list": "<complex-real-selector-list>",
    "forgiving-relative-selector-list": "<relative-real-selector-list>",
    "selector-list": "<complex-selector-list>",
    "complex-real-selector-list": "<complex-real-selector>#",
    "simple-selector-list": "<simple-selector>#",
    "relative-real-selector-list": "<relative-real-selector>#",
    "complex-selector-unit": "[<compound-selector>? <pseudo-compound-selector>*]!",
    "complex-real-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
    "relative-real-selector": "<combinator>? <complex-real-selector>",
    "pseudo-compound-selector": "<pseudo-element-selector> <pseudo-class-selector>*",
    "simple-selector": "<type-selector>|<subclass-selector>",
    "legacy-pseudo-element-selector": "':' [before|after|first-line|first-letter]",
    "single-animation-composition": "replace|add|accumulate",
    "svg-length": "<percentage>|<length>|<number>",
    "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
    "top": "<length>|auto",
    "x": "<number>",
    "y": "<number>",
    "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
    "declaration-list": "[<declaration>? ';']* <declaration>?",
    "url": "url( <string> <url-modifier>* )|<url-token>",
    "url-modifier": "<ident>|<function-token> <any-value> )",
    "number-zero-one": "<number [0,1]>",
    "number-one-or-greater": "<number [1,]>",
    "color()": "color( <colorspace-params> [/ [<alpha-value>|none]]? )",
    "colorspace-params": "[<predefined-rgb-params>|<xyz-params>]",
    "predefined-rgb-params": "<predefined-rgb> [<number>|<percentage>|none]{3}",
    "predefined-rgb": "srgb|srgb-linear|display-p3|a98-rgb|prophoto-rgb|rec2020",
    "xyz-params": "<xyz-space> [<number>|<percentage>|none]{3}",
    "xyz-space": "xyz|xyz-d50|xyz-d65",
    "oklab()": "oklab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
    "oklch()": "oklch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
    "offset-path": "<ray()>|<url>|<basic-shape>",
    "rect()": "rect( [<length-percentage>|auto]{4} [round <'border-radius'>]? )",
    "xywh()": "xywh( <length-percentage>{2} <length-percentage [0,]>{2} [round <'border-radius'>]? )",
    "query-in-parens": "( <container-condition> )|( <size-feature> )|style( <style-query> )|<general-enclosed>",
    "size-feature": "<mf-plain>|<mf-boolean>|<mf-range>",
    "style-feature": "<declaration>",
    "style-query": "<style-condition>|<style-feature>",
    "style-condition": "not <style-in-parens>|<style-in-parens> [[and <style-in-parens>]*|[or <style-in-parens>]*]",
    "style-in-parens": "( <style-condition> )|( <style-feature> )|<general-enclosed>",
    "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box",
    "inset-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
    "position-area": "[[left|center|right|span-left|span-right|x-start|x-end|span-x-start|span-x-end|x-self-start|x-self-end|span-x-self-start|span-x-self-end|span-all]||[top|center|bottom|span-top|span-bottom|y-start|y-end|span-y-start|span-y-end|y-self-start|y-self-end|span-y-self-start|span-y-self-end|span-all]|[block-start|center|block-end|span-block-start|span-block-end|span-all]||[inline-start|center|inline-end|span-inline-start|span-inline-end|span-all]|[self-block-start|center|self-block-end|span-self-block-start|span-self-block-end|span-all]||[self-inline-start|center|self-inline-end|span-self-inline-start|span-self-inline-end|span-all]|[start|center|end|span-start|span-end|span-all]{1,2}|[self-start|center|self-end|span-self-start|span-self-end|span-all]{1,2}]",
    "anchor()": "anchor( <anchor-element>?&&<anchor-side> , <length-percentage>? )",
    "anchor-side": "inside|outside|top|left|right|bottom|start|end|self-start|self-end|<percentage>|center",
    "anchor-size()": "anchor-size( [<anchor-element>||<anchor-size>]? , <length-percentage>? )",
    "anchor-size": "width|height|block|inline|self-block|self-inline",
    "anchor-element": "<dashed-ident>",
    "try-size": "most-width|most-height|most-block-size|most-inline-size",
    "try-tactic": "flip-block||flip-inline||flip-start",
    "font-variant-css2": "normal|small-caps",
    "font-width-css3": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded",
    "system-family-name": "caption|icon|menu|message-box|small-caption|status-bar"
  },
  "properties": {
    "--*": "<declaration-value>",
    "-ms-accelerator": "false|true",
    "-ms-block-progression": "tb|rl|bt|lr",
    "-ms-content-zoom-chaining": "none|chained",
    "-ms-content-zooming": "none|zoom",
    "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
    "-ms-content-zoom-limit-max": "<percentage>",
    "-ms-content-zoom-limit-min": "<percentage>",
    "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
    "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
    "-ms-content-zoom-snap-type": "none|proximity|mandatory",
    "-ms-filter": "<string>",
    "-ms-flow-from": "[none|<custom-ident>]#",
    "-ms-flow-into": "[none|<custom-ident>]#",
    "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
    "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
    "-ms-high-contrast-adjust": "auto|none",
    "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
    "-ms-hyphenate-limit-lines": "no-limit|<integer>",
    "-ms-hyphenate-limit-zone": "<percentage>|<length>",
    "-ms-ime-align": "auto|after",
    "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
    "-ms-scrollbar-3dlight-color": "<color>",
    "-ms-scrollbar-arrow-color": "<color>",
    "-ms-scrollbar-base-color": "<color>",
    "-ms-scrollbar-darkshadow-color": "<color>",
    "-ms-scrollbar-face-color": "<color>",
    "-ms-scrollbar-highlight-color": "<color>",
    "-ms-scrollbar-shadow-color": "<color>",
    "-ms-scrollbar-track-color": "<color>",
    "-ms-scroll-chaining": "chained|none",
    "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
    "-ms-scroll-limit-x-max": "auto|<length>",
    "-ms-scroll-limit-x-min": "<length>",
    "-ms-scroll-limit-y-max": "auto|<length>",
    "-ms-scroll-limit-y-min": "<length>",
    "-ms-scroll-rails": "none|railed",
    "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
    "-ms-scroll-snap-type": "none|proximity|mandatory",
    "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
    "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
    "-ms-scroll-translation": "none|vertical-to-horizontal",
    "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
    "-ms-touch-select": "grippers|none",
    "-ms-user-select": "none|element|text",
    "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
    "-ms-wrap-margin": "<length>",
    "-ms-wrap-through": "wrap|none",
    "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
    "-moz-binding": "<url>|none",
    "-moz-border-bottom-colors": "<color>+|none",
    "-moz-border-left-colors": "<color>+|none",
    "-moz-border-right-colors": "<color>+|none",
    "-moz-border-top-colors": "<color>+|none",
    "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
    "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
    "-moz-force-broken-image-icon": "0|1",
    "-moz-image-region": "<shape>|auto",
    "-moz-orient": "inline|block|horizontal|vertical",
    "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
    "-moz-outline-radius-bottomleft": "<outline-radius>",
    "-moz-outline-radius-bottomright": "<outline-radius>",
    "-moz-outline-radius-topleft": "<outline-radius>",
    "-moz-outline-radius-topright": "<outline-radius>",
    "-moz-stack-sizing": "ignore|stretch-to-fit",
    "-moz-text-blink": "none|blink",
    "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
    "-moz-user-input": "auto|none|enabled|disabled",
    "-moz-user-modify": "read-only|read-write|write-only",
    "-moz-window-dragging": "drag|no-drag",
    "-moz-window-shadow": "default|menu|tooltip|sheet|none",
    "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
    "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
    "-webkit-border-before-color": "<color>",
    "-webkit-border-before-style": "<'border-style'>",
    "-webkit-border-before-width": "<'border-width'>",
    "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
    "-webkit-line-clamp": "none|<integer>",
    "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
    "-webkit-mask-attachment": "<attachment>#",
    "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
    "-webkit-mask-composite": "<composite-style>#",
    "-webkit-mask-image": "<mask-reference>#",
    "-webkit-mask-origin": "[<box>|border|padding|content]#",
    "-webkit-mask-position": "<position>#",
    "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
    "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
    "-webkit-mask-repeat": "<repeat-style>#",
    "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
    "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
    "-webkit-mask-size": "<bg-size>#",
    "-webkit-overflow-scrolling": "auto|touch",
    "-webkit-tap-highlight-color": "<color>",
    "-webkit-text-fill-color": "<color>",
    "-webkit-text-stroke": "<length>||<color>",
    "-webkit-text-stroke-color": "<color>",
    "-webkit-text-stroke-width": "<length>",
    "-webkit-touch-callout": "default|none",
    "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
    "accent-color": "auto|<color>",
    "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
    "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
    "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
    "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
    "all": "initial|inherit|unset|revert|revert-layer",
    "anchor-name": "none|<dashed-ident>#",
    "anchor-scope": "none|all|<dashed-ident>#",
    "animation": "<single-animation>#",
    "animation-composition": "<single-animation-composition>#",
    "animation-delay": "<time>#",
    "animation-direction": "<single-animation-direction>#",
    "animation-duration": "<time>#",
    "animation-fill-mode": "<single-animation-fill-mode>#",
    "animation-iteration-count": "<single-animation-iteration-count>#",
    "animation-name": "[none|<keyframes-name>]#",
    "animation-play-state": "<single-animation-play-state>#",
    "animation-range": "[<'animation-range-start'> <'animation-range-end'>?]#",
    "animation-range-end": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
    "animation-range-start": "[normal|<length-percentage>|<timeline-range-name> <length-percentage>?]#",
    "animation-timing-function": "<easing-function>#",
    "animation-timeline": "<single-animation-timeline>#",
    "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
    "aspect-ratio": "auto||<ratio>",
    "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
    "backdrop-filter": "none|<filter-function-list>",
    "backface-visibility": "visible|hidden",
    "background": "[<bg-layer> ,]* <final-bg-layer>",
    "background-attachment": "<attachment>#",
    "background-blend-mode": "<blend-mode>#",
    "background-clip": "<bg-clip>#",
    "background-color": "<color>",
    "background-image": "<bg-image>#",
    "background-origin": "<box>#",
    "background-position": "<bg-position>#",
    "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
    "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
    "background-repeat": "<repeat-style>#",
    "background-size": "<bg-size>#",
    "block-size": "<'width'>",
    "border": "<line-width>||<line-style>||<color>",
    "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-color": "<'border-top-color'>{1,2}",
    "border-block-style": "<'border-top-style'>",
    "border-block-width": "<'border-top-width'>",
    "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-end-color": "<'border-top-color'>",
    "border-block-end-style": "<'border-top-style'>",
    "border-block-end-width": "<'border-top-width'>",
    "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-block-start-color": "<'border-top-color'>",
    "border-block-start-style": "<'border-top-style'>",
    "border-block-start-width": "<'border-top-width'>",
    "border-bottom": "<line-width>||<line-style>||<color>",
    "border-bottom-color": "<'border-top-color'>",
    "border-bottom-left-radius": "<length-percentage>{1,2}",
    "border-bottom-right-radius": "<length-percentage>{1,2}",
    "border-bottom-style": "<line-style>",
    "border-bottom-width": "<line-width>",
    "border-collapse": "collapse|separate",
    "border-color": "<color>{1,4}",
    "border-end-end-radius": "<length-percentage>{1,2}",
    "border-end-start-radius": "<length-percentage>{1,2}",
    "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
    "border-image-outset": "[<length>|<number>]{1,4}",
    "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
    "border-image-slice": "<number-percentage>{1,4}&&fill?",
    "border-image-source": "none|<image>",
    "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
    "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-color": "<'border-top-color'>{1,2}",
    "border-inline-style": "<'border-top-style'>",
    "border-inline-width": "<'border-top-width'>",
    "border-inline-end-color": "<'border-top-color'>",
    "border-inline-end-style": "<'border-top-style'>",
    "border-inline-end-width": "<'border-top-width'>",
    "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
    "border-inline-start-color": "<'border-top-color'>",
    "border-inline-start-style": "<'border-top-style'>",
    "border-inline-start-width": "<'border-top-width'>",
    "border-left": "<line-width>||<line-style>||<color>",
    "border-left-color": "<color>",
    "border-left-style": "<line-style>",
    "border-left-width": "<line-width>",
    "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
    "border-right": "<line-width>||<line-style>||<color>",
    "border-right-color": "<color>",
    "border-right-style": "<line-style>",
    "border-right-width": "<line-width>",
    "border-spacing": "<length> <length>?",
    "border-start-end-radius": "<length-percentage>{1,2}",
    "border-start-start-radius": "<length-percentage>{1,2}",
    "border-style": "<line-style>{1,4}",
    "border-top": "<line-width>||<line-style>||<color>",
    "border-top-color": "<color>",
    "border-top-left-radius": "<length-percentage>{1,2}",
    "border-top-right-radius": "<length-percentage>{1,2}",
    "border-top-style": "<line-style>",
    "border-top-width": "<line-width>",
    "border-width": "<line-width>{1,4}",
    "bottom": "<length>|<percentage>|auto",
    "box-align": "start|center|end|baseline|stretch",
    "box-decoration-break": "slice|clone",
    "box-direction": "normal|reverse|inherit",
    "box-flex": "<number>",
    "box-flex-group": "<integer>",
    "box-lines": "single|multiple",
    "box-ordinal-group": "<integer>",
    "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
    "box-pack": "start|center|end|justify",
    "box-shadow": "none|<shadow>#",
    "box-sizing": "content-box|border-box",
    "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
    "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
    "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
    "caret": "<'caret-color'>||<'caret-shape'>",
    "caret-color": "auto|<color>",
    "caret-shape": "auto|bar|block|underscore",
    "clear": "none|left|right|both|inline-start|inline-end",
    "clip": "<shape>|auto",
    "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
    "clip-rule": "nonzero|evenodd",
    "color": "<color>",
    "color-interpolation-filters": "auto|sRGB|linearRGB",
    "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
    "column-count": "<integer>|auto",
    "column-fill": "auto|balance",
    "column-gap": "normal|<length-percentage>",
    "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
    "column-rule-color": "<color>",
    "column-rule-style": "<'border-style'>",
    "column-rule-width": "<'border-width'>",
    "column-span": "none|all",
    "column-width": "<length>|auto",
    "columns": "<'column-width'>||<'column-count'>",
    "contain": "none|strict|content|[[size||inline-size]||layout||style||paint]",
    "contain-intrinsic-size": "[auto? [none|<length>]]{1,2}",
    "contain-intrinsic-block-size": "auto? [none|<length>]",
    "contain-intrinsic-height": "auto? [none|<length>]",
    "contain-intrinsic-inline-size": "auto? [none|<length>]",
    "contain-intrinsic-width": "auto? [none|<length>]",
    "container": "<'container-name'> [/ <'container-type'>]?",
    "container-name": "none|<custom-ident>+",
    "container-type": "normal||[size|inline-size]",
    "content": "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
    "content-visibility": "visible|auto|hidden",
    "counter-increment": "[<counter-name> <integer>?]+|none",
    "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
    "counter-set": "[<counter-name> <integer>?]+|none",
    "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
    "d": "none|path( <string> )",
    "cx": "<length>|<percentage>",
    "cy": "<length>|<percentage>",
    "direction": "ltr|rtl",
    "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
    "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
    "empty-cells": "show|hide",
    "field-sizing": "content|fixed",
    "fill": "<paint>",
    "fill-opacity": "<number-zero-one>",
    "fill-rule": "nonzero|evenodd",
    "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
    "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
    "flex-basis": "content|<'width'>",
    "flex-direction": "row|row-reverse|column|column-reverse",
    "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
    "flex-grow": "<number>",
    "flex-shrink": "<number>",
    "flex-wrap": "nowrap|wrap|wrap-reverse",
    "float": "left|right|none|inline-start|inline-end",
    "font": "[[<'font-style'>||<font-variant-css2>||<'font-weight'>||<font-width-css3>]? <'font-size'> [/ <'line-height'>]? <'font-family'>#]|<system-family-name>|<-non-standard-font>",
    "font-family": "[<family-name>|<generic-family>]#",
    "font-feature-settings": "normal|<feature-tag-value>#",
    "font-kerning": "auto|normal|none",
    "font-language-override": "normal|<string>",
    "font-optical-sizing": "auto|none",
    "font-palette": "normal|light|dark|<palette-identifier>",
    "font-variation-settings": "normal|[<string> <number>]#",
    "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
    "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
    "font-smooth": "auto|never|always|<absolute-size>|<length>",
    "font-stretch": "<font-stretch-absolute>",
    "font-style": "normal|italic|oblique <angle>?",
    "font-synthesis": "none|[weight||style||small-caps||position]",
    "font-synthesis-position": "auto|none",
    "font-synthesis-small-caps": "auto|none",
    "font-synthesis-style": "auto|none",
    "font-synthesis-weight": "auto|none",
    "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
    "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
    "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
    "font-variant-emoji": "normal|text|emoji|unicode",
    "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
    "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
    "font-variant-position": "normal|sub|super",
    "font-weight": "<font-weight-absolute>|bolder|lighter",
    "forced-color-adjust": "auto|none|preserve-parent-color",
    "gap": "<'row-gap'> <'column-gap'>?",
    "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
    "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
    "grid-auto-columns": "<track-size>+",
    "grid-auto-flow": "[row|column]||dense",
    "grid-auto-rows": "<track-size>+",
    "grid-column": "<grid-line> [/ <grid-line>]?",
    "grid-column-end": "<grid-line>",
    "grid-column-gap": "<length-percentage>",
    "grid-column-start": "<grid-line>",
    "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
    "grid-row": "<grid-line> [/ <grid-line>]?",
    "grid-row-end": "<grid-line>",
    "grid-row-gap": "<length-percentage>",
    "grid-row-start": "<grid-line>",
    "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
    "grid-template-areas": "none|<string>+",
    "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
    "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
    "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "hyphenate-character": "auto|<string>",
    "hyphenate-limit-chars": "[auto|<integer>]{1,3}",
    "hyphens": "none|manual|auto",
    "image-orientation": "from-image|<angle>|[<angle>? flip]",
    "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
    "image-resolution": "[from-image||<resolution>]&&snap?",
    "ime-mode": "auto|normal|active|inactive|disabled",
    "initial-letter": "normal|[<number> <integer>?]",
    "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
    "inline-size": "<'width'>",
    "input-security": "auto|none",
    "inset": "<'top'>{1,4}",
    "inset-block": "<'top'>{1,2}",
    "inset-block-end": "<'top'>",
    "inset-block-start": "<'top'>",
    "inset-inline": "<'top'>{1,2}",
    "inset-inline-end": "<'top'>",
    "inset-inline-start": "<'top'>",
    "interpolate-size": "numeric-only|allow-keywords",
    "isolation": "auto|isolate",
    "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
    "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
    "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
    "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
    "left": "<length>|<percentage>|auto",
    "letter-spacing": "normal|<length-percentage>",
    "line-break": "auto|loose|normal|strict|anywhere",
    "line-clamp": "none|<integer>",
    "line-height": "normal|<number>|<length>|<percentage>",
    "line-height-step": "<length>",
    "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
    "list-style-image": "<image>|none",
    "list-style-position": "inside|outside",
    "list-style-type": "<counter-style>|<string>|none",
    "margin": "[<length>|<percentage>|auto]{1,4}",
    "margin-block": "<'margin-left'>{1,2}",
    "margin-block-end": "<'margin-left'>",
    "margin-block-start": "<'margin-left'>",
    "margin-bottom": "<length>|<percentage>|auto",
    "margin-inline": "<'margin-left'>{1,2}",
    "margin-inline-end": "<'margin-left'>",
    "margin-inline-start": "<'margin-left'>",
    "margin-left": "<length>|<percentage>|auto",
    "margin-right": "<length>|<percentage>|auto",
    "margin-top": "<length>|<percentage>|auto",
    "margin-trim": "none|in-flow|all",
    "marker": "none|<url>",
    "marker-end": "none|<url>",
    "marker-mid": "none|<url>",
    "marker-start": "none|<url>",
    "mask": "<mask-layer>#",
    "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
    "mask-border-mode": "luminance|alpha",
    "mask-border-outset": "[<length>|<number>]{1,4}",
    "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
    "mask-border-slice": "<number-percentage>{1,4} fill?",
    "mask-border-source": "none|<image>",
    "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
    "mask-clip": "[<geometry-box>|no-clip]#",
    "mask-composite": "<compositing-operator>#",
    "mask-image": "<mask-reference>#",
    "mask-mode": "<masking-mode>#",
    "mask-origin": "<geometry-box>#",
    "mask-position": "<position>#",
    "mask-repeat": "<repeat-style>#",
    "mask-size": "<bg-size>#",
    "mask-type": "luminance|alpha",
    "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
    "math-depth": "auto-add|add( <integer> )|<integer>",
    "math-shift": "normal|compact",
    "math-style": "normal|compact",
    "max-block-size": "<'max-width'>",
    "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "max-inline-size": "<'max-width'>",
    "max-lines": "none|<integer>",
    "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "min-block-size": "<'min-width'>",
    "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "min-inline-size": "<'min-width'>",
    "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "mix-blend-mode": "<blend-mode>|plus-lighter",
    "object-fit": "fill|contain|cover|none|scale-down",
    "object-position": "<position>",
    "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
    "offset-anchor": "auto|<position>",
    "offset-distance": "<length-percentage>",
    "offset-path": "none|<offset-path>||<coord-box>",
    "offset-position": "normal|auto|<position>",
    "offset-rotate": "[auto|reverse]||<angle>",
    "opacity": "<alpha-value>",
    "order": "<integer>",
    "orphans": "<integer>",
    "outline": "[<'outline-width'>||<'outline-style'>||<'outline-color'>]",
    "outline-color": "auto|<color>",
    "outline-offset": "<length>",
    "outline-style": "auto|<'border-style'>",
    "outline-width": "<line-width>",
    "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
    "overflow-anchor": "auto|none",
    "overflow-block": "visible|hidden|clip|scroll|auto",
    "overflow-clip-box": "padding-box|content-box",
    "overflow-clip-margin": "<visual-box>||<length [0,]>",
    "overflow-inline": "visible|hidden|clip|scroll|auto",
    "overflow-wrap": "normal|break-word|anywhere",
    "overflow-x": "visible|hidden|clip|scroll|auto",
    "overflow-y": "visible|hidden|clip|scroll|auto",
    "overlay": "none|auto",
    "overscroll-behavior": "[contain|none|auto]{1,2}",
    "overscroll-behavior-block": "contain|none|auto",
    "overscroll-behavior-inline": "contain|none|auto",
    "overscroll-behavior-x": "contain|none|auto",
    "overscroll-behavior-y": "contain|none|auto",
    "padding": "[<length>|<percentage>]{1,4}",
    "padding-block": "<'padding-left'>{1,2}",
    "padding-block-end": "<'padding-left'>",
    "padding-block-start": "<'padding-left'>",
    "padding-bottom": "<length>|<percentage>",
    "padding-inline": "<'padding-left'>{1,2}",
    "padding-inline-end": "<'padding-left'>",
    "padding-inline-start": "<'padding-left'>",
    "padding-left": "<length>|<percentage>",
    "padding-right": "<length>|<percentage>",
    "padding-top": "<length>|<percentage>",
    "page": "auto|<custom-ident>",
    "page-break-after": "auto|always|avoid|left|right|recto|verso",
    "page-break-before": "auto|always|avoid|left|right|recto|verso",
    "page-break-inside": "auto|avoid",
    "paint-order": "normal|[fill||stroke||markers]",
    "perspective": "none|<length>",
    "perspective-origin": "<position>",
    "place-content": "<'align-content'> <'justify-content'>?",
    "place-items": "<'align-items'> <'justify-items'>?",
    "place-self": "<'align-self'> <'justify-self'>?",
    "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
    "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
    "position-anchor": "auto|<anchor-name>",
    "position-area": "none|<position-area>",
    "position-try": "<'position-try-order'>? <'position-try-fallbacks'>",
    "position-try-fallbacks": "none|[[<dashed-ident>||<try-tactic>]|<'position-area'>]#",
    "position-try-order": "normal|<try-size>",
    "position-visibility": "always|[anchors-valid||anchors-visible||no-overflow]",
    "print-color-adjust": "economy|exact",
    "quotes": "none|auto|[<string> <string>]+",
    "r": "<length>|<percentage>",
    "resize": "none|both|horizontal|vertical|block|inline",
    "right": "<length>|<percentage>|auto",
    "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
    "row-gap": "normal|<length-percentage>",
    "ruby-align": "start|center|space-between|space-around",
    "ruby-merge": "separate|collapse|auto",
    "ruby-position": "[alternate||[over|under]]|inter-character",
    "rx": "<length>|<percentage>",
    "ry": "<length>|<percentage>",
    "scale": "none|[<number>|<percentage>]{1,3}",
    "scrollbar-color": "auto|<color>{2}",
    "scrollbar-gutter": "auto|stable&&both-edges?",
    "scrollbar-width": "auto|thin|none",
    "scroll-behavior": "auto|smooth",
    "scroll-margin": "<length>{1,4}",
    "scroll-margin-block": "<length>{1,2}",
    "scroll-margin-block-start": "<length>",
    "scroll-margin-block-end": "<length>",
    "scroll-margin-bottom": "<length>",
    "scroll-margin-inline": "<length>{1,2}",
    "scroll-margin-inline-start": "<length>",
    "scroll-margin-inline-end": "<length>",
    "scroll-margin-left": "<length>",
    "scroll-margin-right": "<length>",
    "scroll-margin-top": "<length>",
    "scroll-padding": "[auto|<length-percentage>]{1,4}",
    "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-block-start": "auto|<length-percentage>",
    "scroll-padding-block-end": "auto|<length-percentage>",
    "scroll-padding-bottom": "auto|<length-percentage>",
    "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
    "scroll-padding-inline-start": "auto|<length-percentage>",
    "scroll-padding-inline-end": "auto|<length-percentage>",
    "scroll-padding-left": "auto|<length-percentage>",
    "scroll-padding-right": "auto|<length-percentage>",
    "scroll-padding-top": "auto|<length-percentage>",
    "scroll-snap-align": "[none|start|end|center]{1,2}",
    "scroll-snap-coordinate": "none|<position>#",
    "scroll-snap-destination": "<position>",
    "scroll-snap-points-x": "none|repeat( <length-percentage> )",
    "scroll-snap-points-y": "none|repeat( <length-percentage> )",
    "scroll-snap-stop": "normal|always",
    "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
    "scroll-snap-type-x": "none|mandatory|proximity",
    "scroll-snap-type-y": "none|mandatory|proximity",
    "scroll-timeline": "[<'scroll-timeline-name'>||<'scroll-timeline-axis'>]#",
    "scroll-timeline-axis": "[block|inline|x|y]#",
    "scroll-timeline-name": "[none|<dashed-ident>]#",
    "shape-image-threshold": "<alpha-value>",
    "shape-margin": "<length-percentage>",
    "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
    "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
    "stroke": "<paint>",
    "stroke-dasharray": "none|[<svg-length>+]#",
    "stroke-dashoffset": "<svg-length>",
    "stroke-linecap": "butt|round|square",
    "stroke-linejoin": "miter|round|bevel",
    "stroke-miterlimit": "<number-one-or-greater>",
    "stroke-opacity": "<'opacity'>",
    "stroke-width": "<svg-length>",
    "tab-size": "<integer>|<length>",
    "table-layout": "auto|fixed",
    "text-align": "start|end|left|right|center|justify|match-parent",
    "text-align-last": "auto|start|end|left|right|center|justify",
    "text-anchor": "start|middle|end",
    "text-combine-upright": "none|all|[digits <integer>?]",
    "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
    "text-decoration-color": "<color>",
    "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
    "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
    "text-decoration-skip-ink": "auto|all|none",
    "text-decoration-style": "solid|double|dotted|dashed|wavy",
    "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
    "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
    "text-emphasis-color": "<color>",
    "text-emphasis-position": "auto|[over|under]&&[right|left]?",
    "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
    "text-indent": "<length-percentage>&&hanging?&&each-line?",
    "text-justify": "auto|inter-character|inter-word|none",
    "text-orientation": "mixed|upright|sideways",
    "text-overflow": "[clip|ellipsis|<string>]{1,2}",
    "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
    "text-shadow": "none|<shadow-t>#",
    "text-size-adjust": "none|auto|<percentage>",
    "text-spacing-trim": "space-all|normal|space-first|trim-start|trim-both|trim-all|auto",
    "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
    "text-underline-offset": "auto|<length>|<percentage>",
    "text-underline-position": "auto|from-font|[under||[left|right]]",
    "text-wrap": "<'text-wrap-mode'>||<'text-wrap-style'>",
    "text-wrap-mode": "auto|wrap|nowrap",
    "text-wrap-style": "auto|balance|stable|pretty",
    "timeline-scope": "none|<dashed-ident>#",
    "top": "<length>|<percentage>|auto",
    "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
    "transform": "none|<transform-list>",
    "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
    "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
    "transform-style": "flat|preserve-3d",
    "transition": "<single-transition>#",
    "transition-behavior": "<transition-behavior-value>#",
    "transition-delay": "<time>#",
    "transition-duration": "<time>#",
    "transition-property": "none|<single-transition-property>#",
    "transition-timing-function": "<easing-function>#",
    "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
    "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
    "user-select": "auto|text|none|contain|all",
    "vector-effect": "none|non-scaling-stroke|non-scaling-size|non-rotation|fixed-position",
    "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
    "view-timeline": "[<'view-timeline-name'> <'view-timeline-axis'>?]#",
    "view-timeline-axis": "[block|inline|x|y]#",
    "view-timeline-inset": "[[auto|<length-percentage>]{1,2}]#",
    "view-timeline-name": "none|<dashed-ident>#",
    "view-transition-name": "none|<custom-ident>",
    "visibility": "visible|hidden|collapse",
    "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces|[<'white-space-collapse'>||<'text-wrap'>||<'white-space-trim'>]",
    "white-space-collapse": "collapse|discard|preserve|preserve-breaks|preserve-spaces|break-spaces",
    "widows": "<integer>",
    "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|stretch|<-non-standard-size>",
    "will-change": "auto|<animateable-feature>#",
    "word-break": "normal|break-all|keep-all|break-word|auto-phrase",
    "word-spacing": "normal|<length>",
    "word-wrap": "normal|break-word",
    "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
    "x": "<length>|<percentage>",
    "y": "<length>|<percentage>",
    "z-index": "auto|<integer>",
    "zoom": "normal|reset|<number>|<percentage>",
    "-moz-background-clip": "padding|border",
    "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
    "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
    "-moz-border-radius-topleft": "<'border-top-left-radius'>",
    "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
    "-moz-control-character-visibility": "visible|hidden",
    "-moz-osx-font-smoothing": "auto|grayscale",
    "-moz-user-select": "none|text|all|-moz-none",
    "-ms-flex-align": "start|end|center|baseline|stretch",
    "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
    "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
    "-ms-flex-negative": "<'flex-shrink'>",
    "-ms-flex-pack": "start|end|center|justify|distribute",
    "-ms-flex-order": "<integer>",
    "-ms-flex-positive": "<'flex-grow'>",
    "-ms-flex-preferred-size": "<'flex-basis'>",
    "-ms-interpolation-mode": "nearest-neighbor|bicubic",
    "-ms-grid-column-align": "start|end|center|stretch",
    "-ms-grid-row-align": "start|end|center|stretch",
    "-ms-hyphenate-limit-last": "none|always|column|page|spread",
    "-webkit-background-clip": "[<box>|border|padding|content|text]#",
    "-webkit-column-break-after": "always|auto|avoid",
    "-webkit-column-break-before": "always|auto|avoid",
    "-webkit-column-break-inside": "always|auto|avoid",
    "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
    "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
    "-webkit-print-color-adjust": "economy|exact",
    "-webkit-text-security": "none|circle|disc|square",
    "-webkit-user-drag": "none|element|auto",
    "-webkit-user-select": "auto|none|text|all",
    "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
    "baseline-shift": "baseline|sub|super|<svg-length>",
    "behavior": "<url>+",
    "cue": "<'cue-before'> <'cue-after'>?",
    "cue-after": "<url> <decibel>?|none",
    "cue-before": "<url> <decibel>?|none",
    "glyph-orientation-horizontal": "<angle>",
    "glyph-orientation-vertical": "<angle>",
    "kerning": "auto|<svg-length>",
    "pause": "<'pause-before'> <'pause-after'>?",
    "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest": "<'rest-before'> <'rest-after'>?",
    "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
    "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
    "speak": "auto|never|always",
    "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
    "unicode-range": "<urange>#",
    "voice-balance": "<number>|left|center|right|leftwards|rightwards",
    "voice-duration": "auto|<time>",
    "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
    "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
    "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
    "voice-stress": "normal|strong|moderate|none|reduced",
    "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]",
    "white-space-trim": "none|discard-before||discard-after||discard-inner"
  },
  "atrules": {
    "charset": {
      "prelude": "<string>",
      "descriptors": null
    },
    "counter-style": {
      "prelude": "<counter-style-name>",
      "descriptors": {
        "additive-symbols": "[<integer>&&<symbol>]#",
        "fallback": "<counter-style-name>",
        "negative": "<symbol> <symbol>?",
        "pad": "<integer>&&<symbol>",
        "prefix": "<symbol>",
        "range": "[[<integer>|infinite]{2}]#|auto",
        "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
        "suffix": "<symbol>",
        "symbols": "<symbol>+",
        "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
      }
    },
    "document": {
      "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
      "descriptors": null
    },
    "font-palette-values": {
      "prelude": "<dashed-ident>",
      "descriptors": {
        "base-palette": "light|dark|<integer [0,]>",
        "font-family": "<family-name>#",
        "override-colors": "[<integer [0,]> <absolute-color-base>]#"
      }
    },
    "font-face": {
      "prelude": null,
      "descriptors": {
        "ascent-override": "normal|<percentage>",
        "descent-override": "normal|<percentage>",
        "font-display": "[auto|block|swap|fallback|optional]",
        "font-family": "<family-name>",
        "font-feature-settings": "normal|<feature-tag-value>#",
        "font-variation-settings": "normal|[<string> <number>]#",
        "font-stretch": "<font-stretch-absolute>{1,2}",
        "font-style": "normal|italic|oblique <angle>{0,2}",
        "font-weight": "<font-weight-absolute>{1,2}",
        "line-gap-override": "normal|<percentage>",
        "size-adjust": "<percentage>",
        "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
        "unicode-range": "<urange>#"
      }
    },
    "font-feature-values": {
      "prelude": "<family-name>#",
      "descriptors": null
    },
    "import": {
      "prelude": "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
      "descriptors": null
    },
    "keyframes": {
      "prelude": "<keyframes-name>",
      "descriptors": null
    },
    "layer": {
      "prelude": "[<layer-name>#|<layer-name>?]",
      "descriptors": null
    },
    "media": {
      "prelude": "<media-query-list>",
      "descriptors": null
    },
    "namespace": {
      "prelude": "<namespace-prefix>? [<string>|<url>]",
      "descriptors": null
    },
    "page": {
      "prelude": "<page-selector-list>",
      "descriptors": {
        "bleed": "auto|<length>",
        "marks": "none|[crop||cross]",
        "page-orientation": "upright|rotate-left|rotate-right",
        "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
      }
    },
    "position-try": {
      "prelude": "<dashed-ident>",
      "descriptors": {
        "top": "<'top'>",
        "left": "<'left'>",
        "bottom": "<'bottom'>",
        "right": "<'right'>",
        "inset-block-start": "<'inset-block-start'>",
        "inset-block-end": "<'inset-block-end'>",
        "inset-inline-start": "<'inset-inline-start'>",
        "inset-inline-end": "<'inset-inline-end'>",
        "inset-block": "<'inset-block'>",
        "inset-inline": "<'inset-inline'>",
        "inset": "<'inset'>",
        "margin-top": "<'margin-top'>",
        "margin-left": "<'margin-left'>",
        "margin-bottom": "<'margin-bottom'>",
        "margin-right": "<'margin-right'>",
        "margin-block-start": "<'margin-block-start'>",
        "margin-block-end": "<'margin-block-end'>",
        "margin-inline-start": "<'margin-inline-start'>",
        "margin-inline-end": "<'margin-inline-end'>",
        "margin": "<'margin'>",
        "margin-block": "<'margin-block'>",
        "margin-inline": "<'margin-inline'>",
        "width": "<'width'>",
        "height": "<'height'>",
        "min-width": "<'min-width'>",
        "min-height": "<'min-height'>",
        "max-width": "<'max-width'>",
        "max-height": "<'max-height'>",
        "block-size": "<'block-size'>",
        "inline-size": "<'inline-size'>",
        "min-block-size": "<'min-block-size'>",
        "min-inline-size": "<'min-inline-size'>",
        "max-block-size": "<'max-block-size'>",
        "max-inline-size": "<'max-inline-size'>",
        "align-self": "<'align-self'>|anchor-center",
        "justify-self": "<'justify-self'>|anchor-center"
      }
    },
    "property": {
      "prelude": "<custom-property-name>",
      "descriptors": {
        "syntax": "<string>",
        "inherits": "true|false",
        "initial-value": "<declaration-value>?"
      }
    },
    "scope": {
      "prelude": "[( <scope-start> )]? [to ( <scope-end> )]?",
      "descriptors": null
    },
    "starting-style": {
      "prelude": null,
      "descriptors": null
    },
    "supports": {
      "prelude": "<supports-condition>",
      "descriptors": null
    },
    "container": {
      "prelude": "[<container-name>]? <container-condition>",
      "descriptors": null
    },
    "nest": {
      "prelude": "<complex-selector-list>",
      "descriptors": null
    }
  }
};
const PLUSSIGN$5 = 43;
const HYPHENMINUS$2 = 45;
const N = 110;
const DISALLOW_SIGN = true;
const ALLOW_SIGN = false;
function checkInteger(offset2, disallowSign) {
  let pos = this.tokenStart + offset2;
  const code2 = this.charCodeAt(pos);
  if (code2 === PLUSSIGN$5 || code2 === HYPHENMINUS$2) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }
  for (; pos < this.tokenEnd; pos++) {
    if (!isDigit(this.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}
function checkTokenIsInteger(disallowSign) {
  return checkInteger.call(this, 0, disallowSign);
}
function expectCharCode(offset2, code2) {
  if (!this.cmpChar(this.tokenStart + offset2, code2)) {
    let msg = "";
    switch (code2) {
      case N:
        msg = "N is expected";
        break;
      case HYPHENMINUS$2:
        msg = "HyphenMinus is expected";
        break;
    }
    this.error(msg, this.tokenStart + offset2);
  }
}
function consumeB() {
  let offset2 = 0;
  let sign2 = 0;
  let type2 = this.tokenType;
  while (type2 === WhiteSpace$1 || type2 === Comment$1) {
    type2 = this.lookupType(++offset2);
  }
  if (type2 !== Number$2) {
    if (this.isDelim(PLUSSIGN$5, offset2) || this.isDelim(HYPHENMINUS$2, offset2)) {
      sign2 = this.isDelim(PLUSSIGN$5, offset2) ? PLUSSIGN$5 : HYPHENMINUS$2;
      do {
        type2 = this.lookupType(++offset2);
      } while (type2 === WhiteSpace$1 || type2 === Comment$1);
      if (type2 !== Number$2) {
        this.skip(offset2);
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
      }
    } else {
      return null;
    }
  }
  if (offset2 > 0) {
    this.skip(offset2);
  }
  if (sign2 === 0) {
    type2 = this.charCodeAt(this.tokenStart);
    if (type2 !== PLUSSIGN$5 && type2 !== HYPHENMINUS$2) {
      this.error("Number sign is expected");
    }
  }
  checkTokenIsInteger.call(this, sign2 !== 0);
  return sign2 === HYPHENMINUS$2 ? "-" + this.consume(Number$2) : this.consume(Number$2);
}
const name$M = "AnPlusB";
const structure$M = {
  a: [String, null],
  b: [String, null]
};
function parse$N() {
  const start = this.tokenStart;
  let a = null;
  let b = null;
  if (this.tokenType === Number$2) {
    checkTokenIsInteger.call(this, ALLOW_SIGN);
    b = this.consume(Number$2);
  } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$2)) {
    a = "-1";
    expectCharCode.call(this, 1, N);
    switch (this.tokenEnd - this.tokenStart) {
      case 2:
        this.next();
        b = consumeB.call(this);
        break;
      case 3:
        expectCharCode.call(this, 2, HYPHENMINUS$2);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
        b = "-" + this.consume(Number$2);
        break;
      default:
        expectCharCode.call(this, 2, HYPHENMINUS$2);
        checkInteger.call(this, 3, DISALLOW_SIGN);
        this.next();
        b = this.substrToCursor(start + 2);
    }
  } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN$5) && this.lookupType(1) === Ident) {
    let sign2 = 0;
    a = "1";
    if (this.isDelim(PLUSSIGN$5)) {
      sign2 = 1;
      this.next();
    }
    expectCharCode.call(this, 0, N);
    switch (this.tokenEnd - this.tokenStart) {
      case 1:
        this.next();
        b = consumeB.call(this);
        break;
      case 2:
        expectCharCode.call(this, 1, HYPHENMINUS$2);
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
        b = "-" + this.consume(Number$2);
        break;
      default:
        expectCharCode.call(this, 1, HYPHENMINUS$2);
        checkInteger.call(this, 2, DISALLOW_SIGN);
        this.next();
        b = this.substrToCursor(start + sign2 + 1);
    }
  } else if (this.tokenType === Dimension$1) {
    const code2 = this.charCodeAt(this.tokenStart);
    const sign2 = code2 === PLUSSIGN$5 || code2 === HYPHENMINUS$2;
    let i2 = this.tokenStart + sign2;
    for (; i2 < this.tokenEnd; i2++) {
      if (!isDigit(this.charCodeAt(i2))) {
        break;
      }
    }
    if (i2 === this.tokenStart + sign2) {
      this.error("Integer is expected", this.tokenStart + sign2);
    }
    expectCharCode.call(this, i2 - this.tokenStart, N);
    a = this.substring(start, i2);
    if (i2 + 1 === this.tokenEnd) {
      this.next();
      b = consumeB.call(this);
    } else {
      expectCharCode.call(this, i2 - this.tokenStart + 1, HYPHENMINUS$2);
      if (i2 + 2 === this.tokenEnd) {
        this.next();
        this.skipSC();
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
        b = "-" + this.consume(Number$2);
      } else {
        checkInteger.call(this, i2 - this.tokenStart + 2, DISALLOW_SIGN);
        this.next();
        b = this.substrToCursor(i2 + 1);
      }
    }
  } else {
    this.error();
  }
  if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
    a = a.substr(1);
  }
  if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
    b = b.substr(1);
  }
  return {
    type: "AnPlusB",
    loc: this.getLocation(start, this.tokenStart),
    a,
    b
  };
}
function generate$N(node2) {
  if (node2.a) {
    const a = node2.a === "+1" && "n" || node2.a === "1" && "n" || node2.a === "-1" && "-n" || node2.a + "n";
    if (node2.b) {
      const b = node2.b[0] === "-" || node2.b[0] === "+" ? node2.b : "+" + node2.b;
      this.tokenize(a + b);
    } else {
      this.tokenize(a);
    }
  } else {
    this.tokenize(node2.b);
  }
}
var AnPlusB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$N,
  name: name$M,
  parse: parse$N,
  structure: structure$M
});
function consumeRaw$4() {
  return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}
function isDeclarationBlockAtrule() {
  for (let offset2 = 1, type2; type2 = this.lookupType(offset2); offset2++) {
    if (type2 === RightCurlyBracket) {
      return true;
    }
    if (type2 === LeftCurlyBracket || type2 === AtKeyword) {
      return false;
    }
  }
  return false;
}
const name$L = "Atrule";
const walkContext$9 = "atrule";
const structure$L = {
  name: String,
  prelude: ["AtrulePrelude", "Raw", null],
  block: ["Block", null]
};
function parse$M(isDeclaration = false) {
  const start = this.tokenStart;
  let name2;
  let nameLowerCase;
  let prelude = null;
  let block = null;
  this.eat(AtKeyword);
  name2 = this.substrToCursor(start + 1);
  nameLowerCase = name2.toLowerCase();
  this.skipSC();
  if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    if (this.parseAtrulePrelude) {
      prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2, isDeclaration), consumeRaw$4);
    } else {
      prelude = consumeRaw$4.call(this, this.tokenIndex);
    }
    this.skipSC();
  }
  switch (this.tokenType) {
    case Semicolon:
      this.next();
      break;
    case LeftCurlyBracket:
      if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
        block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
      } else {
        block = this.Block(isDeclarationBlockAtrule.call(this));
      }
      break;
  }
  return {
    type: "Atrule",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    prelude,
    block
  };
}
function generate$M(node2) {
  this.token(AtKeyword, "@" + node2.name);
  if (node2.prelude !== null) {
    this.node(node2.prelude);
  }
  if (node2.block) {
    this.node(node2.block);
  } else {
    this.token(Semicolon, ";");
  }
}
var Atrule = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$M,
  name: name$L,
  parse: parse$M,
  structure: structure$L,
  walkContext: walkContext$9
});
const name$K = "AtrulePrelude";
const walkContext$8 = "atrulePrelude";
const structure$K = {
  children: [[]]
};
function parse$L(name2) {
  let children = null;
  if (name2 !== null) {
    name2 = name2.toLowerCase();
  }
  this.skipSC();
  if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
    children = this.atrule[name2].prelude.call(this);
  } else {
    children = this.readSequence(this.scope.AtrulePrelude);
  }
  this.skipSC();
  if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
    this.error("Semicolon or block is expected");
  }
  return {
    type: "AtrulePrelude",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$L(node2) {
  this.children(node2);
}
var AtrulePrelude = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$L,
  name: name$K,
  parse: parse$L,
  structure: structure$K,
  walkContext: walkContext$8
});
const DOLLARSIGN$1 = 36;
const ASTERISK$5 = 42;
const EQUALSSIGN$1 = 61;
const CIRCUMFLEXACCENT = 94;
const VERTICALLINE$2 = 124;
const TILDE$2 = 126;
function getAttributeName() {
  if (this.eof) {
    this.error("Unexpected end of input");
  }
  const start = this.tokenStart;
  let expectIdent = false;
  if (this.isDelim(ASTERISK$5)) {
    expectIdent = true;
    this.next();
  } else if (!this.isDelim(VERTICALLINE$2)) {
    this.eat(Ident);
  }
  if (this.isDelim(VERTICALLINE$2)) {
    if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN$1) {
      this.next();
      this.eat(Ident);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }
  return {
    type: "Identifier",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function getOperator() {
  const start = this.tokenStart;
  const code2 = this.charCodeAt(start);
  if (code2 !== EQUALSSIGN$1 && // =
  code2 !== TILDE$2 && // ~=
  code2 !== CIRCUMFLEXACCENT && // ^=
  code2 !== DOLLARSIGN$1 && // $=
  code2 !== ASTERISK$5 && // *=
  code2 !== VERTICALLINE$2) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }
  this.next();
  if (code2 !== EQUALSSIGN$1) {
    if (!this.isDelim(EQUALSSIGN$1)) {
      this.error("Equal sign is expected");
    }
    this.next();
  }
  return this.substrToCursor(start);
}
const name$J = "AttributeSelector";
const structure$J = {
  name: "Identifier",
  matcher: [String, null],
  value: ["String", "Identifier", null],
  flags: [String, null]
};
function parse$K() {
  const start = this.tokenStart;
  let name2;
  let matcher = null;
  let value2 = null;
  let flags = null;
  this.eat(LeftSquareBracket);
  this.skipSC();
  name2 = getAttributeName.call(this);
  this.skipSC();
  if (this.tokenType !== RightSquareBracket) {
    if (this.tokenType !== Ident) {
      matcher = getOperator.call(this);
      this.skipSC();
      value2 = this.tokenType === String$2 ? this.String() : this.Identifier();
      this.skipSC();
    }
    if (this.tokenType === Ident) {
      flags = this.consume(Ident);
      this.skipSC();
    }
  }
  this.eat(RightSquareBracket);
  return {
    type: "AttributeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    matcher,
    value: value2,
    flags
  };
}
function generate$K(node2) {
  this.token(Delim, "[");
  this.node(node2.name);
  if (node2.matcher !== null) {
    this.tokenize(node2.matcher);
    this.node(node2.value);
  }
  if (node2.flags !== null) {
    this.token(Ident, node2.flags);
  }
  this.token(Delim, "]");
}
var AttributeSelector = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$K,
  name: name$J,
  parse: parse$K,
  structure: structure$J
});
const AMPERSAND$4 = 38;
function consumeRaw$3() {
  return this.Raw(null, true);
}
function consumeRule() {
  return this.parseWithFallback(this.Rule, consumeRaw$3);
}
function consumeRawDeclaration() {
  return this.Raw(this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
  if (this.tokenType === Semicolon) {
    return consumeRawDeclaration.call(this, this.tokenIndex);
  }
  const node2 = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
  if (this.tokenType === Semicolon) {
    this.next();
  }
  return node2;
}
const name$I = "Block";
const walkContext$7 = "block";
const structure$I = {
  children: [[
    "Atrule",
    "Rule",
    "Declaration"
  ]]
};
function parse$J(isStyleBlock) {
  const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
  const start = this.tokenStart;
  let children = this.createList();
  this.eat(LeftCurlyBracket);
  scan:
    while (!this.eof) {
      switch (this.tokenType) {
        case RightCurlyBracket:
          break scan;
        case WhiteSpace$1:
        case Comment$1:
          this.next();
          break;
        case AtKeyword:
          children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw$3));
          break;
        default:
          if (isStyleBlock && this.isDelim(AMPERSAND$4)) {
            children.push(consumeRule.call(this));
          } else {
            children.push(consumer.call(this));
          }
      }
    }
  if (!this.eof) {
    this.eat(RightCurlyBracket);
  }
  return {
    type: "Block",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$J(node2) {
  this.token(LeftCurlyBracket, "{");
  this.children(node2, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
  this.token(RightCurlyBracket, "}");
}
var Block = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$J,
  name: name$I,
  parse: parse$J,
  structure: structure$I,
  walkContext: walkContext$7
});
const name$H = "Brackets";
const structure$H = {
  children: [[]]
};
function parse$I(readSequence2, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftSquareBracket);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightSquareBracket);
  }
  return {
    type: "Brackets",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$I(node2) {
  this.token(Delim, "[");
  this.children(node2);
  this.token(Delim, "]");
}
var Brackets = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$I,
  name: name$H,
  parse: parse$I,
  structure: structure$H
});
const name$G = "CDC";
const structure$G = [];
function parse$H() {
  const start = this.tokenStart;
  this.eat(CDC$1);
  return {
    type: "CDC",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate$H() {
  this.token(CDC$1, "-->");
}
var CDC = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$H,
  name: name$G,
  parse: parse$H,
  structure: structure$G
});
const name$F = "CDO";
const structure$F = [];
function parse$G() {
  const start = this.tokenStart;
  this.eat(CDO$1);
  return {
    type: "CDO",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate$G() {
  this.token(CDO$1, "<!--");
}
var CDO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$G,
  name: name$F,
  parse: parse$G,
  structure: structure$F
});
const FULLSTOP$2 = 46;
const name$E = "ClassSelector";
const structure$E = {
  name: String
};
function parse$F() {
  this.eatDelim(FULLSTOP$2);
  return {
    type: "ClassSelector",
    loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate$F(node2) {
  this.token(Delim, ".");
  this.token(Ident, node2.name);
}
var ClassSelector = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$F,
  name: name$E,
  parse: parse$F,
  structure: structure$E
});
const PLUSSIGN$4 = 43;
const SOLIDUS$7 = 47;
const GREATERTHANSIGN$2 = 62;
const TILDE$1 = 126;
const name$D = "Combinator";
const structure$D = {
  name: String
};
function parse$E() {
  const start = this.tokenStart;
  let name2;
  switch (this.tokenType) {
    case WhiteSpace$1:
      name2 = " ";
      break;
    case Delim:
      switch (this.charCodeAt(this.tokenStart)) {
        case GREATERTHANSIGN$2:
        case PLUSSIGN$4:
        case TILDE$1:
          this.next();
          break;
        case SOLIDUS$7:
          this.next();
          this.eatIdent("deep");
          this.eatDelim(SOLIDUS$7);
          break;
        default:
          this.error("Combinator is expected");
      }
      name2 = this.substrToCursor(start);
      break;
  }
  return {
    type: "Combinator",
    loc: this.getLocation(start, this.tokenStart),
    name: name2
  };
}
function generate$E(node2) {
  this.tokenize(node2.name);
}
var Combinator = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$E,
  name: name$D,
  parse: parse$E,
  structure: structure$D
});
const ASTERISK$4 = 42;
const SOLIDUS$6 = 47;
const name$C = "Comment";
const structure$C = {
  value: String
};
function parse$D() {
  const start = this.tokenStart;
  let end = this.tokenEnd;
  this.eat(Comment$1);
  if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK$4 && this.charCodeAt(end - 1) === SOLIDUS$6) {
    end -= 2;
  }
  return {
    type: "Comment",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substring(start + 2, end)
  };
}
function generate$D(node2) {
  this.token(Comment$1, "/*" + node2.value + "*/");
}
var Comment = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$D,
  name: name$C,
  parse: parse$D,
  structure: structure$C
});
const likelyFeatureToken = /* @__PURE__ */ new Set([Colon, RightParenthesis, EOF$1]);
const name$B = "Condition";
const structure$B = {
  kind: String,
  children: [[
    "Identifier",
    "Feature",
    "FeatureFunction",
    "FeatureRange",
    "SupportsDeclaration"
  ]]
};
function featureOrRange(kind) {
  if (this.lookupTypeNonSC(1) === Ident && likelyFeatureToken.has(this.lookupTypeNonSC(2))) {
    return this.Feature(kind);
  }
  return this.FeatureRange(kind);
}
const parentheses = {
  media: featureOrRange,
  container: featureOrRange,
  supports() {
    return this.SupportsDeclaration();
  }
};
function parse$C(kind = "media") {
  const children = this.createList();
  scan: while (!this.eof) {
    switch (this.tokenType) {
      case Comment$1:
      case WhiteSpace$1:
        this.next();
        continue;
      case Ident:
        children.push(this.Identifier());
        break;
      case LeftParenthesis: {
        let term = this.parseWithFallback(
          () => parentheses[kind].call(this, kind),
          () => null
        );
        if (!term) {
          term = this.parseWithFallback(
            () => {
              this.eat(LeftParenthesis);
              const res = this.Condition(kind);
              this.eat(RightParenthesis);
              return res;
            },
            () => {
              return this.GeneralEnclosed(kind);
            }
          );
        }
        children.push(term);
        break;
      }
      case Function$2: {
        let term = this.parseWithFallback(
          () => this.FeatureFunction(kind),
          () => null
        );
        if (!term) {
          term = this.GeneralEnclosed(kind);
        }
        children.push(term);
        break;
      }
      default:
        break scan;
    }
  }
  if (children.isEmpty) {
    this.error("Condition is expected");
  }
  return {
    type: "Condition",
    loc: this.getLocationFromList(children),
    kind,
    children
  };
}
function generate$C(node2) {
  node2.children.forEach((child) => {
    if (child.type === "Condition") {
      this.token(LeftParenthesis, "(");
      this.node(child);
      this.token(RightParenthesis, ")");
    } else {
      this.node(child);
    }
  });
}
var Condition = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$C,
  name: name$B,
  parse: parse$C,
  structure: structure$B
});
const EXCLAMATIONMARK$1 = 33;
const NUMBERSIGN$2 = 35;
const DOLLARSIGN = 36;
const AMPERSAND$3 = 38;
const ASTERISK$3 = 42;
const PLUSSIGN$3 = 43;
const SOLIDUS$5 = 47;
function consumeValueRaw() {
  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);
}
function consumeCustomPropertyRaw() {
  return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
}
function consumeValue() {
  const startValueToken = this.tokenIndex;
  const value2 = this.Value();
  if (value2.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK$1) === false && this.isBalanceEdge(startValueToken) === false) {
    this.error();
  }
  return value2;
}
const name$A = "Declaration";
const walkContext$6 = "declaration";
const structure$A = {
  important: [Boolean, String],
  property: String,
  value: ["Value", "Raw"]
};
function parse$B() {
  const start = this.tokenStart;
  const startToken = this.tokenIndex;
  const property2 = readProperty.call(this);
  const customProperty = isCustomProperty(property2);
  const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
  const consumeRaw2 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
  let important = false;
  let value2;
  this.skipSC();
  this.eat(Colon);
  const valueStart = this.tokenIndex;
  if (!customProperty) {
    this.skipSC();
  }
  if (parseValue) {
    value2 = this.parseWithFallback(consumeValue, consumeRaw2);
  } else {
    value2 = consumeRaw2.call(this, this.tokenIndex);
  }
  if (customProperty && value2.type === "Value" && value2.children.isEmpty) {
    for (let offset2 = valueStart - this.tokenIndex; offset2 <= 0; offset2++) {
      if (this.lookupType(offset2) === WhiteSpace$1) {
        value2.children.appendData({
          type: "WhiteSpace",
          loc: null,
          value: " "
        });
        break;
      }
    }
  }
  if (this.isDelim(EXCLAMATIONMARK$1)) {
    important = getImportant.call(this);
    this.skipSC();
  }
  if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false) {
    this.error();
  }
  return {
    type: "Declaration",
    loc: this.getLocation(start, this.tokenStart),
    important,
    property: property2,
    value: value2
  };
}
function generate$B(node2) {
  this.token(Ident, node2.property);
  this.token(Colon, ":");
  this.node(node2.value);
  if (node2.important) {
    this.token(Delim, "!");
    this.token(Ident, node2.important === true ? "important" : node2.important);
  }
}
function readProperty() {
  const start = this.tokenStart;
  if (this.tokenType === Delim) {
    switch (this.charCodeAt(this.tokenStart)) {
      case ASTERISK$3:
      case DOLLARSIGN:
      case PLUSSIGN$3:
      case NUMBERSIGN$2:
      case AMPERSAND$3:
        this.next();
        break;
      case SOLIDUS$5:
        this.next();
        if (this.isDelim(SOLIDUS$5)) {
          this.next();
        }
        break;
    }
  }
  if (this.tokenType === Hash$1) {
    this.eat(Hash$1);
  } else {
    this.eat(Ident);
  }
  return this.substrToCursor(start);
}
function getImportant() {
  this.eat(Delim);
  this.skipSC();
  const important = this.consume(Ident);
  return important === "important" ? true : important;
}
var Declaration = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$B,
  name: name$A,
  parse: parse$B,
  structure: structure$A,
  walkContext: walkContext$6
});
const AMPERSAND$2 = 38;
function consumeRaw$2() {
  return this.Raw(this.consumeUntilSemicolonIncluded, true);
}
const name$z = "DeclarationList";
const structure$z = {
  children: [[
    "Declaration",
    "Atrule",
    "Rule"
  ]]
};
function parse$A() {
  const children = this.createList();
  while (!this.eof) {
    switch (this.tokenType) {
      case WhiteSpace$1:
      case Comment$1:
      case Semicolon:
        this.next();
        break;
      case AtKeyword:
        children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw$2));
        break;
      default:
        if (this.isDelim(AMPERSAND$2)) {
          children.push(this.parseWithFallback(this.Rule, consumeRaw$2));
        } else {
          children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
        }
    }
  }
  return {
    type: "DeclarationList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$A(node2) {
  this.children(node2, (prev) => {
    if (prev.type === "Declaration") {
      this.token(Semicolon, ";");
    }
  });
}
var DeclarationList = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$A,
  name: name$z,
  parse: parse$A,
  structure: structure$z
});
const name$y = "Dimension";
const structure$y = {
  value: String,
  unit: String
};
function parse$z() {
  const start = this.tokenStart;
  const value2 = this.consumeNumber(Dimension$1);
  return {
    type: "Dimension",
    loc: this.getLocation(start, this.tokenStart),
    value: value2,
    unit: this.substring(start + value2.length, this.tokenStart)
  };
}
function generate$z(node2) {
  this.token(Dimension$1, node2.value + node2.unit);
}
var Dimension = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$z,
  name: name$y,
  parse: parse$z,
  structure: structure$y
});
const SOLIDUS$4 = 47;
const name$x = "Feature";
const structure$x = {
  kind: String,
  name: String,
  value: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
};
function parse$y(kind) {
  const start = this.tokenStart;
  let name2;
  let value2 = null;
  this.eat(LeftParenthesis);
  this.skipSC();
  name2 = this.consume(Ident);
  this.skipSC();
  if (this.tokenType !== RightParenthesis) {
    this.eat(Colon);
    this.skipSC();
    switch (this.tokenType) {
      case Number$2:
        if (this.lookupNonWSType(1) === Delim) {
          value2 = this.Ratio();
        } else {
          value2 = this.Number();
        }
        break;
      case Dimension$1:
        value2 = this.Dimension();
        break;
      case Ident:
        value2 = this.Identifier();
        break;
      case Function$2:
        value2 = this.parseWithFallback(
          () => {
            const res = this.Function(this.readSequence, this.scope.Value);
            this.skipSC();
            if (this.isDelim(SOLIDUS$4)) {
              this.error();
            }
            return res;
          },
          () => {
            return this.Ratio();
          }
        );
        break;
      default:
        this.error("Number, dimension, ratio or identifier is expected");
    }
    this.skipSC();
  }
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Feature",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    name: name2,
    value: value2
  };
}
function generate$y(node2) {
  this.token(LeftParenthesis, "(");
  this.token(Ident, node2.name);
  if (node2.value !== null) {
    this.token(Colon, ":");
    this.node(node2.value);
  }
  this.token(RightParenthesis, ")");
}
var Feature = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$y,
  name: name$x,
  parse: parse$y,
  structure: structure$x
});
const name$w = "FeatureFunction";
const structure$w = {
  kind: String,
  feature: String,
  value: ["Declaration", "Selector"]
};
function getFeatureParser(kind, name2) {
  const featuresOfKind = this.features[kind] || {};
  const parser = featuresOfKind[name2];
  if (typeof parser !== "function") {
    this.error(`Unknown feature ${name2}()`);
  }
  return parser;
}
function parse$x(kind = "unknown") {
  const start = this.tokenStart;
  const functionName = this.consumeFunctionName();
  const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());
  this.skipSC();
  const value2 = this.parseWithFallback(
    () => {
      const startValueToken = this.tokenIndex;
      const value3 = valueParser.call(this);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value3;
    },
    () => this.Raw(null, false)
  );
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "FeatureFunction",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    feature: functionName,
    value: value2
  };
}
function generate$x(node2) {
  this.token(Function$2, node2.feature + "(");
  this.node(node2.value);
  this.token(RightParenthesis, ")");
}
var FeatureFunction = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$x,
  name: name$w,
  parse: parse$x,
  structure: structure$w
});
const SOLIDUS$3 = 47;
const LESSTHANSIGN = 60;
const EQUALSSIGN = 61;
const GREATERTHANSIGN$1 = 62;
const name$v = "FeatureRange";
const structure$v = {
  kind: String,
  left: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
  leftComparison: String,
  middle: ["Identifier", "Number", "Dimension", "Ratio", "Function"],
  rightComparison: [String, null],
  right: ["Identifier", "Number", "Dimension", "Ratio", "Function", null]
};
function readTerm() {
  this.skipSC();
  switch (this.tokenType) {
    case Number$2:
      if (this.isDelim(SOLIDUS$3, this.lookupOffsetNonSC(1))) {
        return this.Ratio();
      } else {
        return this.Number();
      }
    case Dimension$1:
      return this.Dimension();
    case Ident:
      return this.Identifier();
    case Function$2:
      return this.parseWithFallback(
        () => {
          const res = this.Function(this.readSequence, this.scope.Value);
          this.skipSC();
          if (this.isDelim(SOLIDUS$3)) {
            this.error();
          }
          return res;
        },
        () => {
          return this.Ratio();
        }
      );
    default:
      this.error("Number, dimension, ratio or identifier is expected");
  }
}
function readComparison(expectColon) {
  this.skipSC();
  if (this.isDelim(LESSTHANSIGN) || this.isDelim(GREATERTHANSIGN$1)) {
    const value2 = this.source[this.tokenStart];
    this.next();
    if (this.isDelim(EQUALSSIGN)) {
      this.next();
      return value2 + "=";
    }
    return value2;
  }
  if (this.isDelim(EQUALSSIGN)) {
    return "=";
  }
  this.error(`Expected ${expectColon ? '":", ' : ""}"<", ">", "=" or ")"`);
}
function parse$w(kind = "unknown") {
  const start = this.tokenStart;
  this.skipSC();
  this.eat(LeftParenthesis);
  const left = readTerm.call(this);
  const leftComparison = readComparison.call(this, left.type === "Identifier");
  const middle = readTerm.call(this);
  let rightComparison = null;
  let right = null;
  if (this.lookupNonWSType(0) !== RightParenthesis) {
    rightComparison = readComparison.call(this);
    right = readTerm.call(this);
  }
  this.skipSC();
  this.eat(RightParenthesis);
  return {
    type: "FeatureRange",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    left,
    leftComparison,
    middle,
    rightComparison,
    right
  };
}
function generate$w(node2) {
  this.token(LeftParenthesis, "(");
  this.node(node2.left);
  this.tokenize(node2.leftComparison);
  this.node(node2.middle);
  if (node2.right) {
    this.tokenize(node2.rightComparison);
    this.node(node2.right);
  }
  this.token(RightParenthesis, ")");
}
var FeatureRange = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$w,
  name: name$v,
  parse: parse$w,
  structure: structure$v
});
const name$u = "Function";
const walkContext$5 = "function";
const structure$u = {
  name: String,
  children: [[]]
};
function parse$v(readSequence2, recognizer) {
  const start = this.tokenStart;
  const name2 = this.consumeFunctionName();
  const nameLowerCase = name2.toLowerCase();
  let children;
  children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Function",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    children
  };
}
function generate$v(node2) {
  this.token(Function$2, node2.name + "(");
  this.children(node2);
  this.token(RightParenthesis, ")");
}
var Function$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$v,
  name: name$u,
  parse: parse$v,
  structure: structure$u,
  walkContext: walkContext$5
});
const name$t = "GeneralEnclosed";
const structure$t = {
  kind: String,
  function: [String, null],
  children: [[]]
};
function parse$u(kind) {
  const start = this.tokenStart;
  let functionName = null;
  if (this.tokenType === Function$2) {
    functionName = this.consumeFunctionName();
  } else {
    this.eat(LeftParenthesis);
  }
  const children = this.parseWithFallback(
    () => {
      const startValueToken = this.tokenIndex;
      const children2 = this.readSequence(this.scope.Value);
      if (this.eof === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return children2;
    },
    () => this.createSingleNodeList(
      this.Raw(null, false)
    )
  );
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "GeneralEnclosed",
    loc: this.getLocation(start, this.tokenStart),
    kind,
    function: functionName,
    children
  };
}
function generate$u(node2) {
  if (node2.function) {
    this.token(Function$2, node2.function + "(");
  } else {
    this.token(LeftParenthesis, "(");
  }
  this.children(node2);
  this.token(RightParenthesis, ")");
}
var GeneralEnclosed = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$u,
  name: name$t,
  parse: parse$u,
  structure: structure$t
});
const xxx = "XXX";
const name$s = "Hash";
const structure$s = {
  value: String
};
function parse$t() {
  const start = this.tokenStart;
  this.eat(Hash$1);
  return {
    type: "Hash",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start + 1)
  };
}
function generate$t(node2) {
  this.token(Hash$1, "#" + node2.value);
}
var Hash = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$t,
  name: name$s,
  parse: parse$t,
  structure: structure$s,
  xxx
});
const name$r = "Identifier";
const structure$r = {
  name: String
};
function parse$s() {
  return {
    type: "Identifier",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    name: this.consume(Ident)
  };
}
function generate$s(node2) {
  this.token(Ident, node2.name);
}
var Identifier = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$s,
  name: name$r,
  parse: parse$s,
  structure: structure$r
});
const name$q = "IdSelector";
const structure$q = {
  name: String
};
function parse$r() {
  const start = this.tokenStart;
  this.eat(Hash$1);
  return {
    type: "IdSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start + 1)
  };
}
function generate$r(node2) {
  this.token(Delim, "#" + node2.name);
}
var IdSelector = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$r,
  name: name$q,
  parse: parse$r,
  structure: structure$q
});
const FULLSTOP$1 = 46;
const name$p = "Layer";
const structure$p = {
  name: String
};
function parse$q() {
  let tokenStart = this.tokenStart;
  let name2 = this.consume(Ident);
  while (this.isDelim(FULLSTOP$1)) {
    this.eat(Delim);
    name2 += "." + this.consume(Ident);
  }
  return {
    type: "Layer",
    loc: this.getLocation(tokenStart, this.tokenStart),
    name: name2
  };
}
function generate$q(node2) {
  this.tokenize(node2.name);
}
var Layer = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$q,
  name: name$p,
  parse: parse$q,
  structure: structure$p
});
const name$o = "LayerList";
const structure$o = {
  children: [[
    "Layer"
  ]]
};
function parse$p() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.Layer());
    if (this.lookupTypeNonSC(0) !== Comma) {
      break;
    }
    this.skipSC();
    this.next();
    this.skipSC();
  }
  return {
    type: "LayerList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$p(node2) {
  this.children(node2, () => this.token(Comma, ","));
}
var LayerList = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$p,
  name: name$o,
  parse: parse$p,
  structure: structure$o
});
const name$n = "MediaQuery";
const structure$n = {
  modifier: [String, null],
  mediaType: [String, null],
  condition: ["Condition", null]
};
function parse$o() {
  const start = this.tokenStart;
  let modifier = null;
  let mediaType = null;
  let condition = null;
  this.skipSC();
  if (this.tokenType === Ident && this.lookupTypeNonSC(1) !== LeftParenthesis) {
    const ident = this.consume(Ident);
    const identLowerCase = ident.toLowerCase();
    if (identLowerCase === "not" || identLowerCase === "only") {
      this.skipSC();
      modifier = identLowerCase;
      mediaType = this.consume(Ident);
    } else {
      mediaType = ident;
    }
    switch (this.lookupTypeNonSC(0)) {
      case Ident: {
        this.skipSC();
        this.eatIdent("and");
        condition = this.Condition("media");
        break;
      }
      case LeftCurlyBracket:
      case Semicolon:
      case Comma:
      case EOF$1:
        break;
      default:
        this.error("Identifier or parenthesis is expected");
    }
  } else {
    switch (this.tokenType) {
      case Ident:
      case LeftParenthesis:
      case Function$2: {
        condition = this.Condition("media");
        break;
      }
      case LeftCurlyBracket:
      case Semicolon:
      case EOF$1:
        break;
      default:
        this.error("Identifier or parenthesis is expected");
    }
  }
  return {
    type: "MediaQuery",
    loc: this.getLocation(start, this.tokenStart),
    modifier,
    mediaType,
    condition
  };
}
function generate$o(node2) {
  if (node2.mediaType) {
    if (node2.modifier) {
      this.token(Ident, node2.modifier);
    }
    this.token(Ident, node2.mediaType);
    if (node2.condition) {
      this.token(Ident, "and");
      this.node(node2.condition);
    }
  } else if (node2.condition) {
    this.node(node2.condition);
  }
}
var MediaQuery = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$o,
  name: name$n,
  parse: parse$o,
  structure: structure$n
});
const name$m = "MediaQueryList";
const structure$m = {
  children: [[
    "MediaQuery"
  ]]
};
function parse$n() {
  const children = this.createList();
  this.skipSC();
  while (!this.eof) {
    children.push(this.MediaQuery());
    if (this.tokenType !== Comma) {
      break;
    }
    this.next();
  }
  return {
    type: "MediaQueryList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$n(node2) {
  this.children(node2, () => this.token(Comma, ","));
}
var MediaQueryList = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$n,
  name: name$m,
  parse: parse$n,
  structure: structure$m
});
const AMPERSAND$1 = 38;
const name$l = "NestingSelector";
const structure$l = {};
function parse$m() {
  const start = this.tokenStart;
  this.eatDelim(AMPERSAND$1);
  return {
    type: "NestingSelector",
    loc: this.getLocation(start, this.tokenStart)
  };
}
function generate$m() {
  this.token(Delim, "&");
}
var NestingSelector = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$m,
  name: name$l,
  parse: parse$m,
  structure: structure$l
});
const name$k = "Nth";
const structure$k = {
  nth: ["AnPlusB", "Identifier"],
  selector: ["SelectorList", null]
};
function parse$l() {
  this.skipSC();
  const start = this.tokenStart;
  let end = start;
  let selector2 = null;
  let nth2;
  if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
    nth2 = this.Identifier();
  } else {
    nth2 = this.AnPlusB();
  }
  end = this.tokenStart;
  this.skipSC();
  if (this.lookupValue(0, "of")) {
    this.next();
    selector2 = this.SelectorList();
    end = this.tokenStart;
  }
  return {
    type: "Nth",
    loc: this.getLocation(start, end),
    nth: nth2,
    selector: selector2
  };
}
function generate$l(node2) {
  this.node(node2.nth);
  if (node2.selector !== null) {
    this.token(Ident, "of");
    this.node(node2.selector);
  }
}
var Nth = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$l,
  name: name$k,
  parse: parse$l,
  structure: structure$k
});
const name$j = "Number";
const structure$j = {
  value: String
};
function parse$k() {
  return {
    type: "Number",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consume(Number$2)
  };
}
function generate$k(node2) {
  this.token(Number$2, node2.value);
}
var Number$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$k,
  name: name$j,
  parse: parse$k,
  structure: structure$j
});
const name$i = "Operator";
const structure$i = {
  value: String
};
function parse$j() {
  const start = this.tokenStart;
  this.next();
  return {
    type: "Operator",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate$j(node2) {
  this.tokenize(node2.value);
}
var Operator = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$j,
  name: name$i,
  parse: parse$j,
  structure: structure$i
});
const name$h = "Parentheses";
const structure$h = {
  children: [[]]
};
function parse$i(readSequence2, recognizer) {
  const start = this.tokenStart;
  let children = null;
  this.eat(LeftParenthesis);
  children = readSequence2.call(this, recognizer);
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "Parentheses",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$i(node2) {
  this.token(LeftParenthesis, "(");
  this.children(node2);
  this.token(RightParenthesis, ")");
}
var Parentheses = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$i,
  name: name$h,
  parse: parse$i,
  structure: structure$h
});
const name$g = "Percentage";
const structure$g = {
  value: String
};
function parse$h() {
  return {
    type: "Percentage",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: this.consumeNumber(Percentage$1)
  };
}
function generate$h(node2) {
  this.token(Percentage$1, node2.value + "%");
}
var Percentage = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$h,
  name: name$g,
  parse: parse$h,
  structure: structure$g
});
const name$f = "PseudoClassSelector";
const walkContext$4 = "function";
const structure$f = {
  name: String,
  children: [["Raw"], null]
};
function parse$g() {
  const start = this.tokenStart;
  let children = null;
  let name2;
  let nameLowerCase;
  this.eat(Colon);
  if (this.tokenType === Function$2) {
    name2 = this.consumeFunctionName();
    nameLowerCase = name2.toLowerCase();
    if (this.lookupNonWSType(0) == RightParenthesis) {
      children = this.createList();
    } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name2 = this.consume(Ident);
  }
  return {
    type: "PseudoClassSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    children
  };
}
function generate$g(node2) {
  this.token(Colon, ":");
  if (node2.children === null) {
    this.token(Ident, node2.name);
  } else {
    this.token(Function$2, node2.name + "(");
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
}
var PseudoClassSelector = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$g,
  name: name$f,
  parse: parse$g,
  structure: structure$f,
  walkContext: walkContext$4
});
const name$e = "PseudoElementSelector";
const walkContext$3 = "function";
const structure$e = {
  name: String,
  children: [["Raw"], null]
};
function parse$f() {
  const start = this.tokenStart;
  let children = null;
  let name2;
  let nameLowerCase;
  this.eat(Colon);
  this.eat(Colon);
  if (this.tokenType === Function$2) {
    name2 = this.consumeFunctionName();
    nameLowerCase = name2.toLowerCase();
    if (this.lookupNonWSType(0) == RightParenthesis) {
      children = this.createList();
    } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
      this.skipSC();
      children = this.pseudo[nameLowerCase].call(this);
      this.skipSC();
    } else {
      children = this.createList();
      children.push(
        this.Raw(null, false)
      );
    }
    this.eat(RightParenthesis);
  } else {
    name2 = this.consume(Ident);
  }
  return {
    type: "PseudoElementSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: name2,
    children
  };
}
function generate$f(node2) {
  this.token(Colon, ":");
  this.token(Colon, ":");
  if (node2.children === null) {
    this.token(Ident, node2.name);
  } else {
    this.token(Function$2, node2.name + "(");
    this.children(node2);
    this.token(RightParenthesis, ")");
  }
}
var PseudoElementSelector = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$f,
  name: name$e,
  parse: parse$f,
  structure: structure$e,
  walkContext: walkContext$3
});
const SOLIDUS$2 = 47;
function consumeTerm() {
  this.skipSC();
  switch (this.tokenType) {
    case Number$2:
      return this.Number();
    case Function$2:
      return this.Function(this.readSequence, this.scope.Value);
    default:
      this.error("Number of function is expected");
  }
}
const name$d = "Ratio";
const structure$d = {
  left: ["Number", "Function"],
  right: ["Number", "Function", null]
};
function parse$e() {
  const start = this.tokenStart;
  const left = consumeTerm.call(this);
  let right = null;
  this.skipSC();
  if (this.isDelim(SOLIDUS$2)) {
    this.eatDelim(SOLIDUS$2);
    right = consumeTerm.call(this);
  }
  return {
    type: "Ratio",
    loc: this.getLocation(start, this.tokenStart),
    left,
    right
  };
}
function generate$e(node2) {
  this.node(node2.left);
  this.token(Delim, "/");
  if (node2.right) {
    this.node(node2.right);
  } else {
    this.node(Number$2, 1);
  }
}
var Ratio = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$e,
  name: name$d,
  parse: parse$e,
  structure: structure$d
});
function getOffsetExcludeWS() {
  if (this.tokenIndex > 0) {
    if (this.lookupType(-1) === WhiteSpace$1) {
      return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
    }
  }
  return this.tokenStart;
}
const name$c = "Raw";
const structure$c = {
  value: String
};
function parse$d(consumeUntil, excludeWhiteSpace) {
  const startOffset = this.getTokenStart(this.tokenIndex);
  let endOffset;
  this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);
  if (excludeWhiteSpace && this.tokenStart > startOffset) {
    endOffset = getOffsetExcludeWS.call(this);
  } else {
    endOffset = this.tokenStart;
  }
  return {
    type: "Raw",
    loc: this.getLocation(startOffset, endOffset),
    value: this.substring(startOffset, endOffset)
  };
}
function generate$d(node2) {
  this.tokenize(node2.value);
}
var Raw = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$d,
  name: name$c,
  parse: parse$d,
  structure: structure$c
});
function consumeRaw$1() {
  return this.Raw(this.consumeUntilLeftCurlyBracket, true);
}
function consumePrelude() {
  const prelude = this.SelectorList();
  if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket) {
    this.error();
  }
  return prelude;
}
const name$b = "Rule";
const walkContext$2 = "rule";
const structure$b = {
  prelude: ["SelectorList", "Raw"],
  block: ["Block"]
};
function parse$c() {
  const startToken = this.tokenIndex;
  const startOffset = this.tokenStart;
  let prelude;
  let block;
  if (this.parseRulePrelude) {
    prelude = this.parseWithFallback(consumePrelude, consumeRaw$1);
  } else {
    prelude = consumeRaw$1.call(this, startToken);
  }
  block = this.Block(true);
  return {
    type: "Rule",
    loc: this.getLocation(startOffset, this.tokenStart),
    prelude,
    block
  };
}
function generate$c(node2) {
  this.node(node2.prelude);
  this.node(node2.block);
}
var Rule = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$c,
  name: name$b,
  parse: parse$c,
  structure: structure$b,
  walkContext: walkContext$2
});
const name$a = "Scope";
const structure$a = {
  root: ["SelectorList", "Raw", null],
  limit: ["SelectorList", "Raw", null]
};
function parse$b() {
  let root2 = null;
  let limit = null;
  this.skipSC();
  const startOffset = this.tokenStart;
  if (this.tokenType === LeftParenthesis) {
    this.next();
    this.skipSC();
    root2 = this.parseWithFallback(
      this.SelectorList,
      () => this.Raw(false, true)
    );
    this.skipSC();
    this.eat(RightParenthesis);
  }
  if (this.lookupNonWSType(0) === Ident) {
    this.skipSC();
    this.eatIdent("to");
    this.skipSC();
    this.eat(LeftParenthesis);
    this.skipSC();
    limit = this.parseWithFallback(
      this.SelectorList,
      () => this.Raw(false, true)
    );
    this.skipSC();
    this.eat(RightParenthesis);
  }
  return {
    type: "Scope",
    loc: this.getLocation(startOffset, this.tokenStart),
    root: root2,
    limit
  };
}
function generate$b(node2) {
  if (node2.root) {
    this.token(LeftParenthesis, "(");
    this.node(node2.root);
    this.token(RightParenthesis, ")");
  }
  if (node2.limit) {
    this.token(Ident, "to");
    this.token(LeftParenthesis, "(");
    this.node(node2.limit);
    this.token(RightParenthesis, ")");
  }
}
var Scope = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$b,
  name: name$a,
  parse: parse$b,
  structure: structure$a
});
const name$9 = "Selector";
const structure$9 = {
  children: [[
    "TypeSelector",
    "IdSelector",
    "ClassSelector",
    "AttributeSelector",
    "PseudoClassSelector",
    "PseudoElementSelector",
    "Combinator"
  ]]
};
function parse$a() {
  const children = this.readSequence(this.scope.Selector);
  if (this.getFirstListNode(children) === null) {
    this.error("Selector is expected");
  }
  return {
    type: "Selector",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$a(node2) {
  this.children(node2);
}
var Selector = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$a,
  name: name$9,
  parse: parse$a,
  structure: structure$9
});
const name$8 = "SelectorList";
const walkContext$1 = "selector";
const structure$8 = {
  children: [[
    "Selector",
    "Raw"
  ]]
};
function parse$9() {
  const children = this.createList();
  while (!this.eof) {
    children.push(this.Selector());
    if (this.tokenType === Comma) {
      this.next();
      continue;
    }
    break;
  }
  return {
    type: "SelectorList",
    loc: this.getLocationFromList(children),
    children
  };
}
function generate$9(node2) {
  this.children(node2, () => this.token(Comma, ","));
}
var SelectorList = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$9,
  name: name$8,
  parse: parse$9,
  structure: structure$8,
  walkContext: walkContext$1
});
const REVERSE_SOLIDUS$1 = 92;
const QUOTATION_MARK$1 = 34;
const APOSTROPHE$1 = 39;
function decode$1(str) {
  const len = str.length;
  const firstChar = str.charCodeAt(0);
  const start = firstChar === QUOTATION_MARK$1 || firstChar === APOSTROPHE$1 ? 1 : 0;
  const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
  let decoded = "";
  for (let i2 = start; i2 <= end; i2++) {
    let code2 = str.charCodeAt(i2);
    if (code2 === REVERSE_SOLIDUS$1) {
      if (i2 === end) {
        if (i2 !== len - 1) {
          decoded = str.substr(i2 + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i2);
      if (isValidEscape(REVERSE_SOLIDUS$1, code2)) {
        const escapeStart = i2 - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i2 = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i2 + 1) === 10) {
          i2++;
        }
      }
    } else {
      decoded += str[i2];
    }
  }
  return decoded;
}
function encode$1(str, apostrophe) {
  const quote = '"';
  const quoteCode = QUOTATION_MARK$1;
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i2 = 0; i2 < str.length; i2++) {
    const code2 = str.charCodeAt(i2);
    if (code2 === 0) {
      encoded += "";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === quoteCode || code2 === REVERSE_SOLIDUS$1) {
      encoded += "\\" + str.charAt(i2);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && (isHexDigit(code2) || isWhiteSpace(code2))) {
        encoded += " ";
      }
      encoded += str.charAt(i2);
      wsBeforeHexIsNeeded = false;
    }
  }
  return quote + encoded + quote;
}
const name$7 = "String";
const structure$7 = {
  value: String
};
function parse$8() {
  return {
    type: "String",
    loc: this.getLocation(this.tokenStart, this.tokenEnd),
    value: decode$1(this.consume(String$2))
  };
}
function generate$8(node2) {
  this.token(String$2, encode$1(node2.value));
}
var String$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$8,
  name: name$7,
  parse: parse$8,
  structure: structure$7
});
const EXCLAMATIONMARK = 33;
function consumeRaw() {
  return this.Raw(null, false);
}
const name$6 = "StyleSheet";
const walkContext = "stylesheet";
const structure$6 = {
  children: [[
    "Comment",
    "CDO",
    "CDC",
    "Atrule",
    "Rule",
    "Raw"
  ]]
};
function parse$7() {
  const start = this.tokenStart;
  const children = this.createList();
  let child;
  while (!this.eof) {
    switch (this.tokenType) {
      case WhiteSpace$1:
        this.next();
        continue;
      case Comment$1:
        if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
          this.next();
          continue;
        }
        child = this.Comment();
        break;
      case CDO$1:
        child = this.CDO();
        break;
      case CDC$1:
        child = this.CDC();
        break;
      case AtKeyword:
        child = this.parseWithFallback(this.Atrule, consumeRaw);
        break;
      default:
        child = this.parseWithFallback(this.Rule, consumeRaw);
    }
    children.push(child);
  }
  return {
    type: "StyleSheet",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$7(node2) {
  this.children(node2);
}
var StyleSheet = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$7,
  name: name$6,
  parse: parse$7,
  structure: structure$6,
  walkContext
});
const name$5 = "SupportsDeclaration";
const structure$5 = {
  declaration: "Declaration"
};
function parse$6() {
  const start = this.tokenStart;
  this.eat(LeftParenthesis);
  this.skipSC();
  const declaration = this.Declaration();
  if (!this.eof) {
    this.eat(RightParenthesis);
  }
  return {
    type: "SupportsDeclaration",
    loc: this.getLocation(start, this.tokenStart),
    declaration
  };
}
function generate$6(node2) {
  this.token(LeftParenthesis, "(");
  this.node(node2.declaration);
  this.token(RightParenthesis, ")");
}
var SupportsDeclaration = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$6,
  name: name$5,
  parse: parse$6,
  structure: structure$5
});
const ASTERISK$2 = 42;
const VERTICALLINE$1 = 124;
function eatIdentifierOrAsterisk() {
  if (this.tokenType !== Ident && this.isDelim(ASTERISK$2) === false) {
    this.error("Identifier or asterisk is expected");
  }
  this.next();
}
const name$4 = "TypeSelector";
const structure$4 = {
  name: String
};
function parse$5() {
  const start = this.tokenStart;
  if (this.isDelim(VERTICALLINE$1)) {
    this.next();
    eatIdentifierOrAsterisk.call(this);
  } else {
    eatIdentifierOrAsterisk.call(this);
    if (this.isDelim(VERTICALLINE$1)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    }
  }
  return {
    type: "TypeSelector",
    loc: this.getLocation(start, this.tokenStart),
    name: this.substrToCursor(start)
  };
}
function generate$5(node2) {
  this.tokenize(node2.name);
}
var TypeSelector = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$5,
  name: name$4,
  parse: parse$5,
  structure: structure$4
});
const PLUSSIGN$2 = 43;
const HYPHENMINUS$1 = 45;
const QUESTIONMARK = 63;
function eatHexSequence(offset2, allowDash) {
  let len = 0;
  for (let pos = this.tokenStart + offset2; pos < this.tokenEnd; pos++) {
    const code2 = this.charCodeAt(pos);
    if (code2 === HYPHENMINUS$1 && allowDash && len !== 0) {
      eatHexSequence.call(this, offset2 + len + 1, false);
      return -1;
    }
    if (!isHexDigit(code2)) {
      this.error(
        allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
        pos
      );
    }
    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
  }
  this.next();
  return len;
}
function eatQuestionMarkSequence(max) {
  let count = 0;
  while (this.isDelim(QUESTIONMARK)) {
    if (++count > max) {
      this.error("Too many question marks");
    }
    this.next();
  }
}
function startsWith(code2) {
  if (this.charCodeAt(this.tokenStart) !== code2) {
    this.error((code2 === PLUSSIGN$2 ? "Plus sign" : "Hyphen minus") + " is expected");
  }
}
function scanUnicodeRange() {
  let hexLength = 0;
  switch (this.tokenType) {
    case Number$2:
      hexLength = eatHexSequence.call(this, 1, true);
      if (this.isDelim(QUESTIONMARK)) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
        break;
      }
      if (this.tokenType === Dimension$1 || this.tokenType === Number$2) {
        startsWith.call(this, HYPHENMINUS$1);
        eatHexSequence.call(this, 1, false);
        break;
      }
      break;
    case Dimension$1:
      hexLength = eatHexSequence.call(this, 1, true);
      if (hexLength > 0) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
      }
      break;
    default:
      this.eatDelim(PLUSSIGN$2);
      if (this.tokenType === Ident) {
        hexLength = eatHexSequence.call(this, 0, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        break;
      }
      if (this.isDelim(QUESTIONMARK)) {
        this.next();
        eatQuestionMarkSequence.call(this, 5);
        break;
      }
      this.error("Hex digit or question mark is expected");
  }
}
const name$3 = "UnicodeRange";
const structure$3 = {
  value: String
};
function parse$4() {
  const start = this.tokenStart;
  this.eatIdent("u");
  scanUnicodeRange.call(this);
  return {
    type: "UnicodeRange",
    loc: this.getLocation(start, this.tokenStart),
    value: this.substrToCursor(start)
  };
}
function generate$4(node2) {
  this.tokenize(node2.value);
}
var UnicodeRange = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$4,
  name: name$3,
  parse: parse$4,
  structure: structure$3
});
const SPACE$1 = 32;
const REVERSE_SOLIDUS = 92;
const QUOTATION_MARK = 34;
const APOSTROPHE = 39;
const LEFTPARENTHESIS = 40;
const RIGHTPARENTHESIS = 41;
function decode(str) {
  const len = str.length;
  let start = 4;
  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
  let decoded = "";
  while (start < end && isWhiteSpace(str.charCodeAt(start))) {
    start++;
  }
  while (start < end && isWhiteSpace(str.charCodeAt(end))) {
    end--;
  }
  for (let i2 = start; i2 <= end; i2++) {
    let code2 = str.charCodeAt(i2);
    if (code2 === REVERSE_SOLIDUS) {
      if (i2 === end) {
        if (i2 !== len - 1) {
          decoded = str.substr(i2 + 1);
        }
        break;
      }
      code2 = str.charCodeAt(++i2);
      if (isValidEscape(REVERSE_SOLIDUS, code2)) {
        const escapeStart = i2 - 1;
        const escapeEnd = consumeEscaped(str, escapeStart);
        i2 = escapeEnd - 1;
        decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
      } else {
        if (code2 === 13 && str.charCodeAt(i2 + 1) === 10) {
          i2++;
        }
      }
    } else {
      decoded += str[i2];
    }
  }
  return decoded;
}
function encode(str) {
  let encoded = "";
  let wsBeforeHexIsNeeded = false;
  for (let i2 = 0; i2 < str.length; i2++) {
    const code2 = str.charCodeAt(i2);
    if (code2 === 0) {
      encoded += "";
      continue;
    }
    if (code2 <= 31 || code2 === 127) {
      encoded += "\\" + code2.toString(16);
      wsBeforeHexIsNeeded = true;
      continue;
    }
    if (code2 === SPACE$1 || code2 === REVERSE_SOLIDUS || code2 === QUOTATION_MARK || code2 === APOSTROPHE || code2 === LEFTPARENTHESIS || code2 === RIGHTPARENTHESIS) {
      encoded += "\\" + str.charAt(i2);
      wsBeforeHexIsNeeded = false;
    } else {
      if (wsBeforeHexIsNeeded && isHexDigit(code2)) {
        encoded += " ";
      }
      encoded += str.charAt(i2);
      wsBeforeHexIsNeeded = false;
    }
  }
  return "url(" + encoded + ")";
}
const name$2 = "Url";
const structure$2 = {
  value: String
};
function parse$3() {
  const start = this.tokenStart;
  let value2;
  switch (this.tokenType) {
    case Url$1:
      value2 = decode(this.consume(Url$1));
      break;
    case Function$2:
      if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
        this.error("Function name must be `url`");
      }
      this.eat(Function$2);
      this.skipSC();
      value2 = decode$1(this.consume(String$2));
      this.skipSC();
      if (!this.eof) {
        this.eat(RightParenthesis);
      }
      break;
    default:
      this.error("Url or Function is expected");
  }
  return {
    type: "Url",
    loc: this.getLocation(start, this.tokenStart),
    value: value2
  };
}
function generate$3(node2) {
  this.token(Url$1, encode(node2.value));
}
var Url = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$3,
  name: name$2,
  parse: parse$3,
  structure: structure$2
});
const name$1 = "Value";
const structure$1 = {
  children: [[]]
};
function parse$2() {
  const start = this.tokenStart;
  const children = this.readSequence(this.scope.Value);
  return {
    type: "Value",
    loc: this.getLocation(start, this.tokenStart),
    children
  };
}
function generate$2(node2) {
  this.children(node2);
}
var Value = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$2,
  name: name$1,
  parse: parse$2,
  structure: structure$1
});
const SPACE = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " "
});
const name = "WhiteSpace";
const structure = {
  value: String
};
function parse$1() {
  this.eat(WhiteSpace$1);
  return SPACE;
}
function generate$1(node2) {
  this.token(WhiteSpace$1, node2.value);
}
var WhiteSpace = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  generate: generate$1,
  name,
  parse: parse$1,
  structure
});
var node$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AnPlusB,
  Atrule,
  AtrulePrelude,
  AttributeSelector,
  Block,
  Brackets,
  CDC,
  CDO,
  ClassSelector,
  Combinator,
  Comment,
  Condition,
  Declaration,
  DeclarationList,
  Dimension,
  Feature,
  FeatureFunction,
  FeatureRange,
  Function: Function$1,
  GeneralEnclosed,
  Hash,
  IdSelector,
  Identifier,
  Layer,
  LayerList,
  MediaQuery,
  MediaQueryList,
  NestingSelector,
  Nth,
  Number: Number$1,
  Operator,
  Parentheses,
  Percentage,
  PseudoClassSelector,
  PseudoElementSelector,
  Ratio,
  Raw,
  Rule,
  Scope,
  Selector,
  SelectorList,
  String: String$1,
  StyleSheet,
  SupportsDeclaration,
  TypeSelector,
  UnicodeRange,
  Url,
  Value,
  WhiteSpace
});
var lexerConfig = {
  generic: true,
  cssWideKeywords,
  ...definitions,
  node: node$1
};
const NUMBERSIGN$1 = 35;
const ASTERISK$1 = 42;
const PLUSSIGN$1 = 43;
const HYPHENMINUS = 45;
const SOLIDUS$1 = 47;
const U = 117;
function defaultRecognizer(context2) {
  switch (this.tokenType) {
    case Hash$1:
      return this.Hash();
    case Comma:
      return this.Operator();
    case LeftParenthesis:
      return this.Parentheses(this.readSequence, context2.recognizer);
    case LeftSquareBracket:
      return this.Brackets(this.readSequence, context2.recognizer);
    case String$2:
      return this.String();
    case Dimension$1:
      return this.Dimension();
    case Percentage$1:
      return this.Percentage();
    case Number$2:
      return this.Number();
    case Function$2:
      return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context2.recognizer);
    case Url$1:
      return this.Url();
    case Ident:
      if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN$1)) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      if (code2 === SOLIDUS$1 || code2 === ASTERISK$1 || code2 === PLUSSIGN$1 || code2 === HYPHENMINUS) {
        return this.Operator();
      }
      if (code2 === NUMBERSIGN$1) {
        this.error("Hex or identifier is expected", this.tokenStart + 1);
      }
      break;
    }
  }
}
var atrulePrelude = {
  getNode: defaultRecognizer
};
const NUMBERSIGN = 35;
const AMPERSAND = 38;
const ASTERISK = 42;
const PLUSSIGN = 43;
const SOLIDUS = 47;
const FULLSTOP = 46;
const GREATERTHANSIGN = 62;
const VERTICALLINE = 124;
const TILDE = 126;
function onWhiteSpace(next2, children) {
  if (children.last !== null && children.last.type !== "Combinator" && next2 !== null && next2.type !== "Combinator") {
    children.push({
      // FIXME: this.Combinator() should be used instead
      type: "Combinator",
      loc: null,
      name: " "
    });
  }
}
function getNode() {
  switch (this.tokenType) {
    case LeftSquareBracket:
      return this.AttributeSelector();
    case Hash$1:
      return this.IdSelector();
    case Colon:
      if (this.lookupType(1) === Colon) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }
    case Ident:
      return this.TypeSelector();
    case Number$2:
    case Percentage$1:
      return this.Percentage();
    case Dimension$1:
      if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
        this.error("Identifier is expected", this.tokenStart + 1);
      }
      break;
    case Delim: {
      const code2 = this.charCodeAt(this.tokenStart);
      switch (code2) {
        case PLUSSIGN:
        case GREATERTHANSIGN:
        case TILDE:
        case SOLIDUS:
          return this.Combinator();
        case FULLSTOP:
          return this.ClassSelector();
        case ASTERISK:
        case VERTICALLINE:
          return this.TypeSelector();
        case NUMBERSIGN:
          return this.IdSelector();
        case AMPERSAND:
          return this.NestingSelector();
      }
      break;
    }
  }
}
var selector$1 = {
  onWhiteSpace,
  getNode
};
function expressionFn() {
  return this.createSingleNodeList(
    this.Raw(null, false)
  );
}
function varFn() {
  const children = this.createList();
  this.skipSC();
  children.push(this.Identifier());
  this.skipSC();
  if (this.tokenType === Comma) {
    children.push(this.Operator());
    const startIndex = this.tokenIndex;
    const value2 = this.parseCustomProperty ? this.Value(null) : this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);
    if (value2.type === "Value" && value2.children.isEmpty) {
      for (let offset2 = startIndex - this.tokenIndex; offset2 <= 0; offset2++) {
        if (this.lookupType(offset2) === WhiteSpace$1) {
          value2.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    children.push(value2);
  }
  return children;
}
function isPlusMinusOperator(node2) {
  return node2 !== null && node2.type === "Operator" && (node2.value[node2.value.length - 1] === "-" || node2.value[node2.value.length - 1] === "+");
}
var value = {
  getNode: defaultRecognizer,
  onWhiteSpace(next2, children) {
    if (isPlusMinusOperator(next2)) {
      next2.value = " " + next2.value;
    }
    if (isPlusMinusOperator(children.last)) {
      children.last.value += " ";
    }
  },
  "expression": expressionFn,
  "var": varFn
};
var scope$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AtrulePrelude: atrulePrelude,
  Selector: selector$1,
  Value: value
});
const nonContainerNameKeywords = /* @__PURE__ */ new Set(["none", "and", "not", "or"]);
var container = {
  parse: {
    prelude() {
      const children = this.createList();
      if (this.tokenType === Ident) {
        const name2 = this.substring(this.tokenStart, this.tokenEnd);
        if (!nonContainerNameKeywords.has(name2.toLowerCase())) {
          children.push(this.Identifier());
        }
      }
      children.push(this.Condition("container"));
      return children;
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
var fontFace = {
  parse: {
    prelude: null,
    block() {
      return this.Block(true);
    }
  }
};
function parseWithFallback(parse4, fallback) {
  return this.parseWithFallback(
    () => {
      try {
        return parse4.call(this);
      } finally {
        this.skipSC();
        if (this.lookupNonWSType(0) !== RightParenthesis) {
          this.error();
        }
      }
    },
    fallback || (() => this.Raw(null, true))
  );
}
const parseFunctions = {
  layer() {
    this.skipSC();
    const children = this.createList();
    const node2 = parseWithFallback.call(this, this.Layer);
    if (node2.type !== "Raw" || node2.value !== "") {
      children.push(node2);
    }
    return children;
  },
  supports() {
    this.skipSC();
    const children = this.createList();
    const node2 = parseWithFallback.call(
      this,
      this.Declaration,
      () => parseWithFallback.call(this, () => this.Condition("supports"))
    );
    if (node2.type !== "Raw" || node2.value !== "") {
      children.push(node2);
    }
    return children;
  }
};
var importAtrule = {
  parse: {
    prelude() {
      const children = this.createList();
      switch (this.tokenType) {
        case String$2:
          children.push(this.String());
          break;
        case Url$1:
        case Function$2:
          children.push(this.Url());
          break;
        default:
          this.error("String or url() is expected");
      }
      this.skipSC();
      if (this.tokenType === Ident && this.cmpStr(this.tokenStart, this.tokenEnd, "layer")) {
        children.push(this.Identifier());
      } else if (this.tokenType === Function$2 && this.cmpStr(this.tokenStart, this.tokenEnd, "layer(")) {
        children.push(this.Function(null, parseFunctions));
      }
      this.skipSC();
      if (this.tokenType === Function$2 && this.cmpStr(this.tokenStart, this.tokenEnd, "supports(")) {
        children.push(this.Function(null, parseFunctions));
      }
      if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis) {
        children.push(this.MediaQueryList());
      }
      return children;
    },
    block: null
  }
};
var layer = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.LayerList()
      );
    },
    block() {
      return this.Block(false);
    }
  }
};
var media = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.MediaQueryList()
      );
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
var nest = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};
var page = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block() {
      return this.Block(true);
    }
  }
};
var scope = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.Scope()
      );
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
var startingStyle = {
  parse: {
    prelude: null,
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
var supports = {
  parse: {
    prelude() {
      return this.createSingleNodeList(
        this.Condition("supports")
      );
    },
    block(nested = false) {
      return this.Block(nested);
    }
  }
};
var atrule = {
  container,
  "font-face": fontFace,
  import: importAtrule,
  layer,
  media,
  nest,
  page,
  scope,
  "starting-style": startingStyle,
  supports
};
function parseLanguageRangeList() {
  const children = this.createList();
  this.skipSC();
  loop: while (!this.eof) {
    switch (this.tokenType) {
      case Ident:
        children.push(this.Identifier());
        break;
      case String$2:
        children.push(this.String());
        break;
      case Comma:
        children.push(this.Operator());
        break;
      case RightParenthesis:
        break loop;
      default:
        this.error("Identifier, string or comma is expected");
    }
    this.skipSC();
  }
  return children;
}
const selectorList = {
  parse() {
    return this.createSingleNodeList(
      this.SelectorList()
    );
  }
};
const selector = {
  parse() {
    return this.createSingleNodeList(
      this.Selector()
    );
  }
};
const identList = {
  parse() {
    return this.createSingleNodeList(
      this.Identifier()
    );
  }
};
const langList = {
  parse: parseLanguageRangeList
};
const nth = {
  parse() {
    return this.createSingleNodeList(
      this.Nth()
    );
  }
};
var pseudo = {
  "dir": identList,
  "has": selectorList,
  "lang": langList,
  "matches": selectorList,
  "is": selectorList,
  "-moz-any": selectorList,
  "-webkit-any": selectorList,
  "where": selectorList,
  "not": selectorList,
  "nth-child": nth,
  "nth-last-child": nth,
  "nth-last-of-type": nth,
  "nth-of-type": nth,
  "slotted": selector,
  "host": selector,
  "host-context": selector
};
var node = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AnPlusB: parse$N,
  Atrule: parse$M,
  AtrulePrelude: parse$L,
  AttributeSelector: parse$K,
  Block: parse$J,
  Brackets: parse$I,
  CDC: parse$H,
  CDO: parse$G,
  ClassSelector: parse$F,
  Combinator: parse$E,
  Comment: parse$D,
  Condition: parse$C,
  Declaration: parse$B,
  DeclarationList: parse$A,
  Dimension: parse$z,
  Feature: parse$y,
  FeatureFunction: parse$x,
  FeatureRange: parse$w,
  Function: parse$v,
  GeneralEnclosed: parse$u,
  Hash: parse$t,
  IdSelector: parse$r,
  Identifier: parse$s,
  Layer: parse$q,
  LayerList: parse$p,
  MediaQuery: parse$o,
  MediaQueryList: parse$n,
  NestingSelector: parse$m,
  Nth: parse$l,
  Number: parse$k,
  Operator: parse$j,
  Parentheses: parse$i,
  Percentage: parse$h,
  PseudoClassSelector: parse$g,
  PseudoElementSelector: parse$f,
  Ratio: parse$e,
  Raw: parse$d,
  Rule: parse$c,
  Scope: parse$b,
  Selector: parse$a,
  SelectorList: parse$9,
  String: parse$8,
  StyleSheet: parse$7,
  SupportsDeclaration: parse$6,
  TypeSelector: parse$5,
  UnicodeRange: parse$4,
  Url: parse$3,
  Value: parse$2,
  WhiteSpace: parse$1
});
var parserConfig = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude(options2) {
      return this.AtrulePrelude(options2.atrule ? String(options2.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    condition(options2) {
      return this.Condition(options2.kind);
    },
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value"
  },
  features: {
    supports: {
      selector() {
        return this.Selector();
      }
    },
    container: {
      style() {
        return this.Declaration();
      }
    }
  },
  scope: scope$1,
  atrule,
  pseudo,
  node
};
var walkerConfig = {
  node: node$1
};
var syntax = createSyntax$1({
  ...lexerConfig,
  ...parserConfig,
  ...walkerConfig
});
const {
  tokenize,
  parse,
  generate,
  lexer,
  createLexer,
  walk,
  find,
  findLast,
  findAll,
  toPlainObject,
  fromPlainObject,
  fork
} = syntax;
function transformEsmToCjsSimple(code2) {
  try {
    return transformEsmToCjsAst$1(code2);
  } catch {
    return transformEsmToCjsRegex(code2);
  }
}
function transformEsmToCjsAst$1(code2) {
  const ast = parse3(code2, { ecmaVersion: "latest", sourceType: "module" });
  const replacements = [];
  for (const node2 of ast.body) {
    if (node2.type === "ImportDeclaration") {
      const source = node2.source.value;
      const specs = node2.specifiers;
      if (specs.length === 0) {
        replacements.push([node2.start, node2.end, `require(${JSON.stringify(source)})`]);
      } else {
        const defaultSpec = specs.find((s2) => s2.type === "ImportDefaultSpecifier");
        const nsSpec = specs.find((s2) => s2.type === "ImportNamespaceSpecifier");
        const namedSpecs = specs.filter((s2) => s2.type === "ImportSpecifier");
        const parts = [];
        if (defaultSpec) {
          parts.push(`const ${defaultSpec.local.name} = require(${JSON.stringify(source)})`);
        }
        if (nsSpec) {
          parts.push(`const ${nsSpec.local.name} = require(${JSON.stringify(source)})`);
        }
        if (namedSpecs.length > 0) {
          const bindings = namedSpecs.map((s2) => {
            if (s2.imported.name === s2.local.name) return s2.local.name;
            return `${s2.imported.name}: ${s2.local.name}`;
          }).join(", ");
          if (defaultSpec) {
            parts.push(`const { ${bindings} } = require(${JSON.stringify(source)})`);
          } else {
            parts.push(`const { ${bindings} } = require(${JSON.stringify(source)})`);
          }
        }
        replacements.push([node2.start, node2.end, parts.join(";\n")]);
      }
    } else if (node2.type === "ExportDefaultDeclaration") {
      const decl = node2.declaration;
      if (decl.type === "FunctionDeclaration") {
        const funcCode = code2.slice(decl.start, node2.end);
        replacements.push([node2.start, node2.end, `module.exports = ${funcCode}`]);
      } else if (decl.type === "ClassDeclaration") {
        const classCode = code2.slice(decl.start, node2.end);
        replacements.push([node2.start, node2.end, `module.exports = ${classCode}`]);
      } else {
        const exprCode = code2.slice(decl.start, node2.end);
        replacements.push([node2.start, node2.end, `module.exports = ${exprCode}`]);
      }
    } else if (node2.type === "ExportNamedDeclaration") {
      if (node2.declaration) {
        const decl = node2.declaration;
        if (decl.type === "FunctionDeclaration") {
          const name2 = decl.id.name;
          const funcCode = code2.slice(decl.start, node2.end);
          replacements.push([node2.start, node2.end, `exports.${name2} = ${funcCode}`]);
        } else if (decl.type === "ClassDeclaration") {
          const name2 = decl.id.name;
          const classCode = code2.slice(decl.start, node2.end);
          replacements.push([node2.start, node2.end, `exports.${name2} = ${classCode}`]);
        } else if (decl.type === "VariableDeclaration") {
          const parts = [];
          for (const declarator of decl.declarations) {
            const name2 = declarator.id.name;
            const initCode = declarator.init ? code2.slice(declarator.init.start, declarator.init.end) : "undefined";
            parts.push(`exports.${name2} = ${initCode}`);
          }
          replacements.push([node2.start, node2.end, parts.join(";\n")]);
        }
      } else if (node2.source) {
        const source = node2.source.value;
        const parts = [];
        const tmpVar = `__reexport_${node2.start}`;
        parts.push(`const ${tmpVar} = require(${JSON.stringify(source)})`);
        for (const spec2 of node2.specifiers) {
          parts.push(`exports.${spec2.exported.name} = ${tmpVar}.${spec2.local.name}`);
        }
        replacements.push([node2.start, node2.end, parts.join(";\n")]);
      } else {
        const parts = [];
        for (const spec2 of node2.specifiers) {
          parts.push(`exports.${spec2.exported.name} = ${spec2.local.name}`);
        }
        replacements.push([node2.start, node2.end, parts.join(";\n")]);
      }
    } else if (node2.type === "ExportAllDeclaration") {
      const source = node2.source.value;
      replacements.push([node2.start, node2.end, `Object.assign(exports, require(${JSON.stringify(source)}))`]);
    }
  }
  let result = code2;
  replacements.sort((a, b) => b[0] - a[0]);
  for (const [start, end, replacement] of replacements) {
    result = result.slice(0, start) + replacement + result.slice(end);
  }
  return result;
}
function transformEsmToCjsRegex(code2) {
  let transformed = code2;
  transformed = transformed.replace(
    /import\s+(\w+)\s+from\s+['"]([^'"]+)['"]/g,
    'const $1 = require("$2")'
  );
  transformed = transformed.replace(
    /import\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"]/g,
    'const {$1} = require("$2")'
  );
  transformed = transformed.replace(
    /export\s+default\s+function\s+(\w+)/g,
    "module.exports = function $1"
  );
  transformed = transformed.replace(
    /export\s+default\s+function\s*\(/g,
    "module.exports = function("
  );
  transformed = transformed.replace(
    /export\s+default\s+/g,
    "module.exports = "
  );
  transformed = transformed.replace(
    /export\s+async\s+function\s+(\w+)/g,
    "exports.$1 = async function $1"
  );
  transformed = transformed.replace(
    /export\s+function\s+(\w+)/g,
    "exports.$1 = function $1"
  );
  transformed = transformed.replace(
    /export\s+const\s+(\w+)\s*=/g,
    "exports.$1 ="
  );
  return transformed;
}
function walkAst(node2, callback) {
  if (!node2 || typeof node2 !== "object") return;
  if (typeof node2.type === "string") {
    callback(node2);
  }
  for (const key of Object.keys(node2)) {
    if (key === "type" || key === "start" || key === "end" || key === "loc" || key === "range") continue;
    const child = node2[key];
    if (child && typeof child === "object") {
      if (Array.isArray(child)) {
        for (const item of child) {
          if (item && typeof item === "object" && typeof item.type === "string") {
            walkAst(item, callback);
          }
        }
      } else if (typeof child.type === "string") {
        walkAst(child, callback);
      }
    }
  }
}
function transformDynamicImportsRegex(code2) {
  return code2.replace(new RegExp("(?<![.$\\w])import\\s*\\(", "g"), "__dynamicImport(");
}
function transformEsmToCjs(code2, filename2) {
  const maybeEsm = /\bimport\b|\bexport\b/.test(code2);
  if (!maybeEsm) return code2;
  try {
    return transformEsmToCjsAst(code2, filename2);
  } catch {
    return transformEsmToCjsRegexFallback(code2, filename2);
  }
}
function transformEsmToCjsAst(code2, filename2) {
  const ast = parse3(code2, { ecmaVersion: "latest", sourceType: "module" });
  const deepReplacements = [];
  walkAst(ast, (node2) => {
    var _a3, _b3;
    if (node2.type === "MetaProperty" && ((_a3 = node2.meta) == null ? void 0 : _a3.name) === "import" && ((_b3 = node2.property) == null ? void 0 : _b3.name) === "meta") {
      deepReplacements.push([node2.start, node2.end, "import_meta"]);
    }
    if (node2.type === "ImportExpression") {
      deepReplacements.push([node2.start, node2.start + 6, "__dynamicImport"]);
    }
  });
  const hasImportDecl = ast.body.some((n2) => n2.type === "ImportDeclaration");
  const hasExportDecl = ast.body.some((n2) => {
    var _a3;
    return (_a3 = n2.type) == null ? void 0 : _a3.startsWith("Export");
  });
  let transformed = code2;
  deepReplacements.sort((a, b) => b[0] - a[0]);
  for (const [start, end, replacement] of deepReplacements) {
    transformed = transformed.slice(0, start) + replacement + transformed.slice(end);
  }
  if (hasImportDecl || hasExportDecl) {
    transformed = transformEsmToCjsSimple(transformed);
    if (hasExportDecl) {
      transformed = 'Object.defineProperty(exports, "__esModule", { value: true });\n' + transformed;
    }
  }
  return transformed;
}
function transformEsmToCjsRegexFallback(code2, filename2) {
  let transformed = code2;
  transformed = transformed.replace(/\bimport\.meta\.url\b/g, `"file://${filename2}"`);
  transformed = transformed.replace(/\bimport\.meta\.dirname\b/g, `"${dirname(filename2)}"`);
  transformed = transformed.replace(/\bimport\.meta\.filename\b/g, `"${filename2}"`);
  transformed = transformed.replace(/\bimport\.meta\b/g, `({ url: "file://${filename2}", dirname: "${dirname(filename2)}", filename: "${filename2}" })`);
  transformed = transformDynamicImportsRegex(transformed);
  const hasImport = /\bimport\s+[\w{*'"]/m.test(code2);
  const hasExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code2);
  if (hasImport || hasExport) {
    transformed = transformEsmToCjsSimple(transformed);
    if (hasExport) {
      transformed = 'Object.defineProperty(exports, "__esModule", { value: true });\n' + transformed;
    }
  }
  return transformed;
}
function createDynamicImport(moduleRequire2) {
  return async (specifier) => {
    try {
      const mod = moduleRequire2(specifier);
      if (mod && typeof mod === "object" && ("default" in mod || "__esModule" in mod)) {
        return mod;
      }
      return {
        default: mod,
        ...mod && typeof mod === "object" ? mod : {}
      };
    } catch (error) {
      throw error;
    }
  };
}
function createStringDecoderModule() {
  class StringDecoder {
    constructor(encoding) {
      __publicField(this, "encoding");
      this.encoding = encoding || "utf8";
    }
    write(buffer) {
      return new TextDecoder(this.encoding).decode(buffer);
    }
    end(buffer) {
      if (buffer) return this.write(buffer);
      return "";
    }
  }
  return { StringDecoder };
}
function createTimersModule() {
  return {
    setTimeout: globalThis.setTimeout,
    setInterval: globalThis.setInterval,
    setImmediate: (fn2) => setTimeout(fn2, 0),
    clearTimeout: globalThis.clearTimeout,
    clearInterval: globalThis.clearInterval,
    clearImmediate: globalThis.clearTimeout
  };
}
const prettierShim = {
  format: (source, _options3) => Promise.resolve(source),
  formatWithCursor: (source, _options3) => Promise.resolve({ formatted: source, cursorOffset: 0 }),
  check: (_source, _options3) => Promise.resolve(true),
  resolveConfig: () => Promise.resolve(null),
  resolveConfigFile: () => Promise.resolve(null),
  clearConfigCache: () => {
  },
  getFileInfo: () => Promise.resolve({ ignored: false, inferredParser: null }),
  getSupportInfo: () => Promise.resolve({ languages: [], options: [] }),
  version: "3.0.0",
  doc: {
    builders: {},
    printer: {},
    utils: {}
  }
};
function makeMutable(mod) {
  const mutable = {};
  for (const key of Object.keys(mod)) {
    mutable[key] = mod[key];
  }
  return mutable;
}
const builtinModules = {
  path: pathShim,
  // Make http/https mutable so packages like Sentry can patch them
  http: makeMutable(httpShim),
  https: makeMutable(httpsShim),
  net: netShim,
  events,
  stream: Stream,
  buffer: bufferModule,
  url: urlShim,
  querystring: querystringShim,
  util: utilShim,
  tty: ttyShim,
  os: osShim,
  crypto: cryptoShim,
  zlib: zlibShim,
  dns: dnsShim,
  child_process: childProcessShim,
  assert,
  string_decoder: createStringDecoderModule(),
  timers: createTimersModule(),
  _http_common: {},
  _http_incoming: {},
  _http_outgoing: {},
  // New shims for Vite support
  chokidar: chokidarShim,
  ws: wsShim,
  fsevents: fseventsShim,
  readdirp: readdirpShim,
  module: moduleShim,
  perf_hooks: perfHooksShim,
  worker_threads: workerThreadsShim,
  esbuild: esbuildShim,
  rollup: rollupShim,
  v8: v8Shim,
  readline: readlineShim,
  tls: tlsShim,
  http2: http2Shim,
  cluster: clusterShim,
  dgram: dgramShim,
  vm: vmShim,
  inspector: inspectorShim,
  "inspector/promises": inspectorShim,
  async_hooks: asyncHooksShim,
  domain: domainShim,
  diagnostics_channel: diagnosticsChannelShim,
  // prettier uses createRequire which doesn't work in our runtime, so we shim it
  prettier: prettierShim,
  // Some packages explicitly require 'console' (with Console constructor)
  console: {
    ...console,
    Console: class Console {
      constructor(options2) {
        __publicField(this, "_stdout");
        __publicField(this, "_stderr");
        const opts = options2;
        if (opts && typeof opts === "object" && "write" in opts) {
          this._stdout = opts;
          this._stderr = arguments[1] || this._stdout;
        } else if (opts && typeof opts === "object" && "stdout" in opts) {
          this._stdout = opts.stdout || null;
          this._stderr = opts.stderr || this._stdout;
        } else {
          this._stdout = null;
          this._stderr = null;
        }
      }
      _write(stream, args) {
        const msg = args.map((a) => typeof a === "string" ? a : JSON.stringify(a)).join(" ") + "\n";
        const target = stream === "err" ? this._stderr : this._stdout;
        if (target) target.write(msg);
        else if (stream === "err") console.error(...args);
        else console.log(...args);
      }
      log(...args) {
        this._write("out", args);
      }
      error(...args) {
        this._write("err", args);
      }
      warn(...args) {
        this._write("err", args);
      }
      info(...args) {
        this._write("out", args);
      }
      debug(...args) {
        this._write("out", args);
      }
      trace(...args) {
        this._write("err", args);
      }
      dir(obj) {
        this._write("out", [obj]);
      }
      time(_label) {
      }
      timeEnd(_label) {
      }
      timeLog(_label) {
      }
      assert(value2, ...args) {
        if (!value2) this._write("err", ["Assertion failed:", ...args]);
      }
      clear() {
      }
      count(_label) {
      }
      countReset(_label) {
      }
      group(..._args) {
      }
      groupCollapsed(..._args) {
      }
      groupEnd() {
      }
      table(data2) {
        this._write("out", [data2]);
      }
    }
  },
  // util/types is accessed as a subpath
  "util/types": types$3,
  // path subpaths (our path shim is already POSIX-based)
  "path/posix": pathShim,
  "path/win32": win32,
  // timers subpaths
  "timers/promises": {
    setTimeout: (ms2) => new Promise((resolve2) => setTimeout(resolve2, ms2)),
    setInterval: globalThis.setInterval,
    setImmediate: (value2) => new Promise((resolve2) => setTimeout(() => resolve2(value2), 0)),
    scheduler: { wait: (ms2) => new Promise((resolve2) => setTimeout(resolve2, ms2)) }
  }
};
function createRequire(vfs, fsShim, process, currentDir, moduleCache, options, processedCodeCache) {
  const resolutionCache = /* @__PURE__ */ new Map();
  const packageJsonCache = /* @__PURE__ */ new Map();
  const getParsedPackageJson = (pkgPath) => {
    if (packageJsonCache.has(pkgPath)) {
      return packageJsonCache.get(pkgPath);
    }
    try {
      const content = vfs.readFileSync(pkgPath, "utf8");
      const parsed = JSON.parse(content);
      packageJsonCache.set(pkgPath, parsed);
      return parsed;
    } catch {
      packageJsonCache.set(pkgPath, null);
      return null;
    }
  };
  const resolveModule = (id2, fromDir) => {
    if (id2.startsWith("node:")) {
      id2 = id2.slice(5);
    }
    if (builtinModules[id2] || id2 === "fs" || id2 === "process" || id2 === "url" || id2 === "querystring" || id2 === "util") {
      return id2;
    }
    if (id2.startsWith("#")) {
      let searchDir2 = fromDir;
      while (searchDir2 !== "/") {
        const pkgPath = join$1(searchDir2, "package.json");
        const pkg = getParsedPackageJson(pkgPath);
        if (pkg == null ? void 0 : pkg.imports) {
          try {
            const resolved = f(pkg, id2, { require: true });
            if (resolved && resolved.length > 0) {
              const fullPath = join$1(searchDir2, resolved[0]);
              if (vfs.existsSync(fullPath)) return fullPath;
            }
          } catch {
          }
        }
        searchDir2 = dirname(searchDir2);
      }
      throw new Error(`Cannot find module '${id2}'`);
    }
    const cacheKey = `${fromDir}|${id2}`;
    const cached = resolutionCache.get(cacheKey);
    if (cached !== void 0) {
      if (cached === null) {
        throw new Error(`Cannot find module '${id2}'`);
      }
      return cached;
    }
    if (id2.startsWith("./") || id2.startsWith("../") || id2.startsWith("/")) {
      const resolved = id2.startsWith("/") ? id2 : resolve$2(fromDir, id2);
      if (vfs.existsSync(resolved)) {
        const stats = vfs.statSync(resolved);
        if (stats.isFile()) {
          resolutionCache.set(cacheKey, resolved);
          return resolved;
        }
        const indexPath = join$1(resolved, "index.js");
        if (vfs.existsSync(indexPath)) {
          resolutionCache.set(cacheKey, indexPath);
          return indexPath;
        }
      }
      const extensions = [".js", ".json"];
      for (const ext2 of extensions) {
        const withExt = resolved + ext2;
        if (vfs.existsSync(withExt)) {
          resolutionCache.set(cacheKey, withExt);
          return withExt;
        }
      }
      resolutionCache.set(cacheKey, null);
      throw new Error(`Cannot find module '${id2}' from '${fromDir}'`);
    }
    const tryResolveFile = (basePath) => {
      if (vfs.existsSync(basePath)) {
        const stats = vfs.statSync(basePath);
        if (stats.isFile()) {
          return basePath;
        }
        const indexPath = join$1(basePath, "index.js");
        if (vfs.existsSync(indexPath)) {
          return indexPath;
        }
      }
      const extensions = [".js", ".json", ".node"];
      for (const ext2 of extensions) {
        const withExt = basePath + ext2;
        if (vfs.existsSync(withExt)) {
          return withExt;
        }
      }
      return null;
    };
    const tryResolveFromNodeModules = (nodeModulesDir, moduleId) => {
      const parts = moduleId.split("/");
      const pkgName = parts[0].startsWith("@") && parts.length > 1 ? `${parts[0]}/${parts[1]}` : parts[0];
      const pkgRoot = join$1(nodeModulesDir, pkgName);
      const pkgPath = join$1(pkgRoot, "package.json");
      const pkg = getParsedPackageJson(pkgPath);
      if (pkg) {
        if (pkg.exports) {
          for (const conditions of [{ require: true }, { import: true }]) {
            try {
              const resolved2 = s(pkg, moduleId, conditions);
              if (resolved2 && resolved2.length > 0) {
                const exportPath = resolved2[0];
                const fullExportPath = join$1(pkgRoot, exportPath);
                const resolvedFile = tryResolveFile(fullExportPath);
                if (resolvedFile) {
                  if (resolvedFile.endsWith(".cjs")) {
                    try {
                      const content = vfs.readFileSync(resolvedFile, "utf8");
                      if (content.trimStart().startsWith("throw ")) {
                        continue;
                      }
                    } catch {
                    }
                  }
                  return resolvedFile;
                }
              }
            } catch {
            }
          }
        }
        if (pkgName === moduleId) {
          let main;
          if (typeof pkg.browser === "string") {
            main = pkg.browser;
          }
          if (!main && pkg.module) {
            main = pkg.module;
          }
          if (!main) {
            main = pkg.main || "index.js";
          }
          const mainPath = join$1(pkgRoot, main);
          const resolvedMain = tryResolveFile(mainPath);
          if (resolvedMain) return resolvedMain;
        }
      }
      const fullPath = join$1(nodeModulesDir, moduleId);
      const resolved = tryResolveFile(fullPath);
      if (resolved) return resolved;
      return null;
    };
    let searchDir = fromDir;
    while (searchDir !== "/") {
      const nodeModulesDir = join$1(searchDir, "node_modules");
      const resolved = tryResolveFromNodeModules(nodeModulesDir, id2);
      if (resolved) {
        resolutionCache.set(cacheKey, resolved);
        return resolved;
      }
      searchDir = dirname(searchDir);
    }
    const rootResolved = tryResolveFromNodeModules("/node_modules", id2);
    if (rootResolved) {
      resolutionCache.set(cacheKey, rootResolved);
      return rootResolved;
    }
    resolutionCache.set(cacheKey, null);
    throw new Error(`Cannot find module '${id2}'`);
  };
  const loadModule = (resolvedPath) => {
    if (moduleCache[resolvedPath]) {
      return moduleCache[resolvedPath];
    }
    const module = {
      id: resolvedPath,
      filename: resolvedPath,
      exports: {},
      loaded: false,
      children: [],
      paths: []
    };
    moduleCache[resolvedPath] = module;
    const cacheKeys = Object.keys(moduleCache);
    if (cacheKeys.length > 2e3) {
      delete moduleCache[cacheKeys[0]];
    }
    if (resolvedPath.endsWith(".json")) {
      const content = vfs.readFileSync(resolvedPath, "utf8");
      module.exports = JSON.parse(content);
      module.loaded = true;
      return module;
    }
    const rawCode = vfs.readFileSync(resolvedPath, "utf8");
    const dirname$1 = dirname(resolvedPath);
    const codeCacheKey = `${resolvedPath}|${simpleHash(rawCode)}`;
    let code = processedCodeCache == null ? void 0 : processedCodeCache.get(codeCacheKey);
    if (!code) {
      code = rawCode;
      if (code.startsWith("#!")) {
        code = code.slice(code.indexOf("\n") + 1);
      }
      if (!resolvedPath.endsWith(".cjs")) {
        code = transformEsmToCjs(code, resolvedPath);
      }
      processedCodeCache == null ? void 0 : processedCodeCache.set(codeCacheKey, code);
    }
    const moduleRequire = createRequire(
      vfs,
      fsShim,
      process,
      dirname$1,
      moduleCache,
      options,
      processedCodeCache
    );
    moduleRequire.cache = moduleCache;
    const consoleWrapper = createConsoleWrapper(options.onConsole);
    try {
      const importMetaUrl = "file://" + resolvedPath;
      const wrappedCode = `(function($exports, $require, $module, $filename, $dirname, $process, $console, $importMeta, $dynamicImport) {
var exports = $exports;
var require = $require;
var module = $module;
var __filename = $filename;
var __dirname = $dirname;
var process = $process;
var console = $console;
var import_meta = $importMeta;
var __dynamicImport = $dynamicImport;
// Set up global.process and globalThis.process for code that accesses them directly
var global = globalThis;
globalThis.process = $process;
global.process = $process;
return (function() {
${code}
}).call(this);
})`;
      let fn;
      try {
        fn = eval(wrappedCode);
      } catch (evalError) {
        const msg = evalError instanceof Error ? evalError.message : String(evalError);
        throw new SyntaxError(`${msg} (in ${resolvedPath})`);
      }
      const dynamicImport = createDynamicImport(moduleRequire);
      fn(
        module.exports,
        moduleRequire,
        module,
        resolvedPath,
        dirname$1,
        process,
        consoleWrapper,
        { url: importMetaUrl, dirname: dirname$1, filename: resolvedPath },
        dynamicImport
      );
      module.loaded = true;
    } catch (error) {
      delete moduleCache[resolvedPath];
      if (error instanceof Error && !error.message.includes("(in /")) {
        error.message = `${error.message} (in ${resolvedPath})`;
      }
      throw error;
    }
    return module;
  };
  const require = (id2) => {
    if (id2.startsWith("node:")) {
      id2 = id2.slice(5);
    }
    if (id2 === "fs") {
      return fsShim;
    }
    if (id2 === "fs/promises") {
      return fsShim.promises;
    }
    if (id2 === "process") {
      return process;
    }
    if (id2 === "module") {
      return {
        ...moduleShim,
        createRequire: (filenameOrUrl) => {
          let fromPath = filenameOrUrl;
          if (filenameOrUrl.startsWith("file://")) {
            fromPath = filenameOrUrl.slice(7);
            if (fromPath.startsWith("/") && fromPath[2] === ":") {
              fromPath = fromPath.slice(1);
            }
          }
          const fromDir = dirname(fromPath);
          const newRequire = createRequire(
            vfs,
            fsShim,
            process,
            fromDir,
            moduleCache,
            options
          );
          newRequire.cache = moduleCache;
          return newRequire;
        }
      };
    }
    if (builtinModules[id2]) {
      return builtinModules[id2];
    }
    if (id2 === "rollup" || id2.startsWith("rollup/") || id2.startsWith("@rollup/")) {
      console.log("[runtime] Intercepted rollup:", id2);
      return builtinModules["rollup"];
    }
    if (id2 === "esbuild" || id2.startsWith("esbuild/") || id2.startsWith("@esbuild/")) {
      console.log("[runtime] Intercepted esbuild:", id2);
      return builtinModules["esbuild"];
    }
    if (id2 === "prettier" || id2.startsWith("prettier/")) {
      return builtinModules["prettier"];
    }
    const resolved = resolveModule(id2, currentDir);
    if (builtinModules[resolved]) {
      return builtinModules[resolved];
    }
    if (resolved.includes("/node_modules/rollup/") || resolved.includes("/node_modules/@rollup/")) {
      return builtinModules["rollup"];
    }
    if (resolved.includes("/node_modules/esbuild/") || resolved.includes("/node_modules/@esbuild/")) {
      return builtinModules["esbuild"];
    }
    if (resolved.includes("/node_modules/prettier/")) {
      return builtinModules["prettier"];
    }
    return loadModule(resolved).exports;
  };
  require.resolve = (id2) => {
    if (id2 === "fs" || id2 === "process" || builtinModules[id2]) {
      return id2;
    }
    return resolveModule(id2, currentDir);
  };
  require.cache = moduleCache;
  return require;
}
function createConsoleWrapper(onConsole) {
  const wrapper = {
    log: (...args) => {
      console.log(...args);
      onConsole == null ? void 0 : onConsole("log", args);
    },
    error: (...args) => {
      console.error(...args);
      onConsole == null ? void 0 : onConsole("error", args);
    },
    warn: (...args) => {
      console.warn(...args);
      onConsole == null ? void 0 : onConsole("warn", args);
    },
    info: (...args) => {
      console.info(...args);
      onConsole == null ? void 0 : onConsole("info", args);
    },
    debug: (...args) => {
      console.debug(...args);
      onConsole == null ? void 0 : onConsole("debug", args);
    },
    trace: (...args) => {
      console.trace(...args);
      onConsole == null ? void 0 : onConsole("trace", args);
    },
    dir: (obj) => {
      console.dir(obj);
      onConsole == null ? void 0 : onConsole("dir", [obj]);
    },
    time: console.time.bind(console),
    timeEnd: console.timeEnd.bind(console),
    timeLog: console.timeLog.bind(console),
    assert: console.assert.bind(console),
    clear: console.clear.bind(console),
    count: console.count.bind(console),
    countReset: console.countReset.bind(console),
    group: console.group.bind(console),
    groupCollapsed: console.groupCollapsed.bind(console),
    groupEnd: console.groupEnd.bind(console),
    table: console.table.bind(console)
  };
  return wrapper;
}
class Runtime {
  constructor(vfs2, options2 = {}) {
    __publicField(this, "vfs");
    __publicField(this, "fsShim");
    __publicField(this, "process");
    __publicField(this, "moduleCache", {});
    __publicField(this, "options");
    /** Cache for pre-processed code (after ESM transform) before eval */
    __publicField(this, "processedCodeCache", /* @__PURE__ */ new Map());
    /**
     * Execute code as a module (async version for IRuntime interface)
     * Alias: executeSync() is the same as execute() for backward compatibility
     */
    __publicField(this, "executeSync", this.execute);
    /**
     * Alias for runFile (backward compatibility)
     */
    __publicField(this, "runFileSync", this.runFile);
    this.vfs = vfs2;
    this.process = createProcess({
      cwd: options2.cwd || "/",
      env: options2.env,
      onStdout: options2.onStdout,
      onStderr: options2.onStderr
    });
    this.fsShim = createFsShim(vfs2, () => this.process.cwd());
    this.options = options2;
    initChildProcess(vfs2);
    setVFS$2(vfs2);
    setVFS$1(vfs2);
    setVFS(vfs2);
    if (typeof globalThis.setImmediate === "undefined") {
      globalThis.setImmediate = (fn2, ...args) => setTimeout(fn2, 0, ...args);
      globalThis.clearImmediate = (id2) => clearTimeout(id2);
    }
    if (!globalThis.setTimeout.__patched) {
      const origSetTimeout = globalThis.setTimeout.bind(globalThis);
      const origSetInterval = globalThis.setInterval.bind(globalThis);
      const origClearTimeout = globalThis.clearTimeout.bind(globalThis);
      const origClearInterval = globalThis.clearInterval.bind(globalThis);
      const wrapTimer = (id2) => {
        const t2 = { _id: id2, ref() {
          return t2;
        }, unref() {
          return t2;
        }, hasRef() {
          return true;
        }, refresh() {
          return t2;
        }, [Symbol.toPrimitive]() {
          return id2;
        } };
        return t2;
      };
      globalThis.setTimeout = Object.assign((...args) => wrapTimer(origSetTimeout(...args)), { __patched: true });
      globalThis.setInterval = Object.assign((...args) => wrapTimer(origSetInterval(...args)), { __patched: true });
      globalThis.clearTimeout = (t2) => origClearTimeout((t2 == null ? void 0 : t2._id) ?? t2);
      globalThis.clearInterval = (t2) => origClearInterval((t2 == null ? void 0 : t2._id) ?? t2);
    }
    this.setupStackTracePolyfill();
    this.setupTextDecoderPolyfill();
  }
  /**
   * Set up a polyfilled TextDecoder that handles binary encodings
   */
  setupTextDecoderPolyfill() {
    const OriginalTextDecoder = globalThis.TextDecoder;
    class PolyfillTextDecoder {
      constructor(encoding = "utf-8", options2) {
        __publicField(this, "encoding");
        __publicField(this, "decoder", null);
        this.encoding = encoding.toLowerCase();
        const validTextEncodings = [
          "utf-8",
          "utf8",
          "utf-16le",
          "utf-16be",
          "utf-16",
          "ascii",
          "iso-8859-1",
          "latin1",
          "windows-1252"
        ];
        if (validTextEncodings.includes(this.encoding)) {
          try {
            this.decoder = new OriginalTextDecoder(encoding, options2);
          } catch {
            this.decoder = new OriginalTextDecoder("utf-8", options2);
          }
        }
      }
      decode(input, options2) {
        if (this.decoder) {
          return this.decoder.decode(input, options2);
        }
        if (!input) return "";
        const bytes = input instanceof ArrayBuffer ? new Uint8Array(input) : new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
        if (this.encoding === "base64") {
          return uint8ToBase64(bytes);
        }
        if (this.encoding === "base64url") {
          return uint8ToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
        }
        if (this.encoding === "hex") {
          return uint8ToHex(bytes);
        }
        return new OriginalTextDecoder("utf-8").decode(input, options2);
      }
      get fatal() {
        var _a3;
        return ((_a3 = this.decoder) == null ? void 0 : _a3.fatal) ?? false;
      }
      get ignoreBOM() {
        var _a3;
        return ((_a3 = this.decoder) == null ? void 0 : _a3.ignoreBOM) ?? false;
      }
    }
    globalThis.TextDecoder = PolyfillTextDecoder;
  }
  /**
   * Polyfill V8's Error.captureStackTrace and Error.prepareStackTrace for Safari/WebKit.
   * Express's `depd` and other npm packages use these V8-specific APIs which don't
   * exist in Safari, causing "callSite.getFileName is not a function" errors.
   */
  setupStackTracePolyfill() {
    if (typeof Error.captureStackTrace === "function") return;
    if (Error.stackTraceLimit === void 0) {
      Error.stackTraceLimit = 10;
    }
    function parseStack(stack) {
      if (!stack) return [];
      const frames = [];
      const lines = stack.split("\n");
      for (const raw of lines) {
        const line = raw.trim();
        if (!line || line.startsWith("Error") || line.startsWith("TypeError")) continue;
        let fn2 = "", file = "", lineNo = 0, colNo = 0;
        const safariMatch = line.match(/^(.*)@(.*?):(\d+):(\d+)$/);
        if (safariMatch) {
          fn2 = safariMatch[1] || "";
          file = safariMatch[2];
          lineNo = parseInt(safariMatch[3], 10);
          colNo = parseInt(safariMatch[4], 10);
          frames.push({ fn: fn2, file, line: lineNo, col: colNo });
          continue;
        }
        const chromeMatch = line.match(/^at\s+(?:(.+?)\s+\()?(.*?):(\d+):(\d+)\)?$/);
        if (chromeMatch) {
          fn2 = chromeMatch[1] || "";
          file = chromeMatch[2];
          lineNo = parseInt(chromeMatch[3], 10);
          colNo = parseInt(chromeMatch[4], 10);
          frames.push({ fn: fn2, file, line: lineNo, col: colNo });
          continue;
        }
      }
      return frames;
    }
    function createCallSite(frame) {
      return {
        getFileName: () => frame.file || null,
        getLineNumber: () => frame.line || null,
        getColumnNumber: () => frame.col || null,
        getFunctionName: () => frame.fn || null,
        getMethodName: () => frame.fn || null,
        getTypeName: () => null,
        getThis: () => void 0,
        getFunction: () => void 0,
        getEvalOrigin: () => void 0,
        isNative: () => false,
        isConstructor: () => false,
        isToplevel: () => !frame.fn,
        isEval: () => false,
        toString: () => frame.fn ? `${frame.fn} (${frame.file}:${frame.line}:${frame.col})` : `${frame.file}:${frame.line}:${frame.col}`
      };
    }
    function buildCallSites(stack, constructorOpt) {
      const frames = parseStack(stack);
      let startIdx = 0;
      if (constructorOpt && constructorOpt.name) {
        for (let i2 = 0; i2 < frames.length; i2++) {
          if (frames[i2].fn === constructorOpt.name) {
            startIdx = i2 + 1;
            break;
          }
        }
      }
      return frames.slice(startIdx).map(createCallSite);
    }
    const stackSymbol = Symbol("rawStack");
    Object.defineProperty(Error.prototype, "stack", {
      get() {
        const rawStack = this[stackSymbol];
        if (rawStack !== void 0 && typeof Error.prepareStackTrace === "function") {
          const callSites = buildCallSites(rawStack);
          try {
            return Error.prepareStackTrace(this, callSites);
          } catch {
            return rawStack;
          }
        }
        return rawStack;
      },
      set(value2) {
        this[stackSymbol] = value2;
      },
      configurable: true,
      enumerable: false
    });
    Error.captureStackTrace = function(target, constructorOpt) {
      const savedPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      const err2 = new Error();
      const rawStack = err2.stack || "";
      Error.prepareStackTrace = savedPrepare;
      if (typeof savedPrepare === "function") {
        const callSites = buildCallSites(rawStack, constructorOpt);
        try {
          target.stack = savedPrepare(target, callSites);
        } catch (e2) {
          console.warn("[almostnode] Error.prepareStackTrace threw:", e2);
          target.stack = rawStack;
        }
      } else {
        target.stack = rawStack;
      }
    };
  }
  /**
   * Execute code as a module (synchronous - backward compatible)
   */
  execute(code, filename = "/index.js") {
    const dirname$1 = dirname(filename);
    this.vfs.writeFileSync(filename, code);
    const require = createRequire(
      this.vfs,
      this.fsShim,
      this.process,
      dirname$1,
      this.moduleCache,
      this.options,
      this.processedCodeCache
    );
    const module = {
      id: filename,
      filename,
      exports: {},
      loaded: false,
      children: [],
      paths: []
    };
    this.moduleCache[filename] = module;
    const consoleWrapper = createConsoleWrapper(this.options.onConsole);
    if (code.startsWith("#!")) {
      code = code.slice(code.indexOf("\n") + 1);
    }
    if (!filename.endsWith(".cjs")) {
      code = transformEsmToCjs(code, filename);
    }
    try {
      const importMetaUrl = "file://" + filename;
      const wrappedCode = `(function($exports, $require, $module, $filename, $dirname, $process, $console, $importMeta, $dynamicImport) {
var exports = $exports;
var require = $require;
var module = $module;
var __filename = $filename;
var __dirname = $dirname;
var process = $process;
var console = $console;
var import_meta = $importMeta;
var __dynamicImport = $dynamicImport;
// Set up global.process and globalThis.process for code that accesses them directly
var global = globalThis;
globalThis.process = $process;
global.process = $process;

return (function() {
${code}
}).call(this);
})`;
      const dynamicImport = createDynamicImport(require);
      const fn = eval(wrappedCode);
      fn(
        module.exports,
        require,
        module,
        filename,
        dirname$1,
        this.process,
        consoleWrapper,
        { url: importMetaUrl, dirname: dirname$1, filename },
        dynamicImport
      );
      module.loaded = true;
    } catch (error) {
      delete this.moduleCache[filename];
      throw error;
    }
    return { exports: module.exports, module };
  }
  /**
   * Execute code as a module (async - for IRuntime interface)
   */
  async executeAsync(code2, filename2 = "/index.js") {
    return Promise.resolve(this.execute(code2, filename2));
  }
  /**
   * Run a file from the virtual file system (synchronous - backward compatible)
   */
  runFile(filename2) {
    const code2 = this.vfs.readFileSync(filename2, "utf8");
    return this.execute(code2, filename2);
  }
  /**
   * Run a file from the virtual file system (async - for IRuntime interface)
   */
  async runFileAsync(filename2) {
    return Promise.resolve(this.runFile(filename2));
  }
  /**
   * Clear the module cache
   */
  clearCache() {
    for (const key of Object.keys(this.moduleCache)) {
      delete this.moduleCache[key];
    }
  }
  /**
   * Get the virtual file system
   */
  getVFS() {
    return this.vfs;
  }
  /**
   * Get the process object
   */
  getProcess() {
    return this.process;
  }
  /**
   * Create a REPL context that evaluates expressions and persists state.
   *
   * Returns an object with an `eval` method that:
   * - Returns the value of the last expression (unlike `execute` which returns module.exports)
   * - Persists variables between calls (`var x = 1` then `x` works)
   * - Has access to `require`, `console`, `process`, `Buffer` (same as execute)
   *
   * Security: The eval runs inside a Generator's local scope via direct eval,
   * NOT in the global scope. Only the runtime's own require/console/process are
   * exposed  the same sandbox boundary as execute(). Variables created in the
   * REPL are confined to the generator's closure and cannot leak to the page.
   *
   * Note: `const`/`let` are transformed to `var` so they persist across calls
   * (var hoists to the generator's function scope, const/let are block-scoped
   * to each eval call and would be lost).
   */
  createREPL() {
    const require2 = createRequire(
      this.vfs,
      this.fsShim,
      this.process,
      "/",
      this.moduleCache,
      this.options,
      this.processedCodeCache
    );
    const consoleWrapper2 = createConsoleWrapper(this.options.onConsole);
    const process2 = this.process;
    const buffer = bufferModule.Buffer;
    const GeneratorFunction = Object.getPrototypeOf(function* () {
    }).constructor;
    const replGen = new GeneratorFunction(
      "require",
      "console",
      "process",
      "Buffer",
      `var __code, __result;
while (true) {
  __code = yield;
  try {
    __result = eval(__code);
    yield { value: __result, error: null };
  } catch (e) {
    yield { value: undefined, error: e };
  }
}`
    )(require2, consoleWrapper2, process2, buffer);
    replGen.next();
    return {
      eval(code2) {
        const transformed = code2.replace(/^\s*(const|let)\s+/gm, "var ");
        const exprResult = replGen.next("(" + transformed + ")").value;
        if (!exprResult.error) {
          replGen.next();
          return exprResult.value;
        }
        replGen.next();
        const stmtResult = replGen.next(transformed).value;
        if (stmtResult.error) {
          replGen.next();
          throw stmtResult.error;
        }
        replGen.next();
        return stmtResult.value;
      }
    };
  }
}
let runtime = null;
let vfs = null;
let consoleCallback = null;
const workerApi = {
  /**
   * Initialize the worker with a VFS snapshot and runtime options
   */
  init(vfsSnapshot, options2) {
    console.log("[Worker] Initializing with", vfsSnapshot.files.length, "files");
    vfs = VirtualFS.fromSnapshot(vfsSnapshot);
    const runtimeOptions = {
      ...options2,
      onConsole: (method, args) => {
        if (consoleCallback) {
          consoleCallback(method, args);
        }
      }
    };
    runtime = new Runtime(vfs, runtimeOptions);
    console.log("[Worker] Runtime initialized");
  },
  /**
   * Set the console callback for forwarding output to main thread
   */
  setConsoleCallback(callback) {
    consoleCallback = callback;
  },
  /**
   * Sync a file change from the main thread
   */
  syncFile(path2, content) {
    if (!vfs) {
      console.warn("[Worker] VFS not initialized, cannot sync file:", path2);
      return;
    }
    if (content === null) {
      try {
        vfs.unlinkSync(path2);
        console.log("[Worker] Deleted file:", path2);
      } catch (err2) {
      }
    } else {
      vfs.writeFileSync(path2, content);
      console.log("[Worker] Synced file:", path2);
    }
    if (runtime) {
      runtime.clearCache();
    }
  },
  /**
   * Execute code in the worker
   */
  async execute(code2, filename2) {
    if (!runtime) {
      throw new Error("Worker runtime not initialized. Call init() first.");
    }
    console.log("[Worker] Executing code in file:", filename2);
    return runtime.execute(code2, filename2);
  },
  /**
   * Run a file from the VFS
   */
  async runFile(filename2) {
    if (!runtime) {
      throw new Error("Worker runtime not initialized. Call init() first.");
    }
    console.log("[Worker] Running file:", filename2);
    return runtime.runFile(filename2);
  },
  /**
   * Clear the module cache
   */
  clearCache() {
    if (runtime) {
      runtime.clearCache();
      console.log("[Worker] Cache cleared");
    }
  },
  /**
   * Get current VFS state (for debugging)
   */
  getVFSSnapshot() {
    if (!vfs) return null;
    return vfs.toSnapshot();
  }
};
expose(workerApi);
console.log("[Worker] Runtime worker loaded and ready");
let wasm;
const heap = new Array(32).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
const cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
let cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
let heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length) heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
let WASM_VECTOR_LEN = 0;
const cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset2 = 0;
  for (; offset2 < len; offset2++) {
    const code2 = arg.charCodeAt(offset2);
    if (code2 > 127) break;
    mem[ptr + offset2] = code2;
  }
  if (offset2 !== len) {
    if (offset2 !== 0) {
      arg = arg.slice(offset2);
    }
    ptr = realloc(ptr, len, len = offset2 + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset2, ptr + len);
    const ret = encodeString(arg, view);
    offset2 += ret.written;
  }
  WASM_VECTOR_LEN = offset2;
  return ptr;
}
let cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}
function dropObject(idx) {
  if (idx < 36) return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1);
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
let stack_pointer = 32;
function addBorrowedObject(obj) {
  if (stack_pointer == 1) throw new Error("out of js stack");
  heap[--stack_pointer] = obj;
  return stack_pointer;
}
function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function compress(buf, raw_options) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(buf, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.compress(retptr, ptr0, len0, addBorrowedObject(raw_options));
    var r02 = getInt32Memory0()[retptr / 4 + 0];
    var r12 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    if (r3) {
      throw takeObject(r2);
    }
    var v12 = getArrayU8FromWasm0(r02, r12).slice();
    wasm.__wbindgen_free(r02, r12 * 1);
    return v12;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    heap[stack_pointer++] = void 0;
  }
}
function decompress$1(buf) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passArray8ToWasm0(buf, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.decompress(retptr, ptr0, len0);
    var r02 = getInt32Memory0()[retptr / 4 + 0];
    var r12 = getInt32Memory0()[retptr / 4 + 1];
    var r2 = getInt32Memory0()[retptr / 4 + 2];
    var r3 = getInt32Memory0()[retptr / 4 + 3];
    if (r3) {
      throw takeObject(r2);
    }
    var v12 = getArrayU8FromWasm0(r02, r12).slice();
    wasm.__wbindgen_free(r02, r12 * 1);
    return v12;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function isLikeNone(x2) {
  return x2 === void 0 || x2 === null;
}
const BrotliStreamResultCode = Object.freeze({ ResultSuccess: 1, "1": "ResultSuccess", NeedsMoreInput: 2, "2": "NeedsMoreInput", NeedsMoreOutput: 3, "3": "NeedsMoreOutput" });
class BrotliStreamResult {
  static __wrap(ptr) {
    const obj = Object.create(BrotliStreamResult.prototype);
    obj.ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_brotlistreamresult_free(ptr);
  }
  /**
  * Result code.
  *
  * See [`BrotliStreamResultCode`] for available values.
  *
  * When error, the error code is not passed here but rather goes to `Err`.
  */
  get code() {
    const ret = wasm.__wbg_get_brotlistreamresult_code(this.ptr);
    return ret >>> 0;
  }
  /**
  * Result code.
  *
  * See [`BrotliStreamResultCode`] for available values.
  *
  * When error, the error code is not passed here but rather goes to `Err`.
  * @param {number} arg0
  */
  set code(arg0) {
    wasm.__wbg_set_brotlistreamresult_code(this.ptr, arg0);
  }
  /**
  * Output buffer
  */
  get buf() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.__wbg_get_brotlistreamresult_buf(retptr, this.ptr);
      var r02 = getInt32Memory0()[retptr / 4 + 0];
      var r12 = getInt32Memory0()[retptr / 4 + 1];
      var v02 = getArrayU8FromWasm0(r02, r12).slice();
      wasm.__wbindgen_free(r02, r12 * 1);
      return v02;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * Output buffer
  * @param {Uint8Array} arg0
  */
  set buf(arg0) {
    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_brotlistreamresult_buf(this.ptr, ptr0, len0);
  }
  /**
  * Consumed bytes of the input buffer
  */
  get input_offset() {
    const ret = wasm.__wbg_get_brotlistreamresult_input_offset(this.ptr);
    return ret >>> 0;
  }
  /**
  * Consumed bytes of the input buffer
  * @param {number} arg0
  */
  set input_offset(arg0) {
    wasm.__wbg_set_brotlistreamresult_input_offset(this.ptr, arg0);
  }
}
class CompressStream {
  static __wrap(ptr) {
    const obj = Object.create(CompressStream.prototype);
    obj.ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_compressstream_free(ptr);
  }
  /**
  * @param {number | undefined} quality
  */
  constructor(quality) {
    const ret = wasm.compressstream_new(!isLikeNone(quality), isLikeNone(quality) ? 0 : quality);
    return CompressStream.__wrap(ret);
  }
  /**
  * @param {Uint8Array | undefined} input_opt
  * @param {number} output_size
  * @returns {BrotliStreamResult}
  */
  compress(input_opt, output_size) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      var ptr0 = isLikeNone(input_opt) ? 0 : passArray8ToWasm0(input_opt, wasm.__wbindgen_malloc);
      var len0 = WASM_VECTOR_LEN;
      wasm.compressstream_compress(retptr, this.ptr, ptr0, len0, output_size);
      var r02 = getInt32Memory0()[retptr / 4 + 0];
      var r12 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r12);
      }
      return BrotliStreamResult.__wrap(r02);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @returns {number}
  */
  total_out() {
    const ret = wasm.compressstream_total_out(this.ptr);
    return ret >>> 0;
  }
}
class DecompressStream {
  static __wrap(ptr) {
    const obj = Object.create(DecompressStream.prototype);
    obj.ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_decompressstream_free(ptr);
  }
  /**
  */
  constructor() {
    const ret = wasm.decompressstream_new();
    return DecompressStream.__wrap(ret);
  }
  /**
  * @param {Uint8Array} input
  * @param {number} output_size
  * @returns {BrotliStreamResult}
  */
  decompress(input, output_size) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(input, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.decompressstream_decompress(retptr, this.ptr, ptr0, len0, output_size);
      var r02 = getInt32Memory0()[retptr / 4 + 0];
      var r12 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r12);
      }
      return BrotliStreamResult.__wrap(r02);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @returns {number}
  */
  total_out() {
    const ret = wasm.decompressstream_total_out(this.ptr);
    return ret >>> 0;
  }
}
async function load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e2) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e2);
        } else {
          throw e2;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
async function init(input) {
  if (typeof input === "undefined") {
    input = new URL("data:application/wasm;base64,AGFzbQEAAAAByQQ4YAJ/fwBgAn9/AX9gA39/fwBgA39/fwF/YAF/AGABfwF/YAV/f39/fwBgBn9/f39/fwBgBH9/f38AYAV/f39/fwF/YAZ/f39/f38Bf2AHf39/f39/fwBgCH9/f39/f39/AGAEf39/fwF/YAx/f39/f39/f39/f38AYA5/f39/f39/f39/f39/fwBgCX9/f39/f39/fwBgC39/f39/f39/f39/AX9gCn9/f39/f39/f38AYAAAYA1/f39/f39/f39/f39/AGAIf39/f39/f38Bf2AOf39/f39/f39/f39/f38Bf2ABfwF+YAABf2AJf39/f39/f39/AX9gAX8BfWAFf39/fn8AYAp/f39/f39/f39/AX9gC39/f39/f39/f39/AGAHf39/f39/fwF/YAN/f38BfmAPf39/f39/f39/f39/f39/AGAQf39/f39/f39/f39/f39/fwBgFH9/f39/f39/f39/f39/f39/f39/AGAEf39/fgBgBX9+f39/AGABfgF/YAN+f38Bf2ACf38BfmABfQF9YBJ/f39/f39/f39/f39/f39/f38AYAl/f39/f39+fn4AYBV/f39/fn9/f39/f39/f39/f39/f38AYAV/f35/fwBgBH5/f38AYAx/f39/f39/f39/f38Bf2APf39/f39/f39/f39/f39/AX9gEH9/f39/f39/f39/f39/f38Bf2AHf39/fn9/fwF/YAN/fH8Bf2AEf3x/fwF/YAJ+fwF/YAJ/fwF9YAR/f39/AX1gAn9/AXwCsAIKA3diZxdfX3diaW5kZ2VuX2lzX3VuZGVmaW5lZAAFA3diZxRfX3diaW5kZ2VuX2lzX29iamVjdAAFA3diZxVfX3diaW5kZ2VuX3N0cmluZ19uZXcAAQN3YmcUX193YmluZGdlbl9lcnJvcl9uZXcAAQN3YmcZX193YmluZGdlbl9qc29uX3NlcmlhbGl6ZQAAA3diZxpfX3diZ19uZXdfNjkzMjE2ZTEwOTE2MjM5NgAYA3diZxxfX3diZ19zdGFja18wZGRhY2E1ZDFhYmZiNTJmAAADd2JnHF9fd2JnX2Vycm9yXzA5OTE5NjI3YWMwOTkyZjUAAAN3YmcaX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYABAN3YmcQX193YmluZGdlbl90aHJvdwAAA7IHsAcGCgIGDgwMDA0UBRwNFhYWDwcwEBAQGQodCQIJIgcLFAURBwcHAg8IBwcHBwkNBgQPDw8QDw8PDxQUFhYWEQYEBgYBCgYDARwEGhoaDAYGEQwBEQIJBiAKCwoDBRERKwYGIQsLBhIuFAANEQczAxICDAIAEQkNBgYJEhIHGQoKEgoCGQwABwcHEAIQBxkKAwMRLxAEBDIEBAIDEQYDDgAcAwMiBAECABQDIQoGAAICCwsIDggICAkGAAgGBgILDRUJAAQAAA8pADQKCgoHCQwIAwQIBwMSEh0bHQsGAQoAACobAAwBAgcEBgAUAQkQBA0BHgACBQAeDAQGCQEJAQ4CBQAKAxAmBwQCCgAKATcABAcHBQ0ECAcEBAMHAAULAAcHAAEkCRUECAYBGAYBCgAPNgIEBAECGQIAAigFDg4ODg4ODg4ODgETBAIABjEBCQAVFRUVAgEEBQkJCQcEAhsBBgQCAgMGByMLACQJCQkLDQYABgQBAQYGAgAGAggICAgICAgEAgICCAgAAAgGDQgMDAwCBQMCAgkJEgAACwYDBQgHCAICAgICAgICAgICAAAAAAAABgAHAgIIDwUICDUIBgMDAAUcIwgFLBAEAAEIBAACAgEAAAAAAAAAAAAAAAICAAsCCAgEAAAFAwYEBAEBAQEEAQEAAAYIDQEHAwAFBQgAAgEBAh4AAAAABAsLBgAEAi0GBgYAAAIMAgAACAQFAAgICAECAAAABQgICAQABggEAgICAgIEGwcGAAIABAUAAAEICQQBAAknAQAABQYGBgMTDQMDGAAAAgQHAAYADQcJAQgIAAIICAIAAgABAwEBAQEBAAEAAQIABAcEAAAAAAAAAAAAAAAAAQYGAAAACAsABQYEBQUACAAHBwcDBAEAAgQHBwcBASABAQEIAwIEAwICAgICAgICAgACBQIAAgAABwcHBwcHBAADAAACAwMEAAgMAAEEEwQCABMDAAQBGAQCAAAAAAAKAAEAAAAAAAAAAAAAAAAAAAAJBwcHBwcHBwUlHwAFAgQAJQUAAQEBAQEAAAAABAUaGgQFAAUFBQUEHwUBAAAfAQ0CCAAAAgQTAyYIBAIBAwYBAQIBAAQBAAAFBAEFKBcAAQEFAAIABCcCAwENAQUBAQMBBQUBBgEBBAADAQEBBAAFBAAAAAUAAQUFAwUBBQUABQEBAgICAQMBAQUBAQEEExMAAgUBAAUFAAEFBQUFAAMDAwMDAQEABAQEGAEBAQUFABcXFxcEAgQFAXABcXEFAwEAHAYJAX8BQYCAwAALB/AEFgZtZW1vcnkCAAhjb21wcmVzcwCKBApkZWNvbXByZXNzAKQEHV9fd2JnX2Jyb3RsaXN0cmVhbXJlc3VsdF9mcmVlAJIGIV9fd2JnX2dldF9icm90bGlzdHJlYW1yZXN1bHRfY29kZQCnBiFfX3diZ19zZXRfYnJvdGxpc3RyZWFtcmVzdWx0X2NvZGUA2wUgX193YmdfZ2V0X2Jyb3RsaXN0cmVhbXJlc3VsdF9idWYA5gQgX193Ymdfc2V0X2Jyb3RsaXN0cmVhbXJlc3VsdF9idWYAjwQpX193YmdfZ2V0X2Jyb3RsaXN0cmVhbXJlc3VsdF9pbnB1dF9vZmZzZXQAqAYpX193Ymdfc2V0X2Jyb3RsaXN0cmVhbXJlc3VsdF9pbnB1dF9vZmZzZXQAnAYZX193YmdfY29tcHJlc3NzdHJlYW1fZnJlZQCdARJjb21wcmVzc3N0cmVhbV9uZXcA6QUXY29tcHJlc3NzdHJlYW1fY29tcHJlc3MA7wIYY29tcHJlc3NzdHJlYW1fdG90YWxfb3V0AKkGG19fd2JnX2RlY29tcHJlc3NzdHJlYW1fZnJlZQC8AhRkZWNvbXByZXNzc3RyZWFtX25ldwDqBRtkZWNvbXByZXNzc3RyZWFtX2RlY29tcHJlc3MAlgMaZGVjb21wcmVzc3N0cmVhbV90b3RhbF9vdXQAqgYRX193YmluZGdlbl9tYWxsb2MAkAYSX193YmluZGdlbl9yZWFsbG9jALsGH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAjQcPX193YmluZGdlbl9mcmVlANIGCeUBAQBBAQtwuAenB64HuAezB7MHswfaBekCwAa4B5cGjge4B48HuAeQB+cGTPAGkQf9BrYC/wS4B+QGuAftBqwC9wTNBtQG0wapB7QH+QapB7kHiQfuBs0G/Qa2ArgHyQaLB8QG9AWzAu8GuAeqBcoGuAe1B7gHlweYBpoGlwa4B98GtAW4B5kGuAecB9QG8AbWBLgH2AWHAvkE4QacB8YG7wauBsgG0wa2B7UHuQbUAusD8wX3BrcHwwbOBrgH2QWEB/oE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Ih8gCEobaiEVIBhBACAFLgESIiAgCEobaiEUIBhBACAFLgEQIiEgCEobaiETIBhBACAFLgEOIiIgCEobaiESIBhBACAFLgEMIiMgCEobaiENIBhBACAFLgEKIiUgCEobaiEPIBhBACAFLgEIIiYgCEobaiEQIBhBACAFLgEGIikgCEobaiEZIBhBACAFLgEEIisgCEobaiERIBhBACAFLgECIiwgCEobaiEOIBhBACAFLgEAIi0gCEobaiEbIAcgGEEAIAUuAR4iLiAIShtqQRB0QRB1IgcgGk4EQCAHIC5qIgcgB0EQdEESdWshByAMIBxqIgwgDEEQdEESdWshDCAXIB1qIhcgF0EQdEESdWshFyAWIB5qIhYgFkEQdEESdWshFiAVIB9qIhUgFUEQdEESdWshFSAUICBqIhQgFEEQdEESdWshFCATICFqIhMgE0EQdEESdWshEyASICJqIhIgEkEQdEESdWshEiANICNqIg0gDUEQdEESdWshDSAPICVqIg8gD0EQdEESdWshDyAQICZqIhAgEEEQdEESdWshECAZIClqIhkgGUEQdEESdWshGSARICtqIhEgEUEQdEESdWshESAOICxqIg4gDkEQdEESdWshDiAbIC1qIhsgG0EQdEESdWshGyAKICRqIgogCkEQdEESdWshCgsgBiAHOwEeIAYgCjsBHCAGIAw7ARogBiAXOwEYIAYgFjsBFiAGIBU7ARQgBiAUOwESIAYgEzsBECAGIBI7AQ4gBiANOwEMIAYgDzsBCiAGIBA7AQggBiAZOwEGIAYgETsBBCAGIA47AQIgBiAbOwEAIAEgAkEFakEHcWotAAAiG0EJdCAnciIBIABBHGooAgAiEU8NByAAKAIYIicgAUEFdGoiByAJQQF0ai8BACECIARB/wFxQRBPBH8gCUF/aiIBQRBPDREgAiAHIAFBAXRqLwEAawUgAgtB//8DcUECdEGQx9IAaioCACFKIAcvAR4iBkECdEGQx9IAaioCACFLIAcvAQAgBy8BAiAHLwEEIAcvAQYgBy8BCCAHLwEKIAcvAQwgBy8BDiAHLwEQIAcvARIgBy8BFCAHLwEWIAcvARggBy8BGiAHLwEcIAVCjYC4gPCBgAg3ATggBUKJgKiAsIGABjcBMCAFQoWAmIDwgIAENwEoIAVCgYCIgLCAgAI3ASAgBSAFQSBqEO0FIAtBACAFLgEcIiQgCUobaiEOIAtBACAFLgEaIhwgCUobaiECIAtBACAFLgEYIh0gCUobaiEBIAtBACAFLgEWIh4gCUobaiEKIAtBACAFLgEUIh8gCUobaiEMIAtBACAFLgESIiAgCUobaiEXIAtBACAFLgEQIiEgCUobaiEWIAtBACAFLgEOIiIgCUobaiEVIAtBACAFLgEMIiMgCUobaiEUIAtBACAFLgEKIiUgCUobaiETIAtBACAFLgEIIiYgCUobaiESIAtBACAFLgEGIikgCUobaiENIAtBACAFLgEEIisgCUobaiEPIAtBACAFLgECIiwgCUobaiEQIAtBACAFLgEAIi0gCUobaiEZIAYgC0EAIAUuAR4iCyAJShtqQRB0QRB1IgYgKE4EQCAGIAtqIgYgBkEQdEESdWshBiAOICRqIg4gDkEQdEESdWshDiACIBxqIgIgAkEQdEESdWshAiAKIB5qIgogCkEQdEESdWshCiAMIB9qIgwgDEEQdEESdWshDCAXICBqIhcgF0EQdEESdWshFyAWICFqIhYgFkEQdEESdWshFiAVICJqIhUgFUEQdEESdWshFSAUICNqIhQgFEEQdEESdWshFCATICVqIhMgE0EQdEESdWshEyASICZqIhIgEkEQdEESdWshEiANIClqIg0gDUEQdEESdWshDSAPICtqIg8gD0EQdEESdWshDyAQICxqIhAgEEEQdEESdWshECAZIC1qIhkgGUEQdEESdWshGSABIB1qIgEgAUEQdEESdWshAQsgByAGOwEeIAcgDjsBHCAHIAI7ARogByABOwEYIAcgCjsBFiAHIAw7ARQgByAXOwESIAcgFjsBECAHIBU7AQ4gByAUOwEMIAcgEzsBCiAHIBI7AQggByANOwEGIAcgDzsBBCAHIBA7AQIgByAZOwEAICogG0EPcUEJdHJBAXIiASARTw0IICcgAUEFdGoiECAIQQF0ai8BACECIAgEfyAIQX9qIgFBEE8NESACIBAgAUEBdGovAQBrBSACC0H//wNxQQJ0QZDH0gBqKgIAIUwgEC8BHiIHQQJ0QZDH0gBqKgIAIU0gEC8BACAQLwECIBAvAQQgEC8BBiAQLwEIIBAvAQogEC8BDCAQLwEOIBAvARAgEC8BEiAQLwEUIBAvARYgEC8BGCAQLwEaIBAvARwg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AnRqIgYgBigCACALajYCACAAKAIAIgYgA08NBCAHKAK4CCEIIAcqArwIIRIgAiAGQYgIbGogB0E4akGACBClByIGIBI4AoQIIAYgCDYCgAggACAHKgLMECISOAIIIAEoAhBBAUYEQCAAQQxqIBI4AgALIABBADYCJCAAKAIoIgYgA08NECACIAZBiAhsakEAQYQIEKMHQaPg//sHNgKECCAAIAAoAixBAWoiAjYCLCACQQFNDRMgACAAKAIUIAAoAiBqNgIgDBMLIA0gA0H08sAAELwEAAsgB0EYaiABQQhqEJgHIAogBygCHCIGTw0IIAcoAhggCkECdGogCzYCACABKAIQIQggB0EQaiABEJgHIAAoAhwiBiAHKAIUIglPDQkgBygCECAGaiAIOgAAIAAgACgCADYCBCAAKgIIIRMgACASOAIIIABBDGogEzgCACABIAEoAhAiBkEBajYCECAAIAZB/wFxNgIAIAAgACgCHEEBajYCHCAAIAAoAihBAWoiBjYCKCAGIAQoAgBPDQ8gBiADSQRAIAIgBkGICGxqQQBBhAgQowdBo+D/+wc2AoQIDBALIAYgA0Gk88AAELwEAAsgCiAGTw0JIAggCkECdGogCzYCACAHQShqIAEQmAcgACgCHCIGQX5qIgggBygCLCIJTw0KIAcoAiggCGotAAAhCCAHQSBqIAEQmAcgBiAHKAIkIglPDQsgBygCICAGaiAIOgAAIAAoAgQhBiAAIAAoAgA2AgQgACAGNgIAIAYgA08NDCAHKALAECEIIAcqAsQQIRIgAiAGQYgIbGogD0GACBClByIGIBI4AoQIIAYgCDYCgAggAEEANgIkIAAqAgghEiAAIAcqAtAQOAIIIABBDGogEjgCACAAIAAoAhxBAWo2AhwgACgCKCIGIANJBEAgAiAGQYgIbGpBAEGECBCjByAAQQA2AixBo+D/+wc2AoQIIAAgACgCFDYCIAwRCyAGIANB9PPAABC8BAALIAkgBkGE9MAAELwEAAsgBiADQZT0wAAQvAQAC0EAQQBBtPTAABC8BAALQQBBAEHE9MAAELwEAAtBAEEAQdT0wAAQvAQACyAGIANJBEAgAiAGQYgIbGpBAEGECBCjB0Gj4P/7BzYChAgMCgsgBiADQeT0wAAQvAQACyAGIANB5PLAABC8BAALIAogBkGE88AAELwE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TQ0EIAJBAkYNAyABQXxqIQwgCEF+aiEKIAEoAgggASgCBCAJampBCHRBA25BpANqIQdBACEEQQAhBUEAIQYDQCAGIAhJIQsCQAJAAkACQAJAAkACQCAGIAhGIgkNACAGQcAFTw0CIAMgBmotAAANACAGBEAgBkF/aiIAQcAFTw0EIAAgA2otAAANAQsgBiACTw0EIAEgBkECdGooAgAiAEEIdCAHa0GodmpB0GxPDQELIARBA01BACAEQQNHIAVyGw0EQQEgBSAEQQF2aiIAIARuIAQgAEsbQQAgBRshACAGQX9qIQUgDCAGQQJ0aiEHA0AgBSACSQRAIAcgADYCACAHQXxqIQcgBUF/aiEFIARBf2oiBA0BDAYLCyAFIAJBsPviABC8BAALIAAgBWohBSAEQQFqIgRBA00NBCAFQQh0IARBAXZqIARuIgBB+ABqIAAgBEEERhshBwwECyAGQcAFQYD74gAQvAQACyAAQcAFQZD74gAQvAQACyAGIAJBoPviABC8BAALAkACQAJAAkAgBiAKTwRAQQAhByALDQEMBAsgBiACTw0BIAZBAWoiBCACTw0CIAZBAmoiACACSQRAIAEgAEECdGooAgAgASAGQQJ0aigCACABIARBAnRqKAIAampBCHRBA25BpANqIQcMBAsgACACQeD74gAQvAQACyAGIAJJBEAgASAGQQJ0aigCAEEIdCEHDAMLIAYgAkHw++IAELwEAAsgBiACQcD74gAQvAQACyAEIAJB0PviABC8BAALQQAhBUEBIQQgCQ0AIAYgAk8NAyABIAZBAnRqKAIAIQULIAYgCE8gBiALaiIGIAhLckUNAAsLDwsgBiACQYD84gAQvAQACyAFQcAFQcD64gAQvAQAC0ECQQJB8PriABC8BAALQQFBAUHg+uIAELwEAAsgBCACQdD64gAQvAQACyAEIAJBsPriABC8BAALIAIgAkHw+eIAELwEAAsgAiACQeD54gAQvAQAC6MLAgx/AX4jAEGQE2siBiQAIAZB+AFqEPEGIANBoARuIQcCQCADRQRAIAVBATYCEAwBCyADQYABTwRAIAZB8AFqIAdBAWoiB0EyIAdBMkkbIgcQ8gMgASACIAMgByAGKALwASIIIAYoAvQBIgkQmgIgASACIAMgByAIIAkQpAIgBkHoAWogACADENcFIAYgBikD6AE3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IBUgAkGYiMAAELwEAAsgCCAFQaiIwAAQvAQACyABIAVBuIjAABC8BAALIAMgBUHIiMAAELwEAAsgBiAFQdiIwAAQvAQACyAFIABB6IjAABC8BAALIAEgAEH4iMAAELwEAAsgASAAQYiJwAAQvAQACyACIAFBAnRqIARBDGo2AgAgC0EQaiQAC4gKAQF/IwBBMGsiAiQAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAC0AAEEBaw4RAQIDBAUGBwgJCgsMDQ4PEBEACyACIAAtAAE6AAggAkEkakECNgIAIAJBLGpBATYCACACQfC8wQA2AiAgAkEANgIYIAJBLTYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwRCyACIAApAwg3AwggAkEkakECNgIAIAJBLGpBATYCACACQdS8wQA2AiAgAkEANgIYIAJBLjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwQCyACIAApAwg3AwggAkEkakECNgIAIAJBLGpBATYCACACQdS8wQA2AiAgAkEANgIYIAJBLzYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwPCyACIAArAwg5AwggAkEkakECNgIAIAJBLGpBATYCACACQbi8wQA2AiAgAkEANgIYIAJBMDYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwOCyACIAAoAgQ2AgggAkEkakECNgIAIAJBLGpBATYCACACQZi8wQA2AiAgAkEANgIYIAJBMTYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwNCyACIAApAgQ3AwggAkEkakEBNgIAIAJBLGpBATYCACACQYS8wQA2AiAgAkEANgIYIAJBMjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD9BAwMCyACQSRqQQE2AgAgAkEsakEANgIAIAJB9LvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwLCyACQSRqQQE2AgAgAkEsakEANgIAIAJB4LvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwKCyACQSRqQQE2AgAgAkEsakEANgIAIAJBzLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwJCyACQSRqQQE2AgAgAkEsakEANgIAIAJBuLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwICyACQSRqQQE2AgAgAkEsakEANgIAIAJBoLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwHCyACQSRqQQE2AgAgAkEsakEANgIAIAJBkLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwGCyACQSRqQQE2AgAgAkEsakEANgIAIAJBhLvBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwFCyACQSRqQQE2AgAgAkEsakEANgIAIAJB+LrBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwECyACQSRqQQE2AgAgAkEsakEANgIAIAJB5LrBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwDCyACQSRqQQE2AgAgAkEsakEANgIAIAJBzLrBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwCCyACQSRqQQE2AgAgAkEsakEANgIAIAJBtLrBADYCICACQaS6wQA2AiggAkEANgIYIAEgAkEYahD9BAwBCyABIAAoAgQgAEEIaigCABDjBgsgAkEwaiQAC7IIAhp/BX4jAEEwayIHJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIARBCGogBU0EQCAAQRRqKAIAIQggACgCECEOIAdBCGogAEEYahCYByAHKAIMIQkgBygCCCEPIAcgCDYCECAHIAAoAgQiBjYCFCAGIAhHDQEgByAJNgIQIAcgACgCBCAAEJkHbCIGNgIUIAYgCUcNESAFIARrIhRBBE8EQCAUQQJ2IRUgADUCAEI/gyEhIAQhBQNAIAMgBXEiBiACTw0EIAZBAWoiECACTw0FIAZBAmoiESACTw0GIAZBA2oiEiACTw0HIAZBBGoiCiACTw0IIAZBBWoiCyACTw0JIAZBBmoiDCACTw0KIAEgCmoxAAAhICABIAxqMQAAISIgASALajEAACEjIAggASAGajEAACABIBBqMQAAQgiGhCABIBFqMQAAQhCGhCABIBJqMQAAQhiGhCIkQr3P1vEBfkL/////D4MgIYinIgpNDQsgDiAKQQF0aiILIAsvAQAiFkEBajsBACAAKAIIIRcgCCAgQiCGICSEIiBCCIhCvc/W8QF+Qv////8PgyAhiKciC00NDCAOIAtBAXRqIgwgDC8BACIYQQFqOwEAIAAoAgghGSAIICNCKIYgIIQiIEIQiEK9z9bxAX5C/////w+DICGIpyIMTQ0NIA4gDEEBdGoiDSANLwEAIhpBAWo7AQAgACgCCCEbIAggICAiQjCGhEIYiEK9z9bxAX5C/////w+DICGIpyINTQ0OIA4gDUEBdGoiEyATLwEAIhNBAWo7AQAgACgCCCEcIAAoAgwhHSAAKAIMIR4gACgCDCEfIBYgF3EgCiAAKAIMdGoiCiAJTw0PIA8gCkECdGogBjYCACAYIBlxIAsgHXRqIgYgCU8NECAPIAZBAnRqIBA2AgAgGiAbcSAMIB50aiIGIAlPDREgDyAGQQJ0aiARNgIAIBMgHHEgDSAfdGoiBiAJTw0SIA8gBkECdGogEjYCACAFQQRqIQUgFUF/aiIVDQALCyAUQXxxIARqIQQLIAdBMGokACAEDwsgB0EANgIgIAdBEGogB0EUaiAHQRhqQfiRwAAQ8QQACyAGIAJBmJLAABC8BAALIBAgAkGoksAAELwEAAsgESACQbiSwAAQvAQACyASIAJByJLAABC8BAALIAogAkHYksAAELwEAAsgCyACQeiSwAAQvAQACyAMIAJB+JLAABC8BAALIAogCEGIk8AAELwEAAsgCyAIQZiTwAAQvAQACyAMIAhBqJPAABC8BAALIA0gCEG4k8AAELwEAAsgCiAJQciTwAAQvAQACyAGIAlB2JPAABC8BAALIAYgCUHok8AAELwEAAsgBiAJQfiTwAAQvAQACyAHQQA2AiAgB0EQaiAHQRRqIAdBGGpBiJLAABDxBAALgAgCD38IfiMAQRBrIgokACAAQRRqKAIAIQYgACgCECEJIAAoAgAhEiAKQQhqIABBGGoQmAcCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADIARxIgUgAkkEQCAFQQFqIgggAk8NASAFQQJqIgsgAk8NAiAFQQNqIgwgAk8NAyAFQQRqIg0gAk8NBCAFQQVqIg4gAk8NBSAFQQZqIg8gAk8NBiAFQQdqIhAgAk8NByAEQQhqIANxIgcgAk8NCCAHQQFqIhEgAk8NCSAKKAIMIQIgCigCCCEDIAEgDWoxAAAhFCABIA5qMQAAIRYgASAPajEAACEXIAEgEGoxAAAhGCABIAdqMQAAIRkgASARajEAACEaIAYgASAFajEAACABIAhqMQAAQgiGhCABIAtqMQAAQhCGhCABIAxqMQAAQhiGhCIbQr3P1vEBfkL/////D4MgEkE/ca0iFYinIgFNDQogCSABQQF0aiIFIAUvAQAiC0EBajsBACAAKAIIIQwgBiAUQiCGIBuEIBZCKIaEIhRCEIhCvc/W8QF+Qv////8PgyAViKciBU0NCyAJIAVBAXRqIgcgBy8BACINQQFqOwEAIAAoAgghDiAGIBdCMIYgFIQgGEI4hoQiFEIgiEK9z9bxAX5C/////w+DIBWIpyIHTQ0MIAkgB0EBdGoiCCAILwEAIg9BAWo7AQAgACgCCCEQIAYgGUIQhiAaQhiGhCAUQjCIhEK9z9bxAX5C/////w+DIBWIpyIITQ0NIAkgCEEBdGoiBiAGLwEAIgZBAWo7AQAgACgCCCEJIAAoAgwhESAAKAIMIRIgACgCDCETIAsgDHEgASAAKAIMdGoiACACTw0OIAMgAEECdGogBDYCACANIA5xIAUgEXRqIgAgAk8NDyADIABBAnRqIARBAmo2AgAgDyAQcSAHIBJ0aiIAIAJPBEAgACACQaiLwAAQvAQACyADIABBAnRqIARBBGo2AgAgBiAJcSAIIBN0aiIAIAJJDRAgACACQbiLwAAQvAQACyAFIAJBqInAABC8BAALIAggAkG4icAAELwEAAsgCyACQciJwAAQvAQACyAMIAJB2InAABC8BAALIA0gAkHoicAAELwEAAsgDiACQfiJwAAQvAQACyAPIAJBiIrAABC8BAALIBAgAkGYisAAELwEAAsgByACQaiKwAAQvAQACyARIAJBuIrAABC8BAALIAEgBkHIisAAELwEAAsgBSAGQdiKwAAQvAQACyAHIAZB6IrAABC8BAALIAggBkH4isAAELwEAAsgACACQYiLwAAQvAQACyAAIAJBmIvAABC8BAALIAMgAEECdGogBEEGajYCACAKQRBqJAALlAkBA38jAEEwayIDJAAgA0EgaiAAEKoEAn8CQAJAAkACQAJAAkAgAy0AIA0AAkACQAJAAkACQAJAAkACQAJAIAMtACEiBEHt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DQMgDkF/aiILIAVxIg8gEU8NBiAGIBogD0ECdGooAgAiE2shDwJAIB0gBEsNACAEIBNxIhMgDWoiFiAESw0AIA0gEE8NCCAWIANPDQkgHC0AACACIBZqLQAARw0AIA8gCEsNBCATIANLDQogDkF/aiELIAIgE2ogAyATayASIBAgBxAlIgVFDQIgHyAFIA8gFxCxBiIeWg0CIAogDzYCECAKIAU2AgggCiAeNwMAIA5Bf2ohC0EBIRggBSENIB4hHwwDCyAPIAhNDQALCwsLIAUgDHEiAiARTw0GIBogAkECdGogBjYCAEEBIQsgGSAZLwEAQQFqOwEAIBgNByABRQRAQQAhCwwICyABIAAgEiAQIAcgCCAJIAoQ3QIhCwwHC0HkjsAAQSNBqIzAABC4BQALQeSOwABBI0G4jMAAELgFAAsgDyARQaSNwAAQvAQACyANIBBBtI3AABC8BAALIBYgA0HEjcAAELwEAAtB5I7AAEEjQdSNwAAQuAUACyACIBFB5I3AABC8BAALIBRBEGokACALC74JAgx/BH4jAEHAAmsiAyQAIAMgAjYCXCADIAE2AlggA0HQAGogA0HYAGoQmAcgAygCVCEEIANB4ABqIgFCADcDACABQRBqQQA2AgAgAUEIakIANwMAIANByABqEKoHIAMoAkwhASADKAJIIQUgA0H4AGoQvgYgA0GQAWoQvgYgA0GoAWoQvgYgA0FAaxCrByADKAJEIQYgAygCQCEHIANBOGoQqwcgAygCPCEIIAMoAjghCSADQTBqEKoHIAMoAjQhCiADKAIwIQsgA0EoaiICQQA6AAIgAkEAOwEAIANBwAJqIQwgA0HAAWohAiADLQAqIQ0gAy8BKCEOA0AgAiAOOwEAIAJBAmogDToAACACQQRqIgIgDEcNAAsgA0EgahCrByADKQNYIQ8gAykDICEQIANBGGoQqgcgAykDGCERIANBEGoQqgcgAykDECESIABB2A1qQgA3AwAgAEHQDWpCADcDACAAQcgNakIANwMAIABCADcDwA0gAEEAOgCKESAAQQA2AtAPIAAgAykDYDcD8A0gAEH4DWogA0HoAGopAwA3AwAgAEGADmogA0HwAGopAwA3AwAgAEIANwLUDyAAQgA3A4gOIABB3A9qQgA3AgAgAEHkD2pCADcCACAAQewPakIANwIAIABBADsB8BAgAEGUDmogATYCACAAIAU2ApAOIABB6A1qQouAgIDAADcDACAAQpCAgIDwATcD4A0gAEG8m+sANgLoECAAQQA2AvwPIABCADcC9A8gACADKQN4NwKYDiAAQaAOaiADQYABaikDADcCACAAQagOaiADQYgBaikDADcCACAAIAMpA5ABNwKwDiAAQbgOaiADQZgBaikDADcCACAAQcAOaiADQaABaikDADcCACAAQgA3A4AQIABBADYCiBAgAEGYD2pCADcDACAAQZAPakIANwMAIABCADcDiA8gAEGsD2ogCDYCACAAQagPaiAJNgIAIABBpA9qIAY2AgAgAEGgD2ogBzYCACAAQgA3AowQIABBlBBqQgA3AgAgAEGwD2pCADcDACAAQbgPakIANwMAIABBwA9qQgA3AwAgAEHFD2pCADcAACAAQdgOaiADQbgBaikDADcCACAAQdAOaiADQbABaikDADcCACAAIAMpA6gBNwLIDiAAQQA7AI8RIABBADsBhBEgAEHkDmogCjYCACAAIAs2AuAOIABBATYC7BAgAEGcEGpBAEEkEKMHGiAAIANBwAFqQYABEKUHIgBCADcB8hAgAEEQNgLAECAAQfoQakIANwEAIABBghFqQQA7AQAgAEIANwLEECAAQcwQakIANwIAIABB1BBqQQA2AgAgAEGAAWpBAEHADBCjBxogAEH/ATYC2BAgACAQNwPoDiAAQZERakEAQYECEKMHGiAAQQA7AZITIAAgBDYC3BAgACAPNwPwDiAAQQA2AIsRIABBADYBhhEgAEIANwPgECAAIBI3A4APIAAgETcD+A4gA0EIakG4CBDKBCADKAIMIQEgAygCCCECIABB7A5qKAIABEAgACgC6A4QUgsgAEEBOgCPESAAIAI2AugOIAAgATYC7A4gAEHwDWoiAEHAADYCCCAAQgA3AwAgA0HAAmokAAvXBwIFfwF+IAIpAwAhCgJAAkACQAJAAkACQAJAAkACQAJAAkAgAigCCCIGQTBPBEAgAigCDCIFQQhqIQcgBUF3Sw0BIAcgBEsNAiACIAVBBmo2AgwgAiACKAIQQXpqNgIQIAIgAyAFaiIFMQABQhiGIAUxAABCEIYgCkIwiISEIAUxAAJCIIaEIAUxAANCKIaEIAUxAARCMIaEIAUxAAVCOIaEIgo3AwAgBkEwcyEGCyAK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BAALIABBgAFB5InjABC8BAALIABBgAFB9InjABC8BAALIABBgAFBhIrjABC8BAALIABBgAFBpIrjABC8BAALIABBgAFBtIrjABC8BAALIABBgAFB5IrjABC8BAALIABBgAFBhIvjABC8BAALIABBgAFBlIvjABC8BAALIABBgAFBxIvjABC8BAALIAMgAEECdGoiACAAKAIAQQFqNgIAC/8HAgp/AX4jAEEwayIHJAAgA0GOEWohDyADQfANaiELIAMtAI0RIQYDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAGQQdxQQFrDgQGAAECAwsgAygC7A4hCCADKALoDiEJIANCAjcD6A4gAygC0BAgASgCAGoiBiAGIAkgCEEAQQAgAyAEIAUQlgEhBiADKALsDiADIAg2AuwOIAMoAugOIQggAyAJNgLoDgRAIAgQUgsgBkEBRw0JQQMhBiADQQM6AI0RIANB//8DNgLUEAwLCyACKAIEIQogAigCACEMIAMoAtAQIQ0gAygCzBAhBiAHIAMoAtQQIgg2AhwgCEH//wNHIQkgCEH//wNHIAYgAElyDQIMCQtBACEJIAdBADYCIEEBIQYgC0EBIAdBIGogBCAFEM4ERQRAQQIhBkEEIQkMBwsgBygCIEUNBkFhIQYgAy0AkRENByACKAIAIAIoAgQgACADQZIRaiADQdgQahC+A0EBIQYMBgsgDyALIAEgBCAFENgCIgZBAUYNAQwGCwNAAkACQCAJQQFxDQACQCADKALoDiADKALsDiALIAdBHGogBCAFELQBBEACQAJAIAcoAhwiCEUEQCAGIApPDQIgBiAMakEAOgAADAELIAggDU0NBCAGIApPDQMgBiAMaiAIIA1rOgAACyAGQQFqIQYMBAsgBiAKQdyl4wAQvAQACyADIAY2AswQIANB//8DNgLUEAwGCyAGIApBzKXjABC8BAALIAdBADYCIAJAIAsgCCAHQSBqIAQgBRDOBARAIAcoAiBBASAIdGoiCSAGaiAATQ0BQXghBgwJCyADIAY2AswQIAMgCDYC1BAMBQsgCiAGIAogBksbIQ4DQCAGIA5HBEAgBiAMakEAOgAAIAZBAWohBiAJQX9qIgkNAQwCCwsgDiAKQeyl4wAQvAQAC0EAIQkgBiAASQ0ACwwGCyADQQA2AswQIAEgASgCAEEBaiIG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+OIAELwEAAsgCyAFQYD54gAQvAQACyAIIAVBkPniABC8BAALIAogBUGg+eIAELwEAAsgDUEBdCENIBFBf2ogBCAFIAYgByADEJMCRQ0BCwsLgwYCA38BfiMAQUBqIgIkACABQSBqIQMCQAJAAkACQAJAAkACQAJAAkACQCABKAIgIgRBfmoOCQABAgMHBwcEBQYLIAJBOGoiASADQRBqKQIANwMAIAJBMGoiBCADQQhqKQIANwMAIAIgAykCADcDKCACQQhqQYmABBDWBSACKQMIIQUgAxDzBiEDIAAgBTcCBCAAQTBqIAM2AgAgAEEsakEANgIAIABBJGpCATcCACAAQQE2AgAgAEEMaiACKQMoNwIAIABBFGogBCkDADcCACAAQRxqIAEpAwA3AgAMCAsgAkE4aiIBIANBEGopAgA3AwAgAkEwaiIEIANBCGopAgA3AwAgAiADKQIANwMoIAJBEGpBioAEENYFIAIpAxAhBSADEPMGIQMgACAFNwIEIABBMGogAzYCACAAQSxqQQA2AgAgAEEkakIBNwIAIABBAjYCACAAQQxqIAIpAyg3AgAgAEEUaiAEKQMANwIAIABBHGogASkDADcCAAwHCyACQThqIgEgA0EQaikCADcDACACQTBqIgQgA0EIaikCADcDACACIAMpAgA3AyggAkEYakGIgAgQ1gUgAikDGCEFIAMQ8wYhAyAAIAU3AgQgAEEwaiADNgIAIABBLGpBADYCACAAQSRqQgE3AgAgAEEDNgIAIABBDGogAikDKDcCACAAQRRqIAQpAwA3AgAgAEEcaiABKQMANwIADAYLIAAgARCoAQwFCyAAQQRqIAEQkwMgAEEJNgIADAQLIABBBGogARDNAyAAQQo2AgAMAwsgBEE2Rg0BCyAAIAEQmAIMAQsgAkE4aiIBIANBEGopAgA3AwAgAkEwaiIEIANBCGopAgA3AwAgAiADKQIANwMoIAJBIGpBjIDAABDWBSACKQMgIQUgAxDzBiEDIAAgBTcCBCAAQTBqIAM2AgAgAEEsakEANgIAIABBJGpCATcCACAAQQQ2AgAgAEEMaiACKQMoNwIAIABBFGogBCkDADcCACAAQRxqIAEpAwA3AgALIAJBQGskAAuMBgEEfyMAQZABayIGJAAgAEEANgIsIABCADcCJCAAQYAENgIgIABBADYCHCAA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IgdB/wFLDQEgAyABLwEAIgcgAUFgai8BACIIazsBBCAHIAhGDQIMAwsgAS8BAA0CIANBADYCECABIANBCGpB+JPjABDwBAALIAdBgAJB2JPjABC8BAALIANBADYCECADQQRqIANBCGpB6JPjABDwBAALIAFBAmohASACQQFqIgINAAsgAEEgaiEAIAZBEGohBiIEQRBHDQALIANBIGokAA8LIAJBgAJB2JLjABC8BAALIANBADYCECADQQRqQZCR4wAgA0EIakGokuMAEPEEAAv4BQEFfyMAQYAVayIKJAAgCkEAQYACEKMHIglBgAJqQQBBgAQQowcaIAlBgAZqQQBBgAgQowcaIAlBgA5qQQBBgAEQowcaIAlBgA9qQQBBgAIQowcaIAlBgBFqQQBBgAQQowcaAkACQAJAAkAgAgRAA0AgASALRg0CIAlBgAZqIAAgC2otAABBAnRqIgogCigCAEEBajYCACACIAtBAWoiC0cNAAsLIAlBgAZqQYACIAJBCCAJQYACIAlBgAJqQYACIAYgByAIECIgBUUNAUEAIQsgAyECAkADQCAEIAtGDQEgAi0AACIKQYABTw0FIAlBgBFqIApBAnRqIgogCigCAEEBajYCACACQQRqIQIgBSALQQFqIgtHDQALIAkgCSgC0BNBAWo2AtATIAkgCSgCgBNBAWo2AoATIAkgCSgCiBFBAWo2AogRIAkgCSgChBFBAWo2AoQRIAlBgBFqIAlBgA5qIAlBgA9qIAYgByAIEIUBA0ACQAJAAkACQCAEIAxHBEAgAyAMQQJ0aigCACILQf8BcSICQYABTw0BIAlBgA5qIAJqLQAAIAlBgA9qIAJBAXRqMwEAIAYgByAIEPQCIAJBAnQiCkH05OIAaigCACALQQh2IgutIAYgByAIEPQCIAJBGE8NBCABIApB9OjiAGooAgAgC2oiCkkNAiAAIQsgCiICRQ0DA0AgCSALLQAAIg1qLQAAIAlBgAJqIA1BAXRqMwEAIAYgByAIEPQCIAtBAWohCyACQX9qIgINAAsMAwsgBCAEQZS5wAAQvAQACyACQYABQaS5wAAQvAQACyAKIAFBtLnAABCHBwALIAAgCmohACABIAprIQELIAxBAWoiDCAFRw0ACwwDCyAEIARB9LjAABC8BAALIAEgAUHkuMAAELwEAAsgCUEBNgLQEyAJ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CQJAIA4iCEUNAANAIAQgCXEiCyADSQRAIAogAiALai0AAEECdGoiCyALKAIAQQFqNgIAIAlBAWohCSAIQX9qIggNAQwCCwsgCyADQZCRwQAQvAQACyAMIA5qIA9qIQwgDUEBaiINIAdHDQALCyAKQYACQYACQQEgCkGwImpBgAIQ3QFBACEJIApBgAhqQcAFQcAFQQAgAEHABRDdASAKQYAeakGMASAAKAKQFkEAIAAoAoAWIABBhBZqKAIAEN0BQ57J/34hEANAIBAgECAAIAlqKgIAIhEgECARXRsgESARXBshECAJQQRqIgUhCSAFQYAWRw0ACyAAIBA4ApQWAkACQCAAQYwWaigCACIFBEAgACgCmBYhBkEAIQkgACgCiBYiAEEANgIAIAYEQCAAQQRqIQggBUF/aiEHQwAAAAAhEANAIAEgCWogBHEiACADTw0DIAcgCUYNBCAIIBAgEiAKQbAiaiAAIAJqLQAAQQJ0aioCAJIiEpIiETgCACASIBEgEJOTIRIgCEEEaiEIIBEhECAGIAlBAWoiCUcNAAsLIApBsCpqJAAPC0EAQQBBoJHBABC8BAALIAAgA0GwkcEAELwEAAsgBSAFQcCRwQAQvAQAC6wEAQF/IwBB0CprIgEkACABQQhqIAAQowUgAUEIahCZAgJAAn8CQAJAAkACQAJAAkACQAJAAkACQCABKAKQKQ4KCwECAwQFBgcICQALIAFBmClqKAIABEAgAUGUKWooAgAQUgsgAUGgKWooAgBFDQogAUGcKWoMCQsgAUGYKWooAgBFDQkgAUGUKWoMCAsgAUGYKWooAgBFDQggAUGUKWoMBwsgAUGYKWooAgBFDQcgAUGUKWoMBgsgAUGYKWooAgBFDQYgAUGUKWoMBQsgAUGoKWooAgAEQCABQaQpaigCABBSCyABQbApaigCAEUNBSABQawpagwECyABQZgpaigCAARAIAFBlClqKAIAEFILIAFBoClqKAIARQ0EIAFBnClqDAMLIAFBmClqKAIABEAgAUGUKWooAgAQUgsgAUGgKWooAgBFDQMgAUGcKWoMAgsgAUG0KWooAgAEQCABQbApaigCABBSCyABQbwpaigCAEUNAiABQbgpagwBCyABQZgpaigCAARAIAFBlClqKAIAEFILIAFBoClqKAIARQ0BIAFBnClqCygCABBSCyABQZgqaigCAARAIAEoApQqEFILIAFB7ChqKAIABEAgASgC6CgQUgsgAUH0KGooAgAEQCABKALwKBBSCyABQfwoaigCAARAIAEoAvgoEFILIAFBhClqKAIABEAgASgCgCkQUgsgAUGMKWooAgAEQCABKAKIKRBSCyABQdAqaiQAC5cGAQR/IwBBkAFrIgEkACABQZABaiEDIAFBEGohAgNAIAJBADsBACACQQJqQQA6AAAgAkEEaiICIANHDQALIABCADcDwA0gAEEAOgCKESAAQgA3A/ANIABCADcDiA4gAEHYDWpCADcDACAAQdANakIANwMAIABByA1qQgA3AwAgAEH4DWoiAkIANwMAIABBgA5qQQA2AgAgAEHQD2pBAEEkEKMHGiAAQQA7AfAQIABCATcDkA4gAEHoDWpCi4CAgMAANwMAIABCkICAgPABNwPgDSAAQbyb6wA2AugQIABBADYC/A8gAEIANwL0DyAAQaQOakIANwIAIABBoA5qQQI2AgAgAEIENwOYDiAAQawOakEAOwEAIABBuA5qQQI2AgAgAEIENwOwDiAAQbwOakIANwIAIABBxA5qQQA7AQAgAEIENwPIDiAAQdAOakECNgIAIABB3A5qQQA7AQAgAEHUDmpCADcCACAAQQA2AogQIABCADcDgBAgAEIANwOIDyAAQZAPakIANwMAIABBmA9qQgA3AwAgAEGoD2pBAjYCACAAQaAPakICNwMAIABCADcCjBAgAEGUEGpCADcCACAAQawPakEAQSEQowcaIABBADoAkBEgAEEAOwGEESAAQgE3A+AOIABBATYC7BAgAEGcEGpBAEEkEKMHGiAAIAFBEGpBgAEQpQciAEIANwHyECAAQRA2AsAQIABB+hBqQgA3AQAgAEGCEWpBADsBACAAQgA3AsQQIABBzBBqQgA3AgAgAEHUEGpBADYCACAAQYABakEAQcAMEKMHGiAAQf8BNgLYECAAQgI3A+gOIABBkRFqQQBBgQIQowcaIABBADsBkhMgAEEANgLcECAAQgE3A/AOIABBADYAixEgAEEANgGGESAAQgA3A+AQIABCATcDgA8gAEIBNwP4DiAAQQE6AI8RIAFBCGpBuAgQygQgASgCDCEDIAEoAgghBCAAQewOaigCAARAIAAoAugOEFILIAAgBDYC6A4gAEIANwPwDSAAIAM2AuwOIAJBwAA2AgAgAUGQAWokAAuoBQIFfwZ+IwBBgAFrIgMkACABvSEIAkAgASABYgRAQQIhBAwBCyAIQv////////8HgyIMQoCAgICAgIAIhCAIQgGGQv7///////8PgyAIQjSIp0H/D3EiBhsiCUIBgyEKQQMhBAJAAkACQEEBQQJBBCAIQoCAgICAgID4/wCDIg1QIgcbIA1CgICAgICAgPj/AFEbQQNBBCAHGyAMUBtBfmoOAwABAgMLQQQhBAwCCyAGQc13aiEFIAqnQQFzIQRCASELDAELQoCAgICAgIAgIAlCAYYgCUKAgICAgICACFEiBRshCUICQgEgBRshCyAKp0EBcyEEQct3Qcx3IAUbIAZqIQULIAMgBTsBeCADIAs3A3AgA0IBNwNoIAMgCTcDYCADIAQ6AHoCfyAEQQJGBEBByNvrACECQQAMAQsgAkUEQEG78+sAQcjb6wAgCEIAUxshAiAIQj+IpwwBC0G78+sAQbzz6wAgCEIAUxshAkEBCyEGQQEhBQJ/AkACQAJAAkAgBEF+akEDIARBAUsbQf8BcUEBaw4DAgEAAwsgA0EgaiADQeAAaiADQQ9qECQCQCADKAIgRQRAIANB0ABqIANB4ABqIANBD2oQDAwBCyADQdgAaiADQShqKAIANgIAIAMgAykDIDcDUAsgAyADKAJQIAMoAlQgAy8BWEEAIANBIGoQ8AEgAygCBCEFIAMoAgAMAwsgA0ECOwEgIANBATYCKCADQb3z6wA2AiQgA0EgagwCCyADQQM2AiggA0G+8+sANgIkIANBAjsBICADQSBqDAELIANBAzYCKCADQcHz6wA2AiQgA0ECOwEgIANBIGoLIQQgA0HcAGogBTYCACADIAQ2AlggAyAGNgJUIAMgAjYCUCAAIANB0ABqEK4BIANBgAFqJAALhgYBH38jAEGAAWsiASQAIAFB+ABqQYCABBDWBSABKAJ4IQIgASgCfCEDIAFB8ABqQYCABBDWBSABKAJwIQQgASgCdCEFIAFB6ABqQYCABBDWBSABKAJoIQYgASgCbCEHIAFB4ABqQYCABBDWBSABKAJgIQggASgCZCEJIAFB2ABqQYCABBDWBSABKAJYIQogASgCXCELIAFB0ABqQYCABBDWBSABKAJQIQwgASgCVCENIAFByABqQYCABBDWBSABKAJIIQ4gASgCTCEPIAFBQGtBgIAEENYFIAEoAkAhECABKAJEIREgAUE4akGAgAQQ1gUgASgCOCESIAEoAjwhEyABQTBqQYCABBDWBSABKAIwIRQgASgCNCEVIAFBKGpBgIAEENYFIAEoAighFiABKAIsIRcgAUEgakGAgAQQ1gUgASgCICEYIAEoAiQhGSABQRhqQYCABBDWBSABKAIYIRogASgCHCEbIAFBEGpBgIAEENYFIAEoAhAhHCABKAIUIR0gAUEIakGAgAQQ1gUgASgCCCEeIAEoAgwhHyAAQfcBakIANwAAIABCADcD8AEgACAfNgLsASAAIB42AugBIABCADcD4AEgACAdNgLcASAAIBw2AtgBIABCADcD0AEgACAbNgLMASAAIBo2AsgBIABCADcDwAEgACAZNgK8ASAAIBg2ArgBIABCADcDsAEgACAXNgKsASAAIBY2AqgBIABCADcDoAEgACAVNgKcASAAIBQ2ApgBIABCADcDkAEgACATNgKMASAAIBI2AogBIABCADcDgAEgACARNgJ8IAAgEDYCeCAAQgA3A3AgACAPNgJsIAAgDjYCaCAAQgA3A2AgACANNgJcIAAgDDYCWCAAQgA3A1AgACALNgJMIAAgCjYCSCAAQgA3A0AgACAJNgI8IAAgCDYCOCAAQgA3AzAgACAHNgIsIAAgBjYCKCAAQgA3AyAgACAFNgIcIAAgBDYCGCAAQgA3AxAgACADNgIMIAAgAjYCCCAAQgA3AwAgAUGAAWokAAuGBAACQAJ/AkACQAJAAkACQAJAAkACQAJAAkAgACgCiCkOCgsBAgMEBQYHCAkACyAAQZApaigCAARAIABBjClqKAIAEFILIABBmClqKAIARQ0KIABBlClqDAkLIABBkClqKAIARQ0JIABBjClqDAgLIABBkClqKAIARQ0IIABBjClqDAcLIABBkClqKAIARQ0HIABBjClqDAYLIABBkClqKAIARQ0GIABBjClqDAULIABBoClqKAIABEAgAEGcKWooAgAQUgsgAEGoKWooAgBFDQUgAEGkKWoMBAsgAEGQKWooAgAEQCAAQYwpaigCABBSCyAAQZgpaigCAEUNBCAAQZQpagwDCyAAQZApaigCAARAIABBjClqKAIAEFILIABBmClqKAIARQ0DIABBlClqDAILIABBrClqKAIABEAgAEGo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A3FBA0YbIAMgAUF/RxshAwsgAEH0DmooAgAhBSAAKALwDiEHAkACQAJAAkACQAJAAkAgACgC3BAiAiAEQXBqIgFNBEAgAiAFTQRAIAIhAQwCCyACIAVBvKnjABCHBwALIAIgBUsNASAAIAE2AtwQIAcgAiABa2ohBwsCQCADQf8BcUUgBEEhSHINACAEIAAoAogQIAFqQQF0IgVIDQAgBCECA0ACQCACQQF1IQMgAkHCAEgNACADIQIgAyAFTg0BCwsgACADIAQgAyAESBsiBDYC6A8LIAAgBEF/aiIDNgLsDyAGQQhqIARBwgBqIgJBARCCBSAGKQMIIQogBiACNgIYIAYgCjcDECAGIAZBEGoQlwUgBigCBCECIAYoAgAhBCAAQZQOaigCAARAIAAoApAOEFILIAAgAjYClA4gACAENgKQDgJAIAJFDQAgAyACTw0CIAMgBGpBADoAACAAKALoD0F+aiIDIAAoApQOIgRPDQMgACgCkA4iCSADakEAOgAAIAEEQCAAKALsD0EAIAAoAtwQIgNrcSIFIANqIgggBUkNBSAIIARLDQYgASADRw0HIAUgCWogByABEKUHGgsgACgC9A5FDQAgACgC8A4gAEIBNwPwDhBSCyAGQSBqJAAgAkEARw8LIAIgBUGsqeMAEIcHAAsgAyACQcyp4wAQvAQACyADIARB3KnjABC8BAALIAUgCEHsqeMAEIgHAAsgCCAEQeyp4wAQhwcACyADIAFB/KnjABDABAAL+QQBCn8jAEEwayIDJAAgA0EDOgAoIANCgICAgIAENwMgIANBADYCGCADQQA2AhAgAyABNgIMIAMgADYCCAJ/AkACQCACKAIAIgpFBEAgAkEUaigCACIARQ0BIAIoAhAhASAAQQN0IQUgAEF/akH/////AXFBAWohByACKAIIIQADQCAAQQRqKAIAIgQEQCADKAIIIAAoAgAgBCADKAIMKAIMEQMADQQLIAEoAgAgA0EIaiABQQRqKAIAEQEADQMgAUEIaiEBIABBCGohACAFQXhqIgUNAAsMAQsgAigCBCIARQ0AIABBBXQhCyAAQX9qQf///z9xQQFqIQcgAigCCCEAA0AgAEEEaigCACIBBEAgAygCCCAAKAIAIAEgAygCDCgCDBEDAA0DCyADIAUgCmoiBEEcai0AADoAKCADIARBFGopAgA3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RQ0DIABBDGoMAgsgAEEkaigCAARAIABBIGooAgAQUgsgAEEsaigCAEUNAiAAQShqDAELIABBCGooAgAEQCAAKAIEEFILIABBEGooAgBFDQEgAEEMagsoAgAQUgsL5wMBDH8jAEFAaiICJAACQAJAAkACQAJAIAEtAABBAWsOBgADBAIEBAELIAAgACgCmAEgAUEKai0AAGo2ApgBDAMLIAAgACgCmAEgAUEIaigCAGo2ApgBDAILIAAgAS8AATsBnAEMAQsgAkIANwMwIABBOGohBUEHIQQDQCAAKAKYASIGIANLBEAgAkEwaiAEaiAFIAQgBmpBeGpB3J/AABDUBS0AADoAAAsgA0EBaiEDIARBf2oiBEF/Rw0ACyACQShqIAFBBGoiBhCYByACKAIsIgEEQCACKAIoIQQgAEHcAGohCSAAQdAAaiEKQQAhAwNAIAJBMGogA0EGakEHcXItAAAhByADQX9qQQdxIgsgAkEwanItAAAhCCACQSBqIAoQmAcgAigCJCEMIAIoAiAhDSACQRhqIAkQmAdBACEFIAJBEGogCCAHIA0gDCACKAIcBH8gAigCGC0AAAUgBQsgAC0AnAEQlgQgBC0AACEFIAItABQhByACKAIQIQggAiACKQMwNwM4IAAgAkE4aiALIAggBRAKIAJBMGogA2ogBC0AADoAACADQQFqQQdxIQMgBEEBaiEEIAFBf2oiAQ0ACwsgAkEIaiAGEJgHIAAgACgCmAEgAigCDGo2ApgBCyACQUBrJAAL3QMBCn8jAEFAaiICJAACQAJAAkACQAJAIAEtAABBAWsOBgADBAIEBAELIAAgACgCaCABQQpqLQAAajYCaAwDCyAAIAAoAmggAUEIaigCAGo2AmgMAgsgACABLQABIAFBAmotAAAQ0wIMAQsgAkIANwMwIABByABqIQVBByEEA0AgACgCaCIGIANLBEAgAkEwaiAEaiAFIAQgBmpBeGpB/ILBABDUBS0AADoAAAsgA0EBaiEDIARBf2oiBEF/Rw0ACyACQShqIAFBBGoiBhCYByACKAIsIgEEQCACKAIoIQRBACEDA0AgAkEwaiADQQZqQQdxci0AACEHIANBf2pBB3EiCCACQTBqci0AACEJIAJBIGogACgCdBCYByACKAIkIQogAigCICELIAJBGGogACgCdEEMahCYB0EAIQUg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AogWIgAgAUECdGoqAgAgACoCAJMiDV8EQCAIQQhqQgA3AwAgCEIANwMAIAggATYCECAIIAw4AhggCCAMIA2TOAIUIAEgAyAGIAcgCBCDAiAFIAgQlAILIAhBIGokAA8LIAEgB0HkjMEAELwEAAsgACAHQcyPwQAQvAQACyABIABBwJDBABC8BAALsgMCAX8DfiMAQSBrIgEkACAAQcAnahCGBSABQRhqEKoHIAEpAxghAiABQRBqEKwHIAEpAxAhAyABQQhqEKoHIAEpAwghBCABEKoHIAAgASkDADcCjCogAEIANwPAKCAAQQA2AogpIABBlCpqQgA3AgAgAEEANgLoKSAAQZwqakIANwIAIABBpCpqQgA3AgAgAEGsKmpBADYCACAAQQA2AvQpIABCADcC7CkgAEIENwPgKCAAQgA3A8goIABB0ChqQgA3AwAgAEGIJ2pCj4CAgIACNwMAIABChICAgLABNwOAJyAAQZAnakEAQTAQowcaIABBADYCtCogAEEANgL4KSAAQagoakKPgICAgAI3AwAgAEKEgICAsAE3A6AoIABBuCpqQQA6AAAgACACNwPoKCAAQQBBgCAQowciAEEANgL8KSAAQgQ3A/AoIABBgCBqQQBBgAcQowcaIABBAjYC4CkgACAENwOAKSAAIAM3A/goIABCADcD2CggAEIANwOwKCAAQbgoakIANwMAIABBADYCsCogAEIANwOAKiAAQQA2ALkqIABBADYCiCogAUEgaiQAC/ECAQR/QRAhBwJAAkACQAJAAkACQAJAAkAgACADSQRAIAIgAEEUbGoiACgCAEECRw0FIAAoAgQiAEUNBSAEIQgDQCAGIQUgACADTw0CIAVBBEYNAyAIIAIgAEEUbGoiBigCDDYCACAAIAYoAghB////D3EgBigCEEH///8/cWprIgAgA08NBCACIABBFGxqIgAoAgBBAkcgBUECS3INBSAFQQFqIQYgCEEEaiEIIAAoAgQiAA0ACwwECyAAIANB5JbjABC8BAALIAAgA0H0luMAELwEAAtBBEEEQYSX4wAQvAQACyAAIANBlJfjABC8BAALIAVBAksNASAFQQFqIQULIAVBBCAFQQRLGyECIAQgBUECdGohAANAIAdFDQMgAiAFRg0CIAAgASgCADYCACAAQQRqIQAgAUEEaiEBIAdBf2ohByAF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AkACQAJAQeGT7AAtAABBAWsOAwIEAQALQeGT7ABBAjoAACABQeGT7AA2AgggACgCACIALQAAIABBADoAAEEBcUUNAhDRAiABQQM6AAwgAUEIaiIAKAIAIAAtAAQ6AAALIAFBIGokAA8LIAFBFGpBATYCACABQRxqQQA2AgAgAUHoocAANgIQDAILQfChwABBK0HoosAAELgFAAsgAUEUakEBNgIAIAFBHGpBADYCACABQbShwAA2AhALIAFB8J/AADYCGCABQQA2AgggAUEIakHUoMAAEI8GAAvmAQEFfyMAQSBrIgMkAAJAIAEoAgAiByACTwRAQYGAgIB4IQQgB0UNASABKAIEIQZBASEFAkAgAgRAAkAgAkF/TARAIAJBARDpBiIFDQFBACEEDAULQQEhBCAGIAdBASACEN4GIgUNAgwECyAFIAYgAhClBxoLIAYQUgsgASACNgIAIAEgBTYCBEGBgICAeCEEDAELIANBFGpBATYCACADQRxqQQA2AgAgA0GYqsEANgIQIANB9KnBADYCGCADQQA2AgggA0EIakHsqsEAEI8GAAsgACAENgIEIAAgAjYCACADQSBqJAAL3AEBA38jAEEQayIEJAAgACACNgIEIAAgATYCAAJ/IAAtAFZFBEBBASABQRpqdCACakF/IAFBAmp0aiEFQRgMAQsgBEKMgICAwAM3AgggBEKAgICAwAA3AgACQCABQQNNBEAgBCABQQJ0aigCACIDIAJLBEAgAiADa0H8//8/aiEFDAILQfz//z8hBSADQQEgAXRqIAJLDQEgAiADa0H8////BWohBQwBCyABQQRBoJvjABC8BAALQT4LIQMgACAFNgIMIAAgAiADIAFBAWp0akEQajYCCCAEQRBqJAAL5gEBBX8jAEEgayIDJAACQCABKAIAIgcgAk8EQEGBgICAeCEEIAdFDQEgASgCBCEGQQEhBQJAIAIEQAJAIAJBf0wEQCACQQEQ6QYiBQ0BQQAhBAwFC0EBIQQgBiAHQQEgAhDeBiIFDQIMBAsgBSAGIAIQpQcaCyAGEFILIAEgAjYCACABIAU2AgRBgYCAgHghBAwBCyADQRRqQQE2AgAgA0EcakEANgIAIANB4KvrADYCECADQbyr6wA2AhggA0EANgIIIANBCGpBtKzrABCPBgALIAAgBDYCBCAAIAI2AgAgA0Eg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IAU2AgRBgYCAgHghBgsgACAGNgIEIAAgBDYCACADQSBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEAOgAgIAAgAkEQahDLAQsgAUEMaiIBKAIEBEAgAkEMaiABQQhqKAAANgAAIAIgASkAADcABCACQRhqIAJBCGopAAA3AAAgAkECOgAQIAIgAikAATcAESACQQA6ACAgACACQRBqEMsBCyACQTBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEBOgAgIAAgAkEQahDLAQsgAUEMaiIBKAIEBEAgAkEMaiABQQhqKAAANgAAIAIgASkAADcABCACQRhqIAJBCGopAAA3AAAgAkECOgAQIAIgAikAATcAESACQQE6ACAgACACQRBqEMsBCyACQTBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEAOgAgIAAgAkEQahDNAQsgAUEMaiIBKAIEBEAgAkEMaiABQQhqKAAANgAAIAIgASkAADcABCACQRhqIAJBCGopAAA3AAAgAkECOgAQIAIgAikAATcAESACQQA6ACAgACACQRBqEM0BCyACQTBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEBOgAgIAAgAkEQahDNAQsgAUEMaiIBKAIEBEAgAkEMaiABQQhqKAAANgAAIAIgASkAADcABCACQRhqIAJBCGopAAA3AAAgAkECOgAQIAIgAikAATcAESACQQE6ACAgACACQRBqEM0BCyACQTBqJAALwQEBAX8jAEEwayICJAAgASgCBARAIAJBDGogAUEIaigAADYAACACIAEpAAA3AAQgAkEYaiACQQhqKQAANwAAIAJBAjoAECACIAIpAAE3ABEgAkEA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NgKACCAEQYgIaiEEIAVBf2oiBQ0ACyABIANqQX9qIQMLIAAgAQR/IAQgAkGICBClBxogA0EBagUgAws2AggLqgEBA38jAEEwayICJAAgASgCBEUEQCABKAIMIQMgAkEQaiIEQQA2AgAgAkKAgICAEDcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUakG0wusAIAJBGGoQqwEaIAFBCGogBCgCADYCACABIAIpAwg3AgALIABBjM3rADYCBCAAIAE2AgAgAkEwaiQAC58BAQF/AkAgA0EDdiIHIAZJBEAgBCADNgIAIAUgB2oiByAHLQAAQX8gA0EHcXRBf3NxOgAAIAJBASAEIAUgBhCUBSAFIAYgBCgCAEEHaiIDQQN2IAAgASACEMMEIAQgA0F4cSACQQN0aiIANgIAIABBA3YiACAGSQ0BIAAgBkH0h+MAELwEAAsgByAGQeSH4wAQvAQACyAAIAVqQQA6AAALpgECAn8BfgJAAkAgACgCCCIDQSBPBEAgACADQSBzNgIIIAAoAgwiBEEEaiEDIARBe0sNASADIAJLDQIgACkDACEFIAAgAzYCDCAAIAAoAhBBfGo2AhAgACABIARqIgAxAAFCKIYgADEAAEIghiAFQiCIhIQgADEAAkIwhoQgADEAA0I4hoQ3AwALDwsgBCADQfi56wAQiAcACyADIAJB+LnrABCHBwALqQEBAX8jAEEgayIEJAAgASADRgRAIAEEQANAIAAgAkGAFhClByIAQYQWaiACQYQWaioCADgCACAAQYAWaiACQYAWaigCADYCACAAQYgWaiEAIAJBiBZqIQIgAUF/aiIBDQALCyAEQSBqJAAPCyAEQRRqQQE2AgAgBEEcakEANgIAIARBmJzAADYCECAEQdSbwAA2AhggBEEANgIIIARBCGpBzNfAABCPBgALqQEBAX8jAEEgayIEJAAgASADRgRAIAEEQANAIAAgAkGACBClByIAQYQIaiACQYQIaioCADgCACAAQYAIaiACQYAIaigCADYCACAAQYgIaiEAIAJBiAhqIQIgAUF/aiIBDQALCyAEQSBqJAAPCyAEQRRqQQE2AgAgBEEcakEANgIAIARBmJzAADYCECAEQdSbwAA2AhggBEEANgIIIARBCGpBzNfAABCPBgALqAEBBH8jAEEQayICJAACQAJAIAAgACgCCCIBBH8gAQUgACAAKAIAQQFqIgE2AgAgAkEIaiAAKAIMIgMQmAcgASACKAIMIgRPDQIgACACKAIIIAFqLQAANgIEIAIgA0EIahCYByABIAIoAgQiA08NASACKAIAIAFBAnRqKAIAC0F/ajYCCCACQRBqJAAPCyABIANB0J3AABC8BAALIAEgBEHAncAAELwEAAuwAQAgAAJ/AkACQAJAAkACQAJAAkAgAS0AAEEBaw4GAQIDBAUGAAsgACABKQIENwIEQQAMBgsgACABKQIENwIEQQEMBQsgACABKQIENwIEIABBDGogAUEMai0AADoAAEECDAQLIAAgAS0AAToAAUEDDAMLIAAgAS8AATsAAUEEDAILIAAgAS0AAToAAUEFDAELIAAgASkCBDcCBCAAQQxqIAFBDGopAgA3AgBBBgs6AAALoAEBAn8jAEHAM2siAiQAIAJBsBFqEPEGIAJBKGogAkGwEWoQywYgAkEQaiABEN4DIAJBIGoiA0EANgIAIAIgAikDEDcDGCACQbgiaiACQShqQYgREKUHGiACQRhqIAEgAkG4ImoQ2wMgAkHAImogAygCADYCACACIAIpAxg3A7giIAJBCGogAkG4ImoQjQUgACACKQMINwMAIAJBwDNqJAALmgEBBn8jAEEQayICJAACfwJAAkAgACgCCCIBIAAoAgQiA0kEQCAAKAIAIQQDQCABIARqLQAAIgVBd2oiBkEXS0EBIAZ0QZOAgARxRXINAiAAIAFBAWoiATYCCCABIANHDQALCyACQQM2AgAMAQsgBUE6RgRAIAAgAUEBajYCCEEADAILIAJBBjYCAAsgACACEMwECyACQRBqJAALkwEBB38jAEEQayIEJAAgACgCCCIDIAAoAgQiBSADIAVLGyEGIAAoAgAhBwJ/AkADQEEAIAJFDQIaIAMgBkYEQCAEQQU2AgAMAgsgACADQQFqIgU2AgggAkF/aiECIAMgB2ohCCABLQAAIAUhAyABQQFqIQEgCC0AAEYNAAsgBEEJNgIACyAAIAQQkwULIARBEGokAAujAQICfwF+IAQoAgQhBQJAAkAgBCgCACIGIAMoAgBGBEAgAygCBCAFRg0BCyABIAJJDQEgAkUNACACQQR0IQQgBq0hBwNAAkAgAEEEaigCAEH///8PcUUNACAAQQxqLwEAQf8ATQ0AIAAgAxDUBCAFIAcgAEEOaiAAQQhqENMDCyAAQRBqIQAgBEFwaiIEDQALCw8LQYiV4wBBI0Gwm+MAELgFAAukAQEEfyAAKALwDyEBIAAoAqgQIgJFBEAgAEEBNgKEECAAIAFBf2oiATYC8A8gACAAIAFBA3FBAnRqQeANaigCADYCqBAPC0GAyv5SIAJBAXQiBHZBA3EhAyAAQZv+v9V6IAR1IAFqQQNxQQJ0akHgDWooAgAhASACQQFxRQRAIABB/////wcgASADayIAIABBAUgbNgKoEA8LIAAgASADajYCqBALfwECfyAAQfwOaigCACAAKAL4DiECIABCATcD+A4EQCACEFILIABBhA9qKAIAIAAoAoAPIQIgAEIBNwOADwRAIAIQUgsgAEHkDmooAgAgACgC4A4hAiAAQgE3A+AOBEAgAhBSCyAAQZgOahCoBSAAQbAOahCoBSAAQcgOahCoBQuTAQEDfyMAQYABayIDJAAgAC8BACECQQAhAANAIAAgA2pB/wBqQTBB1wAgAkEPcSIEQQpJGyAEajoAACAAQX9qIQAgAiIEQQR2IQIgBEEPSw0ACyAAQYABaiICQYEBTwRAIAJBgAFBqPfrABCGBwALIAFBAUG49+sAQQIgACADakGAAWpBACAAaxCKASADQYABaiQAC5IBAQN/IwBBgAFrIgMkACAALQAAIQJBACEAA0AgACADakH/AGpBMEE3IAJBD3EiBEEKSRsgBGo6AAAgAEF/aiEAIAIiBEEEdiECIARBD0sNAAsgAEGAAWoiAkGBAU8EQCACQYABQaj36wAQhgcACyABQQFBuPfrAEECIAAgA2pBgAFqQQAgAGsQigEgA0GAAWokAAuTAQEDfyMAQYABayIDJAAgAC0AACECQQAhAANAIAAgA2pB/wBqQTBB1wAgAkEPcSIEQQpJGyAEajoAACAAQX9qIQAgAiIEQQR2IQIgBEEPSw0ACyAAQYABaiICQYEBTwRAIAJBgAFBqPfrABCGBwALIAFBAUG49+sAQQIgACADakGAAWpBACAAaxCKASADQYABaiQAC5IBAQN/IwBBgAFrIgMkACAALwEAIQJBACEAA0AgACADakH/AGpBMEE3IAJBD3EiBEEKSRsgBGo6AAAgAEF/aiEAIAIiBEEEdiECIARBD0sNAAsgAEGAAWoiAkGBAU8EQCACQYABQaj36wAQhgcACyABQQFBuPfrAEECIAAgA2pBgAFqQQAgAGsQigEgA0GAAWokAAu1AQEDfyMAQRBrIgEkACAAKAIAIgJBFGooAgAhAwJAAn8CQAJAIAJBDGooAgAOAgABAwsgAw0CQQAhAkHMwusADAELIAMNASACKAIIIgMoAgQhAiADKAIACyEDIAEgAjYCBCABIAM2AgAgAUHAzesAIAAoAgQiASgCCCAAKAIIIAEtABAQpwMACyABQQA2AgQgASACNgIMIAFBrM3rACAAKAIEIgEoAgggACgCCCABLQAQEKcDAAuNAQEDfyMAQYABayIDJAAgACgCACEAA0AgAiADakH/AGpBMEHXACAAQQ9xIgRBCkkbIARqOgAAIAJBf2ohAiAAQQ9LIABBBHYhAA0ACyACQYABaiIAQYEBTwRAIABBgAFBqPfrABCGBwALIAFBAUG49+sAQQIgAiADakGAAWpBACACaxCKASADQYABaiQAC4wBAQN/IwBBgAFrIgMkACAAKAIAIQADQCACIANqQf8AakEwQTcgAEEPcSIEQQpJGyAEajoAACACQX9qIQIgAEEPSyAAQQR2IQANAAsgAkGAAWoiAEGBAU8EQCAAQYABQaj36wAQhgcACyABQQFBuPfrAEECIAIgA2pBgAFqQQAgAmsQigEgA0GAAWokAAuSAQEDfyMAQUBqIgIkACACQQhqIAEQ5gMgAkEYaiIDQQA2AgAgAiACKQMINwMQIAJBOGpCADcDACACQTBqQgA3AwAgAkEoaiIEQgA3AwAgAkIANwMgIAJBEGogASACQSBqEOwCIAQgAygCADYCACACIAIpAxA3AyAgAiACQSBqEJIFIAAgAikDADcDACACQUBrJAALkgEBA38jAEFAaiICJAAgAkEIaiABEOgDIAJBGGoiA0EANgIAIAIgAikDCDcDECACQThqQgA3AwAgAkEwakIANwMAIAJBKGoiBEIANwMAIAJCADcDICACQRBqIAEgAkEgahDtAiAEIAMoAgA2AgAgAiACKQMQNwMgIAIgAkEgahCJBSAAIAIpAwA3AwAgAkFAayQAC6IBAQJ/IwBBEGsiBSQAIAACfwJAIANFQQAgBBtFBEAgASgCCCIDIAEoAgQiBE8NASABKAIAIQYDQCADIAZq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9+maHn5CMIinC5MBAgF/BX4jAEEQayICJAAgAkIANwMIIAFBB00EQEHkjsAAQSNBhJDAABC4BQALIAJBCGpBCCAAQQhBlJDAABDCBiACMQAIIQMgAjEACSACMQAKIQUgAjEACyEGIAIxAAwhByACQRBqJABCIIYgA0IYhoQgBUIohoQgBkIwhoQgB0I4hoRCvc/W8dH36ZoefkIviKcLigEBAX8jAEEgayIDJAACQCAABEAgAyACNgIYIAMgATYCFCADIAI2AhAgA0EIaiADQRBqEJ8GIAAoAgANASADKAIMIQEgAygCCCECIABBfzYCACAAQQhqKAIABEAgACgCBBBSCyAAIAI2AgQgAEEANgIAIAAgATYCCCADQSBqJAAPCxCSBwALEJMHAAuPAQECfyMAQRBrIgckAAJAIANFDQAgB0EANgIMIARBGU0EQCABIARBAnQiAUGmpOMAai0AACAHQQxqIAUgBhDOBEUEQCAAQQE6AEQgACAENgI0DAILIABBADoARCACIAcoAgwgAUGkpOMAai8BAGo2AgBBASEIDAELIARBGkGMpeMAELwEAAsgB0EQaiQAIAgLjQEBAX8jAEEgayICJAAgASgCBARAIAJBEGpBADoAACACQQxqIAFBCGooAgA2AgAgAkECOgAAIAIgASkCADcCBCAAIAIQwgILIAFBDGoiASgCBARAIAJBEGpBADoAACACQQxqIAFBCGooAgA2AgAgAkECOgAAIAIgASkCADcCBCAAIAIQwgILIAJBIGokAAuNAQEBfyMAQSBrIgIkACABKAIEBEAgAkEQakEBOgAAIAJBDGogAUEIaigCADYCACACQQI6AAAgAiABKQIANwIEIAAgAhDCAgsgAUEMaiIBKAIEBEAgAkEQakEBOgAAIAJBDGogAUEIaigCADYCACACQQI6AAAgAiABKQIANwIEIAAgAhDCAgsgAkEgaiQAC40BAQJ/IwBBsAhrIgIkACACQRBqIAEQ4gMgAkEgaiIDQQA2AgAgAiACKQMQNwMYIAJBKGpBAEGECBCjBxogAkGj4P/7BzYCrAggAkEYaiABIAJBKGoQ6gMgAkEwaiADKAIANgIAIAIgAikDGDcDKCACQQhqIAJBKGoQiwUgACACKQMINwMAIAJBsAhqJAALjQEBAn8jAEGwFmsiAiQAIAJBEGogARDgAyAC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rAcgACgCBCECIAEoAgAhAyAAIAEoAgQ2AgQgACgCACAAIAM2AgAgAhDSBiABQRBqJAALdgEGfwJAIAEoAggiAiABKAIEIgRPDQAgASgCACEFQQEhAwNAIAIgBWotAAAiBkF3aiIHQRdLQQEgB3RBk4CABHFFcg0BIAEgAkEBaiICNgIIIAIgBEcNAAtBACEDCyAAIAM6AAEgAEEAOgAAIABBAmogBjoAAAuGAQECf0H06eIAIQUCQAJAAkACQAJAIAEoAgBBAWsOAgECAAsgASgCBCIBIANLDQIgAyABayEGIAEgAmohBQwBCyABKAIEIgFBEU8NAkEQIAFrIQYgASAEaiEFCyAAIAY2AgQgACAFNgIADwsgASADQdzq4gAQhgcACyABQRBBzOriABCGBwALdQEBfwJAAkACQCABRQRAQQEhASAAQXBqDgIDAQILIABBCHRBgP4AcUERciEEQQ4hAQwCC0EHIQFBASEEDAELIABBEUwEQCAAQQR0QYF/aiEEQQchAQwBCyAAQQF0QV9qIQRBBCEBCyADIAE6AAAgAiAEOwEAC48BAQN/AkACQAJAIAAtAJARBEAgAEGUDmooAgAiASAAKALoDyICSQ0BIAIgACgC2A8iA0kNAiABIAJrIANJDQMgACgCkA4iASABIAJqIAMQpQcaIABBADoAkBELDwtByJ3jAEEjQeyo4wAQuAUAC0HIneMAQSNB/KjjABC4BQALQcid4wBBI0GMqeMAELgFAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakECNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0HI9OsANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEI8GAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakECNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0Go++sANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEI8GAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakECNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0HI++sANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEI8GAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakECNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0H8++sANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEI8GAAt3AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EUakEDNgIAIANBHGpBAjYCACADQSxqQSc2AgAgA0HM/OsANgIQIANBADYCCCADQSc2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEI8GAAtjAQV/IwBBEGsiASQAIAFBCGoQqgcgACgCECABKAIMIQMgACABKAIINgIQIABBFGoiBCgCACAEIAM2AgAQ0gYgAEEcaigCACAAKAIYIQMgAEICNwIYBEAgAxBSCyABQRBqJAALdwEEfwJAAkAgASgCCCIFIAEoAgQiBk8NACABKAIAIQcDQCAFIAdqLQAAIghBUGpB/wFxQQpJBEAgASAFQQFqIgU2AgggBSAGRw0BDAILCyAIQSByQeUARg0BCyAAIAEgAiADIAQQ6AIPCyAAIAEgAiADIAQQ6wELeQEBfwJAAkACQCACIAVqIgYgBU8EQCAGIAFLDQEgBSIBIAVJDQIgASAESw0DIAAgAmogBSADIAVBxOTiABDCBg8LIAIgBkGk5OIAEIgHAAsgBiABQaTk4gAQhwcAC0EAIAFBtOTiABCIBwALIAEgBEG05OIAEIcHAAt2AQF/IwBBEGsiBSQAAkAgAyAEcSIDIAJNBEAgASADaiACIANrEI0EIQEgBUEIaiAAEJgHIAEgBSgCDCIASQ0BIAEgAEG8hcAAELwEAAtB5I7AAEEjQayFwAAQuAUACyAFKAIIIAFBAnRqIAQ2AgAgBUEQaiQAC3MBA38jAEEgayICJAAgAkEQakGAgAgQ1gUgAiACKQMQNwMYIAJBCGogAkEYahCYByACKAIMIgMEQCACKAIIIQQgA0ECdCEDA0AgBCABNgIAIARBBGohBCADQXxqIgMNAAsLIAAgAikDGDcDACACQSBqJAALZQEDfyABKAIAIgMoAgAhBAJAQYAgIAMoAgQiBUGAICAFSRsiAUEBRwRAIAIgASAEIAEQvQYMAQsgAiAELQAAOgAACyAAIAE2AgQgAEEEOgAAIAMgBSABazYCBCADIAEgBGo2AgALdAECfyMAQSBrIgIkACAAAn8gASgCCCIDIAEoAgRPBEAgAkEIaiABIAMQrwQgAigCDCEBIAIoAgghAyACQQQ2AhAgACACQRBqIAMgARDmBTYCBEEBDAELIAAgASgCACADai0AADoAAUEACzoAACACQSBqJAALWAEEfyAAQeQAaigCACAAKAJgIQIgAEIENwJgBEAgAhBSC0EAIQEDQCAAIAFqIgIoAgAhAyACQQRqKAIAIAJCAjcCAARAIAMQUgsgAUEIaiIBQcAARw0ACwtkAQJ/AkACfyAAKAI4IgFBAk8EQEEOIAFBBEgNARogACgCQCICDQIgACgCPCIAQRIgAEESSBtBECAAQRBKG0EQIAFBCEsbDwsgACgCPAsPCyACQRAgAkEQShsiAEEYIABBGEgbC2kBAn8jAEEwayICJAAgAkEIaiABEKYEIAJBGGoiA0EANgIAIAIgAikDCDcDECACQRBqIAEQhwQgAkEoaiADKAIANgIAIAIgAikDEDcDICACIAJBIGoQlgUgACACKQMANwMAIAJBMGokAAtrAQJ/IwBBMGsiAiQAIAJBCGogAUEAEIIFIAJBGGoiA0EANgIAIAIgAikDCDcDECACQRBqIAEQsQQgAkEoaiADKAIANgIAIAIgAikDEDcDICACIAJBIGoQjAUgACACKQMANwMAIAJBMGokAAtpAQJ/IwBBIGsiAiQAIAJBCGogACAAKAIEIgMgACgCCEEBaiIAIAMgAEkbEK8EIAIoAgwhACACKAIIIQMgAkEYaiABQQhqKAIANgIAIAIgASkCADcDECACQRBqIAMgABDmBSACQSBqJAALdwEBfyMAQRBrIgQkACAEQgA3AwAgBEEANgIIIARBADYCDEEBQgAgASACIAMQrQIgACAEIARBCGogBEEMahDHA0ECIAQ1AgwgASACIAMQrQIgBCgCCCAEKQMAIAEgAiADEK0CQQFCASABIAIgAxCtAiAEQRBqJAALcgECfwJAA0ACQEHAACAAKAIIIgVrIgYgAU8EQCABQSFPDQMgACABIAVqNgIIIAIgAUECdEH4t+sAaigCACAAKQMAIAVBP3GtiKdxNgIADAELIAAgAyAEEN4EDQELCyAGIAFPDwsgAUEh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IgIkACACQQhqQQ5BABCCBSACKAIIIQMgAigCDCABQQ4QpQchBEEMQQQQ6QYiAUUEQEEMQQQQoQcACyABQQ42AgggASAENgIEIAEgAzYCACAAQcipwQA2AgQgACABNgIAIAJBEGokAAtmAgF/AX4jAEEQayIEJAAgBEIANwMIIAFBB00EQEG42OIAQSNB2NniABC4BQALIARBCGpBCCAAQQhB6NniABDCBiAEKQMIIARBEGokACADQThsQThxrYZCvc/W8QF+IAJBP3GtiKcLYgEBfyACQQEgAyAEIAUQlAUgBCAFIAMoAgBBB2oiBkEDdiAAIAEgAhDDBCADIAZBeHEgAkEDdGoiADYCACAAQQN2IgAgBUkEQCAAIARqQQA6AAAPCyAAIAVB1OniABC8BAALaAECfwJAA0ACQEHAACAAKAIIIgVrIgYgAU8EQCABQSFPDQMgAiABQQJ0Qfi36wBqKAIAIAApAwAgBUE/ca2Ip3E2AgAMAQsgACADIAQQ3gQNAQsLIAYgAU8PCyABQSFB6LnrABC8BAALWQECfyMAQSBrIgIkACABKAIEIQMgASgCACACQRhqIAAoAgAiAEEQaikCADcDACACQRBqIABBCGopAgA3AwAgAiAAKQIANwMIIAMgAkEIahCrASACQSBqJAALYwEBfyMAQSBrIgQkACAEIAE2AgQgBCAANgIAIARBGGogAkEQaikCADcDACAEQRBqIAJBCGopAgA3AwAgBCACKQIANwMIQQAgBEGcssAAIARBBGpBnLLAACAEQQhqIAMQ5AEAC2MBAX8jAEEgayIEJAAgBCABNgIEIAQgADYCACAEQRhqIAJBEGopAgA3AwAgBEEQaiACQQhqKQIANwMAIAQgAikCADcDCEEAIARBrLLAACAEQQRqQayywAAgBEEIaiADEOQBAAtpAQF/IwBBIGsiAiQAIAJBoNPBADYCBCACIAA2AgAgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwhBACACQZDewQAgAkEEakGQ3sEAIAJBCGpBjNTBABDkAQALZgEBfyMAQSBrIgMkACADQcSR4wA2AgQgAyAANgIAIANBGGogAUEQaikCADcDACADQRBqIAFBCGopAgA3AwAgAyABKQIANwMIQQEgA0Gg3sEAIANBBGpBoN7BACADQQhqIAIQ5AEAC2MBAX8jAEEgayIEJAAgBCABNgIEIAQgADYCACAEQRhqIAJBEGopAgA3AwAgBEEQaiACQQhqKQIANwMAIAQgAikCADcDCEEAIARBsN7BACAEQQRqQbDewQAgBEEIaiADEOQBAAtjAQF/IwBBIGsiBCQAIAQgATYCBCAEIAA2AgAgBEEYaiACQRBqKQIANwMAIARBEGogAkEIaikCADcDACAEIAIpAgA3AwhBACAEQfzb4wAgBEEEakH82+MAIARBCGogAxDkAQALZgEBfyMAQSBrIgMkACADIAE2AgQgAyAANgIAIANBGGogAkEQaikCADcDACADQRBqIAJBCGopAgA3AwAgAyACKQIANwMIQQAgA0GM3OMAIANBBGpBjNzjACADQQhqQeza4wAQ5AEAC2kBAX8jAEEgayICJAAgAkHswusANgIEIAIgADYCACACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCEEAIAJB8MLrACACQQRqQfDC6wAgAkEIakGk0+sAEOQBAAtmAQF/IwBBIGsiAyQAIAMgATYCBCADIAA2AgAgA0EYaiACQRBqKQIANwMAIANBEGogAkEIaikCADcDACADIAIpAgA3AwhBACADQaz16wAgA0EEakGs9esAIANBCGpBmNzrABDkAQALXwECfyMAQRBrIgIkACACQQhqIABBCGoQmAcgAigCCCACKAIMIQAgAiABQQhqEJgHIAIoAgQiASAARwRAIAAgAUGchsEAEMAEAAsgAigCACAAQQJ0EKUHGiACQRBqJAALWgEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGgqcEAIAJBCGoQqwEgAkEgaiQAC28AAkACQAJAAkAgAkH/AXFBAWsOAwEDAgALIABBP3EPCyAAQfwBcUECdg8LIAFB/wFxQZDB0gBqLQAAIABB/wFxQZDB0gBqLQAAQQN0ag8LIAFB/wFxQZDF0gBqLQAAIABB/wFxQZDD0gBqLQAAcgtaAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQbTC6wAgAkEIahCrASACQSBqJAALWgEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakH82esAIAJBCGoQqwEgAkEgaiQAC1QBAn8jAEEgayICJAAgASgCBCEDIAEoAgAgAkEYaiAAQRBqKQIANwMAIAJBEGogAEEIaikCADcDACACIAApAgA3AwggAyACQQhqEKsBIAJBIGokAAtaAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQYT56wAgAkEIahCrASACQSBqJAALVAECfyMAQSBrIgIkACAAKAIEIQMgACgCACACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCADIAJBCGoQqwEgAkEgaiQAC2cBA38jAEEgayICJAAgASgCACEDIAJBCGogASgCBCIBQQAQggUgAiACKAIMIgQ2AhQgAiACKAIINgIQIAQgAyABEKUHGiACIAE2AhggAiACQRBqEJ8GIAAgAikDADcDACACQSBqJAALVwEBfyMAQSBrIgIkACACIAA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGgqcEAIAJBCGoQqwEgAkEgaiQACy4BAX8jAEEQayICJAAgAiABQQEQggUgACACKQMANwIAIAAgATYCCCACQRBqJAALVwEBfyMAQSBrIgIkACACIAA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGE+esAIAJBCGoQqwEgAkEgaiQAC1wBAX8CQCABRQRAQQEhAgwBCyABQQBOBEAgAUF/c0EfdiEDAn8gAkUEQCABIAMQ6QYMAQsgASADEOoGCyICDQEgASADEKEHAAsQ5QUACyAAIAI2AgQgACABNgIAC1UBAX8jAEGwE2siAiQAAkAgAQRAIAEoAgANASABQQA2AgAgAkEIaiABQagTEKUHGiAAIAJBEGpBoBMQpQcaIAEQUiACQbATaiQADwsQkgcACxCTBwALQwECfyAAEMgEA0AgACABaiICQQRqKAIABEAgAigCABBSCyABQQhqIgFBwABHDQALIABB5ABqKAIABEAgACgCYBBSCwtPAQF/IwBBIGsiBiQAIAYgATYCACAGIAI2AgQgBkEIakGRicEAEJ0GIAYgBikDCDcDECAAIAYgBkEEaiADIAQgBSAGQRBqEG0gBkEgaiQAC3wAIABCADcCECAAQsCAgIDA////AzcCCCAAQgA3AgAgAEEAOgBUIABBCzYCOCAAQgA3AkQgAEIWNwI8IABCgICAgBA3AFUgAEIANwJMIABChoCAgPABNwIgIABBGGpCADcCACAAQTBqQhA3AgAgAEEoakKIgICA0AA3AgALYAICfwF+IwBBEGsiAiQAIAJBCGogAUEIaigCACIDNgIAIAIgASkCACIENwMAIASnIANLBEAgAiADEPwFIAIoAgghAwsgAigCBCEBIAAgAzYCBCAAIAE2AgAgAkEQaiQAC2ACAn8BfiMAQRBrIgIkACACQQhqIAFBCGooAgAiAzYCACACIAEpAgAiBDcDACAEpyADSwRAIAIgAxD6BSACKAIIIQMLIAIoAgQhASAAIAM2AgQgACABNgIAIAJBEGokAAtgAgJ/AX4jAEEQayICJAAgAkEIaiABQQhqKAIAIgM2AgAgAiABKQIAIgQ3AwAgBKcgA0sEQCACIAMQ/gUgAigCCCEDCyACKAIEIQEgACADNgIEIAAgATYCACACQRBqJAALYAICfwF+IwBBEGsiAiQAIAJBCGogAUEIaigCACIDNgIAIAIgASkCACIENwMAIASnIANLBEAgAiADEPYFIAIoAgghAwsgAigCBCEBIAAgAzYCBCAAIAE2AgAgAkEQaiQAC2ACAn8BfiMAQRBrIgIkACACQQhqIAFBCGooAgAiAzYCACACIAEpAgAiBDcDACAEpyADSwRAIAIgAxD4BSACKAIIIQMLIAIoAgQhASAAIAM2AgQgACABNgIAIAJBEGokAAtgAgJ/AX4jAEEQayICJAAgAkEIaiABQQhqKAIAIgM2AgAgAiABKQIAIgQ3AwAgBKcgA0sEQCACIAMQyAUgAigCCCEDCyACKAIEIQEgACADNgIEIAAgATYCACACQRBqJAALYAICfwF+IwBBEGsiAiQAIAJBCGogAUEIaigCACIDNgIAIAIgASkCACIENwMAIASnIANLBEAgAiADEP8FIAIoAgghAwsgAigCBCEB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KAIMIgBBgYCAgHhHBEAgAigCCCAAEKEHAAsgAkEQaiQACzwBAX8jAEEQayICJAAgAkEIaiAAIAEQswMgAigCDCIAQYGAgIB4RwRAIAIoAgggABChBwALIAJBEGokAAs8AQF/IwBBEGsiAiQAIAJBCGogACABELQDIAIoAgwiAEGBgICAeEcEQCACKAIIIAAQoQcACyACQRBqJAALPAEBfyMAQRBrIgIkACACQQhqIAAgARC1AyACKAIMIgBBgYCAgHhHBEAgAigCCCAAEKEHAAsgAkEQaiQACzwBAX8jAEEQayICJAAgAkEIaiAAIAEQtgMgAigCDCIAQYGAgIB4RwRAIAIoAgggABChBwALIAJBEGokAAs8AQF/IwBBEGsiAiQAIAJBCGogACABELcDIAIoAgwiAEGBgICAeEcEQCACKAIIIAAQoQcACyACQRBqJAALPAEBfyMAQRBrIgIkACACQQhqIAAgARDBAyACKAIMIgBBgYCAgHhHBEAgAigCCCAAEKEHAAsgAkEQaiQACzwBAX8jAEEQayICJAAgAkEIaiAAIAEQwgMgAigCDCIAQYGAgIB4RwRAIAIoAgggABChBwALIAJBEGokAAs/AQF/QQxBBBDpBiICRQRAQQxBBBChBwALIAJBJToACCACQcipwQA2AgQgAiABNgIAIAAgAq1CIIZCA4Q3AgALOQEBfyABQRB2QAAhAiAAQQA2AgggAEEAIAFBgIB8cSACQX9GIgEbNgIEIABBACACQRB0IAEbNgIACzkAAkACfyACQYCAxABHBEBBASAAIAIgASgCEBEBAA0BGgsgAw0BQQALDwsgACADIAQgASgCDBEDAAs1ACAAIAEgAiADIAQgBRDTASIEIAVJBEADQCAAIAEgAiADIAQQnQQgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRDnASIEIAVJBEADQCAAIAEgAiADIAQQxAQgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRDUASIEIAVJBEADQCAAIAEgAiADIAQQngQgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRDVASIEIAVJBEADQCAAIAEgAiADIAQQnwQgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRCHASIEIAVJBEADQCAAIAEgAiADIAQQgAMgBSAEQQFqIgRHDQALCws1ACAAIAEgAiADIAQgBRCIASIEIAVJBEADQCAAIAEgAiADIAQQgQMgBSAEQQFqIgRHDQALCws0ACAAIAEgAiADIAQgBRBNIgQgBUkEQANAIAAgASACIAMgBBDVAiAFIARBAWoiBEcNAAsLCzwBAX9BFEEEEOkGIgFFBEBBFEEEEKEHAAsgAUEANgIAIAEgACkCADcCBCABQQxqIABBCGopAgA3AgAgAQsnAQJ/IABCAloEQANAIAFBAWohASAAQgRUIABCAYghAEUNAAsLIAELMQAgAUEPTQRAIAFBAnRByNbiAGo1AgAgAq0gAK1+fEICiA8LIAFBEEGI1+IAELwEAAs/AQF/IwBBIGsiAiQAIAJBAToAGCACIAE2AhQgAiAANgIQIAJBlPXrADYCDCACQcjb6wA2AgggAkEIahCsBQALMwACQCAAQfz///8HSw0AIABFBEBBBA8LIAAgAEH9////B0lBAnQQ6QYiAEUNACAADwsAC0ABAn8CQAJAAkAgASgCACIEQQFrDgIBAgALIAEoAgQgAmohAwwBCyABKAIEIAJqIQMLIAAgAzYCBCAAIAQ2AgALKgEBfyMAQRBrIgEkACABIAAQmQQgASgCBARAIAEoAgAQUgsgAUEQaiQACzkAIABBgAE6ABggAEKAgICAEDcCDCAAIAEpAgA3AgAgAEEUakEANgIAIABBCGogAUEIaigCADYCAAs1AQF/IACnIQEgAUEBdEEBdUGAgICAfHEgAUH/////A3FyQYCAgIB4cyABIABC/////wtWGwsxACAAKAIcIAAoAhggACgCFCAAKAIQIAAoAgwgACgCCCAAKAIEIAAoAgBqampqampqCy8BAn8gASgCCCIDIAEoAgRJBEAgASgCACADai0AACECCyAAQQA6AAAgACACOgABCzIAIAAoAgAhACABEPsGRQRAIAEQ/AZFBEAgACABEIkHDwsgACABEP4DDwsgACABEP0DCzIAIAAoAgAhACABEPsGRQRAIAEQ/AZFBEAgACABEIsHDwsgACABEP8CDwsgACABEP4CCzcAIAAoAgAhACABEPsGRQRAIAEQ/AZFBEAgADEAAEEBIAEQjwIPCyAAIAEQ+QMPCyAAIAEQ+gMLNwAgACgCACEAIAEQ+wZFBEAgARD8BkUEQCAAMwEAQQEgARCPAg8LIAAgARD7Aw8LIAAgARD4AwsnAAJAIAAgARDmASIBRQ0AIAEQsgcQgQcNACABQQAgABCjBxoLIAELKwACQCAABEAgACgCAA0BIABBADYCACAAQQxqIAE2AgAPCxCSBwALEJMHAAsoAQF/IwBBEGsiAiQAIAJBCGogARDoBCAAIAIoAggQggYgAkEQaiQACzIBAX8gACABKAIAIAEoAggiAksEfyABIAIQygUgASgCCAUgAgs2AgQgACABKAIENgIACzIBAX8gACABKAIAIAEoAggiAksEfyABIAIQywUgASgCCAUgAgs2AgQgACABKAIENgIACy0BAX8jAEEQayIBJAAgAUEIaiAAQQhqKAIANgIAIAEgACkCADcDACABEKsGAAsoAQF/QQEgACgCPCIBIAAoAkAiACABIABKG0EBaiIAQRggAEEYSBt0CyoBAX8gABCIBCIBQRBJBEAgACABQQJ0aioCAA8LIAFBEEH4lOMAELwEAAssACAARQRAQwAAAMAPCyAAQYACTwRAIACzEMQCDwsgAEECdEGQx+IAaioCAAstAQF/IwBBEGsiASQAIAFBCGogAEEIaigCADYCACABIAApAgA3AwAgARD8AwALMgEBf0EBIQEgAC0ABAR/IAEFIAAoAgAiACgCAEGL9+sAQQEgAEEEaigCACgCDBEDAAsLMwAgACABKAIAQdTJ6wBBBCABKAIEKAIMEQMAOgAIIAAgATYCBCAAQQA6AAkgAEEANgIACyUAAkAgAARAIAAoAgBBf0YNASAAQRBqKAIADwsQkgcACxCTBwALJQACQCAABEAgACgCAEF/Rg0BIABBDGooAgAPCxCSBwALEJMHAAsmAAJAIAAEQCAAKAIAQX9GDQEgAEHIKmooAgAPCxCSBwALEJMHAAsmAAJAIAAEQCAAKAIAQX9GDQEgAEGgE2ooAgAPCxCSBwALEJMHAAsuAQF/IwBBEGsiASQAIAEgACkCADcDCCABQQhqQYS9wQBBACAAKAIIQQEQpwMACx8AIAKtIACtfiABZ0EgakE/c0H4AGytfUKAPHxCAogLJQAgACgCBCIAQRh2QYABcSAAQRl2ckEYdEEYdSAAQf///w9xagssAAJAIAEQ+wZFBEAgARD8Bg0BIAAgARDABg8LIAAgARD9Aw8LIAAgARD+AwslAQF/IwBBEGsiAiQAIAIgATYCDCAAIAJBDGoQ2QIgAkEQaiQACycAIAAgACgCBEEBcSABckECcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsdACACQQJ2IABsrSABZ0EgakE/c0EebK19QoAPfAsmAQJ/QYACIQMDQCADIgIgAEkEQCACQQF0IQMgAiABSQ0BCwsgAgskACAAIAFBiA9qIAFB8A1qQQAgAiADEGEiAARAIAEQ1QMLIAALMQAgAEEDOgAgIABCgICAgIAENwIYIABBADYCECAAQQA2AgggACACNgIEIAAgATYCAAstACABKAIAIAIgAyABKAIEKAIMEQMAIQIgAEEAOgAFIAAgAjoABCAAIAE2AgALMgEBfyABKAIAQYr36wBBASABKAIEKAIMEQMAIQIgAEEAOgAFIAAgAjoABCAAIAE2AgALKgEBfyABKAIAIgEQ8wMiAkUEQCAAIAEQ/AEPCyAAQQE2AgAgACACNgIECygBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAxCgBgALIAEBfwJAIABBBGooAgAiAUUNACAAKAIARQ0AIAEQUgsLJwEBfyMAQRBrIgAkACAAQSY2AgwgAEHQyusANgIIIABBCGoQuQUACyMAAkAgAUH8////B00EQCAAIAFBBCACEN4GIgANAQsACyAACyAAIAAgAUEDdEE4ca2IQoCAgOj7tI0PfiACQT9xrYinCyIAIAEgA0YEQCAAIAIgARClBxoPCyABIANB/LHAABDABAALJAAgAEECNgIIIABCBDcCACAAQQxqQgA3AgAgAEEUakEAOwEACyMAIAIgAigCBEF+cTYCBCAAIAFBAXI2AgQgACABaiABNgIACx8AIAAoAgAiAK1CACAArH0gAEF/SiIAGyAAIAEQjwILHAAgAUEITwRAIAFBCCACELwEAAsgACABQQJ0agseACABIANHBEAgASADIAQQwAQACyAAIAIgARClBxoLKAAgASAAKAIALQAAQQJ0IgBB2NjrAGooAgAgAEG01+sAaigCABDjBgsgAQJ+IAApAwAiAiACQj+HIgOFIAN9IAJCf1UgARCPAgshAAJAIAENACAAKAIAQQFHDQAgAkECNgIAIABBADYCAAsLJQAgASAALQAAQQJ0IgBB2NjrAGooAgAgAEG01+sAaigCABDjBgseACAAIAFBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQLFAAgACgCAARAIABBBGooAgAQUgsLIgAgAC0AAEUEQCABQZz66wBBBRBkDwsgAUGY+usAQQQQZAsdACABKAIARQRAAAsgAEGYvcEANgIEIAAgATYCAAskACAAIAFBgBEQpQciACABKgKEETgChBEgACABKAKAETYCgBELHAAgACAAKAIAQaeDAWwiAEEBIAAbIgA2AgAgAAsRACAAKAIABEAgACgCBBBSCwscACAAKAIAIgAoAgAgASAAQQRqKAIAKAIMEQEACxkBAX8gACgCECIBBH8gAQUgAEEUaigCAAsLHQBDAAAAAEMAAAAAIAAgAEMAAAAAXRsgACAAXBsLEwBCkJQHIABBDnGtiEIOg0InfAsLACABBEAgABBSCwsWACAAQQRqKAIAIABBCGooAgAgARB3CxcAIABBBGooAgAgAEEIaigCACABEKIHCxIAQQBBGSAAQQF2ayAAQR9GGwsWACAAIAFBAXI2AgQgACABaiABNgIACxcAIABBADYCCCAAIAI2AgQgACABNgIACxQAIAAoAgggAU8EQCAAIAE2AggLCyAAIABBADYCECAAQgE3AgggAEKAgICA4LPy//4ANwIACxAAIAFBAnatIACtfkKPD3wLGQAgACACOwEGIABB//8DOwEEIAAgATYCAAsRACAAQTJsIAFNIAJB1AdLcQsQACAAIAFqQX9qQQAgAWtxCwwAIAAgASACIAMQcwsWACAAKAIAIgAoAgAgACgCBCABEKcFCw8AIABBAXQiAEEAIABrcgsZACABKAIAQYj06wBBDiABKAIEKAIMEQMACxUAIAEgACgCACIAKAIAIAAoAgQQZAsWACAAKAIAIAEgAiAAKAIEKAIMEQMACxkAIAEoAgBB3ozsAEEFIAEoAgQoAgwRAwALEAAgAEEQaigCACAAKAIEagsRAEHAAEGABCAAKAI4QQlIGwsUACAAKAIAIAEgACgCBCgCDBEBAAsPACAAIAEgAiADIAQQSAALCQAgACABEOYBCwkAIAAgARCbBgsPACAAIAAoAghBAWo2AggLEAAgAEEBOgAEIAAgATYCAAsQACAAKAIAIAEgAhDjBUEACxAAIAAoAgQgACgCCCABEHcLEAAgACgCACAAKAIEIAEQdwsRACAAKAIAIAAoAgQgARCiBwsWACAAQQBBhBEQowdBo+D/+wc2AoQRCw8AIAAgASkCBEIgiTcDAAsPACAAKAIUIgBBnAQgABsLEwAgAEEANgIEIABB9JvjADYCAAsQACAAQQA6AAEgACABOgAACxAAIABBADYCBCAAIAE2AgALEwAgAEGczesANgIEIAAgATYCAAsNACAALQAEQQJxQQF2Cw8AIAAgAUEEaikCADcDAAsQACABIAAoAgAgACgCBBBkCw0AIAAtABhBEHFBBHYLDQAgAC0AGEEgcUEFdgsNACAAIAEgAhDjBUEACwoAQQEgAHRBcGoLDQAgACgCACABKAIASQsKAEEAIABrIABxCwsAIAAtAARBA3FFCwwAIAAgAUEDcjYCBAsNACAAKAIAIAAoAgRqCw4AIAAoAgAgARCLAkEACw4AIAAoAgAaA0AMAAsACwwAIAAgASACEL0EAAsMACAAIAEgAhC+BAALDAAgACABIAIQvwQACw4AIAA1AgBBASABEI8CCw4AIAAoAgAgASACENoBCw4AIAApAwBBASABEI8CCw8AIAAoAgApAwAgARDSAQsLACAAIwBqJAAjAAsMACAAKAIAIAEQ3wULDgAgAUH7p8AAQQ4Q4wYLDQAgAUG8wcAAQQIQZAsHACAAEM0GCw0AQYiVwQBBGxCUBwALDgBBo5XBAEHPABCUBwALCQAgACABEAkACwsAIAAgASACEO8BCw0AIAAoAgRB////D3ELDQAgAUGw3cEAQQIQZAsMACAAIAEpAgA3AwALCgBBASAAKAIMdAsKAEEBIAAoAhR0CwwAIAAgASkBADcBAAsMACAAKAIAIAEQyQYLCgAgACgCBEF4cQsKACAAKAIEQQFxCwoAIAAoAgxBAXELCgAgACgCDEEBdgsaACAAIAFBlJTsACgCACIAQcYAIAAbEQAAAAsKACACIAAgARBkCwsAIAAgASACEMwDCwsAIAAgASACELoFCwsAIAAgASACEI0CCwsAIAAgASACEJgBCw4AIAFBgL3BAEEDEOMGCwkAIAEgABCpBQsJACAAQQA2AgALCQAgAEIBNwMACwkAIABCAjcDAAsJACAAQgQ3AwALCwBB9JfsACgCAEULCQAgACABEPoBCwcAIAAgAWoLBwAgACABawsHACAAQQhqCwcAIABBeGoLBwAgARC9AgsMAELTz56i/5e3gk8LDQBCyLXgz8qG29OJfwsMAEK5h9OJk5/l8gALDQBCqd3+1cDm39HMAAsDAAELAwABCwu20inyJgBBgYDAAAvYRwECAwAAAAAAAAEBAQEBAS9ob21lL3RpbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9icm90bGktNS4wLjAvc3JjL2VuYy9iYWNrd2FyZF9yZWZlcmVuY2VzL21vZC5ycwAAABAAEABpAAAA2QIAABIAAAAAAAAA/wH+Av0D/wH+Av0DEAAQAGkAAADkAgAAFAAAABAAEABpAAAA5QIAABgAAAAQABAAaQAAAOsCAAAvAAAAEAAQAGkAAADrAgAAQQAAABAAEABpAAAA+gIAACsAAAAQABAAaQAAAP4CAAASAAAAEAAQAGkAAAAAAwAAEgAAABAAEABpAAAABAMAACUAAAAQABAAaQAAAAsDAAAlAAAAEAAQAGkAAAAVAwAAKQAAABAAEABpAAAAGwMAAB4AAAAQABAAaQAAAC4DAAAtAAAAEAAQAGkAAAA3AwAAJgAAABAAEABpAAAASAMAACUAAAAQABAAaQAAAEoDAAAhAAAAEAAQAGkAAABMAwAACQAAABAAEABpAAAAXgEAACgAAAAQABAAaQAAAF8BAAAlAAAAEAAQAGkAAABiAQAAJgAAABAAEABpAAAAaAEAACAAAAAQABAAaQAAAGoBAAAWAAAAEAAQAGkAAAB0AQAAJAAAABAAEABpAAAAdgEAABkAAAAQABAAaQAAAJQBAAAnAAAAEAAQAGkAAACUAQAAEQAAABAAEABpAAAAmQEAACQAAAAQABAAaQAAAKABAAAWAAAAEAAQAGkAAACsAQAAKAAAABAAEABpAAAAgAEAABcAAAAQABAAaQAAAIEBAAANAAAAEAAQAGkAAACEAQAAIAAAABAAEABpAAAAiwEAAC8AAAAQABAAaQAAAL8BAAAJAAAAEAAQAGkAAAAqAQAAJQAAABAAEABpAAAALQEAAAkAAAAQABAAaQAAAD4BAAArAAAAEAAQAGkAAABAAQAAHQAAAFVOSU5USUFMSVpFRBAAEABpAAAAkggAAAkAAAAQABAAaQAAAK0IAAAJAAAAEAAQAGkAAACYCAAACQAAABAAEABpAAAACwYAACAAAAAQABAAaQAAAAwGAAAaAAAAEAAQAGkAAAANBgAAGgAAABAAEABpAAAADgYAABoAAAAQABAAaQAAAA8GAAAgAAAAEAAQAGkAAAAQBgAAGgAAABAAEABpAAAAEQYAABoAAAAQABAAaQAAABIGAAAaAAAAEAAQAGkAAAAUBgAAIAAAABAAEABpAAAAFQYAABoAAAAQABAAaQAAABYGAAAaAAAAEAAQAGkAAAAXBgAAGgAAABAAEABpAAAAGQYAACAAAAAQABAAaQAAABoGAAAaAAAAEAAQAGkAAAAbBgAAGgAAABAAEABpAAAAHAYAABoAAAAQABAAaQAAACoGAAAmAAAAEAAQAGkAAAAtBgAAJgAAABAAEABpAAAAMAYAACYAAAAQABAAaQAAADMGAAAmAAAAEAAQAGkAAAA6BgAACQAAABAAEABpAAAAOwYAAAkAAAAQABAAaQAAADwGAAAJAAAAEAAQAGkAAAA9BgAACQAAABAAEABpAAAA1AUAAB8AAAAQABAAaQAAANUFAAAaAAAAEAAQAGkAAADWBQAAGgAAABAAEABpAAAA1wUAABoAAAAQABAAaQAAANgFAAAaAAAAEAAQAGkAAADZBQAAGgAAABAAEABpAAAA2gUAABoAAAAQABAAaQAAANsFAAAaAAAAEAAQAGkAAADdBQAAHwAAABAAEABpAAAA3QUAADYAAAAQABAAaQAAAOsFAAAmAAAAEAAQAGkAAADuBQAAJgAAABAAEABpAAAA8QUAACYAAAAQABAAaQAAAPQFAAAmAAAAEAAQAGkAAAD7BQAACQAAABAAEABpAAAA/AUAAAkAAAAQABAAaQAAAP0FAAAJAAAAEAAQAGkAAAD+BQAACQAAABAAEABpAAAAfgYAAB0AAAAQABAAaQAAAIIGAAArAAAAEAAQAGkAAACNBgAAHAAAABAAEABpAAAAjQYAADIAAAAQABAAaQAAAJEGAAAqAAAAEAAQAGkAAACtBgAAJAAAABAAEABpAAAAsgYAABIAAAAQABAAaQAAALQGAAASAAAAYXNzZXJ0aW9uIGZhaWxlZDogYnVja2V0LmxlbigpID4gc2VsZi5zcGVjaWFsaXphdGlvbi5ibG9ja19tYXNrKCkgYXMgdXNpemUAABAAEABpAAAAtgYAAA0AAAAQABAAaQAAAMAGAAAZAAAAEAAQAGkAAADFBgAAHAAAABAAEABpAAAAxQYAADIAAAAQABAAaQAAAM8GAAAqAAAAEAAQAGkAAADeBgAADQAAABAAEABpAAAAQAYAACUAAAAQABAAaQAAAEMGAAAOAAAAEAAQAGkAAABGBgAACQAAABAAEABpAAAASAYAAB0AAAAQABAAaQAAAK0FAAArAAAAEAAQAGkAAACuBQAAEQAAABAAEABpAAAAsgUAABEAAABhc3NlcnRpb24gZmFpbGVkOiBtaWQgPD0gc2VsZi5sZW4oKS9ob21lL3RpbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9icm90bGktNS4wLjAvc3JjL2VuYy9zdGF0aWNfZGljdC5yc4cHEABdAAAAIwAAAB8AAACHBxAAXQAAACMAAAALAAAAhwcQAF0AAAAuAAAAHwAAAIcHEABdAAAALgAAAAsAAAAQABAAaQAAAPIAAAAjAAAAEAAQAGkAAADyAAAAMQAAABAAEABpAAAA/AAAABEAAAAQABAAaQAAAP0AAAARAAAAEAAQAGkAAAD+AAAAEQAAABAAEABpAAAA/wAAABEAAAAQABAAaQAAAKQJAAAlAAAAEAAQAGkAAACkCQAAFQAAABAAEABpAAAArgkAADwAAAAQABAAaQAAAJQHAAAfAAAAd29ya2luZyB3aXRoIHVuaW5pdGlhbGl6ZWQgaGFzaCBtYXAAEAAQAGkAAAD0CQAAJQAAABAAEABpAAAAbQQAAA0AAAAQABAAaQAAAG4EAAANAAAAEAAQAGkAAAB4BAAAJgAAABAAEABpAAAAeQQAACIAAAAQABAAaQAAAHoEAAAiAAAAEAAQAGkAAAB7BAAAIgAAABAAEABpAAAAfAQAACIAAAAQABAAaQAAAH0EAAAiAAAAEAAQAGkAAAB+BAAAIgAAABAAEABpAAAAiwQAAC4AAAAQABAAaQAAAI4EAAAuAAAAEAAQAGkAAACRBAAALgAAABAAEABpAAAAlAQAAC4AAAAQABAAaQAAAJ8EAAARAAAAEAAQAGkAAACgBAAAEQAAABAAEABpAAAAoQQAABEAAAAQABAAaQAAAKIEAAARAAAAEAAQAGkAAAC5BAAADQAAABAAEABpAAAAugQAAA0AAAAQABAAaQAAAMMEAAAaAAAAEAAQAGkAAADFBAAAGgAAABAAEABpAAAAwgQAADUAAAAQABAAaQAAAOEEAAAyAAAAEAAQAGkAAADkBAAAMgAAABAAEABpAAAA5wQAADIAAAAQABAAaQAAAOoEAAAyAAAAEAAQAGkAAAD1BAAAFQAAABAAEABpAAAA9gQAABUAAAAQABAAaQAAAPcEAAAVAAAAEAAQAGkAAAD4BAAAFQAAAC9ob21lL3RpbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9icm90bGktNS4wLjAvc3JjL2VuYy9jb21tYW5kLnJzAAAA2AoQAFkAAAApAAAAOwAAANgKEABZAAAAKgAAADsAAADYChAAWQAAADMAAAAfAAAA2AoQAFkAAAA1AAAAHwAAAFRyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0eXQLEAAkAAAAL3J1c3RjLzllYjNhZmU5ZWJlOWM3ZDJiODRiNzEwMDJkNDRmNGEwZWRhYzk1ZTAvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc6ALEABMAAAAqgEAAAkAAAAvaG9tZS90aW0vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYnJvdGxpLTUuMC4wL3NyYy9lbmMvaGlzdG9ncmFtLnJzL2hvbWUvdGltLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jyb3RsaS01LjAuMC9zcmMvZW5jL2NvbnRleHRfbWFwX2VudHJvcHkucnNXDBAAZQAAABkCAAAJAAAAL2hvbWUvdGltLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jyb3RsaS1kZWNvbXByZXNzb3ItNC4wLjAvc3JjL2xpYi5yc1VuZXhwZWN0ZWQgRU9GYXNzZXJ0aW9uIGZhaWxlZDogaW5wdXRfYnVmZmVyLmxlbigpICE9IDAAAADMDBAAXgAAANsAAAADAAAAYXNzZXJ0aW9uIGZhaWxlZDogb3V0cHV0X2J1ZmZlci5sZW4oKSAhPSAwAADMDBAAXgAAANwAAAADAAAAAAAAAMwMEABeAAAAFgEAABgAAADMDBAAXgAAABwBAAANAAAAAQAAAAAAAAAB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AwAAGgAAAKwVEABjAAAACAQAABYAAACsFRAAYwAAADgAAAAnAAAArBUQAGMAAABPAAAAKwAAAKwVEABjAAAAdgAAAD0AAAAvcnVzdGMvOWViM2FmZTllYmU5YzdkMmI4NGI3MTAwMmQ0NGY0YTBlZGFjOTVlMC9saWJyYXJ5L3N0ZC9zcmMvaW8vaW1wbHMucnMAsBgQAEsAAAD0AAAAGAAAALAYEABLAAAA8gAAAA0AAAALAAAABAAAAAQAAAAMAAAACwAAAAQAAAAEAAAADQAAAC9ob21lL3RpbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9icm90bGktNS4wLjAvc3JjL2VuYy9lbnRyb3B5X2VuY29kZS5yczwZEABgAAAAUAAAACgAAAA8GRAAYAAAAF8AAAANAAAAPBkQAGAAAABoAAAAMAAAADwZEABgAAAAaQAAAEYAAAA8GRAAYAAAAG8AAAAVAAAAL2hvbWUvdGltLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jyb3RsaS01LjAuMC9zcmMvZW5jL2ludGVyZmFjZS5ycwDsGRAAWwAAADsBAAAZAAAA7BkQAFsAAAA8AQAAGgAAAOwZEABbAAAAPQEAABcAAADsGRAAWwAAAD4BAAAYAAAA7BkQAFsAAAApAQAAGQAAAOwZEABbAAAAKgEAABoAAADsGRAAWwAAACsBAAAXAAAA7BkQAFsAAAAsAQAAGAAAAOwZEABbAAAAqQAAAAkAAABpbnZhbGlkIGVudW0gdmFsdWUgcGFzc2VkVW5leHBlY3RlZCBCcm90bGkgc3RyZWFtaW5nIGNvbXByZXNzOiBib3RoIGF2YWlsYWJsZV9pbiAmIGF2YWlsYWJsZV9vdXQgYXJlIG5vdCAwIGFmdGVyIGEgc3VjY2Vzc2Z1bCBwcm9jZXNzaW5nQnJvdGxpIHN0cmVhbWluZyBjb21wcmVzcyBmYWlsZWQ6IFdoZW4gcHJvY2Vzc2luZ0Jyb3RsaSBzdHJlYW1pbmcgY29tcHJlc3MgZmFpbGVkOiBXaGVuIGZpbmlzaGluZ0Jyb3RsaSBzdHJlYW1pbmcgZGVjb21wcmVzcyBmYWlsZWQ6IEVycm9yIGNv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95k5/RwDfpx1AIg85Dd+A5MAqkvdbX7iW0BKT6qiftpy0BzjVNd+kI8E5BsqDX+62YJuUTpCfymQI8rlyHZ/M3SsPB97rH+gyOuF88zhfxsAAAAEAAAABAAAABwAAAAdAAAAHgAAAB8AAAAMAAAABAAAACAAAAAfAAAADAAAAAQAAAAhAAAAIAAAALhUEAAiAAAAIwAAACQAAAAlAAAAJgAAAFRyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0efRUEAAkAAAAL3J1c3RjLzllYjNhZmU5ZWJlOWM3ZDJiODRiNzEwMDJkNDRmNGEwZWRhYzk1ZTAvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5ycyBVEABMAAAAqgEAAAkAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL2hvbWUvdGltLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3NlcmRlX2pzb24tMS4wLjc5L3NyYy9yZWFkLnJzAACnVRAAVwAAAKEBAAAUAAAAp1UQAFcAAADGAQAAEwAAAKdVEABXAAAA1QEAADAAAACnVRAAVwAAAMsBAAApAAAAp1UQAFcAAADPAQAANAAAAKdVEABXAAAAJgIAABMAAACnVRAAVwAAAD4CAAAlAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAEAQcytwQALAQEAQfCuwQAL/g6nVRAAVwAAAKYDAAAvAAAA////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg///////////////////////////////////woLDA0OD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////ykAAAAMAAAABAAAACoAAAArAAAAGAAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkALAAAAAAAAAABAAAAGgAAAC9ydXN0Yy85ZWIzYWZlOWViZTljN2QyYjg0YjcxMDAyZDQ0ZjRhMGVkYWM5NWUwL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwDgWBAASwAAAOkJAAAOAAAAL3J1c3RjLzllYjNhZmU5ZWJlOWM3ZDJiODRiNzEwMDJkNDRmNGEwZWRhYzk1ZTAvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwA8WRAATwAAAP4FAAAUAAAAPFkQAE8AAAD+BQAAIQAAADxZEABPAAAACgYAABQAAAA8WRAATwAAAAoGAAAhAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pc19jaGFyX2JvdW5kYXJ5KG5ld19sZW4p4FgQAEsAAAD/BAAADQAAADxZEABPAAAAiwQAABcAAAByZWN1cnNpb24gbGltaXQgZXhjZWVkZWR1bmV4cGVjdGVkIGVuZCBvZiBoZXggZXNjYXBldHJhaWxpbmcgY2hhcmFjdGVyc3RyYWlsaW5nIGNvbW1hbG9uZSBsZWFkaW5nIHN1cnJvZ2F0ZSBpbiBoZXggZXNjYXBla2V5IG11c3QgYmUgYSBzdHJpbmdjb250cm9sIGNoYXJhY3RlciAoXHUwMDAwLVx1MDAxRikgZm91bmQgd2hpbGUgcGFyc2luZyBhIHN0cmluZ2ludmFsaWQgdW5pY29kZSBjb2RlIHBvaW50bnVtYmVyIG91dCBvZiByYW5nZWludmFsaWQgbnVtYmVyaW52YWxpZCBlc2NhcGVleHBlY3RlZCB2YWx1ZWV4cGVjdGVkIGlkZW50ZXhwZWN0ZWQgYCxgIG9yIGB9YGV4cGVjdGVkIGAsYCBvciBgXWBleHBlY3RlZCBgOmBFT0Ygd2hpbGUgcGFyc2luZyBhIHZhbHVlRU9GIHdoaWxlIHBhcnNpbmcgYSBzdHJpbmdFT0Ygd2hpbGUgcGFyc2luZyBhbiBvYmplY3RFT0Ygd2hpbGUgcGFyc2luZyBhIGxpc3QgYXQgbGluZSBFcnJvcigsIGxpbmU6ICwgY29sdW1uOiApAADtWxAABgAAAPNbEAAIAAAA+1sQAAoAAAAFXBAA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HQCn8wEAp/MFAKfzCQCn8w0Ap/MRAKfzFQCn8xkAp/MdAKf7AQCn+wUAp/sJAKf7DQCn+xEAp/sVAKf7GQCn+x0At8MBALfDBQC3wwkAt8MNALfDEQC3wxUAt8MZALfDHQC3ywEAt8sFALfLCQC3yw0At8sRALfLFQC3yxkAt8sdALfTAQC30wUAt9MJALfTDQC30xEAt9MVALfTGQC30x0At9sBALfbBQC32wkAt9sNALfbEQC32xUAt9sZALfbHQC34wEAt+MFALfjCQC34w0At+MRALfjFQC34xkAt+MdALfrAQC36wUAt+sJALfrDQC36xEAt+sVALfrGQC36x0At/MBALfzBQC38wkAt/MNALfzEQC38xUAt/MZALfzHQC3+wEAt/sFALf7CQC3+w0At/sRALf7FQC3+xkAt/sdAMfDAQDHwwUAx8MJAMfDDQDHwxEAx8MVAMfDGQDHwx0Ax8sBAMfLBQDHywkAx8sNAMfLEQDHyxUAx8sZAMfLHQDH0wEAx9MFAMfTCQDH0w0Ax9MRAMfTFQDH0xkAx9MdAMfbAQDH2wUAx9sJAMfbDQDH2xEAx9sVAMfbGQDH2x0Ax+MBAMfjBQDH4wkAx+MNAMfjEQDH4xUAx+MZAMfjHQDH6wEAx+sFAMfrCQDH6w0Ax+sRAMfrFQDH6xkAx+sdAMfzAQDH8wUAx/MJAMfzDQDH8xEAx/MVAMfzGQDH8x0Ax/sBAMf7BQDH+wkAx/sNAMf7EQDH+xUAx/sZAMf7HQDXwwEA18MFANfDCQDXww0A18MRANfDFQDXwxkA18MdANfLAQDXywUA18sJANfLDQDXyxEA18sVANfLGQDXyx0A19MBANfTBQDX0wkA19MNANfTEQDX0xUA19MZANfTHQDX2wEA19sFANfbCQDX2w0A19sRANfbFQDX2xkA19sdANfjAQDX4wUA1+MJANfjDQDX4xEA1+MVANfjGQDX4x0A1+sBANfrBQDX6wkA1+sNANfrEQDX6xUA1+sZANfrHQDX8wEA1/MFANfzCQDX8w0A1/MRANfzFQDX8xkA1/MdANf7AQDX+wUA1/sJANf7DQDX+xEA1/sVANf7GQDX+x0A58MBAOfDBQDnwwkA58MNAOfDEQDnwxUA58MZAOfDHQDnywEA58sFAOfLCQDnyw0A58sRAOfLFQDnyxkA58sdAOfTAQDn0wUA59MJAOfTDQDn0xEA59MVAOfTGQDn0x0A59sBAOfbBQDn2wkA59sNAOfbEQDn2xUA59sZAOfbHQDn4wEA5+MFAOfjCQDn4w0A5+MRAOfjFQDn4xkA5+MdAOfrAQDn6wUA5+sJAOfrDQDn6xEA5+sVAOfrGQDn6x0A5/MBAOfzBQDn8wkA5/MNAOfzEQDn8xUA5/MZAOfzHQDn+wEA5/sFAOf7CQDn+w0A5/sRAOf7FQDn+xkA5/sdAPfDAQD3wwUA98MJAPfDDQD3wxEA98MVAPfDGQD3wx0A98sBAPfLBQD3ywkA98sNAPfLEQD3yxUA98sZAPfLHQD30wEA99MFAPfTCQD30w0A99MRAPfTFQD30xkA99MdAPfbAQD32wUA99sJAPfbDQD32xEA99sVAPfbGQD32x0A9+MBAPfjBQD34wkA9+MNAPfjEQD34xUA9+MZAPfjHQD36wEA9+sFAPfrCQD36w0A9+sRAPfrFQD36xkA9+sdAPfzAQD38wUA9/MJAPfzDQD38xEA9/MVAPfzGQD38x0A9/sBAPf7BQD3+wkA9/sNAPf7EQD3+xUA9/sZAPf7HQCHw+EAh8PhAofD4QSHw+EGh8PhCIfD4QqHw+EMh8PhDofD5QCHw+UCh8PlBIfD5QaHw+UIh8PlCofD5QyHw+UOh8PpAIfD6QKHw+kEh8PpBofD6QiHw+kKh8PpDIfD6Q6Hw+0Ah8PtAofD7QSHw+0Gh8PtCIfD7QqHw+0Mh8PtDofD8QCHw/ECh8PxBIfD8QaHw/EIh8PxCofD8QyHw/EOh8P1AIfD9QKHw/UEh8P1BofD9QiHw/UKh8P1DIfD9Q6Hw/kAh8P5AofD+QSHw/kGh8P5CIfD+QqHw/kMh8P5DofD/QCHw/0Ch8P9BIfD/QaHw/0Ih8P9CofD/QyHw/0Oh8vhAIfL4QKHy+EEh8vhBofL4QiHy+EKh8vhDIfL4Q6Hy+UAh8vlAofL5QSHy+UGh8vlCIfL5QqHy+UMh8vlDofL6QCHy+kCh8vpBIfL6QaHy+kIh8vpCofL6QyHy+kOh8vtAIfL7QKHy+0Eh8vtBofL7QiHy+0Kh8vtDIfL7Q6Hy/EAh8vxAofL8QSHy/EGh8vxCIfL8QqHy/EMh8vxDofL9QCHy/UCh8v1BIfL9QaHy/UIh8v1CofL9QyHy/UOh8v5AIfL+QKHy/kEh8v5BofL+QgAAAAABAAAAAgAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAsAAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAAAQEBAQEBAQEBAQEBAQFBQAEBAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYAAAAAAAAIAAAABAAAAAwAAAACAAAACgAAAAYAAAAOAAAAAQAAAAkAAAAFAAAADQAAAAMAAAAPAAAAHwAAAAAAAAALAAAABwAAAAsAAAAbAAAAKwAAADsAAADLAgAAywYAAMsKAADLDgAA2wIAANsGAADbCgAA2w4AAOsCAADrBgAA6woAAOsOAAD7AgAA+wYAAPsKAAD7DgAAy7IAAMuyAQDLsgIAy7IDAMu2AADLtgEAy7YCAMu2AwDLugAAy7oBAMu6AgDLugMAy74AAMu+AQDLvgIAy74DANuyAADbsgEA27ICANuyAwDbtgAA27YBANu2AgDbtgMA27oAANu6AQDbugIA27oDANu+AADbvgEA274CANu+AwDrsgAA67IBAOuyAgDrsgMA67YAAOu2AQDrtgIA67YDAOu6AADrugEA67oCAOu6AwDrvgAA674BAOu+AgDrvgMA+7IAAPuyAQD7sgIA+7IDAPu2AAD7tgEA+7YCAPu2AwD7ugAA+7oBAPu6AgD7ugMA+74AAPu+AQD7vgIA+74DAMuyLADLsmwAy7KsAMuy7ADLsi0Ay7JtAMuyrQDLsu0Ay7IuAMuybgDLsq4Ay7LuAMuyLwDLsm8Ay7KvAMuy7wDLtiwAy7ZsAMu2rADLtuwAy7YtAMu2bQDLtq0Ay7btAMu2LgDLtm4Ay7auAMu27gDLti8Ay7ZvAMu2rwDLtu8Ay7osAMu6bADLuqwAy7rsAMu6LQDLum0Ay7qtAMu67QDLui4Ay7puAMu6rgDLuu4Ay7ovAMu6bwDLuq8Ay7rvAMu+LADLvmwAy76sAMu+7ADLvi0Ay75tAMu+rQDLvu0Ay74uAMu+bgDLvq4Ay77uAMu+LwDLvm8Ay76vAMu+7wDbsiwA27JsANuyrADbsuwA27ItANuybQDbsq0A27LtANuyLgDbsm4A27KuANuy7gDbsi8A27JvANuyrwDbsu8A27YsANu2bADbtqwA27bsANu2LQDbtm0A27atANu27QDbti4A27ZuANu2rgDbtu4A27YvANu2bwDbtq8A27bvANu6LADbumwA27qsANu67ADbui0A27ptANu6rQDbuu0A27ouANu6bgDbuq4A27ruANu6LwDbum8A27qvANu67wDbviwA275sANu+rADbvuwA274tANu+bQDbvq0A277tANu+LgDbvm4A276uANu+7gDbvi8A275vANu+rwDbvu8A67IsAOuybADrsqwA67LsAOuyLQDrsm0A67KtAOuy7QDrsi4A67JuAOuyrgDrsu4A67IvAOuybwDrsq8A67LvAOu2LADrtmwA67asAOu27ADrti0A67ZtAOu2rQDrtu0A67YuAOu2bgDrtq4A67buAOu2LwDrtm8A67avAOu27wDruiwA67psAOu6rADruuwA67otAOu6bQDruq0A67rtAOu6LgDrum4A67quAOu67gDrui8A67pvAOu6rwDruu8A674sAOu+bADrvqwA677sAOu+LQDrvm0A676tAOu+7QDrvi4A675uAOu+rgDrvu4A674vAOu+bwDrvq8A677vAPuyLAD7smwA+7KsAPuy7AD7si0A+7JtAPuyrQD7su0A+7IuAPuybgD7sq4A+7LuAPuyLwD7sm8A+7KvAPuy7wD7tiwA+7ZsAPu2rAD7tuwA+7YtAPu2bQD7tq0A+7btAPu2LgD7tm4A+7auAPu27gD7ti8A+7ZvAPu2rwD7tu8A+7osAPu6bAD7uqwA+7rsAPu6LQD7um0A+7qtAPu67QD7ui4A+7puAPu6rgD7uu4A+7ovAPu6bwD7uq8A+7rvAPu+LAD7vmwA+76sAPu+7AD7vi0A+75tAPu+rQD7vu0A+74uAPu+bgD7vq4A+77uAPu+LwD7vm8A+76vAPu+7wDLsiwLy7IsG8uyLCvLsiw7y7JsC8uybBvLsmwry7JsO8uyrAvLsqwby7KsK8uyrDvLsuwLy7LsG8uy7CvLsuw7y7ItC8uyLRvLsi0ry7ItO8uybQvLsm0by7JtK8uybTvLsq0Ly7KtG8uyrSvLsq07y7LtC8uy7RvLsu0ry7LtO8uyLgvLsi4by7IuK8uyLjvLsm4Ly7JuG8uybivLsm47y7KuC8uyrhvLsq4ry7KuO8uy7gvLsu4by7LuK8uy7jvLsi8Ly7IvG8uyLyvLsi87y7JvC8uybxvLsm8ry7JvO8uyrwvLsq8by7KvK8uyrzvLsu8Ly7LvG8uy7yvLsu87y7YsC8u2LBvLtiwry7YsO8u2bAvLtmwby7ZsK8u2bDvLtqwLy7asG8u2rCvLtqw7y7bsC8u27BvLtuwry7bsO8u2LQvLti0by7YtK8u2LTvLtm0Ly7ZtG8u2bSvLtm07y7atC8u2rRvLtq0ry7atO8u27QvLtu0by7btK8u27TvLti4Ly7YuG8u2LivLti47y7ZuC8u2bhvLtm4ry7ZuO8u2rgvLtq4by7auK8u2rjvLtu4Ly7buG8u27ivLtu47y7YvC8u2LxvLti8ry7YvO8u2bwvLtm8by7ZvK8u2bzvLtq8Ly7avG8u2ryvLtq87y7bvC8u27xvLtu8ry7bvO8u6LAvLuiwby7osK8u6LDvLumwLy7psG8u6bCvLumw7y7qsC8u6rBvLuqwry7qsO8u67AvLuuwby7rsK8u67DvLui0Ly7otG8u6LSvLui07y7ptC8u6bRvLum0ry7ptO8u6rQvLuq0by7qtK8u6rTvLuu0Ly7rtG8u67SvLuu07y7ouC8u6LhvLui4ry7ouO8u6bgvLum4by7puK8u6bjvLuq4Ly7quG8u6rivLuq47y7ruC8u67hvLuu4ry7ruO8u6LwvLui8by7ovK8u6LzvLum8Ly7pvG8u6byvLum87y7qvC8u6rxvLuq8ry7qvO8u67wvLuu8by7rvK8u67zvLviwLy74sG8u+LCvLviw7y75sC8u+bBvLvmwry75sO8u+rAvLvqwby76sK8u+rDvLvuwLy77sG8u+7CvLvuw7y74tC8u+LRvLvi0ry74tO8u+bQvLvm0by75tK8u+bTvLvq0Ly76tG8u+rSvLvq07y77tC8u+7RvLvu0ry77tO8u+LgvLvi4by74uK8u+LjvLvm4Ly75uG8u+bivLvm47y76uC8u+rhvLvq4ry76uO8u+7gvLvu4by77uK8u+7jvLvi8Ly74vG8u+LyvLvi87y75vC8u+bxvLvm8ry75vO8u+rwvLvq8by76vK8u+rzvLvu8Ly77vG8u+7yvLvu8727IsC9uyLBvbsiwr27IsO9uybAvbsmwb27JsK9uybDvbsqwL27KsG9uyrCvbsqw727LsC9uy7Bvbsuwr27LsO9uyLQvbsi0b27ItK9uyLTvbsm0L27JtG9uybSvbsm0727KtC9uyrRvbsq0r27KtO9uy7Qvbsu0b27LtK9uy7Tvbsi4L27IuG9uyLivbsi4727JuC9uybhvbsm4r27JuO9uyrgvbsq4b27KuK9uyrjvbsu4L27LuG9uy7ivbsu4727IvC9uyLxvbsi8r27IvO9uybwvbsm8b27JvK9uybzvbsq8L27KvG9uyryvbsq8727LvC9uy7xvbsu8r27LvO9u2LAvbtiwb27YsK9u2LDvbtmwL27ZsG9u2bCvbtmw727asC9u2rBvbtqwr27asO9u27Avbtuwb27bsK9u27Dvbti0L27YtG9u2LSvbti0727ZtC9u2bRvbtm0r27ZtO9u2rQvbtq0b27atK9u2rTvbtu0L27btG9u27Svbtu0727YuC9u2Lhvbti4r27YuO9u2bgvbtm4b27ZuK9u2bjvbtq4L27auG9u2rivbtq47BgAAAAYAAAAGAAAABgAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAEgAAABIAAAASAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwAAIAAQADAACAAoABgAOAAEACQAFAA0AAwALAAcADwAAgAiABIAMgAKACoAGgA6AAYAJgAWADYADgAuAB4APgABACEAEQAxAAkAKQAZADkABQAlABUANQANAC0AHQA9AAMAIwATADMACwArABsAOwAHACcAFwA3AA8ALwAfAD8AAAAAAYAAgAFAAEABwADAASAAIAGgAKABYABgAeAA4AEQABABkACQAVAAUAHQANABMAAwAbAAsAFwAHAB8ADwAQgACAGIAIgBSABIAcgAyAEoACgBqACoAWgAaAHoAOgBGAAYAZgAmAFYAFgB2ADYATgAOAG4ALgBeAB4AfgA+AEEAAQBhACEAUQARAHEAMQBJAAkAaQApAFkAGQB5ADkARQAFAGUAJQBVABUAdQA1AE0ADQBtAC0AXQAdAH0APQBDAAMAYwAjAFMAEwBzADMASwALAGsAKwBbABsAewA7AEcABwBnACcAVwAXAHcANwBPAA8AbwAvAF8AHwB/AD8AQIAAgGCAIIBQgBCAcIAwgEiACIBogCiAWIAYgHiAOIBEgASAZIAkgFSAFIB0gDSATIAMgGyALIBcgByAfIA8gEKAAoBigCKAUoASgHKAMoBKgAqAaoAqgFqAGoB6gDqARoAGgGaAJoBWgBaAdoA2gE6ADoBugC6AXoAegH6APoBBgAGAYYAhgFGAEYBxgDGASYAJgGmAKYBZgBmAeYA5gEWABYBlgCWAVYAVgHWANYBNgA2AbYAtgF2AHYB9gD2AQ4ADgGOAI4BTgBOAc4AzgEuAC4BrgCuAW4AbgHuAO4BHgAeAZ4AngFeAF4B3gDeAT4APgG+AL4BfgB+Af4A/gEBAAEBgQCBAUEAQQHBAMEBIQAhAaEAoQFhAGEB4QDhAREAEQGRAJEBUQBRAdEA0QExADEBsQCxAXEAcQHxAPEBCQAJAYkAiQFJAEkByQDJASkAKQGpAKkBaQBpAekA6QEZABkBmQCZAVkAWQHZANkBOQA5AbkAuQF5AHkB+QD5AQUABQGFAIUBRQBFAcUAxQElACUBpQClAWUAZQHlAOUBFQAVAZUAlQFVAFUB1QDVATUANQG1ALUBdQB1AfUA9QENAA0BjQCNAU0ATQHNAM0BLQAtAa0ArQFtAG0B7QDtAR0AHQGdAJ0BXQBdAd0A3QE9AD0BvQC9AX0AfQH9AP0BAwADAYMAgwFDAEMBwwDDASMAIwGjAKMBYwBjAeMA4wETABMBkwCTAVMAUwHTANMBMwAzAbMAswFzAHMB8wDzAQsACwGLAIsBSwBLAcsAywErACsBqwCrAWsAawHrAOsBGwAbAZsAmwFbAFsB2wDbATsAOwG7ALsBewB7AfsA+wEHAAcEBwIHBgcBBwUHAwcHhwCHBIcChwaHAYcFhwOHB0cARwRHAkcGRwFHBUcDRwfHAMcExwLHBscBxwXHA8cHJwAnBCcCJwYnAScFJwMnB6cApwSnAqcGpwGnBacDpwdnAGcEZwJnBmcBZwVnA2cH5wDnBOcC5wbnAecF5wPnBxcAFwQXAhcGFwEXBRcDFweXAJcElwKXBpcBlwWXA5cHVwBXBFcCVwZXAVcFVwNXB9cA1wTXAtcG1wHXBdcD1wc3ADcENwI3BjcBNwU3AzcHtwC3BLcCtwa3AbcFtwO3B3cAdwR3AncGdwF3BXcDdwf3APcE9wL3BvcB9wX3A/cHDwAPBA8CDwYPAQ8FDwMPB48AjwSPAo8GjwGPBY8DjwdPAE8ETwJPBk8BTwVPA08HzwDPBM8CzwbPAc8FzwPPBy8ALwQvAi8GLwEvBS8DLwevAK8ErwKvBq8BrwWvA68HbwBvBG8CbwZvAW8FbwNvB+8A7wTvAu8G7wHvBe8D7wcfAB8EHwIfBh8BHwUfAx8HnwCfBJ8CnwafAZ8FnwOfB18AXwRfAl8GXwFfBV8DXwffAN8E3wLfBt8B3wXfA98HPwA/BD8C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PQAAxBUoNABB5KXDAAsE6UinWwBB9KXDAAsELTzlGgBBgKbDAAsCqDsAQZKmwwALAoUmAEGkpsMACwwoJcUPAAAAACst58EAQbymwwALBOhs5uEAQcqmwwALBmejAACkVQBB3qbDAAsKpWMAAEZrAAClRgBBgKfDAAsGSjaEH0lnAEGSp8MACwLkYgBBnKfDAAsIqj/lHEoWJ0sAQbSnwwALBHAF58YAQcKnwwALAmfSAEHMp8MACwKrBQBB4qfDAAsCB4wAQYiowwALEIlFxT0AAMQxAAAAAAAAx4AAQaSowwALAg0VAEG6qMMACwaneQAARFAAQdKowwALAubJAEGEqcMACw5NL0dKAACniAAA5FQQDgBBmqnDAAsKhrqIQ8erSVnHuQBBrKnDAAsEKGfmvABByqnDAAsSBncAAAAACFzlEQAAhFcAAIbAAEGCqsMACxSnwgAAAAAAAIVry3sHAAAAAADrZABBoKrDAAsIaRBlQAAAxFAAQbCqwwALCKkOB1uIPyYPAEHEqsMACwKqLABB0qrDAAsCpR0AQeaqwwALAgffAEH+qsMACwokWYorBsAAAEdcAEGWq8MACwJFNgBBpKvDAAsGyi2n6uoEAEG2q8MACwKESABB1KvDAAsCKW0AQd6rwwALDmcVAAAmTshEZw3sKuR1AEH6q8MACwMFYA4AQYqswwALCuRjAAAAAAAAxG8AQbaswwALAifRAEHOrMMACwKGgwBB7qzDAAsaBiIAACQ3AAAAAHQAJAEAAAAAAADHkwAARqgAQZitwwALF0hVAAAAAIZ9DwMAAAAABnkAAAAAAABEAEHsrcMACwwsFwAAAAAAAElIRzsAQZSuwwALBC4ORUIAQcKuwwALAoVFAEHQrsMACxIIAqakAAAAADIMAAAAAAAA6lcAQfKuwwALFoZvAAAAAAAAZsQAAAAASTVGFwAApokAQZivwwALBCl1JEkAQbyvwwALBItQZyQAQcivwwALDKldAABJFAAAAACkLwBB9q/DAAsCRl8AQaiwwwALBIlOpQIAQbywwwALAutyAEHQsMMACwIqTwBB2rDDAAsChykAQe6wwwALAie6AEGiscMACxAEaMgxAACoUAAAAAAAALABAEHGscMACwaGAgAABGQAQeaxwwALAib5AEHwscMACwooYAAAAAAAACtTAEGOssMACwJG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AACSKJQoligAQfiDyAALGJcoAAAAAJgomigAAAAAnCgAAJ0oAACjKABBoITIAAsSpCgAAKUoqigAAAAAqygAAKwoAEHAhMgACwa1KLYotygAQdiEyAALDrkoAAAAALsoAAAAAL4oAEHwhMgACwjAKAAAwSjCKABBgIXIAAsSxCjFKAAAxigAAMcoAADMKM4oAEGchcgACwLQKABBqIXIAAsC0SgAQbiFyAALGtMoAADVKAAAAAAAANYo2SgAAAAA2ygAAOUoAEHchcgACwToKPEoAEHqhcgACwjyKPMoAAD8KABBhobIAAsgAykAAAAAAAAGKQAAAAAOKQAAGSkcKQAAAAAdKR4pICkAQbaGyAALAiIpAEHAhsgACwYlKQAAJikAQdqGyAALFicpKCkAAAAAMCkAADkpPCkAAD0pPykAQfqGyAALFkIpQylEKQAARSkAAAAAAABGKQAARykAQZiHyAALDE8pAAAAAFApAABSKQBBuIfIAAsSWSlaKVspXSkAAF4pAAAAAGIpAEHUh8gACypmKQAAAABpKQAAAAAAAGopAABrKQAAbCkAAG0pAAAAAG8pAACCKQAAgykAQYiIyAALOIUphimHKQAAAAAAAJYpAAAAAAAAlykAAJopAACbKQAAAAAAAJwpnSmfKQAAoikAAAAAoykAAKspAEHIiMgACwKtKQBB3IjIAAsKrikAAAAAAACvKQBB7ojIAAsQsCmxKQAAsikAAAAAAAC0KQBBionIAAsQtikAALopAAAAAMQpAADJKQBBoonIAAsKyikAAAAAAADMKQBBtonIAAsGzykAANApAEHKicgACxDRKQAA2yneKeApAAAAAOIpAEHqicgACwLjKQBB9InIAAsC5ikAQYCKyAALBucp6in3KQBBkorIAAsI+CkAAAAA+SkAQaaKyAALAvwpAEGwisgACxL+KQAAAAAAKgEqAAAAAAAABCoAQc6KyAALFAYqAAAAAAAAByoAABEqAAAAABQqAEHuisgACxAVKgAAAAAAABkqAAAAABsqAEGOi8gACxQcKiAqAAAAAAAAJSoAAAAAAAAnKgBBtIvIAAsmKyoAAAAALCoAADgqAAA5KgAAAAAAADoqAAAAAAAAPCoAAAAAPioAQeyLyAALAj8qAEH2i8gACwRAKkEqAEGCjMgACwZDKgAARCoAQZCMyAALDEUq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xpTKAAsop2gAAKhoqWgAAAAAAACqaAAArWiuaAAAAAAAALBoAAAAALNoAAC0aABBgJXKAAsOtWgAAAAAuGgAAAAAuWgAQZyVygALBrxoAADJaABBsJXKAAsMymgAAAAAy2jNaNJoAEHElcoACwzTaAAAAADhaAAA42gAQeKVygALEORoAADlaOloAADqaAAA62gAQYCWygALCvxoAAD+aAJpA2kAQZKWygALBAppDmkAQZ6WygALBA9pEGkAQayWygALAhRpAEG8lsoACzgfaSFpImkjaSRpJ2kAAAAAAAApaSppAAAAAC1pAAAAAAAAMGkAAAAAMWkyaQAAAAAAADNpAAA0aQBB/pbKAAsCNWkAQYyXygALFjlpAAAAAD9pAAAAAEBpAAAAAAAAQmkAQbCXygALDExpAABOaQAAAABTaQBBypfKAAsKVWkAAFlpWmlcaQBB3pfKAAsOXWkAAF5pAABiaQAAZGkAQfiXygALDGZpAABqaWtpAABuaQBBjJjKAAsQe2l+aQAAAAB/aYJphGmFaQBBrJjKAAsKhmmHaYppAACLaQBBwJjKAAsKkWkAAAAAAACSaQBB0pjKAAsilWmWaZdpmmkAAAAAnGmdaQAAAAAAAJ5pomkAAAAAAACkaQBBkJnKAAsCpWkAQaCZygALAqZpAEGwmcoACxanaalpAACqaQAAAAAAAKtprGkAAK9pAEHsmcoACw6wabJps2kAALVpAAC4aQBBhJrKAAsIvWkAAAAAvmkAQZqaygALAsBpAEGsmsoACwLEaQBBuJrKAAsOxmkAAMdpAAAAAAAAyWkAQdKaygALCMppAADLac5pAEHimsoACwLPaQBB7prKAAsc0GnSaQAA1mkAAAAA12kAANtp3mkAAAAAAADfaQBBkpvKAAsK4WkAAAAAAADiaQBBqJvKAAsC42kAQbKbygALBORp7WkAQb6bygALFO5pAAAAAPRpAAD2aQAAAAD6aftpAEHem8oACwILagBB6JvKAAsEDGoNagBB9JvKAAsUDmoPagAAEGoAABdqAAAAAAAAHGoAQZacygALGCdqAAA1agAAAAA3agAAOWoAADtqAAA+agBBuJzKAAsCQGoAQcKcygALAkJqAEHMnMoACxJDagAAAABEagAAAABGagAAR2oAQeacygALKElqAAAAAAAATWoAAAAAUGpTalRqVmpXagAAWGoAAFlqWmoAAAAAYWoAQZadygALCmNqAABlagAAZmoAQbydygALGGdqAABqamtqAAByagAAAAAAAHNqAAB1agBB/p3KAAsOdmp3anpqAAAAAAAAe2oAQZieygALCINqAACMao5qAEGynsoACwagaqFqpWoAQcSeygALAqZqAEHSnsoACwSwarFqAEHgnsoACxS2agAAuGoAAMFqAADCasNqAADEagBB/J7KAAsKzGoAAAAAAADUagBBkp/KAAsG1moAANdqAEGgn8oACyTbagAAAADeat9q4WoAAAAAAADlagAA52oAAPBq8moAAAAA82oAQdCfygALCARrAAAFawxrAEHin8oACwIQawBB7J/KAAsSPWsAAAAAAABAawAAAAAAAEJrAEGMoMoACypDawAAAAAAAERrAAAAAEVrAABJa0trAAAAAE1rAABOawAAT2sAAFVrWmsAQcKgygALAlxrAEHQoMoACwJdawBB3KDKAAsIZWsAAGZrbmsAQfygygALFndrjGsAAAAAAACNa5lrAAAAAAAAmmsAQaahygALDptrAAAAAJ1rnmsAAJ9rAEHCocoACx6jawAAAACzawAAtWu2a7druWsAALprAAAAALtrwWsAQeqhygALCsJrAAAAAMRrxWsAQfyhygALCMxrAAAAANBrAEGaosoACwLYawBBsqLKAAs02msAAAAAAADiawAAAADkawAAAAAAAO9rAAAAAPBr8msAAPRr9msAAAAAAAD7awAA/GsBbABBgKPKAAsIA2wMbAAADWwAQZajygALRg5sAAAAABBsAAARbAAAAAAAABVsAAAXbAAAAAAAABlsGmwAAAAAAAAibAAAAAAAAD9sAABAbEFsR2xIbAAAAABQbAAAUWwAQe6jygALIlNsAAAAAFRsAABVbAAAWmwAAAAAAABebAAAAAAAAF9sYGwAQZykygALTmFsYmwAAAAAAABjbGRsZ2xobAAAAAAAAHhsemwAAAAAAAB+bH9sAACAbIFsAAAAAIVsAACIbAAAimwAAAAAj2wAAJBskWycbAAApGylbABB+qTKAAsKpmwAALFsAACzbABBjKXKAAsctGzVbNZsAAAAAAAA2GwAAAAAAADZbOxsAADxbABBsqXKAAsO8mwAAPNsAAAAAAAA9GwAQcqlygALLvls+mwAAAAA+2wAAAAA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eAAAAAAueAAAMXgyeDN4Nng5eAAAAAA7eDx4PXgAQZrRygALCkZ4AAAAAAAASHgAQazRygALAlp4AEG80coACxRceGN4AAAAAGd4aHgAAGl4AABreABB3NHKAAsebHgAAAAAbngAAAAAAAByeAAAc3gAAHV4dngAAH14AEGE0soACw5+eH94AAAAAIF4AACDeABBnNLKAAsqhHiKeAAAAACLeAAAkXgAAAAAkngAAAAAlHgAAAAAlXgAAAAAAACheKN4AEHQ0soACwapeAAAq3gAQd7SygALHK54AACveAAAsXgAALJ4AAAAAAAAuHi6eAAAvXgAQYbTygALDr54AAAAAAAAw3jVeN54AEGc08oACwjfeAAAAADheABBsNPKAAs84ngAAAAA43gAAAAA63jseAAAAADweAAAAADxePJ49ngAAAAA+Xj+eAAAAAAAAAB5AAAAAAF5AAACeQZ5AEH608oACyoSeRN5FnkAABh5AAAAABl5AAAAABt5HXkAAAAAHnkjeQAAAAAmeQAAKHkAQazUygALDip5AAAAACx5L3kweTF5AEHW1MoACwYzeTR5NXkAQejUygALAjh5AEGA1coACzQ8eT15PnkAAAAAAABBeUN5RXkAAEd5AAAAAAAASHkAAEl5AAAAAAAATXlOeU95AAAAAFd5AEG+1coACxJaeQAAXHlfeQAAAAAAAGB5YXkAQdjVygALFmN5AAAAAGR5AAAAAAAAZXlneQAAaHkAQYLWygALFG95AACmeQAAqHkAAAAAqXmqeat5AEGy1soACwiteQAAr3mweQBByNbKAAsQunnDecZ5x3kAAAAAAADIeQBB5tbKAAsay3kAAAAAAADSeQAAAAAAANh523kAAAAA3HkAQZDXygALAt55AEGc18oACwrfeQAAAAAAAOV5AEGu18oACwTree95AEG618oACwb/eQAAAHoAQdTXygALCgF6BHoVegAAFnoAQerXygALCBd6AAAAABl6AEGE2MoACw4aeht6AAAAABx6AAAdegBBnNjKAAsSHnofegAAAAAgegAAInoAACN6AEG42MoACywxegAAMnoAADR6AAAAADV6N3o4egAAAAA6egAAAAAAADx6P3oAAEN6AABEegBB7tjKAAsCRnoAQfjYygALAkd6AEGG2coACwJIegBBktnKAAsMSXpMek16U3oAAFV6AEGo2coACwZbegAAXHoAQbjZygALCl16X3oAAAAAY3oAQczZygALAmV6AEHY2coACwhoegAAAABpegBB7NnKAAsCanoAQYbaygALAmt6AEGW2soACwJuegBBoNrKAAsCcXoAQbLaygALAnN6AEHA2soACxR0egAAAAB2end6AAB4egAAAAB6egBB3NrKAAsIe3oAAAAAfHoAQfjaygALDIN6AACMegAAAACNegBBltvKAAsekHoAAJx6AACdegAAoHoAAKl6AACteq96sHoAALF6AEHA28oACw61erd6AAAAAAAAuHq6egBB2tvKAAsQvnq/egAAAADAegAAwXrIegBB/NvKAAsCyXoAQY7cygALAsp6AEGc3MoACwLLegBBptzKAAsCznoAQczcygALENJ6AADUegAA2HoAAAAA23oAQeTcygALKNx6AADleul6AAAAAOp6AAAAAOt6AAAAAOx6AAAAAAAA7XrxegAA9HoAQZTdygALBAF7AnsAQabdygALBgR7BXsGewBBtN3KAAsGDXsQexF7AEHM3coACwIVewBB1t3KAAsOFnsAAAAAF3sAAAAAGXsAQfbdygALEBp7AAAiezB7M3s0ewAANXsAQZLeygALJjp7QXtHewAAAAAAAEh7SXtKewAAAABMe097AABRewAAAAAAAFJ7AEHA3soACwJTewBBzt7KAAsaVHtWe1x7XXsAAAAAXntge2F7YntrewAAbHsAQfDeygALKG17AABvewAAcHtxewAAAABze3R7AAAAAHh7ensAAAAAAAB7ewAAf3sAQaDfygALAoB7AEGu38oACwKBewBBut/KAAsCgnsAQcjfygALAoV7AEHc38oACwSGe4l7AEHo38oACxKLewAAmXsAAAAAmnsAAAAAm3sAQYzgygALBpx7AACeewBBmuDKAAsYoHsAAAAAAACkewAAAAAAAKl7AAAAALx7AEHA4MoAC9DiB8l7y3vMewAAznsAAAAAAADQewAA1nsAANd7AAAAAAAACADqA4gA9wMEAKsCBApFAYoKfQAHCzwCCQtQAgsLqAILC0oDCwucAwwLZAEMCyYCDQs9AQ0LcgENC9UBDQvXAQ4LjQESC0UAkguRAIYA8QSICxYChgCXBQsAigCMACgABACbAAcAmQYECs4ChwrABAQA9QAFAJcABQDlAgYAewQH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Cg8ABQrLAQcKMQQICvEAiApOAYoAhwGHAKAHhQsNAggLgQILC4QBjAtEAo4AfgCGAIAChADjAQcAUAYJAEUABgpEAQYKCAIHClIBBwrBBggK5ACLCu4CBQvtAYYLEAKHAN4CBAuuAIcLjwOKAOABCQDvAZIAaACHCsECCQDYAQQKSQAGCmQCBwqfAwcKMgUHCh4HCArZAAkK/QIJCv4CCgqYAQsKMwALChkDDAoKAQ8KngAUClkAlgogAAcLJAKJCzoABAsgAAUL1wAGCw0BBwv2BgcLZAcKCxAACws2AwsLugONC+EBhABqAwkA5QAFCoUBiAp8AgcL1QaIC90BhgC0AwULNAGHC0AEBADsAosA8QOIChUABgArAocA5QEFC34ACAspAQkLbgEJC70BDAs1AAwLdgGNC+wBBwsPBosLaQGIAMEAiADYAQgAjQINAF0AkwAOAIQA2AOEC68ABQCsAAYAsweEC60ClQsIAIULHQMNAFMABQq9AAcKugEHCrsBCAoZAQwKrgCNCgUBhgAgBoULNQKLAIABhQAEAQcA9gIHAHADBwBPBQkApAAJAKcACgCcAAoATAIMAGUADgAwAA8ARgAGCgIABwruBAcKyQYIChYACAoOAQgKZAIJCjgBCQq0AQoKNwEKCm8CCwpIAAsKSgELCscBDApBAQwK+AEMChICDAofAg0KEQANCpwADQpOAREKPACUCkAABAv8AAcLLAQKC7IBCwvkAAsLqgENC+cAEgtqAJQLVwAHCmIBCgqaAYsKLwMGAG8BBwqeAgcKLwUICpsBCAqzAQkKjQIJCuQCCgqBAQsK3gALCkQBCwo9A4wKYwIHAJYEBgqmAIcKdgGSAHkAhAA8AwUL5wCKC/0BBwtZAgkLFQEJC6ICCguyAAoLAQEKC6IBCwsTAgsLIAILC0kCDAtxAAwL2wENC2MAjgusAYYABQaHC/MGBQBXAYYKjgGHCjIAhwuTBgQAuAEHADkACACnAAgAdwEJAFIACQAxAgkA6AIKAGwCiQvoAoYAngMGCgUCBwqHBAoKbQKLCsAAiQA7AwgAwgCIAPQCCgrfAIsKhQIHCkAAiAr1AAQLjwEFC3cABQvuAQcL7wKJCywChAAoA4cAFgAHCuMGjAo2AQUAfwIHAOEECwCAA4YLSAKGAE4GhwBcA4cLYQQFCoEABgo9AIcKswME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Cr0GBwpNAAcKqgEHCiUFBwpLBQgKfgAICjMCCQoLAgkK7gIKCjYBCgpEAwsKKgALCj4BCwrbAgwKRAAMClwADAr7AQwKtAINClEADQruAA0KdgEOCrQBEgqKABMKTgATCm8AFAo3ABQKTQCUClwAjQqiAQcAJweECqoDBgAIA4YAkwOKCl8BBQtcAQYLCgIGCoQGBwrbBQgKdQAJCjoBigquAIcKwwKEAGUChQqTAYQLiAEFC7EBCQt5AosLdQKFAPsChABuA4QA0QOEAGQABgDPAQQKLAAFCjcBBwp/AgcK+gIHCiMHCQoIAAkKzgGUClMAhgvqAAQKWgEHCnMACQq0AAkKyAGKCmsBBQBqAQUAuwEGAD4BBwD7A4sAbwIFAM8BCAAoAQcLjAAHC54HCAuoAgsLMQOTC1gABwvGBIoLggGOAIkAhADGAQcAegcGCwUABwobBAkKIQILC/kADAs5ARALQgCRCxoAhwD3BZEAOgCUCzsABQAwAAUAlAEGAC0CBwDKAQgAVQIKAMcBCgBeAgsAMQALACQCDADcAQ0AEgCNAMIBBQvDA4YL7QaFANkCigtKAgUAugGHAMAHhgDBAZAAKAAEAFUDBwu0AAgL/QGICxgDBgq5AAcKawcJCmsDiwqhAoYLDAIMAOMABApHAQUK3gEHCjQFiArxAgYA0wUFCvwDhQr+AwQKZwCFCpEBhAujAwQK8wGHCo0FBQA3AAcAeAGMAKEAhQDCAQYAlgSGABoGCgA+AA0AkAGHCy0HjADPAIcAZQMECwUDBQtqAokL9AKECmAABADVAAcA3wAIAFAAhwrIAwQLWgAFC1EBBQshAgcL8gIJC7oACgtIAAoLDgMLCwECCwtBAgsLYgILC3kDCwvBAwwLYgEMC2oBDAvNAQwLUwINC08Ajwt5AAcAfQEHACYDBwA0AwgAYgEIALUBCAATAwkAkQIKADoACgBTAQoA7QILAJIDDACiAA0ASwAOAGoADgDGAA4AQAEOAJ0BkgArAIgA6wKIALoDhgAxBIcALAIHC5cACQtJAYsL/gAFALQChgBzBQYKMwKJCuAAhgC/AIQAJAMJC7sACgskABELLACSC0AABwulAAcLlwOICwUCBAv6AQULJwEHC5AGDwsOAJALBQAEAMICBgCiAAcAqAeIAD8DhwtgBQcL2wMJC7ACCgsKAgsLFAOM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C8EBDgs1AA8LDQAQC0AAkQspAAYAdAMGAPsDhgB+BAYL5wYMC8IAkQtrAIgK9wGFC0gDBwCfAoYK0gGEAHgDBACVAIoAcAEEAJoABwBuBIgAaQCHANcDCQuCAgsL7ACOC8EABAAfAAYArQEHAMIDCQDKAYsAswIGAIMChgBOBIQAOAEEC0QABQt6AgYLggEHCxoDCAsRAQkLMwIKC2kACgurAAsLXgCLC2IBhQDkAocAagYEC18ABwugAQgL0wCLCz4DhADsAIoK8QAHC9sCDQsUAI8LCwAFAEQDBQBZAwYAkAaHADsACgBEAAsA7gGYCwYABABRAIsAYwOHABsDhQuxAgQA6QMFABoBBgCMBwYAuQcGAMMHBgDIBwgAigIIAJcDCACYAwgAmwMIAJ4DCACfAwgAowMIAKsDCACzAwgAvAMIAOUDCQCLAwoAtgMKALkDCgC6AwoAvAMKAL4DCgC/AwoAxAMKAMoDCgDMAwoAzQMKAM8DCgDQAwoA1AMKANUDCgDYAwoA3AMKAN4DCgDjAwoA5wMKAOoDCgDrAwoA7QMKAO4DCgDwAwoA8QMKAPQDCgD2AwoA9wMKAPsDCgD8AwoA/gMMAL8DDADBAwwAwgMMAMMDDADEAwwAxQMMAMcDDADIAwwAyQMMAMoDDADLAwwAzAMMAM0DDADOAwwAzwMMANADDADRAwwA0wMMANUDDADWAwwA1wMMANgDDADZAwwA2gMMANsDDADdAwwA3gMMAOADDADhAwwA4wMMAOYDDADnAwwA6AMMAOkDDADqAwwA7AMMAO0DDADuAwwA7wMMAPADDADxAwwA8gMMAPMDDAD0AwwA9gMMAPcDDAD4AwwA+QMMAPoDDAD7AwwA/gMMAP8DDgDbAQ4A3QEOAN4BDgDfAQ4A4AEOAOIBDgDjAQ4A5AEOAOUBDgDmAQ4A5wEOAOgBDgDpAQ4A6gEOAOsBDgDsAQ4A7QEOAO4BDgDvAQ4A8AEOAPEBDgDyAQ4A8wEOAPQBDgD1AQ4A9gEOAPcBDgD4AQ4A+gEOAPsBDgD8AQ4A/QEOAP4BDgD/ARAAcQAQAHIAEABzABAAdQAQAHYAEAB3ABAAeQAQAHoAEAB7ABAAfAAQAH0AEAB+ABAAfwASAPIAEgDzABIA9AASAPUAEgD4ABIA+QASAPoAEgD7ABIA/AASAP0AEgD+ABIA/wAUAH0AFAB+AJQAfwAHC7UGBwvpBooLIgIHC2cEBwskBgoLKQEKC6YBCwv8AgsLKgMMCwgBDQtmAA0LLAENC+QBDguTAA4L5QARC0cAEgt2AJMLeAAGAHwEhgAyBoQABwOHCroDhQtgA4ULoAOKC70AhwqmBwYKJQIICiIACAobAQkKpQCKCtsBBQqMAgUKvQKHCsEBhwu3AgQKjwIHClIDEQpLAJIKiQCMC6oChQsLAggAygOICp4CiAsrAgcLTAAICywACQt0AwoLRAILC48BCwt+Aw8LegASC5AAkws9AAYKnwAGCmwBBwoEAgcKnwWJCgYCBABHAAUAeAEHAHcAigCZAo0KlwALADsDDgAiAI8AlACFCwYCBADfAYcL+waHCzwHhwrhAwcAXwKIAGMAhgCoB4QAGQMEACkABQBKAAcAWwYLAGcDjABrAgcAXgALAEkBCwDFAwwA8QAOAGIBDwAWAJQAPwAHCvUBCQpvAAoKjQALCkwBDQorAA0KrQEOCoIADgqfAZEKZgAJANEAiQAsAYYA2QWKC/8ABAumAwULigCIC2IChQBiAAYAJAUKCyQDigtAAwgLYAAJCyQACgtfAgsLpwELC7oBDAs1AQ4LxwAPC1oAkQtuAIQAzwEFCpUAiArpAIUKpwMEC4wCCAtAAQkLDQAJC44BCQvXAgoLSwAKC7gACgvmAAoLNAIKCzkCCwvNAwwLRgAMC70ADQs5AA0LAQEWCwYAlgsQAI4AIwEMCkYCkgqDAIgKIQOFANgDkQt0AAQLtAKFC0EBBAC2AAYAzQCHANwABAAqAAkAzQAJABIDigCTAgYAIQMLC4IAjAthAoQAewIFC1kBhwv4A4sAFQKEAHMBBAAQAYcARAMGAAIFhwtMBAUAOQOGAGgGhwstBYULoQIECx8BhQv6A4cAZQEGANMBiQBvAwcAPQGHADkCBgCcA4YANAYFCyIABQqWAQoL1AIMC7wBDQtiARILIAAXCxgAFwsfAJgLBQAGAAMHBgArBwYALAcGAEAHCABMAwgAUQMIAFYDCABmAwgAdwMKAFQDigCuAwYKRQCHCnUAiQAzAQQAsAMGAAcHBgAhBwoAUAMKAGsDCgB/AwoAgwMKAIYDjAAFAwsAKwANAEgAjQCOAIcKJgeGC34BBAqwAYcKOAOEC0kBBwAcB4sLfACFCjoDhQANAoQLigMH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CugCjQu6AQoKawCMCrQBhwv3AYYAigSECp8DBwAeAAgAVgAIADsBCAC8AgkAQAIJAFoDCgCeAQsANgELAHgDCwCIAwwAaQENAPgADQBzAQ4AjgAMCp4CkgpeAIYA0QIEC3EABQujAAUL3wIHC/EDBwp9BAkLCQAJCpwACQsDAwwLWgANC4oADQuaAY8LgACKAEcDhQoKA4kAaQKFCvYBCArEAAoKGwGLCpYBBgCsAQcADAIIAKkACADqAAkA4AGKAIYChQpXA4YAcAYHALUEigB9AgcAPAYEC6cDhQs3AwULDQEHC7IBBwt7AwgLUwEJC74CCwtSAgsLzgKRC2QABwtuAwkL5QGNCwgBBAAKAQgABAAJACcACgCmAAsAlgMMAHsCFAAKABYAGwAWACsAFgA0AIYLsQYHCngFCQq+AYoKLQCHC4QDhABeA4YAEgaHCwkEEwAQAJMLEACHC7gEBwCdAIgAFwEGAFwCiACHAQ0KxwEPCmMADwqBAJAKRACHCqwABwCxAwsAyQKLAOgCBADNAwoAbQMKAKkDCgCqA4wAxwKLAP4DhAo4Ao4LjwAEADcCCQBbA4QK3AIHADYHiAB0AogK3QKFAPoCBAqsAYcK/QYKABADDQC/AAcK3weMCpkChQAqAQcAeQIHAIkDBwCNAwcAAgYJAP8CjAB8AooKJgOEABsDiwAtAYcAsgcFC3EChwtRBocLEwEHCyUACAupAQgLtQIJC9ACCgt8AQoLfgILCxEBCwszAQsL2QEMCz0AjwsrAIcLxgCGANQEBwBxAQwAhAIMAIUCkABaABMADwCVABsABgBHAAcATQMIAKAACQA+AQYKVwaGCpEGhgCnBYYA5wSKAN8CCABMAIQLqAAGCtQGCArLAgkKIgMKCi4ACgozAw0KNAEOCl8BDgprAZIKQwCHC1sABgDaAQQKPwCFClsBhQrtAooASQOFCm4BBgBEA4QL4QCHAFYGhwpZAIwA3wKGAEEGiguRAAYAbgWJACQDjgCKAQYLDwAHC0YACgvwAJMLXQAGAGAAhwCSBQQAiwKFACEBBwu8AwcK0QMHC4UEBwviBQcLRgYHC08GBwtTBgcLyAYHC+8GCAtOAgkLRAEJC+ACCQsGAwkLCAMJCxADCgs3AgoLxAILCwYCCwtlAgsLtwILC8wCCwvjAgsLAgMLCwMDCwtQAwsLWQMLC6MDCwuzAwwLRgEMC4MBDAvkAQwLEAIMCygCDAtlAg0LvQANCwABDQtUAQ0LsAENC7QBDQu4AQ0LxgEOC64ADgvcAA4LHAEOC4YBkQt5AAcAsAIIACMACQD/AQoA/wKTAHYAhgCbAgQAAQIFCjgDhQqtAwcKuAEICuYAiwpqAIYA8geHC3cFjwtCAIcL+QUEC5EABguwAAcLiwEJCzICkAscAIQL9QGEAMAChgD0BQcANgSGC9ABBgv9AQoLUgAUC1sAlwsNAAQA0AKFADIBhQCvAQcArAQECpIDBQogA4UKVAOHC6UECgA2AI0KcwAHCjQCjgqoAAUA0AEGAOwABwC4AgcAkgMHAFQEBwCoBQkADwAJADQCCgAOAAwANQINAMEBDgA1AA8ADQAQAEAAEQApAAQKlgOFCmwDBgCKBYYK5AYEClwAhQoSAYYAiwMEC3IACAr1AQkL7AENC84BjgvXAAQLTQAFC2kBBguLAAYLkQEGC5QBBwudAQcLywIHC7QGCwsXAQwLswAMCwIBDQv0AI4LZgEGAOcGDADCAJEAawCGC7UGBQrnAo4LSQEECjEABwoYAYcKYQYFAEgDBwslBAgLUgALC/oADAukAY0LuACHC9QChgCEA4gKLwCGAJwFkAsAAAYAowIHAPADBwAYBgkAggILAOwADgDBAAUKEAEFCowDBQquAwgKxQAJCi8ACwoaAosK5gIEAEQABQB0AgUAegIGAIIBBwAaAwgAEQEJADMCCgBpAAoAqwALAF4AiwBiAYcKdweJCnsDBABfAAYAEQUGAEQGBwCgAYsAPgMGCwEChwscBAcA2wINABQAjwALAIkLgwMKAFIDjAC5AgQAlgIHC4kFDAt+ARELMACYCwwAhQDgAoQAXQMECpcBhAowAo0K6gEGCyECBws1AgcLhQYKC3IACwuCAowLagIGAGcDhgDoAwUAYAMKAIgCCwCfAg8ALgCFCwUAhQCgAwsAWgANAAcABArbAQsKIwANCkcADQqxAI4KpgGIAEwBhwvAAIYAHwSIC/sCCwDaA4wAqgIHAEwACAAsAAkAdAMKAEQCCwCPAQsAfgOPAHoAhwvVBIcKfAILACwBBgreAAcKVAYICpkBiQq1AgQLVwAFC/oACgtZAg0LKgENC2EBjQt4AQUABgIKAFQBCwCvAJUAEACMAAMDBgBUBIkAPwOEAEQDhwA8BwQAvQMGAAwHCABKAwgASwMIAFMDCABXA4wA/wKHCy4DBAs5AAcLqwQHC54FBwsMBgcLKwcHC3AHCQv1AgoLXAKLCwcChQpyA4oA9gAEAKYDBQDKAAgAYgIHC2kHDAsiAQ0LUAANC7UBkQtKAAgAYAAJACQACgBfAgoAJAMKAEADCwCnAQsAugEMADUBDgDHAA8AWgCRAG4AhAqqAQcAjgIIAPAABgo6AAcK6QIHCrEHCAqjAgkK3wEJCtsCCgpKAQoKUQIKCjEDCwogAAsKhQALCt0AkQpEAAkADQAJAI4BCQDXAgoASwAKALgACgDmAAoANAIKADkCCwDNAwwARgAMAL0ADQA5AI0AAQEEC9EAhwuGAwcAhwGJChoChgCTAQYLLwEHC08BBwudBQcLhAYICykCCAuMAggLkAIJCy4CCwvnApULEgCECy8CCwBLAI4ACwEGAC8DjQsCAI0AbgGJAHcChQv5AwUAWQGHAPgDhQvFAoYL0QaFCjYCBwC4AwYKMAAJCosACgqPAQsK1QEMCnoCjQrfAIUAoQIJAFIDBwsIAIgLzgAGAJYClQAjAAQAHwGFAPoDBgpyAAcKyAQHChQGiAoDAAgKQAKJCgsBBAB0AwUAIgAKANQCDAC8AQ0AYgESACAAFwAYABcAHwCYAAUAhQqlA4QLCAOKAJcAiACrAYYAfgGEAEkBCQBOAwoAOwOKCyEACQAXAQoAlwEOAFQAFgASAIcLEQWIC5YBhACKA4gAbgGGAEsDhgCjBYcAXAWKAOADBAB7AAUAXQIHAOUFiAAkAIQAiQIIC68ACguoAIoLPQKFAP8ChgD6A4cLGQUMCh4ADQqUAA4KVwAOCrYAEAoqAJQKRgCGC18CBAARAQUAkgKFAOMDBgBIAIsLrgAKAOMBDABwAQcKOAAHCsUHCApRAQgK4gIJClgCDQq/AY4KXAAFCxADigqaAocAQQWLC3IDhgANBYUATQKGAMQHBQB1AAYAAgIGAB0CBwCMBAcAnAUIANwACACIAgoAsAKLADACiAB7AQUArgIHCmIDhwqLBIQKSAEJCw4ACQu5AQoLMgGLCwkABAplAIcKkwQFCkEDiAroAgULoQAHC0cDhwt3AwcAxAAKAP0CCwBbAQsAKAILABYDDAAHAQ0A9gANAA4BDQCLAQ4AsAAOAL4ADgCOAQ4AnAEP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C90CCQvCAAoLXAALC8YADAtUAAwLVwANC4AAkAtKAAUAVQEHAGkECwCeAQQKMwAGCgQABwpPAgcKUQMHCrcDBwpNBgcK4AYHCsQHCQqyAQoK8gILChkAiwolAIUKhgOHCqADhwATA4QAtAGGCg4BBwAzBocAqwYGAHkBBwABBAkAZQKRAGgABwvWAwcLUQUKCyAAjws4AIsAYACEAMMBhAqgAY4KdAEFCpgABQrFAAcLMgEHClQBBwpjAwoKJAIKCkUCCwoGAAwKAwAMChMADgpuAI4KIQGGAKgChgthAgcA4wEHCr4ACAocAAgKjQAICrwBCAorAwkK1AELCk4BDAoYAAwKggGMCkACCgCUA4UK9QIFCtEChwoRBoULsgCGAKkDhAqCA4UA4wKTAFIAhwCXApIAgAAFChUBjQr3AIYAPwSECrMBBgt9AQcLhQIHC7YCiAsiAgcA9wGHAF0HBgCtBwgAnQOKALsDBABxAAUAowAFAN8CBwDxAwkACQAJAAMDDABaAA0AigANAJoBjwCAAAQARAGKAGgABwDMAQUKCQGGCtQAhQtpAAcLBQEHC1MEBwtbBAcLSgUHCzQGBwupBgcLbgcJC9EBCgv4AAoLXQEKC4cCCwsPAgsLlAILC50CDAsRAo0LMQEFC7YBCQu2AgwLcwKNC9IAmAsLAAQApwOFADcDhAq+AgUADQEHALIBBwB7AwgAUwEJAL4CCwBSAgsAzgIRAGQABQooA4cK/QcHAPYDCQDlAY0ACAGGALEGBwASBwsAYgMMAGcADQDvAYwL6QAEAKcBCgC1A4oA9QOHAIQDCAsZAIoLOgMFCqYACArjAowK/wGGAOIHBwv2BIsLZAIECncABQqqAAUKvwEHCqwGBwphBwkKZQEJCs8CDArmAYwKVAIMAD4CjAs+AoQLNAEGAMQDBgC2BIYAFgUECsIBhwqGBIcLlgCIC4kCDgDVAJQAJgAJCy0ACQs3AY0LKgCGCwkCBwpfBQcKugWKCksBhAryAgULUwEHC6IFDgsDAA8LKQCTC0IAiAt6AYYA/gMFClIDiAofA44AjwCHAO0HhgtcBggACwKWACIABQBxAocAUQYHABMBBwruAAcK8QcICngACAq8AAgKkwIJClYCCgrSAQwKVgEMCkwCDQr3AQ4K9gCPClwABwAlAAgAqQEIALUCCQDQAgoAfAEKAH4CCwARAQsA2QEMAD0AjwArAIcLPQOHAJcHhAD9AgUL5gGHC0UFBwtjBggLEQAKC9kAigsnAQQKyQAHCtAGCApaAgsK9wALCjoDkQpBAIoLLgILACcCjgCfAAgKpACSCj4AiwuwAIQAqACIAPIDhgDKB4cAWwCKABQChwrbBIcAXAeECosDBQpkAAoKSQEMCqABlQodAIYLvwGECrAABQp8AgUK5gMHCgkABwrkBQgKGgAJCj0BCQpmAQoK0gAKCiQBCgoVAgsKKwIMCg4CDApfAg0KBwENCssBjgoPAQQLYQKHC/QCBgAPAAcARgAKAPAAkwBdAAQLogOFC7MDhgDLBIYA/gWFC6sDhQvCAwULiwIIC6oACQs9AAkLPwAKCxcACgslAAoLQgMLCwQACwu7AAsLGQELC/cBCwulAgwLYAAMC4IADAv0AA4LBQAOCygADguiAA4LygCSC4UABAuWAQULQwIMC+wBlgsPAIsAiAEGCmICCgp/AI0KGwAHAI8CBwA0B4gKdwAEAJEABgCwAAcAiwGJADIChAD1AYwLkQCIAPsDhgD9AYsACwEGCxEABwsQAAcL6QMHC74HCQt2AwoL6QEKCyADCwsOAwwLQAENC9MBDguRAA4LgwGPC3cAkQsRAAYASwSFC8oBBwu/BwgLAAAIC6sACQt4AAkL3AIKC9kBCwuQAgsL5gMSCwAAEgsCAJMLFQAMC6sBkgsmAAoAtAOKAMgDBwp+AIgKVACIChYDBAByAAkA7AENAM4BjgDXAAYKQAAMCnkBjQo1AQQATQAFAGkBBgCLAAYAkQEGAJQBBwCdAQcAywIHALQGCwAXAQwAswAMAAIBDQD0AI4AZgGGALUGBwAEAwcAJQQHAG8GCABSAAsA+gALAF8CDAA3AQwApAENALgADQBvAQcKUAQLCg0BCwobAgsKcwILCsICCwrPAwwK+AAMCrIBDApYAgwKbgINCikBDQrlAQ4KRQAOCpkBjwpsAIcA1AIECwACBAsHAoULVgGGAG0EkQsdAAsK0QONCvsBBgBJAwYAEgQGAKoECgDhA4wA/QMGCx8ABwvrAQcLEgIIC1ACCQoiAAsLNQALCuQBCwsLAwwLpwAMC5sBDgsOAA4LiAAPC0gAEAsRAJALSAAEAP0DBgD1B4ULiwMHAHUBCABPAQgAVAIJAOgBBgqkBgcKJQEHCn4BBwoCBAcKPwQHCusHCAr8AAgK1wIICtkCCQoeAAkKxwAJCucACQr7AAkKTgEJCmkBCQrIAgoKNwAKCjwACgroAAoKTAEKCoABCgqMAQoK+AEKCh4CCgqMAgsKFAALCjAACwrPAAsKIwELCioBCwpWAQsKbQELCooBCwpsAgsKwQILCvkDDAp7AAwKVAEMCpYBDAqDAg0KPQANCg0BDQo3AQ0KPwENCuYBDgrqAA8KPgAPClUAEApHABIKdwCUCmkAlgAlAAQL0AAFC2oABgsTAggLmAEJC7wAigs8AoQANAIGAAEChwAcBIQAOQMJAIMDjAu5AYYACgOFC3sBBwCJBQwAfgERADAAmAAMAIQL8QAHAFwEBgp7AQcKDgEICrAACAq3AAkKsAEJCpUCDAr3AAwKaQKSCn0ABQoYA4UKhAMGACECBwA1AgcAhQYKAHIACwCCAowAagKFAAUAigsHAIQLAwGHAMAAhgC9AogA+wKHCrsHBAqFA4UKCAMKAPMCkwAdAIUA9wIEC60ABQs4AQULAAKHCwUFBwtDBgcLmwYJC9ABCwvDAAwLFwEMC8ABDgsLAJMLZgAHAHIBBwDvAwcAmQSHAB0GhwDVBAQAVwAFAPoAjQAqAQQLxAEFC0cCBQsxAwYLsQEHC1ECBwvQAgcLYgUIC6EACQscAQoLOQGLC3YDBAsjAocLgQWIC9ICBAolAAUKTgGHCuUEhAr8AQwAawCSAB8ACAukAYsLwQCHAC4DhwuZAYwA3wMEADkABwCrBAcAngUHAAwGBwArBwcAcAcJAPUCCgBcAosABwKEABwCigs0AYQKFQKIAGACkAtBAAQA9gOGAO0HBADRAAcAhgMFC+oDiAvpAoYA7gcGAC8BBwBPAQcAnQUHAIQGCAApAggAjAIIAJACCQAuAgsA5wKVABIABQs/AgYLYgGHC70CBAvvAAYL3QEHC0cGCwtEAIsLaQKEAC8CCAAPAhIAPACTABgAhQqYA4oA/wGFAPkDhQCjAooKhwELAJwAhwqgB4oLcQGEC28BhQDFAgYAugKGAHcDjgp+AIYA0QaECuMBDQsrAY4LSwCFAMoCBwAIAIgAzgCKCuABBAu2AgkK7wGSCmgABwvgBAsLbQKLC74CjAuvAoQACAOLCvEDhwD4BIYAIwQICo0CDQpdAJMKDgCHC9UAiACWAYUKrACE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AL4DCQDLAwkA0AMMABwDDAAfAwwAKAMMAEMDDABEAwwAkgMMALIDDwDYAA8A6AASALcAEgC7ABIAwgASANQAEgDoAJUAMQCECuIBBgA7A4YAmgWHCloBhgD7BwYA8gAHAOMABwAtBggAaAAJAHEACQDcAAkAqwEKAIgACgDvAAsAQwILAP8DDQAEAA0AzAANADwBlABWAIYLlQYHAJQACAAcAY0APwCOAAoAhwtIAoYA4QQHAF0DhwpOAQUKGwMGCs0GiQtGAIQAJwMHC4cACAsHAAgLPgAJC/MACguSAgoLuQILC8gBiwv0AgkLiwGKC08AiQtsAJMAXgCIAO4Bhwt3AocKbgIHAOYFhwrWBgQKywCHCpAHBwuWAQcLywEIC14CiwvWAgcAGgUIAPkBCQDiAQoAfgALAOEADABbAQwAwQENABMADgDaAI4AswEFAAwBCgD8AgwAeAANACcAkQB/AI4LRAALCqYCjAozAQwLDAEMC4ACjgt3AIcK/AeFC2QCBAt0AQcL4gEIC54ACQtaAgkLZwIKC/UACgumAgoL6AILC/gAiwsmAwcKNwEJCjQBjAr/AAQAgAGHAP4DBQtWA4cLxweHCvIEBAqQAQUKCwGHCugAhwCnBgkAnwALAJUCjABbAgQAxAMOALYBDgC8AQ4AyAEWADwAFgA/AAkLagAJC6MACQsoAQoLpwAKC6wACgsJA4sLEACIAEcChAADAggAeAIIALkCiQBWAwULwwCHC5UGBgBjBIYAVQWGC0gBBwvNBwgL2gKLC+4DBACIAIUAJwKGAPYGBwAHBQkALAAKACgCCgCCAgsARwMMABIBDAATAQwAdAENAFsAjgB9AAUL7wILCx0DjAvLAIUA3AIHAKcCCAA5AQQKZACHCzUDCgBpAY4APAGGAFMCBgCTAAcAdgMJAPECigAMAQUKagEFCrsBBgo+AQcK+wOLCm8CBQrPAYgKKAEECsYBBQu2AwUL4gOGC18BigCJAAUKMAAFCpQBBgotAgcKygEIClUCCgrHAQoKXgILCjEACwokAgwK3AENChIAjQrCAYUAngGHAOIGBQulAYcLLwAFCroBhwrAB4YAVwKGANUGhgBbBgQA6AGEC14BiQvvAoQAUwCMAKQChQvHAwcAZwYFCjcAjAqhAAQL2QEHC28CCAsoAwkLZwMJC30DCwsmAAsLrwEM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Cs4ACgvmAQoKVAILCw0ACwt9AQsL4AILC/4CCwtNAw0LcgANCtoADQskAQ4LLwCOCpkADAC1AocL9wIFADoBBgDdAAcAowEKAIoCCwCMAQwAnAANAHEBDgBNAZEALwAGC5QGBgvDBgcLZAEHC4wHCAs2AAgL3QAJC+EACQtkAQoLTQAKC74BCgvbAgwLlAGNC+sBhAt3AQQKBgKHCnAEBACRAwQLmwELC4MCjAtzAAQLUACFCywACAqxAokKXwOKAHADBAoSAAcKkQAHCrwBBwr+BAgKMQAICpABCQpHAAkK+gAKCssBDAqgAJAKGACIANsBBQD4AwULKwGHCzsEBwBaAggAswAKAA0DjAB+AAYASQGKAG8AhwBIBwQL2wAHC+EGiQtWAAYAYAcGAGQHBgBtBwYAcAcJALkDCQDZAwkA3wMJAOkDDAAyAwwATgMMAE8DDABdAwwAXgMMAGkDDABrAwwAbQMMAG8DDABxAwwAdAMMAIcDDACTAwwAngMMAKsDDwC2AA8A2wAPAP8AEgC/ABIA0QASANMAlQApAAULSAGHC5YDiQAMAwwAUgCPACQAhQryAwUANQOGAJcGhQsCAoQAvAOGAJwECgBwAAUKVwAHCjkBBwpPBAoKRgILCoUBCwotAwwKgQENCh4BDgp8AJIKbAAFAEcABwB/BQkAwAIKAAUBCgBrAgsAIwILAGsCjwCdAAQAEwIFAMcBBQstAQYLOwIOCzEAkgtmAIQKCwEGAIEBBwDYBwkAUQGKAAUChQvWAoULbAEEC0wABwsOBgkLMgEJC64BCQuXAgoLqwILC6sBCwvxAgwLTgEMC7oBDgsCAQ4LbgGPC4MABgBJBwYAVwcGAFkHBgBmBwYAdAcJAJMDCQCeAwkArAMJAK8DCQDGAwkA1AMJAN0DCQDtAwkA8gMMAC0DDAAxAwwASAMMAEsDDABXAwwAYAMMAGcDDABoAwwAgwMMAIkDDACcAw8AqwAPALUADwDgAA8A6wAPAPsAkgC4AIkLNAAFABAABgBWAAYAWwIHACQBBwAxAggAAQEIAH4BCQDRAgkACgMLAEUCjADSAQQA5gEFAOsBhwphBAQASAAGAAkBhwAUBYcLnwQKCvkAiwrRAIQKMQKJCwcCBAuQAgQK+AKHCwsDCQqaAIwK5QGHCwEHhwuQAIgK/wCFAG0CBApwAYcKgQKHC10FBwsqAgcLXQKNCwoAiQDqAAUALwMGAJgGhgDbBgULRgMFC0kDhgtxBgcAwwcHAPgHiADnAoUL9AMGAMUAiADNAAYAOgGGCzoBkAs1AAYL+wAHC20BBwtNBQcL2QUIC5oAjQsZAYULVAEGAMQBBwA4AYoA2wCKAE0CBABNAQkAsAAMAGEBjQC7AAkKXACTClsAhgBWBAsALwCLC+8BBgoNAggKJgMJCmwDjAocAQgLBQEJC5AACQvSAQoLcgEMC9YBDQuQAI4LXAGJC4EDCABfAwgAYAMIAGQDCAB0AwoAYgMKAGQDCgBpAwoAjwMKAJADCgCwAwwA1wIGC/gACQsiAgoLFwILC6kCjQuHAAYALAGHAOsFhgDVBIsKvgOFClICjAv6AIYAlQaGCzcCBwCHAAgABwAIAD4ACQDzAAoAkgIKALkCCwDIAYsA9AIJAIsBigBPAAYKaQaICjQDBAouAYcK5gaGC64AhwohBYcAdwKGCooGhguLAYoAQwMHAJYBBwDLAQgAXgKLANYChgtpAoYA0wMGCoUBBwqVAAkKjgCKCl4ABQtuA4ULzAMGCggABwpZBwgKWwCIC/8BhQBkAoQLXwEEAHQBBwDiAQgAngAJAFoCCQBnAgoA9QAKAKYCCgDoAgsA+ACLACYDBQBWA4cAxweECx4BhwtYAQcLtgEHC3MCBwvsBQgLKAAJCzgACQsmAQoLHgAKCwMBCwvJA5ILlACHANQFBQsDAQcLngEHC1YDjgtrAIcK0gYGAEEDhgDmA4cKGAAGAO4ChwDLBgQK9wGHCn0GBQqCAAcKIgUJCmICCgrOAgsKWQILCjMDCwqyA4wKGAIKCpUACwoYAY4KUAGEC+IChwqaBwUAwwCHAJUGBwDNBwgA2gKLAO4DlwsRAIULYgMOAM8BDgDWAZYAPQAFAO8CCAAKAQsAQgIECogBhwo9BgUKsQEJCnkCiwp1AocANQMGAMsChgAtBYULdAAGAGQDhAvJAYYAvwMGCuoAigvHAAcAHQQHCp4HCAqoAgsKMQOTClgABwrGBIoKggEFALYDBQDiAwYAXwGGAGQEhgA5BAcAOwYGCgUACwr5AAwKOQEQCkIAkQoaAJQAOwAFCw8CBgu9AIcLWwMFCsMDBgrtBgsLaAALCyoCDws8AI8LfQCHAC8AiQCsAoYLdACGAEYGhgAJAwcA/AMI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AAoABApFAAUKegAJCpACigrQAQUKUQOGCmEGBQBGAwUASQOGAHEGhQD0A4sK8wEHCtwBBwo4BooKVwAGAPsABwBtAQcATQUHANkFCACaAI0AGQGEC7kBhAu3AgcL8QEJC4MBkwtRAIUAVAEOChsBjgsbAYYAKgOHC2YHiwDvAQULHAEGCzEABgteAQcLAQAHC3kBBwudBggLEgAIC6YCCQuhAAkLSQIJC58CCQtHAwsLkAONC6sBBQpbAwcKiAQICmsACQojAQkKtwEKCpcCCwphAowKxQAIAAUBCQCQAAkA0gEKAHIBDADWAQ0AkACOAFwBiQCBAwYA+AAJACICCgAXAgsAqQKNAIcABABmAYcA2AWGADcCiAC9AQQKdQAGCnQBBwpxB44KQwEECtICiwrXAQYAuQKGAOQDBwvXBwkLZQAJC8IBCgtCAAoLSgMLCxgCjAtLAoQAQQKGADgFCQoFAAwK2AAMCiYBDAoqAQwKkAEMCgYCDQrlAI8KiwAGAK4AigCVA4YK7gYFCgwABwp3AQkKWAAJCrYBCws+AIsKDgGGC+YGBgsAAAcLVAAHCjADBwrZBAkKGwEJCggCCgrVAAoKMwEKCs8BCgqfAgoK6gILCpEBCwoaAwsLfwMMCgUCEQsLABIKawCTCnMABQBuA4UAzAMGC4EGBwsAAQcLbAWKC/MBBAoCAYgKfwIECxYABQsKAAYKFgAHC1ADBwqHAwcKqwcIC2EAigpBAgUKqQKICg4DhQvhAYQAXwEECpgCBQokA4sK9QMGC4YABwu1AQcLvwMJCyUADgsdAQ4LcwGQCzwABwvmAQgLmwALC10AjAukAIQAHgEHALYBBwBzAgcA7AUIACgACQA4AAkAJgEKAB4ACwDJAwsA4wOSAJQABQtPAocLUQGGAJ4HhQogAIoL9AEFC3wBBQuKAogLNgEEC2wBBwuEBAcLowSJC5kBBADiAoYL4gEECw0DBgvnAQcLngMICwcBiwv0AYcLogEGAP8HCgDJAwQKIQEHCnUCBwqiBgcKrwaMCtcABgrCAYgKbQCGADIDiArBAoUAYgMEC14AhwvxBIQLoQGGALsFhwrWBAQAzAMGADsHhgBBB4YAYwGFAHQAhADJAYcLgwUEC5gBBAvlAocL9AGGChoAjguJAAUADwIGAL0ABwBbA4gACwELAGgACwAqAg8APACP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CmYBhgq1BgcKJQQIClIACwr6AAwKpAGNCrgAhQDLAocK1AIJAJcDCQCaAwkAnwMJAKUDCQDCAwkA6AMJAOoDCQD9AwwAegMMAIsDDACiAw8AzwAPAOQADwDuAJUAPQAIABoDCQCQAQoAKgGOAOQABQuuAQULpAMGC4MABwuhAQkLCgILCzoBjQuGAYQAYwMIANQChAv7AYkLBQEEC1cBhQv/AQYAvgAHAAADhwCSBAYKAQKHChwEBwvHAYoLTwKGACoEiQqDAw4AQwCTADwABAC0AxIArgCSALAAhwD/AwcKiQUMCn4BEQowAJgKDACGCz8ChAD8AgYKIQIHCjUCBwqFBgoKcgALCoICjApqAgYAiQAJAEsACQD9AAoAwgCKALwBBAD0AoUKBQAIAPADhwrAAIQASgMLAIMCDABzAIgK+wKLAEMAhQr3AgQANQMFAPgCBwAeAggAhwAIAPABhwtEAgcKcgEHCu8DBwqZBIcKHQaHCtUEjADgAgcAPwEHAGMBBwD7AgoAhQGRACsACAtNAYoLtgAEClcABQr6AI0KKgGKABIDhgD8BwgLSgGMC90Bhws6BYQLfQCGAAYEhgA7BIQL0QKHCi4DBwsIAwgLkQCTCzgAhgDKBAQKOQAHCqsEBwqeBQcKDAYHCisHBwpwBwkK9QIKClwCiwoHAgcLGAMIC5MACgs1A4sL/QOJCx0DBAA6AAUAHgEGAD8BBwCSAQcA5gQHAG8HCABkAYwAmAEEAIUBBAAvAwkAtQAJAP8ACgAIAAoAHQAKADADCwA3AQsAMQIMAEMAjQC1AAcLwAWHCxIGBwsvBAcLBQYHC+cGBwsOBwcLzwcJC/gACguQAQsLogALC7IACwvyAAwLXQIPCxoAkAssAAULqAAFC6IDCAtKAAkLbwIMC/QBDAtDAg0LKQCPC10ABgvcAAcLTQSNC2kABQDaAQcA+wEECtEABwv7AYcKhgOEAKsBBgCdAQcKTwEHCp0FBwqEBggKKQIICowCCAqQAgkKLgILCucClQoSAIQA2gIGCxMABwuFBYsLrAGFAHUBhAovAgcLYAAIC5EBiQuAAwcAHwMHALQHBQr5A4oK/wGHAAEHBwupBwcLrQcIC74CiAvuAggLlgAIC+ECjAtuAYQAQgGFCsUCCAsgAwkLlAAJC2gDCQt6AwsLNQELC+kDDQsLAY0LQwGGCtEGBwAiAYgKzgAHAHMGkQBZAIsAAgCEAKACBgBEBwgAiQMKAEwDCgBOAwoAWgMMALsCDADqAowABAOHC6gBhQsjAoUA4QIFC+oBBgtnAgYLbAKHC6sCBgDqAoYATAaECggDCQuBAZULEQCFAJEAhwr4BAcAdAOMAHwABACDAYcACAUFC4UAiAqWAYgLuwAGAKcCCAsIAIoLAACHACYChwseA4gLrQIHCz4EkQsuAAgKrwAKCqgAigo9AocAGQUEAEAChwDvBAYArgKGABsGhgBfAgUAlwOGAIkGlAAlAAgLBgMKC54CjAszAIUKEAOLCnIDBABSAAUATQEFAIgDBgDPAAcARQEHAL4GCABlAAoACgOLANwAhwtzAYQAvgOFAIcDBAt/AAULXgEGC2QBCAuqAQkLPAIKC/cAiws4AYwAkwAGCzsABwt1AwkLWwKNC40BCgBvAQkKDgAJCrkBiwoJAAsKxgMMCh8BDQpWAQ0KkgEPCm4AjwqjAIYAsgKEAMECCQCLAgsAywMNABEBBwqUBQcKaAYHCksHCQqpAAkKtgAJCm8BCQreAQkK+gEJCicCCQotAgkKiAIJCrkCCQrBAgkK1QIJChMDCQoaAwoKxgAKCtYACgoLAQoKEwEKCsgBCgonAgoKMQIKCmUCCgpzAgoKnAIKCqMCCgqzAgoKtwIKCsMCCgrLAgsKtwALCskACwoGAQsKYAELCrcBCwrtAQsKPAILCk8CCwpgAgsKYwILCoYCCwqiAgsKxwILCu8CCwr5AgsKCAMLChEDCwpSAwsKVQMLCl4DCwphAwsKZAMLCmsDCwqCAwsKhgMLCocDCwqOAwsKpAMLCq4DCwq9AwsKxwMLCswDDAqUAAwKwwAMCtwADArtAAwKPgEMClMBDAqJAQwKvQEMCsIBDAraAQwK+QEMCv0BDAoVAgwKTwIMClICDApVAgwKbQIMCnkCDAqCAg0KOwANCjwADQqRAA0K7wANCvoADQpJAQ0KWAENCm0BDQp0AQ0KgwENCpMBDQqeAQ0KyAENCtYBDQreAQ0K4wENCukBDgo3AA4KOQAOClEADgpaAA4KlAAOCu8ADgoKAQ4KQQEOCkYBDgpHAQ4KSgEOClsBDgpjAQ4KkQEOCpQBDgqbAQ4KngEOCqABDgqkAQ8KPQAPCkoADwpXAA8KWAAPCl4ADwpgAA8KdAAP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Cv4DBwCPBwgARAEMACoABAuzAgcLjwcIC0QBCQsjAAoLqAILC2wBDAsqAA0LZQGSCxAAhwDeBwcA1wcJAGUACQDCAQoAQgAKAEoDCwAYAgwASwIGCyAABwuBAQcL9QIHC3wHCAslAAgLXgAIC8cCCQsdAgoLogAKCxsDCwvdAwsL8gMMCw4Ajgs0AYsASgKHCqcGBwA1BAsAHAAJCp8AjApbAgYAxQSICkcCBguYAAYLXQEGC5IGBwvkBAgLcAAJC7MBCQucAgoLIgEKCz8BCgsvAwsLtAALC0UDDAvwAA0LmAANC9sAjgueAIsAPgCECgMCCAp4AggKuQKJClYDhgDmBoQLRQIGC34ABws9AggLjQGOCywAlgAcAAsAngIWABkABAqIAIUKJwIGAIEGBwAAAQcAbAWKAPMBBAAWAAUACgAHACgGiABhAIYK9gYFAOEBBwoHBQkKLAAKCigCCgqCAgsKRwMMChIBDAoTAQwKdAENClsAjgp9AIULngMHC9AEiQsTAgYAhgAHALUBBwAgBwkAJQAOAB0BjgBzAQcA5gEIAJsACwBdAIwApAAGAG8FhgCiBYULngKFAE8CBgqTAAcKdgMHC6UHCQrxAooKDAEFAHwBBQCKAgcAlQSIADYBBABsAQcAhAQHAKMEiQCZAYcLVQaGAOIBhQv6AQQADQMGAOcBBwCeAwgABwGLAPQBigqJAIcL8gCLC2AAhQqeAYcK4gaGACQDBQtCAwcLsgQICw4ACQvhAYkLcAOGClcCBABeAIcA8QQEAJ8BhAChAQUAXAEGAAoCBgrVBgcL9gWKC9EBhgpbBoQA9AOECugBBAtlAQYLrAAHC48AiQudAQQKUwAEC04CkgtMAIwKpAIHCx8BCAtjAQkLJQGJC+cChgoWAQYACwcSAKUAGAAVAAULqQAHC00BiAstAAwKYQCMC2EABACYAQQA5QKHAPQBhAvGAAcKhAEHCoQCiwoNAwQLGAAFC4wABQu5AAcL3AULCzUCiwtGAwYAKQUJAAEBBwrlAAgKOwAJCr4ACgp6AYwKvwAEC04BhQtRAocLXQeGAHIEBAD5AAYASQCHALEAhQBAAo4A5wCJACABhAqUAgcKCwSKCuEChwDPBQYA3QMJALEBBwqyAgkKSwKMCgkCBwDwBAcAjgYLALEDDABVAQwA1wGMADkChAvFAoULgQMF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CyUAFAtJAJYLJgCFCsoBhwDBBwcKvwcICgAACAqrAAkKeAAJCtwCCgrZAQsKkAILCuYDEgoAABIKAgCTChUABQtFAQcLywUICwUACAvjAAkLaQAKC0kCjAtmAogAegCEAOoAhwusBAYA0AMGAEoEhgChBQcA/QCIACUCBgttAg0L+AGQCxMAhAoHAgUArgEFAKQDBgCDAAcAoQEJAAoCCwA6AY0AhgEOAJUADgCPAY8AOQAFCosDBgofAAYL2gAHCusBBwoSAggKUAILCjUACwoLAwwKpwAMCpsBDgoOAA4KiAAPCkgAEAoRAJAKSACMC0oBBwvGAQcLDgOICwADhAD7AQoLpAKMC84BBgB2AgkAKwMECtAABQpqAAYKEwIICpgBCQq8AIoKPAIEAFcBBQD/AYYKnQaGC6QAhADAAQcAxwGKAE8ChwBlBQwKuQGWCzIACQrBAQoKwACKCuQCBgA/AoQK8QCGAJcEhgCNAoYA4QaGAK4EhAoDAQYLVwEHC8MACQviAAoLxQAKCz8CCwv2AYsLgwMHAGcEBwAkBgoAKQEKAKYBCwD8AgsAKgMMAAgBDQBmAA0ALAENAOQBDgCTAA4A5QARAEcAEgB2AJMAeACHC5oChACmAgQKrQAFCjgBBQoAAocKBQUHCkMGBwqbBgkK0AELCsMADAoXAQwKwAEOCgsAkwpmABAAYwCSAKQABwtlBAkLjwALCz0ADguVAZYLFQCJCwQBBArEAQUKRwIFCjEDBgqxAQcKUQIHCtACBwpiBQgKoQAJChwBCgo5AYsKdgOECiMCiArSAg4AIwCOAL8AjQAtAIoAeQCEAH0AhgBWBoULvwMICqQBiwrBAIQA0QKHCpkBiACRAAcAGAMIAJMACgA1AwsAygMLAP0DiAutAIYLCgGEAMsCBwDPB4oKNAGFABMCBQCoAAUAogMIAEoACQBvAgwA9AGMAEMCkABBAIoL9gAGANwABwBNBA0AaQCOCzoBBQrqA4gK6QKGAMADFAAAAJQLAAAEAO0DBArvAAYK3QEHCkcGCwpEAIsKaQIGABMABwCFBYsArAGVCg0ABwBgAAgAkQEIAL8CCQCAA4gLLAGGADsGkQB0AIgA/QMHAKkHBwCtBwcA7gcIAJYACAC+AggA4QIIAO4CjABuAQsLSwCOCwsBhApvAQgAIAMJAJQACQBoAwkAegML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AEQBBAsAAAULKQAHC7MFBwu9BQcLUgYHC0MHCQslAosLiQMECmIABwpVBQkKpgEJCp4CCgoHAwsK0gANChoADQrJAY0K3AEGALcGBgDHBgcA4AcHAOQHCABFA4kAVAOFC7gChwBUA4QAuAOGCsIGhAsDA4oAOAKJAMABiwCSAAgAQwCKAKMBhQuZA4kKkwCGACIHCgCRAg4AKQGOAGkBBgCaAgYA/wKGAAYGiwDZAgYLtAAHC3EECAvvAosLJQMEC7cABwsPAQsLOAMLC7gDDQsWAQ0LUwENC+IBDguoAZQLYwAEAJ0CBQvdAQULVAIGC/kBBwvFBAsLiwMMC9EAjQvWAIcLvwQFAJIBBgoeAAsKOACLCjEBBws0Ao4LqACLAJgABwCQA4cKTgYECpYABQovAYYKRwEHAEABCAAzAAkAZAMKAEEDDADhAQwAOgKUAGoAhAC9AQcLEgELCwcBCwvfAQsL+wGMCxUBCgArAgsANAETAF8ABgttBggKwAAKCk4AjQpnAYcKEgMGC1wABgu8AAcL9QQHC/QFBwtUBwoL5ACLC/wDBAvLAYULxgMLAIIBBgpmBgcKTwAHCvABCQqKAAoKUAEMCpwBDAq4AY4KMQGFAO8ABwBTAAcAxgcIAIIAiwDQAooLxQIEAI8ABQAmAoUA8AIFAHsABgASAgcAXAGHAIsFhwDoBwYLEgAHC7MABwvRAgcLpAMICyQCCAv1AgkLNgAJC0EACQsUAgkLTAMKC3EACgt1AAoL7AAKCzsBCguuAQoLHgMLC5kACwtfAQsLdwEMC04ADAuXAAwLiAEOC/gAjwsXAAcKzAAHCp8BCAoqAAoKVQCLCjQChgC+A4ULxQOEANIAhwuVBYoL4AGGC7YAiwtZAQoLQQAKC+gBigvxAQQKAwAFCvcABQqEAgcK6AIHCrcEBwrJBAcKdQeSCpMAhACuAQUKHQEJCkMADQrZAY8KUgCQCxAABwuKBAkLTAIKCwQBlwoIAIUA1QCKAAcAhwAhA4YL+gaHCzQBBgCoA4YACQWFAGwAhAB1A4UA2wCLAEsCBADBAAUAlAMGABEEBwBsAQoAjgEKANYCCwA9AQsAcgIMAI4ADAAgAQwApgINADkBDwBxAJIAcgCHAI0EBgDxAAkAVgEKANkCCwAcAQsAvQELAIsCCwBfAw0AjgGSAGMABwCLA4gAQAMJAC8BBAodAAYKFAIHClwGBwpwBgkKXgEKCrEBCwphAAsKLQILCukCDAohAQwKTwEMClwBDApeAg0KdAANCukADQrSAQ4KtQAOCtEADgroAA4K7AAOCiwBEAopAJQKYQAHC6cBBwqcBogLTAIGAKMDhgCuBQUK9QEHCqgGCQopAgsKCAIMCi0CjQr5AIgLHwEEADICCQD+AIsAbwOEABIDDgsgABILVQAUCwIAmAsQAIcADgUHC9MChwtvBAYA2AAHAIUDBwA/BQgA7QGGC5MBBwvPAggLKQOIC0IDBQvSAAYL1QAHCzwACgtsAYsLhwAHAFUBCwDbAAULXwIIC0YBiAvqAQQLvQIFC9gBBQt/AgcL4QQJC/YCiwuAA4cLfAGHC5sHiwCCAIcAxgYKAHMACwCkAQwAmgANAJQBDgBaAY8ANgCGCoEABAuCAQcLKQAIC5UBCQvxAQsLbgALC2gBDwslAJALVACNCxoBBQsuAAcLrAUHC8gFCAt6AowL2AEECwwCiAsqAwoL7gCNCyEAhQBcAgUA8wOIAL0CCABYAwgAWgMIAG8DDAC+Ao4AvwEEADYABQCaAgcADwQHAGoECQDDAIoALgEEChkABQo8AAYK+AEHCmYCBwqDBIwKAAAHCuAECwptAosKvgKFC+UDiQpBAYYAhQaGAP8GBAp7AYcKdQWKC3QBBQsOAwULPQOGC8oGhwDMBAQKdgAGChIBBgppAQcKSwCNCrkBhABvAgkLFwEKC5cBDgtUAJYLEgCJCkkDhwAeA4wKtQIFCjoBBgrdAAcKowEKCooCCwqMAQwKnAANCnEBDgpNAZEKLwCHC1wFBwB6AAkAAwEKAFQACwDWAQwAHQKNAHsBhgBFAwgA9QMEC04ABQtgAAULtgAHC7wGBwshBwoLigEKC9cBCwsUAg4LVAGRC1gAhgBBAocLrAeECpEDhgDMAQgAewMKAIUDCgCXAwoApAMMAMsCDADYAgwACQMOAMkBkABnAAUAUgAFAIMABwDbBggAHwAJAKgACQD8AosAZQOICtsBBgBdAgUK+AMJC1kCCQtrAgoL+QEKC9wCCwtjAYwLiwAHCloCCAqzAAoKDQOMCn4AhgDeBAYKSQGKCm8ABgvXAAcLBAQHC8EFBwu5BgkLqAGKCwsDBQAWAYkARAAGAKQDBgA8BJAAVgAEAKMABQDJAAUAMwEFADYBBgBPAQcAHAEHAHwGiAClAIgADQOGAMMCBgAhAIcA3AQFCjUDBgtDAAYKlwYHCwIBBwteBgkLYgEJC6MCCgs+Aw4LUACRC1AABguNAAcL4QAJCzsACQtfAgoLOAELC68CDAsrAg0LdQENC+4BlAs6AIYAWQQJAIQBBQpHAAcKfwUJCsACCgoFAQoKawILCiMCCwprAo8KnQAHAKEHiADQAooAywAHCtgHCQpRAYoKBQIGAEYBBwClAokAqQGLC1EABwAkBQcAhAUHAC8HCQBNAgsA8QALAKQCCwArAwsAewMMAIwADABaAQwA3wENAIwADQB9AQ4AvAASAB4AlABsAAUAoAEGClYABgpbAgcKJAEHCjECCAoBAQgKfgEJCtECCQoKAwsKRQKMCtIBBArmAYUK6wGGABQFhApIAAcATwMGCgkBBwuuAYsLLgAFC1oCBgtqAAcL+gYHCx0HBwviBwkLogGJC/sCBQBmAQcAFwIHAKAECgCWAg0A1AANADABDQBNAZEAYgAFC0EABgugAQcLuAYHC4QHCAulAgoLbQALCw4ACwtGAAsLOQILC98CDwuZAJQLUAAGAB8HCABHAwgAVAMIAIcDCgCsAwwAwwKMAAcDhwvNBAYA8gWMAI4CiAtTAosAowCNADoBhADSAwQAWQIGAPMHiQrqAAUKLwMGCpgGhgrbBoUAsgOIALIBBgrFAIgKzQAHAJsBBwBOAggAdwIJAEMBCgBjAQsA6wEMAI8ADACSAQ0ASQAOAJgBDwBrAJIARwAHALsFCABIAQoAIAILALsDDAANAA0AQAGRAFMAjgCaAQsA/wENAIoBDgAqAQ4APgGSAGcABgrEAQcKOAGKCtsAigpNAgQKTQEJCrAADAphAY0KuwCHC0kBhAvVAQUAQwOGAOMBhgvPBgULoQMGC1QBCAt4AYgLJwOGCpUGhAClAgUL2gAHC0oGigtTAAULOwKHCzIHhAvHAYkARgCHAH0FBwqHAAgKBwAICj4ACQrzAAoKkgIKCrkCCwrIAYsK9AIJCosBigpPAIkAbAAGC6EABwt0AYkLVQKEC10BhAAJA4QASwGHCncChQDrAgYLsAEGC2ACiwtCAYoKQwMFC9QBBwsRBwoLRQELC1gDDAtZAY8LaACFC98ABwqWAQcKywEICl4CiwrWAoQLNgKOAEQABAs7AIcLcgUG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ALgBDQAoAAYKMAEICqIBCwpVAYsKowIOACgBCQqaAYsKqQEKC3kBDAtrAQ0LRAANC14ADgtsAI4LMgEHAHkFhwDEBQQAKAEGANsBBwCRAQcAggUHADoGBwCKBggAPwAIAJQCiQBKAAQAiwAEAIQBjAC8AIQAHQOEC/4CBQtnAAcLmQMIC0QCCAtRAggLdgKKCxwABAuPAwULYwOFC/UDhgoOAIYAJAaGCqwGFQAnAAUKcQAGCvMABwpJBwsKoQAQCiUAkQpjAAcLGwaNC7YABQuHAAYLBwIHC7oGCgsPAQsLBQGRCzYAhAoSAYYAOgYECywBBQu0AYcL5AEEAOsCBgAiAQcAiQIHAMcFhwAvBoULFwKTC1IAhQDoAIkAdwOHCqYAiAAJAgQADgAHANgBBwAJBwoA7AKNAMoBhgDlAoYA4AMQAG8AiQowAQQAqQEFC4MBBwstAgwLIwKOC1YAhwvTBgUKjgKHC9EFBwAVAwQLBgAFC8QCiAtLAAYKEQEKCrwADQp5AZIKTQAGADkGBAsvAQcLawIKCyMCCguvAgsLegCMC1kChgDoBocKmgGKCwQDCwDpAIsKDAIFAK8DhgDzBoYK+QaICxEChAC7AwUA9QAGAEACBwBGAogA4QCECgwDjgDxAIYAlwcEC2oABws2AQcL+QYKC7ICiwvNAoYABAUFC3oDhQvcAwYLcgKOC68BCgvCApELIACJC0wBhAu6AocAxQIFCrQDigsRAIgAKgKGABwGiwqtA4QAuwGGAI0DhgtUAI4AGAEEChQCBQrCAocKlgKEANkCBQpFAwYKcwaLCtkDhwpFBwQAXAGYCwMABQvaAwYLggAHCy4GCAvKAQoLZQAKCz4Bigs3A4YA9gIEACoBiQBQAwQKSgEHCqUDBwrcB4gKJAEHC2wGiQuBAAYAjgUJAD0Dhwr/AgUApAAHAHkAjgC9AAcALAMHAO0EBwBQBQkAeAKMAGABhwv8BosALAKHC+UDkQpyAAQArAAJAGMCCgC0AQwAoQINAP8AiQpzAwsAEgKKChIBhQBMA4YA2AMNAOgAEgAjAAQKvwKHCs8AhAo7AgkABwEKAJMAigDsAQcL3AaJC2IABQppAwUKwAMICjcDiQpxA4UAGQKEAFsDBwsWBIsLoACJAEoDiwobAQUKIQAGCtYBiwqoAQYLLQAHC7EBCAuBAAkLFQAK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AJsDhAv2AooL1wCICu8BBwo2AAgKOAEKCr8ACgpmAowKNwIHC18BiwuAAAcAawMGCtQBBwrGBQgKEgKOCiIBhwD8BhEAMQCFC5YDDAuOARQLJwAVCwsAlgspAAoAlQIGCuQBhwo2A4cAmQeGABoDiQqEA4cKNwUGCrwGhwrmB4QLVAGGAG8EBAAQA4UA6QIFAFQAhgCjAIUAmgEEANADBQvZAwcL/QEHCxECkQtgAIQK2gGGAL8Chwt/BwUAQgEIALoACQAGAQoAuwCOANAAhwrgBYUA4wAJADACDQDQAIUKMQGEC/cABwBzBQgA5gEJAOwACQBuAwoA2gALAF8AEwARAJMAHwAHAPsHCACgAo0AwAEEC7gABQuGAQYLUQEHCxcABwvuAQcLagIHC7AFCAsbAAgLVwIKC5kAiwvGAocA0gGHCtQEBgCnAAcAugAHAJACCgCDAgQK4AEGCi4BBgpqBgcKRQMHCgsGBwp5BggKrQEJCuQADQohAQ0KVwGTCmUAhgCUBYYAoAUFAJwBBwoWAQoK4wILCsQCjQpcAYYAXgSIADIClAsuAAkAPAGLAAABhgDrBocApgSJAIQACgvjAAsL8QELC8UCjAufAY8AQgAGC2gBBwuABogL3gGQChwABAA9AYcA/wQFAD8AhQD9AYgLuwKRCiQAhgDDBQsLVwGOC38AhAvjAoQAIAGHC90GCABZAAgAbAIJAGACCwB0AgwAQgGPAHwAhgDJBAcApQQEC0MABQumAQYKawEHCw0EBwsJBQcLEwYHCqMHCArVAgkL5QKRC2wAhgC8BQYAsQKGAKsFigB4AJcAAQCJCiUDjgBJAQUKLQOHCv4HhwDiAIoLYAAHAD8HBQrIAgsKEQANCkEBkApDAAkAzQEGCkABBwoNAwcKgQcJCjcACgq6AAoKEQEKCpgCCgohAwsK5AMLCuUDDQqdAI4KqgAIC8sACAoPAQsLNwMLC04DDAviAQ0LhQANCxUBDQsuAQ0L0AEOC80AjgvdAIcAQgUEC8EBhQvOAoYAVQAOACsBBwpnAAcKXwMLCrgAkQo+AAQLYwEGCzcBCQsAAYoLlAGJCpMCigv2AoULOwMFC0AAjAtFAoYAkwQEC7oBBwsXBAcLSAWHC2sGhADUAwUL0QMGCyABBwsQAocLKQQFABcBBgDrAAcA1AEIAL4BCQB9AgoAzQIL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AK8ABApOAYUKUQKNC1cAiAv+AgoAHwEMAIoACgsfAYwLigAEAGkAhADkAowKdACGAFkDhwsxBwYAegWJADMDhAtIAoQKxQKFCoEDBQDgAA0ArgCSADQAhwowBwQKYAKFCvEBiws8AAQA9gKHAHEGBAviAAQLRgGHC+oGBQuqAQgLHgAJCwIACwslApMLegCHCvcHBgocAogKiAAEAD0CCACPAgQKgQOFChIDBwBfAYsAgACFCucDBAorAYcK7AOFAJYDhAtZAQQLgQEHCwkBhwtLAoUKyAGICrQABgCvAoYAAQYEC1sBBQunAQUL5AOHCzEFhArzAgcL6wQJC30ACwtBAIwLHQEFC4gABguIAIgLhAKGAPUFBADxA4cAcwSLClIBhABUAYcKuAUIAE8DCgBdAwoAbAMKAHkDCgCaAwoAoQMKAKUDDAAQA4wAFwOLALAACQuGAAoLAgAKCxsACgtNAQsL0gKPCwEABAuxAYULzwIFANkDBwD9AQcAEQKRAGAAhABnAgQKegMFCiUDBQozAwUKwQMGCowBBgpfBgYKjgYHCq8HBwr5BwkKdgILCggACwr7AwwKsAANCuEADgokAZUKGACHAH8HhgBrBJALFQCQCzMAhwoXBwQA9wAHCuEFCgq+AAoKegILChgDDApmAYwKvwEFCgAABgoYAgcKXAINCr0BkQp+AAQAuAAFAIYBBgBRAQcAFwAHAO4BBwBqAgcAsAUIABsACABXAgoAmQCLAMYCBgroAAYKnAEHCjIECAoJAAgKnQAIChIDCQrEAAkKYAEJCskBCgpRAQsK6AALCm0DDArgAYwKIgINACYAhwq+AwQKfgGICkMCBArUAIcKtgQECysCCAsYAooLIAELC4sAiwurAAkLcgGKC1oAhAD3A4YAQAQFCo8ChwvRA4YAMQYRCkMAkwpKAAoA4wALAPEBCwDFAowAnwEGAGgBBwCABogA3gEHAF8ABgrnAIgKpwGMC0EABAsBAYcL7weHC+gGhQosAYsL0wCIALsCBgrtAAcKYwIICmQACQqgAQsKTwEMCq0AkgplAA4AGgCSAJYABgBFAocAXwSHCrgEhADjAgYLUwAGC8UGhwttBYkAZQMEAEMABQCmAQcADQQHAAkFBwATBgkA5QKRAGwAhQrHAAwKqwGSCiYAiADQAY4AKgAKAGAACAv1AYkLuAKG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C84BBwvKA4cLSQQEChwABQq4AQcK+AALCkEDjApYAYYKdgYGAHgCBgCMAgYA+AQGAGgFhgAYBoYLqAYGAHEFhQpVAwYK+QAHCtIEiwo9AgULVgAHC+cCCQtVAAoLGQEKC7ABCwvqAQwL+wANC3YADgt6AZILjwAFCwwChQvoAoYA6gUKAMkAjgA/AQcAzQIKAP4BBwqIAQgKFAAICqwACAqyAgkKfwEJCk0DCwolAQsKQAMLCpgDCwrYA40K3QCGAGUFBQpaA4UK4AMIABACiQBcAQoLawCMC7QBBAAUAIUAaAKGAOMEhAufAwoLewAMC54CDQtzAQ4LjgCSC14AhgCLBAcLfQSJC5wAhgAzAYULCgMHAEMEhwDlBgUL9gEGCgwBiQo+AAgLxAAKCxsBiwuWAQQAGgAFAK0BBgD1AAcAwAIHAGMFhwDCBYULVwOEAHEDBABtAocLPAYHC3gFCQu+AYoLLQAGAOACigpqAIUAHgKGAFwBhQBkA4gAsQGHANcFigADAwYKZQKICt8AigDXAI0AfACIC4cBhwusAIQKngKMADcACQooAIsKiAAHAD4AkwBwAIQAWAOECzgCDAAOAYsKAwEIADwCiQC6AgQL3AIJCjYBiQqqAo4KKAGGAKsDiAvdAocLmwUHCnkFhwrEBQYAYAEECigBBwqRAQcKggUHCjoGBwqKBggKPwAICpQCiQpKAAQLrAGFC5wCBAqLAAQKhAGMCrwABwvfB4wLmQKEAIcCkgAKAIoA3ACOANABhABtAIYA0gYGAAMCBArrAgYLVwYGC5EGBwqJAgcKxwWHCi8GhQroAIcANgKJCncDBAAoAAoAQwALAHUACwAAA4sApwOEACEDBwDgAwgALQEJANICDAA/AA0AHQAOAKEAjwASAIsAmwMGC9QGCAvLAgkLIgMKCy4ACgszAw0LNAEOC18BDgtrAZILQwCJC+kCBwB5BAQKDgAHCgkHCgrsAo0KygEECz8ABQtbAYYL2gGHADgCBAqpAQcLQQIHC5gFCQvbAQkL+QEJCw4CCQthAgkLsQIJC9YCCQvfAgkL4gIKCywCCguiAgoLrAILC1kACwvKAAsLEAELC3wBCwufAQsL+QELCxkCCwsmAgsLMgILC4ACCwubAgsLsAILC08DCwufAwsLogMLC6wDDAuQAAwLRQEMC0kBDAuFAQwLkwEM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E2FBhhNhQd4TYUE2FGFBjhRhQeYUYUE+FWFBlhVhQe8VYUFHFmFBnxZhQfcWYUFPF2FBpxdhQf8XYUFXGGFBrxhhQQcZYUFfGWFBtxlhQQ8aYUFnGmFBvxphQRcbYUFvG2FBxxthQR8cYUF3HGFBzxxhQScdYUF/HWFB1x1hQS8eYUGHHmFB3x5hQTcfYUGPH2FB5x9hQT8gYUGXIGFB7yBhQUchYUGfIWFB9yFhQU8iYUGmImFB/iJhQVYjYUGuI2FBBiRhQV4kYUG2JGFBDiVhQWUlYUG9JWFBFSZhQW0mYUHFJmFBHSdhQXUnYUHMJ2FBJChhQXwoYUHUKGFBLClhQYMpYUHbKWFBMyphQYsqYUHjKmFBOithQZIrYUHqK2FBQixhQZksYUHxLGFBSS1hQaEtYUH4LWFBUC5hQaguYUEAL2FBVy9hQa8vYUEHMGFBXjBhQbYwYUEOMWFBZTFhQb0xYUEVMmFBbDJhQcQyYUEcM2FBczNhQcszYUEjNGFBejRhQdI0YUEqNWFBgTVhQdk1YUEwNmFBiDZhQeA2YUE3N2FBjzdhQeY3YUE+OGFBljhhQe04YUFFOWFBnDlhQfQ5YUFLOmFBozphQfs6YUFSO2FBqjthQQE8YUFZPGFBsDxhQQg9YUFfPWFBtz1hQQ4+YUFmPmFBvT5hQRU/YUFsP2FBxD9hQRtAYUFzQGFBykBhQSFBYUF5QWFB0EFhQShCYUF/QmFB10JhQS5DYUGFQ2FB3UNhQTREYUGMRGFB40RhQTpFYUGSRWFB6UVhQUFGYUGYRmFB70ZhQUdHYUGeR2FB9UdhQU1IYUGkSGFB+0hhQVNJYUGqSWFBAUphQVlKYUGwSmFBB0thQV9LYUG2S2FBDUxhQWRMYUG8TGFBE01hQWpNYUHCTWFBGU5hQXBOYUHHTmFBH09hQXZPYUHNT2FBJFBhQXxQYUHTUGFBKlFhQYFRYUHYUWFBMFJhQYdSYUHeUmFBNVNhQYxTYUHjU2FBO1RhQZJUYUHpVGFBQFVhQZdVYUHuVWFBRlZhQZ1WYUH0VmFBS1dhQaJXYUH5V2FBUFhhQadYYUH+WGFBVllhQa1ZYUEEWmFBW1phQbJaYUEJW2FBYFthQbdbYUEOXGFBZVxhQbxcYUETXWFBal1hQcFdYUEYXmFBb15hQcZeYUEdX2FBdF9hQctfYUEiYGFBeWBhQdBgYUEnYWFBfmFhQdVhYUEsYmFBg2JhQdpiYUExY2FBiGNhQd9jYUE2ZGFBjWRhQeRkYUE7ZWFBkmVhQellYUE/ZmFBlmZhQe1mYUFEZ2FBm2dhQfJnYUFJaGFBoGhhQfZoYUFNaWFBpGlhQftpYUFSamFBqWphQQBrYUFWa2FBrWthQQRsYUFbbGFBsmxhQQhtYUFfbWFBtm1hQQ1uYUFkbmFBum5hQRFvYUFob2FBv29hQRVwYUFscGFBw3BhQRpxYUFwcWFBx3FhQR5yYUF1cmFBy3JhQSJzYUF5c2FBz3NhQSZ0YUF9dGFB1HRhQSp1YUGBdWFB2HVhQS52YUGFdmFB3HZhQTJ3YUGJd2FB4HdhQTZ4YUGNeGFB43hhQTp5YUGReWFB53lhQT56YUGVemFB63phQUJ7YUGYe2FB73thQUV8YUGcfGFB83xhQUl9YUGgfWFB9n1hQU1+YUGjfmFB+n5hQVB/YUGnf2FB/n9hQVSAYUGrgGFBAYFhQViBYUGugWFBBYJhQVuCYUGygmFBCINhQV+DYUG1g2FBC4RhQWKEYUG4hGFBD4VhQWWFYUG8hWFBEoZhQWmGYUG/hmFBFYdhQWyHYUHCh2FBGYhhQW+IYUHFiGFBHIlhQXKJYUHJiWFBH4phQXWKYUHMimFBIothQXiLYUHPi2FBJYxhQXyMYUHSjGFBKI1hQX+NYUHVjWFBK45hQYGOYUHYjmFBLo9hQYSPYUHbj2FBMZBhQYeQYUHekGFBNJFhQYqRYUHgkWFBN5JhQY2SYUHjkmFBOZNhQZCTYUHmk2FBPJRhQZKUYUHplGFBP5VhQZWVYUHrlWFBQZZhQZiWYUHulmFBRJdhQZqXYUHwl2FBRphhQZ2YYUHzmGFBSZlhQZ+ZYUH1mWFBS5phQaKaYUH4mmFBTpthQaSbYUH6m2FBUJxhQaacYUH8nGFBUp1hQamdYUH/nWFBVZ5hQaueYUEBn2FBV59hQa2fYUEDoGFBWaBhQa+gYUEFoWFBW6FhQbGhYUEHomFBXaJhQbOiYUEJo2FBX6NhQbWjYUELpGFBYaRhQbekYUENpWFBY6VhQbmlYUEPpmFBZaZhQbumYUERp2FBZ6dhQb2nYUETqGFBaahhQb+oYUEVqWFBa6lhQcGpYUEWqmFBbKphQcKqYUEYq2FBbqthQcSrYUEarGFBcKxhQcasYUEbrWFBca1hQcetYUEdrmFBc65hQcmuYUEfr2FBdK9hQcqvYUEgsGFBdrBhQcywYUEisWFBd7FhQc2xYUEjsmFBebJhQc6yYUEks2FBerNhQdCzYUEmtGFBe7RhQdG0YUEntWFBfbVhQdK1YUEotmFBfrZhQdS2YUEpt2FBf7dhQdW3YUEquGFBgLhhQda4YUEruWFBgblhQde5YUEtumFBgrphQdi6YUEuu2FBg7thQdm7YUEuvGFBhLxhQdq8YUEvvWFBhb1hQdu9YUEwvmFBhr5hQdy+YUExv2FBh79hQdy/YUEywGFBh8BhQd3AYUEzwWFBiMFhQd7BYUEzwmFBicJhQd7CYUE0w2FBisNhQd/DYUE1xGFBisRhQeDEYUE1xWFBi8VhQeDFYUE2xmFBi8ZhQeHGYUE2x2FBjMdhQeHHYUE3yGFBjMhhQeLIYUE3yWFBjMlhQeLJYUE3ymFBjcphQeLKYUE4y2FBjcthQePLYUE4zGFBjcxhQePMYUE4zWFBjs1hQePNYUE4zmFBjs5hQePOYUE4z2FBjs9hQePPYUE50GFBjtBhQePQYUE50WFBjtFhQePRYUE50mFBjtJhQePSYUE502FBjtNhQePTYUE51GFBjtRhQePUYUE41WFBjtVhQePVYUE41mFBjdZhQePWYUE412FBjddhQePXYUE42GFBjdhhQeLYYUE32WFBjdlhQeLZYUE32mFBjNphQeLaYUE322FBjNthQeHbYUE23GFBi9xhQeHcYUE23WFBi91hQeDdYUE13mFBit5hQeDeYUE132FBit9hQd/fYUE04GFBieBhQd7gYUE04WFBieFhQd7hYUEz4mFBiOJhQd3iYUEy42FBh+NhQdzjYUEx5GFBhuRhQdvkYUEx5WFBhuVhQdvlYUEw5mFBheZhQdrmYUEv52FBhOdhQdnnYUEu6GFBg+hhQdjoYUEt6WFBgulhQdfpYUEs6mFBgephQdbqYUEr62FBgOthQdXrYUEq7GFBf+xhQdPsYUEo7WFBfe1hQdLtYUEn7mFBfO5hQdHuYUEm72FBe+9hQdDvYUEl8GFBevBhQc7wYUEj8WFBePFhQc3xYUEi8mFBd/JhQczyYUEh82FBdfNhQcrzYUEf9GFBdPRhQcn0YUEe9WFBcvVhQcf1YUEc9mFBcfZhQcb2YUEa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GWNBQhpjQZIaY0HjGmNBNBtjQYUbY0HVG2NBJhxjQXccY0HHHGNBGB1jQWkdY0G5HWNBCh5jQVseY0GrHmNB/B5jQU0fY0GdH2NB7h9jQT8gY0GPIGNB4CBjQTEhY0GBIWNB0iFjQSIiY0FzImNBxCJjQRQjY0FlI2NBtSNjQQYkY0FXJGNBpyRjQfgkY0FIJWNBmSVjQeklY0E6JmNBiyZjQdsmY0EsJ2NBfCdjQc0nY0EdKGNBbihjQb4oY0EPKWNBXyljQbApY0EAKmNBUSpjQaEqY0HyKmNBQitjQZMrY0HjK2NBNCxjQYQsY0HVLGNBJS1jQXYtY0HGLWNBFy5jQWcuY0G3LmNBCC9jQVgvY0GpL2NB+S9jQUowY0GaMGNB6jBjQTsxY0GLMWNB3DFjQSwyY0F8MmNBzTJjQR0zY0FuM2NBvjNjQQ40Y0FfNGNBrzRjQf80Y0FQNWNBoDVjQfA1Y0FBNmNBkTZjQeE2Y0EyN2NBgjdjQdI3Y0EjOGNBczhjQcM4Y0EUOWNBZDljQbQ5Y0EFOmNBVTpjQaU6Y0H1OmNBRjtjQZY7Y0HmO2NBNjxjQYc8Y0HXPGNBJz1jQXc9Y0HIPWNBGD5jQWg+Y0G4PmNBCT9jQVk/Y0GpP2NB+T9jQUlAY0GaQGNB6kBjQTpBY0GKQWNB2kFjQStCY0F7QmNBy0JjQRtDY0FrQ2NBu0NjQQxEY0FcRGNBrERjQfxEY0FMRWNBnEVjQexFY0E9RmNBjUZjQd1GY0EtR2NBfUdjQc1HY0EdSGNBbUhjQb1IY0ENSWNBXkljQa5JY0H+SWNBTkpjQZ5KY0HuSmNBPktjQY5LY0HeS2NBLkxjQX5MY0HOTGNBHk1jQW5NY0G+TWNBDk5jQV5OY0GuTmNB/k5jQU5PY0GeT2NB7k9jQT5QY0GOUGNB3lBjQS5RY0F+UWNBzlFjQR5SY0FuUmNBvlJjQQ5TY0FeU2NBrlNjQf5TY0FOVGNBnlRjQe5UY0E9VWNBjVVjQd1VY0EtVmNBfVZjQc1WY0EdV2NBbVdjQb1XY0ENWGNBXFhjQaxYY0H8WGNBTFljQZxZY0HsWWNBPFpjQYtaY0HbWmNBK1tjQXtbY0HLW2NBG1xjQWpcY0G6XGNBCl1jQVpdY0GqXWNB+l1jQUleY0GZXmNB6V5jQTlfY0GIX2NB2F9jQShgY0F4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m2pBbptqQaibakHim2pBHZxqQVecakGRnGpBzJxqQQadakFAnWpBe51qQbWdakHvnWpBKZ5qQWSeakGenmpB2J5qQROfakFNn2pBh59qQcGfakH8n2pBNqBqQXCgakGqoGpB5aBqQR+hakFZoWpBk6FqQc6hakEIompBQqJqQXyiakG3ompB8aJqQSujakFlo2pBoKNqQdqjakEUpGpBTqRqQYmkakHDpGpB/aRqQTelakFxpWpBrKVqQealakEgpmpBWqZqQZWmakHPpmpBCadqQUOnakF9p2pBuKdqQfKnakEsqGpBZqhqQaCoakHaqGpBFalqQU+pakGJqWpBw6lqQf2pakE4qmpBcqpqQayqakHmqmpBIKtqQVqrakGVq2pBz6tqQQmsakFDrGpBfaxqQbesakHxrGpBLK1qQWatakGgrWpB2q1qQRSuakFOrmpBiK5qQcOuakH9rmpBN69qQXGvakGrr2pB5a9qQR+wakFZsGpBk7BqQc6wakEIsWpBQrFqQXyxakG2sWpB8LFqQSqyakFksmpBnrJqQdiyakETs2pBTbNqQYezakHBs2pB+7NqQTW0akFvtGpBqbRqQeO0akEdtWpBV7VqQZG1akHLtWpBBbZqQT+2akF5tmpBtLZqQe62akEot2pBYrdqQZy3akHWt2pBELhqQUq4akGEuGpBvrhqQfi4akEyuWpBbLlqQaa5akHguWpBGrpqQVS6akGOumpByLpqQQK7akE8u2pBdrtqQbC7akHqu2pBJLxqQV68akGYvGpB0rxqQQy9akFGvWpBgL1qQbq9akH0vWpBLr5qQWi+akGivmpB3L5qQRa/akFQv2pBir9qQcS/akH+v2pBOMBqQXLAakGrwGpB5cBqQR/BakFZwWpBk8FqQc3BakEHwmpBQcJqQXvCakG1wmpB78JqQSnDakFjw2pBncNqQdfDakEQxGpBSsRqQYTEakG+xGpB+MRqQTLFakFsxWpBpsVqQeDFakEaxmpBVMZqQY3GakHHxmpBAcdqQTvHakF1x2pBr8dqQenHakEjyGpBXMhqQZbIakHQyGpBCslqQUTJakF+yWpBuMlqQfLJakErympBZcpqQZ/KakHZympBE8tqQU3LakGHy2pBwMtqQfrLakE0zGpBbsxqQajMakHizGpBG81qQVXNakGPzWpByc1qQQPOakE8zmpBds5qQbDOakHqzmpBJM9qQV7PakGXz2pB0c9qQQvQakFF0GpBf9BqQbjQakHy0GpBLNFqQWbRakGf0WpB2dFqQRPSakFN0mpBh9JqQcDSakH60mpBNNNqQW7TakGn02pB4dNqQRvUakFV1GpBjtRqQcjUakEC1WpBPNVqQXXVakGv1WpB6dVqQSPWakFc1mpBltZqQdDWakEK12pBQ9dqQX3XakG312pB8ddqQSrYakFk2GpBnthqQdfYakER2WpBS9lqQYXZakG+2WpB+NlqQTLaakFr2mpBpdpqQd/aakEY22pBUttqQYzbakHG22pB/9tqQTncakFz3GpBrNxqQebcakEg3WpBWd1qQZPdakHN3WpBBt5qQUDeakF63mpBs95qQe3eakEn32pBYN9qQZrfakHT32pBDeBqQUfgakGA4GpBuuBqQfTgakEt4WpBZ+FqQaHhakHa4WpBFOJqQU3iakGH4mpBweJqQfriakE042pBbuNqQafjakHh42pBGuRqQVTkakGO5GpBx+RqQQHlakE65WpBdOVqQa3lakHn5WpBIeZqQVrmakGU5mpBzeZqQQfnakFB52pBeudqQbTnakHt52pBJ+hqQWDoakGa6GpB1OhqQQ3pakFH6WpBgOlqQbrpakHz6WpBLepqQWbqakGg6mpB2epqQRPrakFN62pBhutqQcDrakH562pBM+xqQWzsakGm7GpB3+xqQRntakFS7WpBjO1qQcXtakH/7WpBOO5qQXLuakGr7mpB5e5qQR7vakFY72pBke9qQcvvakEE8GpBPvBqQXfwakGx8GpB6vBqQSTxakFd8WpBl/FqQdDxakEK8mpBQ/JqQXzyakG28mpB7/JqQSnzakFi82pBnPNqQdXzakEP9GpBSPRqQYL0akG79GpB9PRqQS71akFn9WpBofVqQdr1akEU9mpBTfZqQYb2akHA9mpB+fZqQTP3akFs92pBpvdqQd/3akEY+GpBUvhqQYv4akHF+GpB/vhqQTf5akFx+WpBqvlqQeT5akEd+mpBVvpqQZD6akHJ+mpBAvtqQTz7akF1+2pBr/tqQej7akEh/GpBW/xqQZT8akHN/GpBB/1qQUD9akF6/WpBs/1qQez9akEm/mpBX/5qQZj+akHS/mpBC/9qQUT/akF+/2pBt/9qQfD/akEqAGtBYwBrQZwAa0HW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IG5B3yBuQREhbkFDIW5BdSFuQachbkHZIW5BCyJuQT0ibkFvIm5BoSJuQdMibkEGI25BOCNuQWojbkGcI25BziNuQQAkbkEyJG5BZCRuQZYkbkHIJG5B+iRuQSwlbkFeJW5BkCVuQcIlbkH0JW5BJiZuQVgmbkGKJm5BvCZuQe4mbkEgJ25BUiduQYQnbkG2J25B6CduQRoobkFMKG5BfihuQbAobkHiKG5BFCluQUYpbkF4KW5BqiluQdwpbkEOKm5BQCpuQXIqbkGkKm5B1ipuQQgrbkE6K25BbCtuQZ4rbkHQK25BAixuQTQsbkFmLG5BmCxuQcosbkH8LG5BLi1uQWAtbkGSLW5BxC1uQfYtbkEoLm5BWS5uQYsubkG9Lm5B7y5uQSEvbkFTL25BhS9uQbcvbkHpL25BGzBuQU0wbkF/MG5BsTBuQeMwbkEVMW5BRzFuQXgxbkGqMW5B3DFuQQ4ybkFAMm5BcjJuQaQybkHWMm5BCDNuQTozbkFsM25BnjNuQc8zbkEBNG5BMzRuQWU0bkGXNG5ByTRuQfs0bkEtNW5BXzVuQZE1bkHCNW5B9DVuQSY2bkFYNm5BijZuQbw2bkHuNm5BIDduQVE3bkGDN25BtTduQec3bkEZOG5BSzhuQX04bkGvOG5B4DhuQRI5bkFEOW5BdjluQag5bkHaOW5BDDpuQT06bkFvOm5BoTpuQdM6bkEFO25BNztuQWk7bkGaO25BzDtuQf47bkEwPG5BYjxuQZQ8bkHFPG5B9zxuQSk9bkFbPW5BjT1uQb49bkHwPW5BIj5uQVQ+bkGGPm5BuD5uQek+bkEbP25BTT9uQX8/bkGxP25B4j9uQRRAbkFGQG5BeEBuQapAbkHbQG5BDUFuQT9BbkFxQW5Bo0FuQdRBbkEGQm5BOEJuQWpCbkGcQm5BzUJuQf9CbkExQ25BY0NuQZRDbkHGQ25B+ENuQSpEbkFbRG5BjURuQb9EbkHxRG5BI0VuQVRFbkGGRW5BuEVuQepFbkEbRm5BTUZuQX9GbkGxRm5B4kZuQRRHbkFGR25BeEduQalHbkHbR25BDUhuQT5IbkFwSG5BokhuQdRIbkEFSW5BN0luQWlJbkGbSW5BzEluQf5JbkEwSm5BYUpuQZNKbkHFSm5B90puQShLbkFaS25BjEtuQb1LbkHvS25BIUxuQVJMbkGE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Im9BKSNvQVkjb0GJI29BuSNvQegjb0EYJG9BSCRvQXgkb0GoJG9B2CRvQQglb0E4JW9BaCVvQZglb0HIJW9B9yVvQScmb0FXJm9BhyZvQbcmb0HnJm9BFydvQUcnb0F3J29BpydvQdYnb0EGKG9BNihvQWYob0GWKG9BxihvQfYob0EmKW9BVSlvQYUpb0G1KW9B5SlvQRUqb0FFKm9BdSpvQaUqb0HUKm9BBCtvQTQrb0FkK29BlCtvQcQrb0H0K29BIyxvQVMsb0GDLG9BsyxvQeMsb0ETLW9BQi1vQXItb0GiLW9B0i1vQQIub0EyLm9BYi5vQZEub0HBLm9B8S5vQSEvb0FRL29BgC9vQbAvb0HgL29BEDBvQUAwb0FwMG9BnzBvQc8wb0H/MG9BLzFvQV8xb0GOMW9BvjFvQe4xb0EeMm9BTjJvQX0yb0GtMm9B3TJvQQ0zb0E9M29BbDNvQZwzb0HMM29B/DNvQSw0b0FbNG9BizRvQbs0b0HrNG9BGzVvQUo1b0F6NW9BqjVvQdo1b0EJNm9BOTZvQWk2b0GZNm9ByDZvQfg2b0EoN29BWDdvQYg3b0G3N29B5zdvQRc4b0FHOG9BdjhvQaY4b0HWOG9BBjlvQTU5b0FlOW9BlTlvQcU5b0H0OW9BJDpvQVQ6b0GDOm9BszpvQeM6b0ETO29BQjtvQXI7b0GiO29B0jtvQQE8b0ExPG9BYTxvQZA8b0HAPG9B8DxvQSA9b0FPPW9Bfz1vQa89b0HePW9BDj5vQT4+b0FuPm9BnT5vQc0+b0H9Pm9BLD9vQVw/b0GMP29Buz9vQes/b0EbQG9BS0BvQXpAb0GqQG9B2kBvQQlBb0E5QW9BaUFvQZhBb0HIQW9B+EFvQSdCb0FXQm9Bh0JvQbZCb0HmQm9BFkNvQUVDb0F1Q29BpUNvQdRDb0EERG9BNERvQWNEb0GTRG9Bw0RvQfJEb0EiRW9BUkVvQYFFb0GxRW9B4UVvQRBGb0FARm9Bb0ZvQZ9Gb0HPRm9B/kZvQS5Hb0FeR29BjUdvQb1Hb0HtR29BHEhvQUxIb0F7SG9Bq0hvQdtIb0EKSW9BOklvQWpJb0GZSW9ByUlvQfhJb0EoSm9BWEpvQYdKb0G3Sm9B5kpvQRZLb0FGS29BdUtvQaVLb0HUS29BBExvQTRMb0FjTG9Bk0xvQcJMb0Hy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B3FBJwhxQVMIcUF/CHFBqwhxQdcIcUEECXFBMAlxQVwJcUGICXFBtAlxQeAJcUEMCnFBOQpxQWUKcUGRCnFBvQpxQekKcUEVC3FBQQtxQW0LcUGaC3FBxgtxQfILcUEeDHFBSgxxQXYMcUGiDHFBzgxxQfoMcUEnDXFBUw1xQX8NcUGrDXFB1w1xQQMOcUEvDnFBWw5xQYcOcUG0DnFB4A5xQQwPcUE4D3FBZA9xQZAPcUG8D3FB6A9xQRQQcUFAEHFBbBBxQZkQcUHFEHFB8RBxQR0RcUFJEXFBdRFxQaERcUHNEXFB+RFxQSUScUFREnFBfRJxQakScUHWEnFBAhNxQS4TcUFaE3FBhhNxQbITcUHeE3FBChRxQTYUcUFiFHFBjhRxQboUcUHmFHFBEhVxQT4VcUFqFXFBlhVxQcMVcUHvFXFBGxZxQUcWcUFzFnFBnxZxQcsWcUH3FnFBIxdxQU8XcUF7F3FBpxdxQdMXcUH/F3FBKxhxQVcYcUGDGHFBrxhxQdsYcUEHGXFBMxlxQV8ZcUGLGXFBtxlxQeMZcUEPGnFBOxpxQWcacUGTGnFBvxpxQesacUEXG3FBQxtxQW8bcUGbG3FBxxtxQfMbcUEfHHFBSxxxQXcccUGjHHFBzxxxQfsccUEnHXFBUx1xQX8dcUGrHXFB1x1xQQMecUEvHnFBWx5xQYcecUGzHnFB3x5xQQsfcUE3H3FBYx9xQY8fcUG7H3FB5x9xQRMgcUE/IHFBayBxQZcgcUHDIHFB7yBxQRshcUFHIXFBcyFxQZ8hcUHLIXFB9yFxQSMicUFPInFBeiJxQaYicUHSInFB/iJxQSojcUFWI3FBgiNxQa4jcUHaI3FBBiRxQTIkcUFeJHFBiiRxQbYkcUHiJHFBDiVxQTolcUFlJXFBkSVxQb0lcUHpJXFBFSZxQUEmcUFtJnFBmSZxQcUmcUHxJnFBHSdxQUkncUF1J3FBoCdxQcwncUH4J3FBJChxQVAocUF8KHFBqChxQdQocUEAKXFBLClxQVgpcUGDKXFBrylxQdspcUEHKnFBMypxQV8qcUGLKnFBtypxQeMqcUEOK3FBOitxQWYrcUGSK3FBvitxQeorcUEWLHFBQixxQW4scUGZLHFBxSxxQfEscUEdLXFBSS1xQXUtcUGhLXFBzC1xQfgtcUEkLnFBUC5xQXwucUGoLnFB1C5xQQAvcUErL3FBVy9xQYMvcUGvL3FB2y9xQQcwcUEzMHFBXjBxQYowcUG2MHFB4jBxQQ4xcUE6MXFBZTFxQZExcUG9MXFB6TFxQRUycUFBMnFBbDJxQZgycUHEMnFB8DJxQRwzcUFIM3FBczNxQZ8zcUHLM3FB9zNxQSM0cUFPNHFBejRxQaY0cUHSNHFB/jRxQSo1cUFVNXFBgTVxQa01cUHZNXFBBTZxQTA2cUFcNnFBiDZxQbQ2cUHgNnFBCzdxQTc3cUFjN3FBjzdxQbs3cUHmN3FBEjhxQT44cUFqOHFBljhxQcE4cUHtOHFBGTlxQUU5cUFxOXFBnDlxQcg5cUH0OXFBIDpxQUs6cUF3OnFBozpxQc86cUH7OnFBJjtxQVI7cUF+O3FBqjtxQdU7cUEBPHFBLTxxQVk8cUGEPHFBsDxxQdw8cUEIPXFBMz1xQV89cUGLPXFBtz1xQeI9cUEOPnFBOj5xQWY+cUGRPnFBvT5xQek+cUEVP3FBQD9xQWw/cUGYP3FBxD9xQe8/cUEbQHFBR0BxQXNAcUGeQHFBykBxQfZAcUEhQXFBTUFxQXlBcUGlQXFB0EFxQfxBcUEoQnFBU0JxQX9CcUGrQnFB10JxQQJDcUEuQ3FBWkNxQYVDcUGxQ3FB3UNxQQlEcUE0RHFBYERxQYxEcUG3RHFB40RxQQ9FcUE6RXFBZkVxQZJFcUG+RXFB6UVxQRVGcUFBRnFBbEZxQZhGcUHERnFB70ZxQRtHcUFHR3FBckdxQZ5HcUHKR3FB9UdxQSFIcUFNSHFBeEhxQaRIcUHQSHFB+0hxQSdJcUFTSXFBfklxQapJcUHWSXFBAUpxQS1KcUFZSnFBhEpxQbBKcUHcSnFBB0txQTNLcUFfS3FBiktxQbZLcUHiS3FBDUxxQTlMcUFkTHFBkExxQbxMcUHnTHFBE01xQT9NcUFqTXFBlk1xQcJNcUHtTXFBGU5xQUROcUFwTnFBnE5xQcdOcUHzTnFBH09xQUpPcUF2T3FBoU9xQc1PcUH5T3FBJFBxQVBQcUF8UHFBp1BxQdNQcUH+UHFBKlFxQVZRcUGBUXFBrVFxQdhRcUEEUnFBMFJxQVtScUGHUnFBslJxQd5ScUEKU3FBNVNxQWFTcUGMU3FBuFNxQeNTcUEPVHFBO1RxQWZUcUGSVHFBvVRxQelUcUEV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EXJBtRFyQd8RckEKEnJBNBJyQV4SckGIEnJBsxJyQd0SckEHE3JBMRNyQVsTckGFE3JBsBNyQdoTckEEFHJBLhRyQVgUckGDFHJBrRRyQdcUckEBFXJBKxVyQVYVckGAFXJBqhVyQdQVckH+FXJBKBZyQVMWckF9FnJBpxZyQdEWckH7FnJBJRdyQVAXckF6F3JBpBdyQc4XckH4F3JBIhhyQU0YckF3GHJBoRhyQcsYckH1GHJBHxlyQUoZckF0GXJBnhlyQcgZckHyGXJBHBpyQUcackFxGnJBmxpyQcUackHvGnJBGRtyQUMbckFtG3JBmBtyQcIbckHsG3JBFhxyQUAcckFqHHJBlBxyQb8cckHpHHJBEx1yQT0dckFnHXJBkR1yQbsdckHlHXJBEB5yQToeckFkHnJBjh5yQbgeckHiHnJBDB9yQTYfckFgH3JBix9yQbUfckHfH3JBCSByQTMgckFdIHJBhyByQbEgckHbIHJBBiFyQTAhckFaIXJBhCFyQa4hckHYIXJBAiJyQSwickFWInJBgCJyQaoickHVInJB/yJyQSkjckFTI3JBfSNyQacjckHRI3JB+yNyQSUkckFPJHJBeSRyQaMkckHNJHJB+CRyQSIlckFMJXJBdiVyQaAlckHKJXJB9CVyQR4mckFIJnJBciZyQZwmckHGJnJB8CZyQRonckFEJ3JBbidyQZknckHDJ3JB7SdyQRcockFBKHJBayhyQZUockG/KHJB6ShyQRMpckE9KXJBZylyQZEpckG7KXJB5SlyQQ8qckE5KnJBYypyQY0qckG3KnJB4SpyQQsrckE1K3JBXytyQYkrckGzK3JB3ityQQgsckEyLHJBXCxyQYYsckGwLHJB2ixyQQQtckEuLXJBWC1yQYItckGsLXJB1i1yQQAuckEqLnJBVC5yQX4uckGoLnJB0i5yQfwuckEmL3JBUC9yQXovckGkL3JBzi9yQfgvckEiMHJBTDByQXYwckGgMHJByjByQfQwckEeMXJBSDFyQXIxckGcMXJBxjFyQe8xckEZMnJBQzJyQW0yckGXMnJBwTJyQesyckEVM3JBPzNyQWkzckGTM3JBvTNyQeczckERNHJBOzRyQWU0ckGPNHJBuTRyQeM0ckENNXJBNzVyQWE1ckGLNXJBtTVyQd81ckEJNnJBMzZyQVw2ckGGNnJBsDZyQdo2ckEEN3JBLjdyQVg3ckGCN3JBrDdyQdY3ckEAOHJBKjhyQVQ4ckF+OHJBqDhyQdI4ckH7OHJBJTlyQU85ckF5OXJBozlyQc05ckH3OXJBITpyQUs6ckF1OnJBnzpyQck6ckHzOnJBHDtyQUY7ckFwO3JBmjtyQcQ7ckHuO3JBGDxyQUI8ckFsPHJBljxyQcA8ckHpPHJBEz1yQT09ckFnPXJBkT1yQbs9ckHlPXJBDz5yQTk+ckFiPnJBjD5yQbY+ckHgPnJBCj9yQTQ/ckFeP3JBiD9yQbI/ckHbP3JBBUByQS9AckFZQHJBg0ByQa1AckHXQHJBAUFyQSpBckFUQXJBfkFyQahBckHSQXJB/EFyQSZCckFQQnJBeUJyQaNCckHNQnJB90JyQSFDckFLQ3JBdUNyQZ5DckHIQ3JB8kNyQRxEckFGRHJBcERyQZlEckHDRHJB7URyQRdFckFBRXJBa0VyQZVFckG+RXJB6EVyQRJGckE8RnJBZkZyQZBGckG5RnJB40ZyQQ1HckE3R3JBYUdyQYtHckG0R3JB3kdyQQhIckEySHJBXEhyQYVIckGvSHJB2UhyQQNJckEtSXJBV0lyQYBJckGqSXJB1ElyQf5JckEoSnJBUUpyQXtKckGlSnJBz0pyQflKckEiS3JBTEtyQXZLckGgS3JByktyQfNLckEdTHJBR0xyQXFMckGbTHJBxExyQe5MckEYTXJBQk1yQWtNckGVTXJBv01yQelNckETTnJBPE5yQWZOckGQTnJBuk5yQeNOckENT3JBN09yQWFPckGLT3JBtE9yQd5PckEIUHJBMlByQVtQckGFUHJBr1ByQdlQckECUXJBLFFyQVZRckGAUXJBqVFyQdNRckH9UXJBJ1JyQVBSckF6UnJBpFJyQc5SckH3UnJBIVNyQUtTckF1U3JBnlNyQchTckHyU3JBHFRyQUVUckFvVHJBmVRyQcNUckHsVHJBFlVyQUBVckFpVXJBk1VyQb1VckHnVXJBEFZyQTpWckFkVnJBjlZyQbdWckHhVnJBC1dyQTRXckFeV3JBiFdyQbJXckHbV3JBBVhyQS9YckFYWHJBglhyQaxYckHWWHJB/1hyQSlZckFTWXJBfFlyQaZZckHQWXJB+VlyQSNackFNWnJBdlpyQaBackHKWnJB9FpyQR1bckFHW3JBcVtyQZpbckHEW3JB7ltyQRdcckFBXHJBa1xyQZRcckG+XHJB6FxyQRFdckE7XXJBZV1yQY5dckG4XXJB4l1yQQteckE1XnJBX15yQYheckGyXnJB3F5yQQVfckEvX3JBWV9yQYJfckGsX3JB1l9yQf9fckEpYHJBU2ByQXxgckGmYHJB0GByQflgckEjYXJBTWFyQXZhckGgYXJByWFyQfNhckEdYnJBRmJyQXBickGaYnJBw2JyQe1ickEXY3JBQGNyQWpjckGTY3JBvWNyQedjckEQZHJBOmRyQWRkckGNZHJBt2RyQeBkckEKZXJBNGVyQV1lckGHZXJBsGVyQdplckEEZnJBLWZyQVdmckGBZnJBqmZyQdRmckH9ZnJBJ2dyQVFnckF6Z3JBpGdyQc1nckH3Z3JBIWhyQUpockF0aHJBnWhyQcdockHwaHJBGmlyQURpckFtaXJBl2lyQcBpckHqaXJBFGpyQT1qckFnanJBkGpyQbpqckHjanJBDWtyQTdrckFga3JBimtyQbNrckHda3JBBmxyQTBsckFabHJBg2xyQa1sckHWbHJBAG1yQSltckFTbXJBfW1yQaZtckHQbXJB+W1yQSNuckFMbnJBdm5yQZ9uckHJbnJB825yQRxvckFGb3JBb29yQZlvckHCb3JB7G9yQRVwckE/cHJBaHByQZJwckG7cHJB5XByQQ9xckE4cXJBYnFyQYtxckG1cXJB3nFyQQhyckExcnJBW3JyQYRyckGucnJB13JyQQFzckEqc3JBVHNyQX1zckGnc3JB0HNyQfpzckEjdHJBTXRyQXZ0ckGgdHJByXRyQfN0ckEcdXJBRnVyQW91ckGZdXJBwnVyQex1ckEVdnJBP3ZyQWh2ckGSdnJBu3ZyQeV2ckEOd3JBOHdyQWF3ckGLd3JBtHdyQd53ckEHeHJBMXhyQVp4ckGEeHJBrXhyQdd4ckEAeXJBKnlyQVN5ckF9eXJBpnlyQdB5ckH5eXJBI3pyQUx6ckF1enJBn3pyQch6ckHyenJBG3tyQUV7ckFue3JBmHtyQcF7ckHre3JBFHxyQT58ckFnfHJBkHxyQbp8ckHjfHJBDX1yQTZ9ckFgfXJBiX1yQbN9ckHcfXJBBX5yQS9+ckFYfnJBgn5yQat+ckHVfnJB/n5yQSh/ckFRf3JBen9yQaR/ckHNf3JB939yQSCAckFKgHJBc4ByQZyAckHGgHJB74ByQRmBckFCgXJBa4FyQZWBckG+gXJB6IFyQRGCckE7gnJBZIJyQY2CckG3gnJB4IJyQQqDckEzg3JBXINyQYaDckGvg3JB2YNyQQKEckErhHJBVYRyQX6EckGohHJB0YRyQfqEckEkhXJBTYVyQXeFckGghXJByYVyQfOFckEchnJBRoZyQW+GckGYhnJBwoZyQeuGckEUh3JBPodyQWeHckGRh3JBuodyQeOHckENiHJBNohyQV+IckGJiHJBsohyQduIckEFiXJBLolyQViJckGBiXJBqolyQdSJckH9iXJBJopyQVCKckF5inJBoopyQcyKckH1inJBH4tyQUiLckFxi3JBm4tyQcSLckHti3JBF4xyQUCMckFpjHJBk4xyQbyMckHljHJBD41yQTiNckFhjXJBi41yQbSNckHdjXJBB45yQTCOckFZjnJBg45yQayOckHVjnJB/45yQSiPckFRj3JBe49yQaSPckHNj3JB9o9yQSCQckFJkHJBcpByQZyQckHFkHJB7pByQRiRckFBkXJBapFyQZSRckG9kXJB5pFyQQ+SckE5knJBYpJyQYuSckG1knJB3pJyQQeTckExk3JBWpNyQYOTckGsk3JB1pNyQf+TckEolHJBUpRyQXuUckGklHJBzZRyQfeUckEglXJBSZVyQXOVckGclXJBxZVyQe6VckEYlnJBQZZyQWqWckGTlnJBvZZyQeaWckEPl3JBOZdyQWKXckGLl3JBtJdyQd6XckEHmHJBMJhyQVmYckGDmHJBrJhyQdWYckH+mHJBKJlyQVGZckF6mXJBo5lyQc2ZckH2mXJBH5pyQUiackFymnJBm5pyQcSackHtmnJBF5tyQUCbckFpm3JBkptyQbybckHlm3JBDpxyQTecckFgnHJBipxyQbOcckHcnHJBBZ1yQS+dckFYnXJBgZ1yQaqdckHTnXJB/Z1yQSaeckFPnnJBeJ5yQaKeckHLnnJB9J5yQR2fckFGn3JBcJ9yQZmfckHCn3JB659yQRSgckE+oHJBZ6ByQZCgckG5oHJB4qByQQyhckE1oXJBXqFyQYehckGwoXJB2qFyQQOickEsonJBVaJyQX6ickGoonJB0aJyQfqickEjo3JBTKNyQXWjckGfo3JByKNyQfGjckEapHJBQ6RyQW2kckGWpHJBv6RyQeikckERpXJBOqVyQWSlckGNpXJBtqVyQd+lckEIpnJBMaZyQVqmckGEpnJBraZyQdamckH/pnJBKKdyQVGnckF7p3JBpKdyQc2nckH2p3JBH6hyQUiockFxqHJBm6hyQcSockHtqHJBFqlyQT+pckFoqXJBkalyQbupckHkqXJBDapyQTaqckFfqnJBiKpyQbGqckHbqnJBBKtyQS2rckFWq3JBf6tyQairckHRq3JB+qtyQSSsckFNrHJBdqxyQZ+sckHIrHJB8axyQRqtckFDrXJBbK1yQZatckG/rXJB6K1yQRGuckE6rnJBY65yQYyuckG1rnJB3q5yQQevckExr3JBWq9yQYOvckGsr3JB1a9yQf6vckEnsHJBULByQXmwckGisHJBzLByQfWwckEesXJBR7FyQXCxckGZsXJBwrFyQeuxckEUsnJBPbJyQWayckGPsnJBuLJyQeKyckELs3JBNLNyQV2zckGGs3JBr7NyQdizckEBtHJBKrRyQVO0ckF8tHJBpbRyQc60ckH3tHJBILVyQUm1ckFztXJBnLVyQcW1ckHutXJBF7ZyQUC2ckFptnJBkrZyQbu2ckHktnJBDbdyQTa3ckFft3JBiLdyQbG3ckHat3JBA7hyQSy4ckFVuHJBfrhyQae4ckHQuHJB+bhyQSO5ckFMuXJBdblyQZ65ckHHuXJB8LlyQRm6ckFCunJBa7pyQZS6ckG9unJB5rpyQQ+7ckE4u3JBYbtyQYq7ckGzu3JB3LtyQQW8ckEuvHJBV7xyQYC8ckGpvHJB0rxyQfu8ckEkvXJBTb1yQXa9ckGfvXJByL1yQfG9ckEavnJBQ75yQWy+ckGVvnJBvr5yQee+ckEQv3JBOb9yQWK/ckGLv3JBtL9yQd2/ckEGwHJBL8ByQVjAckGBwHJBqsByQdPAckH8wHJBJcFyQU7BckF3wXJBn8FyQcjBckHxwXJBGsJyQUPCckFswnJBlcJyQb7CckHnwnJBEMNyQTnDckFiw3JBi8NyQbTDckHdw3JBBsRyQS/EckFYxHJBgcRyQarEckHTxHJB/MRyQSXFckFNxXJBdsVyQZ/FckHIxXJB8cVyQRrGckFDxnJBbMZyQZXGckG+xnJB58ZyQRDHckE5x3JBYsdyQYvHckG0x3JB3MdyQQXIckEuyHJBV8hyQYDIckGpyHJB0shyQfvIckEkyXJBTclyQXbJckGfyXJByMlyQfDJckEZynJBQspyQWvKckGUynJBvcpyQebKckEPy3JBOMtyQWHLckGJy3JBsstyQdvLckEEzHJBLcxyQVbMckF/zHJBqMxyQdHMckH6zHJBIs1yQUvNckF0zXJBnc1yQcbNckHvzXJBGM5yQUHOckFqznJBks5yQbvOckHkznJBDc9yQTbPckFfz3JBiM9yQbHPckHZz3JBAtByQSvQckFU0HJBfdByQabQckHP0HJB99ByQSDRckFJ0XJBctFyQZvRckHE0XJB7dFyQRbSckE+0nJBZ9JyQZDSckG50nJB4tJyQQvTckEz03JBXNNyQYXTckGu03JB19NyQQDUckEp1HJBUdRyQXrUckGj1HJBzNRyQfXUckEe1XJBRtVyQW/VckGY1XJBwdVyQerVckET1nJBO9ZyQWTWckGN1nJBttZyQd/WckEI13JBMNdyQVnXckGC13JBq9dyQdTXckH813JBJdhyQU7YckF32HJBoNhyQcjYckHx2HJBGtlyQUPZckFs2XJBldlyQb3ZckHm2XJBD9pyQTjackFh2nJBidpyQbLackHb2nJBBNtyQS3bckFV23JBfttyQafbckHQ23JB+NtyQSHcckFK3HJBc9xyQZzcckHE3HJB7dxyQRbdckE/3XJBaN1yQZDdckG53XJB4t1yQQveckEz3nJBXN5yQYXeckGu3nJB1t5yQf/eckEo33JBUd9yQXrfckGi33JBy99yQfTfckEd4HJBReByQW7gckGX4HJBwOByQejgckER4XJBOuFyQWPhckGL4XJBtOFyQd3hckEG4nJBLuJyQVfickGA4nJBqeJyQdHickH64nJBI+NyQUzjckF043JBneNyQcbjckHu43JBF+RyQUDkckFp5HJBkeRyQbrkckHj5HJBDOVyQTTlckFd5XJBhuVyQa7lckHX5XJBAOZyQSnmckFR5nJBeuZyQaPmckHL5nJB9OZyQR3nckFG53JBbudyQZfnckHA53JB6OdyQRHockE66HJBY+hyQYvockG06HJB3ehyQQXpckEu6XJBV+lyQX/pckGo6XJB0elyQfrpckEi6nJBS+pyQXTqckGc6nJBxepyQe7qckEW63JBP+tyQWjrckGQ63JBuetyQeLrckEK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M3NBRTNzQW4zc0GWM3NBvjNzQeYzc0EONHNBNjRzQV80c0GHNHNBrzRzQdc0c0H/NHNBKDVzQVA1c0F4NXNBoDVzQcg1c0HwNXNBGTZzQUE2c0FpNnNBkTZzQbk2c0HhNnNBCjdzQTI3c0FaN3NBgjdzQao3c0HSN3NB+zdzQSM4c0FLOHNBczhzQZs4c0HDOHNB7DhzQRQ5c0E8OXNBZDlzQYw5c0G0OXNB3DlzQQU6c0EtOnNBVTpzQX06c0GlOnNBzTpzQfU6c0EeO3NBRjtzQW47c0GWO3NBvjtzQeY7c0EOPHNBNjxzQV88c0GHPHNBrzxzQdc8c0H/PHNBJz1zQU89c0F3PXNBoD1zQcg9c0HwPXNBGD5zQUA+c0FoPnNBkD5zQbg+c0HgPnNBCT9zQTE/c0FZP3NBgT9zQak/c0HRP3NB+T9zQSFAc0FJQHNBckBzQZpAc0HCQHNB6kBzQRJBc0E6QXNBYkFzQYpBc0GyQXNB2kFzQQJCc0ErQnNBU0JzQXtCc0GjQnNBy0JzQfNCc0EbQ3NBQ0NzQWtDc0GTQ3NBu0NzQeNDc0EMRHNBNERzQVxEc0GERHNBrERzQdREc0H8RHNBJEVzQUxFc0F0RXNBnEVzQcRFc0HsRXNBFEZzQT1Gc0FlRnNBjUZzQbVGc0HdRnNBBUdzQS1Hc0FVR3NBfUdzQaVHc0HNR3NB9UdzQR1Ic0FFSHNBbUhzQZVIc0G9SHNB5UhzQQ1Jc0E1SXNBXklzQYZJc0GuSXNB1klzQf5Jc0EmSnNBTkpzQXZKc0GeSnNBxkpzQe5Kc0EWS3NBPktzQWZLc0GOS3NBtktzQd5Lc0EGTHNBLkxzQVZMc0F+THNBpkxzQc5Mc0H2THNBHk1zQUZNc0FuTXNBlk1zQb5Nc0HmTXNBDk5zQTZOc0FeTnNBhk5zQa5Oc0HWTnNB/k5zQSZPc0FOT3NBdk9zQZ5Pc0HGT3NB7k9zQRZQc0E+UHNBZlBzQY5Qc0G2UHNB3lBzQQZRc0EuUXNBVlFzQX5Rc0GmUXNBzlFzQfZRc0EeUnNBRlJzQW5Sc0GWUnNBvlJzQeZSc0EOU3NBNlNzQV5Tc0GGU3NBrlNzQdZTc0H+U3NBJlRzQU5Uc0F2VHNBnlRzQcZUc0HuVHNBFlVzQT1Vc0FlVXNBjVVzQbVVc0HdVXNBBVZzQS1Wc0FVVnNBfVZzQaVWc0HNVnNB9VZzQR1Xc0FFV3NBbVdzQZVXc0G9V3NB5VdzQQ1Yc0E1WHNBXFhzQYRYc0GsWHNB1FhzQfxYc0EkWXNBTFlzQXRZc0GcWXNBxFlzQexZc0EUWnNBPFpzQWRac0GLWnNBs1pzQdtac0EDW3NBK1tzQVNbc0F7W3NBo1tzQctbc0HzW3NBG1xzQUNcc0FqXHNBklxzQbpcc0HiXHNBCl1zQTJdc0FaXXNBgl1zQapdc0HSXXNB+l1zQSFec0FJXnNBcV5zQZlec0HBXnNB6V5zQRFfc0E5X3NBYV9zQYhfc0GwX3NB2F9zQQBgc0EoYHNBUGBzQXhgc0GgYHNByGBzQe9gc0EXYXNBP2FzQWdhc0GPYXNBt2FzQd9hc0EHYnNBLmJzQVZic0F+YnNBpmJzQc5ic0H2YnNBHmNzQUZjc0FtY3NBlWNzQb1jc0HlY3NBDWRzQTVkc0FdZHNBhGRzQaxkc0HUZHNB/GRzQSRlc0FMZXNBdGVzQZtlc0HDZXNB62VzQRNmc0E7ZnNBY2ZzQYpmc0GyZnNB2mZzQQJnc0EqZ3NBUmdzQXlnc0GhZ3NByWdzQfFnc0EZaHNBQWhzQWhoc0GQaHNBuGhzQeBoc0EIaXNBMGlzQVdpc0F/aXNBp2lzQc9pc0H3aXNBH2pzQUZqc0FuanNBlmpzQb5qc0HmanNBDWtzQTVrc0Fda3NBhWtzQa1rc0HUa3NB/GtzQSRsc0FMbHNBdGxzQZxsc0HDbHNB62xzQRNtc0E7bXNBY21zQYptc0GybXNB2m1zQQJuc0EpbnNBUW5zQXluc0GhbnNByW5zQfBuc0EYb3NBQG9zQWhvc0GQb3NBt29zQd9vc0EHcHNBL3BzQVZwc0F+cHNBpnBzQc5wc0H2cHNBHXFzQUVxc0FtcXNBlXFzQbxxc0HkcXNBDHJzQTRyc0FbcnNBg3JzQatyc0HTcnNB+nJzQSJzc0FKc3NBcnNzQZpzc0HBc3NB6XNzQRF0c0E5dHNBYHRzQYh0c0GwdHNB2HRzQf90c0EndXNBT3VzQXZ1c0GedXNBxnVzQe51c0EVdnNBPXZzQWV2c0GNdnNBtHZzQdx2c0EEd3NBLHdzQVN3c0F7d3NBo3dzQct3c0Hyd3NBGnhzQUJ4c0FpeHNBkXhzQbl4c0HheHNBCHlzQTB5c0FY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LnVBsS51QdYudUH7LnVBIC91QUQvdUFpL3VBji91QbMvdUHYL3VB/S91QSIwdUFHMHVBazB1QZAwdUG1MHVB2jB1Qf8wdUEkMXVBSTF1QW4xdUGSMXVBtzF1QdwxdUEBMnVBJjJ1QUsydUFwMnVBlDJ1QbkydUHeMnVBAzN1QSgzdUFNM3VBcjN1QZYzdUG7M3VB4DN1QQU0dUEqNHVBTzR1QXM0dUGYNHVBvTR1QeI0dUEHNXVBLDV1QVE1dUF1NXVBmjV1Qb81dUHkNXVBCTZ1QS42dUFSNnVBdzZ1QZw2dUHBNnVB5jZ1QQs3dUEvN3VBVDd1QXk3dUGeN3VBwzd1Qeg3dUEMOHVBMTh1QVY4dUF7OHVBoDh1QcQ4dUHpOHVBDjl1QTM5dUFYOXVBfTl1QaE5dUHGOXVB6zl1QRA6dUE1OnVBWTp1QX46dUGjOnVByDp1Qe06dUERO3VBNjt1QVs7dUGAO3VBpTt1Qco7dUHuO3VBEzx1QTg8dUFdPHVBgTx1QaY8dUHLPHVB8Dx1QRU9dUE5PXVBXj11QYM9dUGoPXVBzT11QfE9dUEWPnVBOz51QWA+dUGFPnVBqT51Qc4+dUHzPnVBGD91QTw/dUFhP3VBhj91Qas/dUHQP3VB9D91QRlAdUE+QHVBY0B1QYdAdUGsQHVB0UB1QfZAdUEbQXVBP0F1QWRBdUGJQXVBrkF1QdJBdUH3QXVBHEJ1QUFCdUFlQnVBikJ1Qa9CdUHUQnVB+EJ1QR1DdUFCQ3VBZ0N1QYtDdUGwQ3VB1UN1QfpDdUEeRHVBQ0R1QWhEdUGNRHVBsUR1QdZEdUH7RHVBIEV1QURFdUFpRXVBjkV1QbNFdUHXRXVB/EV1QSFGdUFGRnVBakZ1QY9GdUG0RnVB2UZ1Qf1GdUEiR3VBR0d1QWtHdUGQR3VBtUd1QdpHdUH+R3VBI0h1QUhIdUFtSHVBkUh1QbZIdUHbSHVB/0h1QSRJdUFJSXVBbkl1QZJJdUG3SXVB3El1QQBKdUElSnVBSkp1QW9KdUGTSnVBuEp1Qd1KdUEBS3VBJkt1QUtLdUFvS3VBlEt1QblLdUHeS3VBAkx1QSdMdUFMTHVBcEx1QZVMdUG6THVB3kx1QQNNdUEoTXVBTU11QXFNdUGWTXVBu011Qd9NdUEETnVBKU51QU1OdUFyTnVBl051QbtOdUHg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LHZBfix2QaEsdkHFLHZB6Cx2QQstdkEvLXZBUi12QXUtdkGZLXZBvC12Qd8tdkEDLnZBJi52QUkudkFtLnZBkC52QbMudkHXLnZB+i52QR0vdkFBL3ZBZC92QYcvdkGqL3ZBzi92QfEvdkEUMHZBODB2QVswdkF+MHZBojB2QcUwdkHoMHZBDDF2QS8xdkFSMXZBdTF2QZkxdkG8MXZB3zF2QQMydkEmMnZBSTJ2QW0ydkGQMnZBszJ2QdYydkH6MnZBHTN2QUAzdkFkM3ZBhzN2QaozdkHNM3ZB8TN2QRQ0dkE3NHZBWzR2QX40dkGhNHZBxDR2Qeg0dkELNXZBLjV2QVI1dkF1NXZBmDV2Qbs1dkHfNXZBAjZ2QSU2dkFJNnZBbDZ2QY82dkGyNnZB1jZ2Qfk2dkEcN3ZBPzd2QWM3dkGGN3ZBqTd2Qc03dkHwN3ZBEzh2QTY4dkFaOHZBfTh2QaA4dkHDOHZB5zh2QQo5dkEtOXZBUDl2QXQ5dkGXOXZBujl2Qd05dkEBOnZBJDp2QUc6dkFqOnZBjjp2QbE6dkHUOnZB9zp2QRs7dkE+O3ZBYTt2QYQ7dkGoO3ZByzt2Qe47dkERPHZBNTx2QVg8dkF7PHZBnjx2QcE8dkHlPHZBCD12QSs9dkFOPXZBcj12QZU9dkG4PXZB2z12Qf89dkEiPnZBRT52QWg+dkGLPnZBrz52QdI+dkH1PnZBGD92QTw/dkFfP3ZBgj92QaU/dkHIP3ZB7D92QQ9AdkEyQHZBVUB2QXlAdkGcQHZBv0B2QeJAdkEFQXZBKUF2QUxBdkFvQXZBkkF2QbVBdkHZQXZB/EF2QR9CdkFCQnZBZUJ2QYlCdkGsQnZBz0J2QfJCdkEVQ3ZBOUN2QVxDdkF/Q3ZBokN2QcVDdkHpQ3ZBDER2QS9EdkFSRHZBdUR2QZlEdkG8RHZB30R2QQJFdkElRXZBSEV2QWxFdkGPRXZBskV2QdVFdkH4RXZBHEZ2QT9GdkFiRnZBhUZ2QahGdkHLRnZB70Z2QRJHdkE1R3ZBWEd2QXtHdkGeR3ZBwkd2QeVHdkEISHZBK0h2QU5IdkFySHZBlUh2QbhIdkHbSHZB/kh2QSFJdkFESXZBaEl2QYtJdkGuSXZB0Ul2QfRJdkEXSnZBO0p2QV5KdkGBSnZBpEp2QcdKdkHqSnZBDUt2QTFLdkFU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W3dBJVt3QUZbd0FoW3dBiVt3Qatbd0HNW3dB7lt3QRBcd0ExXHdBU1x3QXRcd0GWXHdBt1x3Qdlcd0H7XHdBHF13QT5dd0FfXXdBgV13QaJdd0HEXXdB5V13QQded0EpXndBSl53QWxed0GNXndBr153QdBed0HyXndBE193QTVfd0FWX3dBeF93QZpfd0G7X3dB3V93Qf5fd0EgYHdBQWB3QWNgd0GEYHdBpmB3Qcdgd0HpYHdBCmF3QSxhd0FOYXdBb2F3QZFhd0GyYXdB1GF3QfVhd0EXYndBOGJ3QVpid0F7YndBnWJ3Qb5id0HgYndBAWN3QSNjd0FEY3dBZmN3QYhjd0GpY3dBy2N3Qexjd0EOZHdBL2R3QVFkd0FyZHdBlGR3QbVkd0HXZHdB+GR3QRpld0E7ZXdBXWV3QX5ld0GgZXdBwWV3QeNld0EEZndBJmZ3QUdmd0FpZndBimZ3Qaxmd0HNZndB72Z3QRBnd0EyZ3dBU2d3QXVnd0GWZ3dBuGd3Qdlnd0H7Z3dBHGh3QT5od0FfaHdBgWh3QaJod0HEaHdB5Wh3QQdpd0EoaXdBSml3QWtpd0GNaXdBrml3QdBpd0HxaXdBE2p3QTRqd0FWandBd2p3QZlqd0G6andB22p3Qf1qd0Eea3dBQGt3QWFrd0GDa3dBpGt3QcZrd0Hna3dBCWx3QSpsd0FMbHdBbWx3QY9sd0GwbHdB0mx3QfNsd0EVbXdBNm13QVdtd0F5bXdBmm13Qbxtd0HdbXdB/213QSBud0FCbndBY253QYVud0GmbndByG53Qelud0EKb3dBLG93QU1vd0Fvb3dBkG93QbJvd0HTb3dB9W93QRZwd0E4cHdBWXB3QXpwd0GccHdBvXB3Qd9wd0EAcXdBInF3QUNxd0FlcXdBhnF3Qadxd0HJcXdB6nF3QQxyd0EtcndBT3J3QXByd0GRcndBs3J3QdRyd0H2cndBF3N3QTlzd0Fac3dBe3N3QZ1zd0G+c3dB4HN3QQF0d0EjdHdBRHR3QWV0d0GHdHdBqHR3Qcp0d0HrdHdBDXV3QS51d0FPdXdBcXV3QZJ1d0G0dXdB1XV3Qfd1d0EYdndBOXZ3QVt2d0F8dndBnnZ3Qb92d0HgdndBAnd3QSN3d0FFd3dBZnd3QYd3d0Gpd3dBynd3Qex3d0ENeHdBLnh3QVB4d0FxeHdBk3h3QbR4d0HVeHdB93h3QRh5d0E6eXdBW3l3QXx5d0GeeXdBv3l3QeF5d0ECendBI3p3QUV6d0FmendBiHp3Qal6d0HKendB7Hp3QQ17d0Eve3dBUHt3QXF7d0GTe3dBtHt3QdV7d0H3e3dBGHx3QTp8d0FbfHdBfHx3QZ58d0G/fHdB4Xx3QQJ9d0EjfXdBRX13QWZ9d0GHfXdBqX13Qcp9d0HsfXdBDX53QS5+d0FQfndBcX53QZJ+d0G0fndB1X53QfZ+d0EYf3dBOX93QVt/d0F8f3dBnX93Qb9/d0Hgf3dBAYB3QSOAd0FEgHdBZYB3QYeAd0GogHdByoB3QeuAd0EMgXdBLoF3QU+Bd0FwgXdBkoF3QbOBd0HUgXdB9oF3QReCd0E4gndBWoJ3QXuCd0GcgndBvoJ3Qd+Cd0EAg3dBIoN3QUODd0Fkg3dBhoN3QaeDd0HIg3dB6oN3QQuEd0EshHdBToR3QW+Ed0GQhHdBsoR3QdOEd0H0hHdBFoV3QTeFd0FYhXdBeoV3QZuFd0G8hXdB3oV3Qf+Fd0EghndBQoZ3QWOGd0GEhndBpoZ3QceGd0HohndBCod3QSuHd0FMh3dBbod3QY+Hd0Gwh3dB0od3QfOHd0EUiHdBNoh3QVeId0F4iHdBmYh3QbuId0HciHdB/Yh3QR+Jd0FAiXdBYYl3QYOJd0GkiXdBxYl3QeeJd0EIindBKYp3QUqKd0FsindBjYp3Qa6Kd0HQindB8Yp3QRKLd0E0i3dBVYt3QXaLd0GXi3dBuYt3QdqLd0H7i3dBHYx3QT6Md0FfjHdBgIx3QaKMd0HDjHdB5Ix3QQaNd0EnjXdBSI13QWmNd0GLjXdBrI13Qc2Nd0HvjXdBEI53QTGOd0FSjndBdI53QZWOd0G2jndB2I53QfmOd0Eaj3dBO493QV2Pd0F+j3dBn493QcCPd0Hij3dBA5B3QSSQd0FGkHdBZ5B3QYiQd0GpkHdBy5B3QeyQd0ENkXdBLpF3QVCRd0FxkXdBkpF3QbORd0HVkXdB9pF3QReSd0E4kndBWpJ3QXuSd0GckndBvZJ3Qd+Sd0EAk3dBIZN3QUKTd0Fkk3dBhZN3QaaTd0HHk3dB6ZN3QQqUd0ErlHdBTJR3QW6Ud0GPlHdBsJR3QdGUd0HzlHdBFJV3QTWVd0FWlXdBeJV3QZmVd0G6lXdB25V3Qf2Vd0EelndBP5Z3QWCWd0GClndBo5Z3QcSWd0HllndBBpd3QSiXd0FJl3dBapd3QYuXd0Gtl3dBzpd3Qe+Xd0EQmHdBMZh3QVOYd0F0mHdBlZh3QbaYd0HYmHdB+Zh3QRqZd0E7mXdBXJl3QX6Zd0GfmXdBwJl3QeGZd0EDmndBJJp3QUWad0FmmndBh5p3Qamad0HKmndB65p3QQybd0Etm3dBT5t3QXCbd0GRm3dBspt3QdObd0H1m3dBFpx3QTecd0FYnHdBeZx3QZucd0G8nHdB3Zx3Qf6cd0EfnXdBQZ13QWKdd0GDnXdBpJ13QcWdd0HnnXdBCJ53QSmed0FKnndBa553QY2ed0GunndBz553QfCed0ERn3dBMp93QVSfd0F1n3dBlp93Qbefd0HYn3dB+p93QRugd0E8oHdBXaB3QX6gd0GfoHdBwaB3QeKgd0EDoXdBJKF3QUWhd0FmoXdBiKF3Qamhd0HKoXdB66F3QQyid0EuondBT6J3QXCid0GRondBsqJ3QdOid0H0ondBFqN3QTejd0FYo3dBeaN3QZqjd0G7o3dB3aN3Qf6jd0EfpHdBQKR3QWGkd0GCpHdBpKR3QcWkd0HmpHdBB6V3QSild0FJpXdBaqV3QYyld0GtpXdBzqV3Qe+ld0EQpndBMaZ3QVKmd0F0pndBlaZ3Qbamd0HXpndB+KZ3QRmnd0E6p3dBXKd3QX2nd0Gep3dBv6d3QeCnd0EBqHdBIqh3QUSod0FlqHdBhqh3Qaeod0HIqHdB6ah3QQqpd0ErqXdBTal3QW6pd0GPqXdBsKl3QdGpd0HyqXdBE6p3QTSqd0FWqndBd6p3QZiqd0G5qndB2qp3Qfuqd0Ecq3dBPat3QV+rd0GAq3dBoat3QcKrd0Hjq3dBBKx3QSWsd0FGrHdBZ6x3QYmsd0GqrHdBy6x3Qeysd0ENrXdBLq13QU+td0FwrXdBka13QbKtd0HUrXdB9a13QRaud0E3rndBWK53QXmud0GarndBu653Qdyud0H9rndBH693QUCvd0Fhr3dBgq93QaOvd0HEr3dB5a93QQawd0EnsHdBSLB3QWmwd0GLsHdBrLB3Qc2wd0HusHdBD7F3QTCxd0FRsXdBcrF3QZOxd0G0sXdB1bF3Qfaxd0EYsndBObJ3QVqyd0F7sndBnLJ3Qb2yd0He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lnhBFJd4QTSXeEFUl3hBdJd4QZSXeEGzl3hB05d4QfOXeEETmHhBM5h4QVOYeEFymHhBkph4QbKYeEHSmHhB8ph4QRGZeEExmXhBUZl4QXGZeEGRmXhBsJl4QdCZeEHwmXhBEJp4QTCaeEFPmnhBb5p4QY+aeEGvmnhBz5p4Qe6aeEEOm3hBLpt4QU6beEFum3hBjZt4Qa2beEHNm3hB7Zt4QQ2ceEEsnHhBTJx4QWyceEGMnHhBrJx4QcuceEHrnHhBC514QSudeEFLnXhBap14QYqdeEGqnXhByp14QemdeEEJnnhBKZ54QUmeeEFpnnhBiJ54QaieeEHInnhB6J54QQefeEEnn3hBR594QWefeEGHn3hBpp94QcafeEHmn3hBBqB4QSWgeEFFoHhBZaB4QYWgeEGloHhBxKB4QeSgeEEEoXhBJKF4QUOheEFjoXhBg6F4QaOheEHCoXhB4qF4QQKieEEionhBQaJ4QWGieEGBonhBoaJ4QcGieEHgonhBAKN4QSCjeEFAo3hBX6N4QX+jeEGfo3hBv6N4Qd6jeEH+o3hBHqR4QT6keEFdpHhBfaR4QZ2keEG9pHhB3KR4QfykeEEcpXhBPKV4QVuleEF7pXhBm6V4QbqleEHapXhB+qV4QRqmeEE5pnhBWaZ4QXmmeEGZpnhBuKZ4QdimeEH4pnhBGKd4QTeneEFXp3hBd6d4QZeneEG2p3hB1qd4QfaneEEVqHhBNah4QVWoeEF1qHhBlKh4QbSoeEHUqHhB9Kh4QROpeEEzqXhBU6l4QXKpeEGSqXhBsql4QdKpeEHxqXhBEap4QTGqeEFQqnhBcKp4QZCqeEGwqnhBz6p4Qe+qeEEPq3hBLqt4QU6reEFuq3hBjqt4Qa2reEHNq3hB7at4QQyseEEsrHhBTKx4QWyseEGLrHhBq6x4QcuseEHqrHhBCq14QSqteEFJrXhBaa14QYmteEGprXhByK14QeiteEEIrnhBJ654QUeueEFnrnhBhq54QaaueEHGrnhB5q54QQWveEElr3hBRa94QWSveEGEr3hBpK94QcOveEHjr3hBA7B4QSKweEFCsHhBYrB4QYKweEGhsHhBwbB4QeGweEEAsXhBILF4QUCxeEFfsXhBf7F4QZ+xeEG+sXhB3rF4Qf6xeEEdsnhBPbJ4QV2yeEF8snhBnLJ4QbyyeEHbsnhB+7J4QRuzeEE6s3hBWrN4QXqzeEGZs3hBubN4QdmzeEH4s3hBGLR4QTi0eEFXtHhBd7R4QZe0eEG2tHhB1rR4Qfa0eEEVtXhBNbV4QVW1eEF0tXhBlLV4QbS1eEHTtXhB87V4QRO2eEEytnhBUrZ4QXK2eEGRtnhBsbZ4QdG2eEHwtnhBELd4QS+3eEFPt3hBb7d4QY63eEGut3hBzrd4Qe23eEENuHhBLbh4QUy4eEFsuHhBjLh4Qau4eEHLuHhB6rh4QQq5eEEquXhBSbl4QWm5eEGJuXhBqLl4Qci5eEHouXhBB7p4QSe6eEFGunhBZrp4QYa6eEGlunhBxbp4QeW6eEEEu3hBJLt4QUO7eEFju3hBg7t4QaK7eEHCu3hB4rt4QQG8eEEhvHhBQLx4QWC8eEGAvHhBn7x4Qb+8eEHfvHhB/rx4QR69eEE9vXhBXb14QX29eEGcvXhBvL14Qdu9eEH7vXhBG754QTq+eEFavnhBer54QZm+eEG5vnhB2L54Qfi+eEEYv3hBN794QVe/eEF2v3hBlr94Qba/eEHVv3hB9b94QRTAeEE0wHhBVMB4QXPAeEGTwHhBssB4QdLAeEHywHhBEcF4QTHBeEFQwXhBcMF4QZDBeEGvwXhBz8F4Qe7BeEEOwnhBLsJ4QU3CeEFtwnhBjMJ4QazCeEHLwnhB68J4QQvDeEEqw3hBSsN4QWnDeEGJw3hBqcN4QcjDeEHow3hBB8R4QSfEeEFGxHhBZsR4QYbEeEGlxHhBxcR4QeTEeEEExXhBI8V4QUPFeEFjxXhBgsV4QaLFeEHBxXhB4cV4QQDGeEEgxnhBQMZ4QV/GeEF/xnhBnsZ4Qb7GeEHdxnhB/cZ4QR3HeEE8x3hBXMd4QXvHeEGbx3hBusd4QdrHeEH5x3hBGch4QTnIeEFYyHhBeMh4QZfIeEG3yHhB1sh4QfbIeEEVyXhBNcl4QVXJeEF0yXhBlMl4QbPJeEHTyXhB8sl4QRLKeEExynhBUcp4QXHKeEGQynhBsMp4Qc/KeEHvynhBDst4QS7LeEFNy3hBbct4QYzLeEGsy3hBy8t4QevLeEELzHhBKsx4QUrMeEFpzHhBicx4QajMeEHIzHhB58x4QQfNeEEmzXhBRs14QWXNeEGFzXhBpM14QcTNeEHkzXhBA854QSPOeEFCznhBYs54QYHOeEGhznhBwM54QeDOeEH/znhBH894QT7PeEFez3hBfc94QZ3PeEG8z3hB3M94QfvPeEEb0HhBOtB4QVrQeEF50HhBmdB4QbjQeEHY0HhB99B4QRfReEE20XhBVtF4QXbReEGV0XhBtdF4QdTReEH00XhBE9J4QTPSeEFS0nhBctJ4QZHSeEGx0nhB0NJ4QfDSeEEP03hBL9N4QU7TeEFu03hBjdN4Qa3TeEHM03hB7NN4QQvUeEEr1HhBStR4QWrUeEGJ1HhBqNR4QcjUeEHn1HhBB9V4QSbVeEFG1XhBZdV4QYXVeEGk1XhBxNV4QePVeEED1nhBItZ4QULWeEFh1nhBgdZ4QaDWeEHA1nhB39Z4Qf/WeEEe13hBPtd4QV3XeEF913hBnNd4QbzXeEHb13hB+td4QRrYeEE52HhBWdh4QXjYeEGY2HhBt9h4QdfYeEH22HhBFtl4QTXZeEFV2XhBdNl4QZTZeEGz2XhB09l4QfLZeEER2nhBMdp4QVDaeEFw2nhBj9p4Qa/aeEHO2nhB7tp4QQ3beEEt23hBTNt4QWvbeEGL23hBqtt4QcrbeEHp23hBCdx4QSjceEFI3HhBZ9x4QYfceEGm3HhBxdx4QeXceEEE3XhBJN14QUPdeEFj3XhBgt14QaLdeEHB3XhB4N14QQDeeEEf3nhBP954QV7eeEF+3nhBnd54Qb3eeEHc3nhB+954QRvfeEE633hBWt94QXnfeEGZ33hBuN94QdffeEH333hBFuB4QTbgeEFV4HhBdeB4QZTgeEGz4HhB0+B4QfLgeEES4XhBMeF4QVHheEFw4XhBj+F4Qa/heEHO4XhB7uF4QQ3ieEEs4nhBTOJ4QWvieEGL4nhBquJ4QcrieEHp4nhBCON4QSjjeEFH43hBZ+N4QYbjeEGl43hBxeN4QeTjeEEE5HhBI+R4QUPkeEFi5HhBgeR4QaHkeEHA5HhB4OR4Qf/keEEe5XhBPuV4QV3leEF95XhBnOV4QbvleEHb5XhB+uV4QRrmeEE55nhBWOZ4QXjmeEGX5nhBt+Z4QdbmeEH15nhBFed4QTTneEFU53hBc+d4QZLneEGy53hB0ed4QfDneEEQ6HhBL+h4QU/oeEFu6HhBjeh4Qa3oeEHM6HhB7Oh4QQvpeEEq6XhBSul4QWnpeEGI6XhBqOl4QcfpeEHn6XhBBup4QSXqeEFF6nhBZOp4QYPqeEGj6nhBwup4QeLqeEEB63hBIOt4QUDreEFf63hBfut4QZ7reEG963hB3et4QfzreEEb7HhBO+x4QVrseEF57HhBmex4QbjseEHX7HhB9+x4QRbteEE27XhBVe14QXTteEGU7XhBs+14QdLteEHy7XhBEe54QTDueEFQ7nhBb+54QY7ueEGu7nhBze54Qe3ueEEM73hBK+94QUvveEFq73hBie94QanveEHI73hB5+94QQfweEEm8HhBRfB4QWXweEGE8HhBo/B4QcPweEHi8HhBAfF4QSHxeEFA8XhBX/F4QX/xeEGe8XhBvfF4Qd3xeEH88XhBG/J4QTvyeEFa8nhBefJ4QZnyeEG48nhB1/J4QffyeEEW83hBNfN4QVXzeEF083hBk/N4QbPzeEHS83hB8fN4QRH0eEEw9HhBT/R4QW/0eEGO9HhBrfR4Qc30eEHs9HhBC/V4QSv1eEFK9XhBafV4QYn1eEGo9XhBx/V4Qeb1eEEG9nhBJfZ4QUT2eEFk9nhBg/Z4QaL2eEHC9nhB4fZ4QQD3eEEg93hBP/d4QV73eEF993hBnfd4Qbz3eEHb93hB+/d4QRr4eEE5+HhBWfh4QXj4eEGX+HhBt/h4Qdb4eEH1+HhBFPl4QTT5eEFT+XhBcvl4QZL5eEGx+XhB0Pl4Qe/5eEEP+nhBLvp4QU36eEFt+nhBjPp4Qav6eEHK+nhB6vp4QQn7eEEo+3hBSPt4QWf7eEGG+3hBpft4QcX7eEHk+3hBA/x4QSP8eEFC/HhBYfx4QYD8eEGg/HhBv/x4Qd78eEH+/HhBHf14QTz9eEFb/XhBe/14QZr9eEG5/XhB2P14Qfj9eEEX/nhBNv54QVb+eEF1/nhBlP54QbP+eEHT/nhB8v54QRH/eEEw/3hBUP94QW//eEGO/3hBrf94Qc3/eEHs/3hBCwB5QSsAeUFKAHlBaQB5QYgAeUGoAHlBxwB5QeYAeUEFAXlBJQF5QUQBeUFjAXlBggF5QaIBeUHBAXlB4AF5Qf8BeUEfAnlBPgJ5QV0CeUF8AnlBnAJ5QbsCeUHaAnlB+QJ5QRkDeUE4A3lBVwN5QXYDeUGWA3lBtQN5QdQDeUHzA3lBEwR5QTIEeUFRBHlBcAR5QY8EeUGvBHlBzgR5Qe0EeUEMBXlBLAV5QUsFeUFqBXlBiQV5QakFeUHIBXlB5wV5QQYGeUElBnlBRQZ5QWQGeUGDBnlBogZ5QcIGeUHhBnlBAAd5QR8HeUE/B3lBXgd5QX0HeUGcB3lBuwd5QdsHeUH6B3lBGQh5QTgIeUFXCHlBdwh5QZYIeUG1CHlB1Ah5QfQIeUETCXlBMgl5QVEJeUFwCXlBkAl5Qa8JeUHOCXlB7Ql5QQwKeUEsCnlBSwp5QWoKeUGJCnlBqAp5QcgKeUHnCnlBBgt5QSULeUFEC3lBZAt5QYMLeUGiC3lBwQt5QeALeUEADHlBHwx5QT4MeUFdDHlBfAx5QZwMeUG7DHlB2gx5QfkMeUEYDXlBOA15QVcNeUF2DXlBlQ15QbQNeUHUDXlB8w15QRIOeUExDnlBUA55QW8OeUGPDnlBrg55Qc0OeUHsDnlBCw95QSsPeUFKD3lBaQ95QYgPeUGnD3lBxg95QeYPeUEFEHlBJBB5QUMQeUFiEHlBghB5QaEQeUHAEHlB3xB5Qf4QeUEdEXlBPRF5QVwReUF7EXlBmhF5QbkReUHYEXlB+BF5QRcSeUE2EnlBVRJ5QXQSeUGTEnlBsxJ5QdISeUHxEnlBEBN5QS8TeUFOE3lBbhN5QY0TeUGsE3lByxN5QeoTeUEJFHlBKBR5QUgUeUFnFHlBhhR5QaUUeUHEFHlB4xR5QQMVeUEiFXlBQRV5QWAVeUF/FXlBnhV5Qb0VeUHdFXlB/BV5QRsWeUE6FnlBWRZ5QXgWeUGXFnlBtxZ5QdYWeUH1FnlBFBd5QTMXeUFSF3lBcRd5QZEXeUGwF3lBzxd5Qe4XeUENGHlBLBh5QUsYeUFqGHlBihh5QakYeUHIGHlB5xh5QQYZeUElGXlBRBl5QWMZeUGDGXlBohl5QcEZeUHgGXlB/xl5QR4aeUE9GnlBXBp5QXwaeUGbGnlBuhp5QdkaeUH4GnlBFxt5QTYbeUFVG3lBdRt5QZQbeUGzG3lB0ht5QfEbeUEQHHlBLxx5QU4ceUFtHHlBjRx5QawceUHLHHlB6hx5QQkdeUEoHXlBRx15QWYdeUGFHXlBpR15QcQdeUHjHXlBAh55QSEeeUFAHnlBXx55QX4eeUGdHnlBvB55QdweeUH7HnlBGh95QTkfeUFYH3lBdx95QZYfeUG1H3lB1B95QfMfeUESIHlBMiB5QVEgeUFwIHlBjyB5Qa4geUHNIHlB7CB5QQsheUEqIXlBSSF5QWgheUGIIXlBpyF5QcYheUHlIXlBBCJ5QSMieUFCInlBYSJ5QYAieUGfInlBviJ5Qd0ieUH8InlBHCN5QTsjeUFaI3lBeSN5QZgjeUG3I3lB1iN5QfUjeUEUJHlBMyR5QVIkeUFxJHlBkCR5Qa8keUHPJHlB7iR5QQ0leUEsJXlBSyV5QWoleUGJJXlBqCV5QccleUHmJXlBBSZ5QSQmeUFDJnlBYiZ5QYEmeUGgJnlBwCZ5Qd8meUH+JnlBHSd5QTwneUFbJ3lBeid5QZkneUG4J3lB1yd5QfYneUEVKHlBNCh5QVMoeUFyKHlBkSh5QbAoeUHPKHlB7ih5QQ0peUEtKXlBTCl5QWspeUGKKXlBqSl5QcgpeUHnKXlBBip5QSUqeUFEKnlBYyp5QYIqeUGhKnlBwCp5Qd8qeUH+KnlBHSt5QTwreUFbK3lBeit5QZkreUG4K3lB1yt5QfYreUEVLHlBNCx5QVMseUFyLHlBkSx5QbAseUHQLHlB7yx5QQ4teUEtLXlBTC15QWsteUGKLXlBqS15QcgteUHnLXlBBi55QSUueUFELnlBYy55QYIueUGhLnlBwC55Qd8ueUH+LnlBHS95QTwveUFbL3lBei95QZkveUG4L3lB1y95QfYveUEVMHlBNDB5QVMweUFyMHlBkTB5QbAweUHPMHlB7jB5QQ0xeUEsMXlBSzF5QWoxeUGJMXlBqDF5QccxeUHmMXlBBTJ5QSQyeUFDMnlBYjJ5QYEyeUGgMnlBvzJ5Qd4yeUH9MnlBHDN5QTszeUFaM3lBeTN5QZgzeUG3M3lB1jN5QfUzeUEUNHlBMzR5QVI0eUFxNHlBkDR5Qa80eUHONHlB7TR5QQw1eUErNXlBSjV5QWk1eUGINXlBpzV5QcY1eUHlNXlBBDZ5QSM2eUFBNnlBYDZ5QX82eUGeNnlBvTZ5Qdw2eUH7NnlBGjd5QTk3eUFYN3lBdzd5QZY3eUG1N3lB1Dd5QfM3eUESOHlBMTh5QVA4eUFvOHlBjjh5Qa04eUHMOHlB6zh5QQo5eUEpOXlBSDl5QWc5eUGGOXlBpTl5QcM5eUHiOXlBATp5QSA6eUE/OnlBXjp5QX06eUGcOnlBuzp5Qdo6eUH5OnlBGDt5QTc7eUFWO3lBdTt5QZQ7eUGzO3lB0jt5QfE7eUEQPHlBLjx5QU08eUFsPHlBizx5Qao8eUHJPHlB6Dx5QQc9eUEmPXlBRT15QWQ9eUGDPXlBoj15QcE9eUHgPXlB/z15QR0+eUE8PnlBWz55QXo+eUGZPnlBuD55Qdc+eUH2PnlBFT95QTQ/eUFTP3lBcj95QZE/eUGwP3lBzz95Qe0/eUEMQHlBK0B5QUpAeUFpQHlBiEB5QadAeUHGQHlB5UB5QQRBeUEjQXlBQkF5QWBBeUF/QXlBnkF5Qb1BeUHcQXlB+0F5QRpCeUE5QnlBWEJ5QXdCeUGWQnlBtUJ5QdNCeUHyQnlBEUN5QTBDeUFPQ3lBbkN5QY1DeUGsQ3lBy0N5QepDeUEIRHlBJ0R5QUZEeUFlRHlBhER5QaNEeUHCRHlB4UR5QQBFeUEfRXlBPUV5QVxFeUF7RXlBmkV5QblFeUHYRXlB90V5QRZGeUE1RnlBVEZ5QXJGeUGRRnlBsEZ5Qc9GeUHuRnlBDUd5QSxHeUFLR3lBakd5QYhHeUGnR3lBxkd5QeVHeUEESHlBI0h5QUJIeUFhSHlBf0h5QZ5IeUG9SHlB3Eh5QftIeUEaSXlBOUl5QVhJeUF2SXlBlUl5QbRJeUHTSXlB8kl5QRFKeUEwSnlBT0p5QW1KeUGMSnlBq0p5QcpKeUHpSnlBCEt5QSdLeUFGS3lBZEt5QYNLeUGiS3lBwUt5QeBLeUH/S3lBHkx5QTxMeUFbTHlBekx5QZlMeUG4THlB10x5QfZMeUEUTXlBM015QVJNeUFxTXlBkE15Qa9NeUHOTXlB7E15QQtOeUEqTnlBSU55QWhOeUGHTnlBpU55QcROeUHjTnlBAk95QSFPeUFAT3lBX095QX1PeUGcT3lBu095QdpPeUH5T3lBGFB5QTZQeUFVUHlBdFB5QZNQeUGyUHlB0VB5Qe9QeUEOUXlBLVF5QUxReUFrUXlBilF5QahReUHHUXlB5lF5QQVSeUEkUnlBQ1J5QWFSeUGAUnlBn1J5Qb5SeUHdUnlB/FJ5QRpTeUE5U3lBWFN5QXdTeUGWU3lBtVN5QdNTeUHyU3lBEVR5QTBUeUFPVHlBbVR5QYxUeUGrVHlBylR5QelUeUEHVXlBJlV5QUVVeUFkVXlBg1V5QaJVeUHAVXlB31V5Qf5VeUEdVnlBPFZ5QVpWeUF5VnlBmFZ5QbdWeUHWVnlB9FZ5QRNXeUEyV3lBUVd5QXBXeUGOV3lBrVd5QcxXeUHrV3lBClh5QShYeUFHWHlBZlh5QYVYeUGkWHlBwlh5QeFYeUEAWXlBH1l5QT5ZeUFcWXlBe1l5QZpZeUG5WXlB2Fl5QfZZeUEVWnlBNFp5QVNaeUFxWnlBkFp5Qa9aeUHOWnlB7Vp5QQtbeUEqW3lBSVt5QWhbeUGHW3lBpVt5QcRbeUHjW3lBAlx5QSBceUE/XHlBXlx5QX1ceUGcXHlBulx5QdlceUH4XHlBF115QTVdeUFUXXlBc115QZJdeUGwXXlBz115Qe5deUENXnlBLF55QUpeeUFpXnlBiF55QadeeUHFXnlB5F55QQNfeUEiX3lBQF95QV9feUF+X3lBnV95QbtfeUHaX3lB+V95QRhgeUE2YHlBVWB5QXRgeUGTYHlBsWB5QdBgeUHvYHlBDmF5QSxheUFLYXlBamF5QYlheUGnYXlBxmF5QeVheUEEYnlBImJ5QUFieUFgYnlBf2J5QZ1ieUG8YnlB22J5QfpieUEYY3lBN2N5QVZjeUF1Y3lBk2N5QbJjeUHRY3lB8GN5QQ5keUEtZHlBTGR5QWtkeUGJZHlBqGR5QcdkeUHlZHlBBGV5QSNleUFCZXlBYGV5QX9leUGeZXlBvWV5QdtleUH6ZXlBGWZ5QTdmeUFWZnlBdWZ5QZRmeUGyZnlB0WZ5QfBmeUEPZ3lBLWd5QUxneUFrZ3lBiWd5QahneUHHZ3lB5md5QQRoeUEjaHlBQmh5QWBoeUF/aHlBnmh5Qb1oeUHbaHlB+mh5QRlpeUE3aXlBVml5QXVpeUGUaXlBsml5QdFpeUHwaXlBDmp5QS1qeUFManlBamp5QYlqeUGoanlBx2p5QeVqeUEEa3lBI2t5QUFreUFga3lBf2t5QZ1reUG8a3lB22t5QfpreUEYbHlBN2x5QVZseUF0bHlBk2x5QbJseUHQbHlB72x5QQ5teUEsbXlBS215QWpteUGIbXlBp215QcZteUHlbXlBA255QSJueUFBbnlBX255QX5ueUGdbnlBu255QdpueUH5bnlBF295QTZveUFVb3lBc295QZJveUGxb3lBz295Qe5veUENcHlBK3B5QUpweUFpcHlBh3B5QaZweUHFcHlB43B5QQJxeUEhcXlBP3F5QV5xeUF9cXlBm3F5QbpxeUHZcXlB93F5QRZyeUE1cnlBU3J5QXJyeUGRcnlBr3J5Qc5yeUHtcnlBC3N5QSpzeUFJc3lBZ3N5QYZzeUGlc3lBw3N5QeJzeUEBdHlBH3R5QT50eUFddHlBe3R5QZp0eUG5dHlB13R5QfZ0eUEUdXlBM3V5QVJ1eUFwdXlBj3V5Qa51eUHMdXlB63V5QQp2eUEodnlBR3Z5QWZ2eUGEdnlBo3Z5QcF2eUHgdnlB/3Z5QR13eUE8d3lBW3d5QXl3eUGYd3lBt3d5QdV3eUH0d3lBEnh5QTF4eUFQeHlBbnh5QY14eUGseHlBynh5Qel4eUEIeXlBJnl5QUV5eUFjeXlBgnl5QaF5eUG/eXlB3nl5Qf15eUEbenlBOnp5QVh6eUF3enlBlnp5QbR6eUHTenlB8Xp5QRB7eUEve3lBTXt5QWx7eUGLe3lBqXt5Qch7eUHme3lBBXx5QSR8eUFCfHlBYXx5QX98eUGefHlBvXx5Qdt8eUH6fHlBGH15QTd9eUFWfXlBdH15QZN9eUGxfXlB0H15Qe99eUENfnlBLH55QUp+eUFpfnlBiH55QaZ+eUHFfnlB4355QQJ/eUEhf3lBP395QV5/eUF8f3lBm395Qbp/eUHYf3lB9395QRWAeUE0gHlBU4B5QXGAeUGQgHlBroB5Qc2AeUHsgHlBCoF5QSmBeUFHgXlBZoF5QYSBeUGjgXlBwoF5QeCBeUH/gXlBHYJ5QTyCeUFbgnlBeYJ5QZiCeUG2gnlB1YJ5QfOCeUESg3lBMYN5QU+DeUFug3lBjIN5QauDeUHJg3lB6IN5QQeEeUElhHlBRIR5QWKEeUGBhHlBn4R5Qb6EeUHdhHlB+4R5QRqFeUE4hXlBV4V5QXWFeUGUhXlBsoV5QdGFeUHwhXlBDoZ5QS2GeUFLhnlBaoZ5QYiGeUGnhnlBxYZ5QeSGeUEDh3lBIYd5QUCHeUFeh3lBfYd5QZuHeUG6h3lB2Id5QfeHeUEWiHlBNIh5QVOIeUFxiHlBkIh5Qa6IeUHNiHlB64h5QQqJeUEoiXlBR4l5QWaJeUGEiXlBo4l5QcGJeUHgiXlB/ol5QR2KeUE7inlBWop5QXiKeUGXinlBtYp5QdSKeUHzinlBEYt5QTCLeUFOi3lBbYt5QYuLeUGqi3lByIt5QeeLeUEFjHlBJIx5QUKMeUFhjHlBf4x5QZ6MeUG9jHlB24x5QfqMeUEYjXlBN415QVWNeUF0jXlBko15QbGNeUHPjXlB7o15QQyOeUErjnlBSY55QWiOeUGGjnlBpY55QcOOeUHijnlBAI95QR+PeUE9j3lBXI95QXqPeUGZj3lBt495QdaPeUH0j3lBE5B5QTGQeUFQkHlBbpB5QY2QeUGrkHlBypB5QeiQeUEHkXlBJZF5QUSReUFikXlBgZF5QZ+ReUG+kXlB3JF5QfuReUEZknlBOJJ5QVaSeUF1knlBk5J5QbKSeUHQknlB75J5QQ2TeUEsk3lBSpN5QWmTeUGHk3lBppN5QcSTeUHjk3lBAZR5QSCUeUE+lHlBXZR5QXuUeUGalHlBuJR5QdeUeUH1lHlBFJV5QTKVeUFRlXlBb5V5QY6VeUGslXlBy5V5QemVeUEIlnlBJpZ5QUWWeUFjlnlBgZZ5QaCWeUG+lnlB3ZZ5QfuWeUEal3lBOJd5QVeXeUF1l3lBlJd5QbKXeUHRl3lB75d5QQ6YeUEsmHlBS5h5QWmYeUGHmHlBpph5QcSYeUHjmHlBAZl5QSCZeUE+mXlBXZl5QXuZeUGamXlBuJl5QdeZeUH1mXlBE5p5QTKaeUFQmnlBb5p5QY2aeUGsmnlBypp5QemaeUEHm3lBJZt5QUSbeUFim3lBgZt5QZ+beUG+m3lB3Jt5QfubeUEZnHlBOJx5QVaceUF0nHlBk5x5QbGceUHQnHlB7px5QQ2deUErnXlBSp15QWideUGGnXlBpZ15QcOdeUHinXlBAJ55QR+eeUE9nnlBW555QXqeeUGYnnlBt555QdWeeUH0nnlBEp95QTCfeUFPn3lBbZ95QYyfeUGqn3lByZ95QeefeUEFoHlBJKB5QUKgeUFhoHlBf6B5QZ6geUG8oHlB2qB5QfmgeUEXoXlBNqF5QVSheUFzoXlBkaF5Qa+heUHOoXlB7KF5QQuieUEponlBR6J5QWaieUGEonlBo6J5QcGieUHfonlB/qJ5QRyjeUE7o3lBWaN5QXijeUGWo3lBtKN5QdOjeUHxo3lBEKR5QS6keUFMpHlBa6R5QYmkeUGopHlBxqR5QeSkeUEDpXlBIaV5QUCleUFepXlBfKV5QZuleUG5pXlB2KV5QfaleUEUpnlBM6Z5QVGmeUFwpnlBjqZ5QaymeUHLpnlB6aZ5QQeneUEmp3lBRKd5QWOneUGBp3lBn6d5Qb6neUHcp3lB+6d5QRmoeUE3qHlBVqh5QXSoeUGSqHlBsah5Qc+oeUHuqHlBDKl5QSqpeUFJqXlBZ6l5QYapeUGkqXlBwql5QeGpeUH/qXlBHap5QTyqeUFaqnlBeap5QZeqeUG1qnlB1Kp5QfKqeUEQq3lBL6t5QU2reUFrq3lBiqt5QaireUHHq3lB5at5QQOseUEirHlBQKx5QV6seUF9rHlBm6x5QbmseUHYrHlB9qx5QRWteUEzrXlBUa15QXCteUGOrXlBrK15QcuteUHprXlBB655QSaueUFErnlBYq55QYGueUGfrnlBva55QdyueUH6rnlBGa95QTeveUFVr3lBdK95QZKveUGwr3lBz695Qe2veUELsHlBKrB5QUiweUFmsHlBhbB5QaOweUHBsHlB4LB5Qf6weUEcsXlBO7F5QVmxeUF3sXlBlrF5QbSxeUHSsXlB8bF5QQ+yeUEtsnlBTLJ5QWqyeUGIsnlBp7J5QcWyeUHjsnlBArN5QSCzeUE+s3lBXbN5QXuzeUGZs3lBuLN5QdazeUH0s3lBE7R5QTG0eUFPtHlBbrR5QYy0eUGqtHlBybR5Qee0eUEFtXlBI7V5QUK1eUFgtXlBfrV5QZ21eUG7tXlB2bV5Qfi1eUEWtnlBNLZ5QVO2eUFxtnlBj7Z5Qa62eUHMtnlB6rZ5QQi3eUEnt3lBRbd5QWO3eUGCt3lBoLd5Qb63eUHdt3lB+7d5QRm4eUE4uHlBVrh5QXS4eUGSuHlBsbh5Qc+4eUHtuHlBDLl5QSq5eUFIuXlBZrl5QYW5eUGjuXlBwbl5QeC5eUH+uXlBHLp5QTu6eUFZunlBd7p5QZW6eUG0unlB0rp5QfC6eUEPu3lBLbt5QUu7eUFpu3lBiLt5Qaa7eUHEu3lB47t5QQG8eUEfvHlBPbx5QVy8eUF6vHlBmLx5Qbe8eUHVvHlB87x5QRG9eUEwvXlBTr15QWy9eUGKvXlBqb15Qce9eUHlvXlBBL55QSK+eUFAvnlBXr55QX2+eUGbvnlBub55Qde+eUH2vnlBFL95QTK/eUFQv3lBb795QY2/eUGrv3lByr95Qei/eUEGwHlBJMB5QUPAeUFhwHlBf8B5QZ3AeUG8wHlB2sB5QfjAeUEWwXlBNcF5QVPBeUFxwXlBj8F5Qa7BeUHMwXlB6sF5QQjCeUEnwnlBRcJ5QWPCeUGBwnlBoMJ5Qb7CeUHcwnlB+sJ5QRnDeUE3w3lBVcN5QXPDeUGSw3lBsMN5Qc7DeUHsw3lBC8R5QSnEeUFHxHlBZcR5QYTEeUGixHlBwMR5Qd7EeUH8xHlBG8V5QTnFeUFXxXlBdcV5QZTFeUGyxXlB0MV5Qe7FeUENxnlBK8Z5QUnGeUFnxnlBhcZ5QaTGeUHCxnlB4MZ5Qf7GeUEdx3lBO8d5QVnHeUF3x3lBlsd5QbTHeUHSx3lB8Md5QQ7IeUEtyHlBS8h5QWnIeUGHyHlBpch5QcTIeUHiyHlBAMl5QR7JeUE9yXlBW8l5QXnJeUGXyXlBtcl5QdTJeUHyyXlBEMp5QS7KeUFMynlBa8p5QYnKeUGnynlBxcp5QePKeUECy3lBIMt5QT7LeUFcy3lBe8t5QZnLeUG3y3lB1ct5QfPLeUESzHlBMMx5QU7MeUFszHlBisx5QanMeUHHzHlB5cx5QQPNeUEhzXlBP815QV7NeUF8zXlBms15QbjNeUHWzXlB9c15QRPOeUExznlBT855QW3OeUGMznlBqs55QcjOeUHmznlBBM95QSLPeUFBz3lBX895QX3PeUGbz3lBuc95QdjPeUH2z3lBFNB5QTLQeUFQ0HlBbtB5QY3QeUGr0HlBydB5QefQeUEF0XlBJNF5QULReUFg0XlBftF5QZzReUG60XlB2dF5QffReUEV0nlBM9J5QVHSeUFv0nlBjtJ5QazSeUHK0nlB6NJ5QQbTeUEk03lBQ9N5QWHTeUF/03lBndN5QbvTeUHZ03lB+NN5QRbUeUE01HlBUtR5QXDUeUGO1HlBrNR5QcvUeUHp1HlBB9V5QSXVeUFD1XlBYdV5QYDVeUGe1XlBvNV5QdrVeUH41XlBFtZ5QTTWeUFT1nlBcdZ5QY/WeUGt1nlBy9Z5QenWeUEH13lBJtd5QUTXeUFi13lBgNd5QZ7XeUG813lB2td5QfnXeUEX2HlBNdh5QVPYeUFx2HlBj9h5Qa3YeUHM2HlB6th5QQjZeUEm2XlBRNl5QWLZeUGA2XlBntl5Qb3ZeUHb2XlB+dl5QRfaeUE12nlBU9p5QXHaeUGP2nlBrtp5QczaeUHq2nlBCNt5QSbbeUFE23lBYtt5QYDbeUGf23lBvdt5QdvbeUH523lBF9x5QTXceUFT3HlBcdx5QZDceUGu3HlBzNx5QerceUEI3XlBJt15QUTdeUFi3XlBgN15QZ/deUG93XlB2915QfndeUEX3nlBNd55QVPeeUFx3nlBj955Qa7eeUHM3nlB6t55QQjfeUEm33lBRN95QWLfeUGA33lBnt95QbzfeUHb33lB+d95QRfgeUE14HlBU+B5QXHgeUGP4HlBreB5QcvgeUHp4HlBB+F5QSbheUFE4XlBYuF5QYDheUGe4XlBvOF5QdrheUH44XlBFuJ5QTTieUFS4nlBceJ5QY/ieUGt4nlBy+J5QenieUEH43lBJeN5QUPjeUFh43lBf+N5QZ3jeUG743lB2uN5QfjjeUEW5HlBNOR5QVLkeUFw5HlBjuR5QazkeUHK5HlB6OR5QQbleUEk5XlBQuV5QWDleUF/5XlBneV5QbvleUHZ5XlB9+V5QRXmeUEz5nlBUeZ5QW/meUGN5nlBq+Z5QcnmeUHn5nlBBed5QSPneUFC53lBYOd5QX7neUGc53lBuud5QdjneUH253lBFOh5QTLoeUFQ6HlBbuh5QYzoeUGq6HlByOh5QeboeUEE6XlBIul5QUDpeUFf6XlBfel5QZvpeUG56XlB1+l5QfXpeUET6nlBMep5QU/qeUFt6nlBi+p5QanqeUHH6nlB5ep5QQPreUEh63lBP+t5QV3reUF763lBmet5QbfreUHV63lB8+t5QRLseUEw7HlBTux5QWzseUGK7HlBqOx5QcbseUHk7HlBAu15QSDteUE+7XlBXO15QXrteUGY7XlBtu15QdTteUHy7XlBEO55QS7ueUFM7nlBau55QYjueUGm7nlBxO55QeLueUEA73lBHu95QTzveUFa73lBeO95QZbveUG073lB0u95QfDveUEO8HlBLPB5QUrweUFo8HlBhvB5QaTweUHC8HlB4fB5Qf/weUEd8XlBO/F5QVnxeUF38XlBlfF5QbPxeUHR8XlB7/F5QQ3yeUEr8nlBSfJ5QWfyeUGF8nlBo/J5QcHyeUHf8nlB/fJ5QRvzeUE583lBV/N5QXXzeUGT83lBsfN5Qc/zeUHt83lBC/R5QSn0eUFH9HlBZfR5QYP0eUGh9HlBv/R5Qd30eUH79HlBGfV5QTf1eUFV9XlBc/V5QZD1eUGu9XlBzPV5Qer1eUEI9nlBJvZ5QUT2eUFi9nlBgPZ5QZ72eUG89nlB2vZ5Qfj2eUEW93lBNPd5QVL3eUFw93lBjvd5Qaz3eUHK93lB6Pd5QQb4eUEk+HlBQvh5QWD4eUF++HlBnPh5Qbr4eUHY+HlB9vh5QRT5eUEy+XlBUPl5QW75eUGM+XlBqvl5Qcj5eUHm+XlBBPp5QSL6eUFA+nlBXvp5QXv6eUGZ+nlBt/p5QdX6eUHz+nlBEft5QS/7eUFN+3lBa/t5QYn7eUGn+3lBxft5QeP7eUEB/HlBH/x5QT38eUFb/HlBefx5QZf8eUG1/HlB0/x5QfH8eUEP/XlBLP15QUr9eUFo/XlBhv15QaT9eUHC/XlB4P15Qf79eUEc/nlBOv55QVj+eUF2/nlBlP55QbL+eUHQ/nlB7v55QQz/eUEq/3lBR/95QWX/eUGD/3lBof95Qb//eUHd/3lB+/95QRkAekE3AHpBVQB6QXMAekGRAHpBrwB6Qc0AekHrAHpBCAF6QSYBekFEAXpBYgF6QYABekGeAXpBvAF6QdoBekH4AXpBFgJ6QTQCekFSAnpBcAJ6QY4CekGrAnpByQJ6QecCekEFA3pBIwN6QUEDekFfA3pBfQN6QZsDekG5A3pB1wN6QfUDekESBHpBMAR6QU4EekFsBHpBigR6QagEekHGBHpB5AR6QQIFekEgBXpBPgV6QVsFekF5BXpBlwV6QbUFekHTBXpB8QV6QQ8GekEtBnpBSwZ6QWkGekGHBnpBpAZ6QcIGekHgBnpB/gZ6QRwHekE6B3pBWAd6QXYHekGUB3pBsgd6Qc8HekHtB3pBCwh6QSkIekFHCHpBZQh6QYMIekGhCHpBvwh6QdwIekH6CHpBGAl6QTYJekFUCXpBcgl6QZAJekGuCXpBzAl6QekJekEHCnpBJQp6QUMKekFhCnpBfwp6QZ0KekG7CnpB2Ap6QfYKekEUC3pBMgt6QVALekFuC3pBjAt6QaoLekHIC3pB5Qt6QQMMekEhDHpBPwx6QV0MekF7DHpBmQx6QbcMekHUDHpB8gx6QRANekEuDXpBTA16QWoNekGIDXpBpQ16QcMNekHhDXpB/w16QR0OekE7DnpBWQ56QXYOekGUDnpBsg56QdAOekHuDnpBDA96QSoPekFID3pBZQ96QYMPekGhD3pBvw96Qd0PekH7D3pBGRB6QTYQekFUEHpBchB6QZAQekGuEHpBzBB6QekQekEHEXpBJRF6QUMRekFhEXpBfxF6QZ0RekG6EXpB2BF6QfYRekEUEnpBMhJ6QVASekFtEnpBixJ6QakSekHHEnpB5RJ6QQMTekEhE3pBPhN6QVwTekF6E3pBmBN6QbYTekHUE3pB8RN6QQ8UekEtFHpBSxR6QWkUekGHFHpBpBR6QcIUekHgFHpB/hR6QRwVekE6FXpBVxV6QXUVekGTFXpBsRV6Qc8VekHsFXpBChZ6QSgWekFGFnpBZBZ6QYIWekGfFnpBvRZ6QdsWekH5FnpBFxd6QTQXekFSF3pBcBd6QY4XekGsF3pByhd6QecXekEFGHpBIxh6QUEYekFfGHpBfBh6QZoYekG4GHpB1hh6QfQYekERGXpBLxl6QU0ZekFrGXpBiRl6QacZekHEGXpB4hl6QQAaekEeGnpBPBp6QVkaekF3GnpBlRp6QbMaekHRGnpB7hp6QQwbekEqG3pBSBt6QWYbekGDG3pBoRt6Qb8bekHdG3pB+xt6QRgcekE2HHpBVBx6QXIcekGPHHpBrRx6QcscekHpHHpBBx16QSQdekFCHXpBYB16QX4dekGcHXpBuR16QdcdekH1HXpBEx56QTAeekFOHnpBbB56QYoeekGoHnpBxR56QeMeekEBH3pBHx96QT0fekFaH3pBeB96QZYfekG0H3pB0R96Qe8fekENIHpBKyB6QUggekFmIHpBhCB6QaIgekHAIHpB3SB6QfsgekEZIXpBNyF6QVQhekFyIXpBkCF6Qa4hekHLIXpB6SF6QQciekElInpBQyJ6QWAiekF+InpBnCJ6QboiekHXInpB9SJ6QRMjekExI3pBTiN6QWwjekGKI3pBqCN6QcUjekHjI3pBASR6QR8kekE8JHpBWiR6QXgkekGWJHpBsyR6QdEkekHvJHpBDSV6QSolekFIJXpBZiV6QYQlekGhJXpBvyV6Qd0lekH7JXpBGCZ6QTYmekFUJnpBciZ6QY8mekGtJnpByyZ6QekmekEGJ3pBJCd6QUInekFfJ3pBfSd6QZsnekG5J3pB1id6QfQnekESKHpBMCh6QU0oekFrKHpBiSh6QacoekHEKHpB4ih6QQApekEdKXpBOyl6QVkpekF3KXpBlCl6QbIpekHQKXpB7il6QQsqekEpKnpBRyp6QWQqekGCKnpBoCp6Qb4qekHbKnpB+Sp6QRcrekE0K3pBUit6QXArekGOK3pBqyt6QckrekHnK3pBBCx6QSIsekFALHpBXix6QXssekGZLHpBtyx6QdQsekHyLHpBEC16QS4tekFLLXpBaS16QYctekGkLXpBwi16QeAtekH+LXpBGy56QTkuekFXLnpBdC56QZIuekGwLnpBzS56QesuekEJL3pBJy96QUQvekFiL3pBgC96QZ0vekG7L3pB2S96QfYvekEUMHpBMjB6QU8wekFtMHpBizB6QakwekHGMHpB5DB6QQIxekEfMXpBPTF6QVsxekF4MXpBljF6QbQxekHRMXpB7zF6QQ0yekEqMnpBSDJ6QWYyekGDMnpBoTJ6Qb8yekHdMnpB+jJ6QRgzekE2M3pBUzN6QXEzekGPM3pBrDN6QcozekHoM3pBBTR6QSM0ekFBNHpBXjR6QXw0ekGaNHpBtzR6QdU0ekHzNHpBEDV6QS41ekFMNXpBaTV6QYc1ekGlNXpBwjV6QeA1ekH+NXpBGzZ6QTk2ekFXNnpBdDZ6QZI2ekGwNnpBzTZ6Qes2ekEJN3pBJjd6QUQ3ekFiN3pBfzd6QZ03ekG7N3pB2Dd6QfY3ekETOHpBMTh6QU84ekFsOHpBijh6Qag4ekHFOHpB4zh6QQE5ekEeOXpBPDl6QVo5ekF3OXpBlTl6QbM5ekHQOXpB7jl6QQs6ekEpOnpBRzp6QWQ6ekGCOnpBoDp6Qb06ekHbOnpB+Tp6QRY7ekE0O3pBUjt6QW87ekGNO3pBqjt6Qcg7ekHmO3pBAzx6QSE8ekE/PHpBXDx6QXo8ekGXPHpBtTx6QdM8ekHwPHpBDj16QSw9ekFJPXpBZz16QYQ9ekGiPXpBwD16Qd09ekH7PXpBGT56QTY+ekFUPnpBcT56QY8+ekGtPnpByj56Qeg+ekEGP3pBIz96QUE/ekFeP3pBfD96QZo/ekG3P3pB1T96QfI/ekEQQHpBLkB6QUtAekFpQHpBh0B6QaRAekHCQHpB30B6Qf1AekEbQXpBOEF6QVZBekFzQXpBkUF6Qa9BekHMQXpB6kF6QQdCekElQnpBQ0J6QWBCekF+QnpBm0J6QblCekHXQnpB9EJ6QRJDekEvQ3pBTUN6QWtDekGIQ3pBpkN6QcNDekHhQ3pB/0N6QRxEekE6RHpBV0R6QXVEekGTRHpBsER6Qc5EekHrRHpBCUV6QSZFekFERXpBYkV6QX9FekGdRXpBukV6QdhFekH2RXpBE0Z6QTFGekFO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k3pB6JN6QQWUekEilHpBQJR6QV2UekF6lHpBl5R6QbSUekHSlHpB75R6QQyVekEplXpBRpV6QWSVekGBlXpBnpV6QbuVekHYlXpB9pV6QROWekEwlnpBTZZ6QWqWekGHlnpBpZZ6QcKWekHflnpB/JZ6QRmXekE3l3pBVJd6QXGXekGOl3pBq5d6QciXekHml3pBA5h6QSCYekE9mHpBWph6QXeYekGVmHpBsph6Qc+YekHsmHpBCZl6QSaZekFEmXpBYZl6QX6ZekGbmXpBuJl6QdWZekHzmXpBEJp6QS2aekFKmnpBZ5p6QYSaekGimnpBv5p6QdyaekH5mnpBFpt6QTObekFRm3pBbpt6QYubekGom3pBxZt6QeKbekEAnHpBHZx6QTqcekFXnHpBdJx6QZGcekGunHpBzJx6QemcekEGnXpBI516QUCdekFdnXpBe516QZidekG1nXpB0p16Qe+dekEMnnpBKZ56QUeeekFknnpBgZ56QZ6eekG7nnpB2J56QfWeekETn3pBMJ96QU2fekFqn3pBh596QaSfekHBn3pB3p96QfyfekEZoHpBNqB6QVOgekFwoHpBjaB6QaqgekHIoHpB5aB6QQKhekEfoXpBPKF6QVmhekF2oXpBk6F6QbGhekHOoXpB66F6QQiiekElonpBQqJ6QV+iekF8onpBmqJ6QbeiekHUonpB8aJ6QQ6jekEro3pBSKN6QWWjekGDo3pBoKN6Qb2jekHao3pB96N6QRSkekExpHpBTqR6QWukekGJpHpBpqR6QcOkekHgpHpB/aR6QRqlekE3pXpBVKV6QXGlekGPpXpBrKV6QcmlekHmpXpBA6Z6QSCmekE9pnpBWqZ6QXemekGVpnpBsqZ6Qc+mekHspnpBCad6QSanekFDp3pBYKd6QX2nekGap3pBuKd6QdWnekHyp3pBD6h6QSyoekFJqHpBZqh6QYOoekGgqHpBvah6QdqoekH4qHpBFal6QTKpekFPqXpBbKl6QYmpekGmqXpBw6l6QeCpekH9qXpBGqp6QTiqekFVqnpBcqp6QY+qekGsqnpByap6QeaqekEDq3pBIKt6QT2rekFaq3pBd6t6QZWrekGyq3pBz6t6QeyrekEJrHpBJqx6QUOsekFgrHpBfax6QZqsekG3rHpB1Kx6QfGsekEPrXpBLK16QUmtekFmrXpBg616QaCtekG9rXpB2q16QfetekEUrnpBMa56QU6uekFrrnpBiK56QaWuekHDrnpB4K56Qf2uekEar3pBN696QVSvekFxr3pBjq96QauvekHIr3pB5a96QQKwekEfsHpBPLB6QVmwekF2sHpBk7B6QbGwekHOsHpB67B6QQixekElsXpBQrF6QV+xekF8sXpBmbF6QbaxekHTsXpB8LF6QQ2yekEqsnpBR7J6QWSyekGBsnpBnrJ6QbuyekHYsnpB9bJ6QROzekEws3pBTbN6QWqzekGHs3pBpLN6QcGzekHes3pB+7N6QRi0ekE1tHpBUrR6QW+0ekGMtHpBqbR6Qca0ekHjtHpBALV6QR21ekE6tXpBV7V6QXS1ekGRtXpBrrV6Qcu1ekHotXpBBbZ6QSK2ekE/tnpBXLZ6QXm2ekGXtnpBtLZ6QdG2ekHutnpBC7d6QSi3ekFFt3pBYrd6QX+3ekGct3pBubd6Qda3ekHzt3pBELh6QS24ekFKuHpBZ7h6QYS4ekGhuHpBvrh6Qdu4ekH4uHpBFbl6QTK5ekFPuXpBbLl6QYm5ekGmuXpBw7l6QeC5ekH9uXpBGrp6QTe6ekFUunpBcbp6QY66ekGrunpByLp6QeW6ekECu3pBH7t6QTy7ekFZu3pBdrt6QZO7ekGwu3pBzbt6Qeq7ekEHvHpBJLx6QUG8ekFevHpBe7x6QZi8ekG1vHpB0rx6Qe+8ekEMvXpBKb16QUa9ekFjvXpBgL16QZ29ekG6vXpB1716QfS9ekERvnpBLr56QUu+ekFovnpBhb56QaK+ekG/vnpB3L56Qfm+ekEWv3pBM796QVC/ekFtv3pBir96Qae/ekHEv3pB4b96Qf6/ekEbwHpBOMB6QVXAekFywHpBj8B6QavAekHIwHpB5cB6QQLBekEfwXpBPMF6QVnBekF2wXpBk8F6QbDBekHNwXpB6sF6QQfCekEkwnpBQcJ6QV7CekF7wnpBmMJ6QbXCekHSwnpB78J6QQzDekEpw3pBRsN6QWPDekGAw3pBncN6QbrDekHXw3pB9MN6QRDEekEtxHpBSsR6QWfEekGExHpBocR6Qb7EekHbxHpB+MR6QRXFekEyxXpBT8V6QWzFekGJxXpBpsV6QcPFekHgxXpB/cV6QRrGekE3xnpBVMZ6QXDGekGNxnpBqsZ6QcfGekHkxnpBAcd6QR7HekE7x3pBWMd6QXXHekGSx3pBr8d6QczHekHpx3pBBsh6QSPIekFAyHpBXMh6QXnIekGWyHpBs8h6QdDIekHtyHpBCsl6QSfJekFEyXpBYcl6QX7JekGbyXpBuMl6QdXJekHyyXpBDsp6QSvKekFIynpBZcp6QYLKekGfynpBvMp6QdnKekH2ynpBE8t6QTDLekFNy3pBast6QYfLekGjy3pBwMt6Qd3LekH6y3pBF8x6QTTMekFRzHpBbsx6QYvMekGozHpBxcx6QeLMekH+zHpBG816QTjNekFVzXpBcs16QY/NekGszXpByc16QebNekEDznpBIM56QTzOekFZznpBds56QZPOekGwznpBzc56QerOekEHz3pBJM96QUHPekFez3pBes96QZfPekG0z3pB0c96Qe7PekEL0HpBKNB6QUXQekFi0HpBf9B6QZvQekG40HpB1dB6QfLQekEP0XpBLNF6QUnRekFm0XpBg9F6QZ/RekG80XpB2dF6QfbRekET0npBMNJ6QU3SekFq0npBh9J6QaPSekHA0npB3dJ6QfrSekEX03pBNNN6QVHTekFu03pBi9N6QafTekHE03pB4dN6Qf7TekEb1HpBONR6QVXUekFy1HpBjtR6QavUekHI1HpB5dR6QQLVekEf1XpBPNV6QVnVekF11XpBktV6Qa/VekHM1XpB6dV6QQbWekEj1npBQNZ6QVzWekF51npBltZ6QbPWekHQ1npB7dZ6QQrXekEn13pBQ9d6QWDXekF913pBmtd6QbfXekHU13pB8dd6QQ3YekEq2HpBR9h6QWTYekGB2HpBnth6QbvYekHX2HpB9Nh6QRHZekEu2XpBS9l6QWjZekGF2XpBodl6Qb7ZekHb2XpB+Nl6QRXaekEy2npBT9p6QWvaekGI2npBpdp6QcLaekHf2npB/Np6QRjbekE123pBUtt6QW/bekGM23pBqdt6QcbbekHi23pB/9t6QRzcekE53HpBVtx6QXPcekGP3HpBrNx6QcncekHm3HpBA916QSDdekE83XpBWd16QXbdekGT3XpBsN16Qc3dekHp3XpBBt56QSPeekFA3npBXd56QXreekGW3npBs956QdDeekHt3npBCt96QSffekFD33pBYN96QX3fekGa33pBt996QdPfekHw33pBDeB6QSrgekFH4HpBZOB6QYDgekGd4HpBuuB6QdfgekH04HpBEOF6QS3hekFK4XpBZ+F6QYThekGh4XpBveF6QdrhekH34XpBFOJ6QTHiekFN4npBauJ6QYfiekGk4npBweJ6Qd3iekH64npBF+N6QTTjekFR43pBbuN6QYrjekGn43pBxON6QeHjekH+43pBGuR6QTfkekFU5HpBceR6QY7kekGq5HpBx+R6QeTkekEB5XpBHuV6QTrlekFX5XpBdOV6QZHlekGt5XpByuV6QeflekEE5npBIeZ6QT3mekFa5npBd+Z6QZTmekGx5npBzeZ6QermekEH53pBJOd6QUHnekFd53pBeud6QZfnekG053pB0Od6Qe3nekEK6HpBJ+h6QUToekFg6HpBfeh6QZroekG36HpB1Oh6QfDoekEN6XpBKul6QUfpekFj6XpBgOl6QZ3pekG66XpB1ul6QfPpekEQ6npBLep6QUrqekFm6npBg+p6QaDqekG96npB2ep6QfbqekET63pBMOt6QU3rekFp63pBhut6QaPrekHA63pB3Ot6QfnrekEW7HpBM+x6QU/sekFs7HpBiex6QabsekHC7HpB3+x6QfzsekEZ7XpBNe16QVLtekFv7XpBjO16QajtekHF7XpB4u16Qf/tekEb7npBOO56QVXuekFy7npBj+56QavuekHI7npB5e56QQLvekEe73pBO+96QVjvekF073pBke96Qa7vekHL73pB5+96QQTwekEh8HpBPvB6QVrwekF38HpBlPB6QbHwekHN8HpB6vB6QQfxekEk8XpBQPF6QV3xekF68XpBl/F6QbPxekHQ8XpB7fF6QQryekEm8npBQ/J6QWDyekF88npBmfJ6QbbyekHT8npB7/J6QQzzekEp83pBRvN6QWLzekF/83pBnPN6QbjzekHV83pB8vN6QQ/0ekEr9HpBSPR6QWX0ekGC9HpBnvR6Qbv0ekHY9HpB9PR6QRH1ekEu9XpBS/V6QWf1ekGE9XpBofV6Qb31ekHa9XpB9/V6QRT2ekEw9npBTfZ6QWr2ekGG9npBo/Z6QcD2ekHd9npB+fZ6QRb3ekEz93pBT/d6QWz3ekGJ93pBpvd6QcL3ekHf93pB/Pd6QRj4ekE1+HpBUvh6QW74ekGL+HpBqPh6QcX4ekHh+HpB/vh6QRv5ekE3+XpBVPl6QXH5ekGN+XpBqvl6Qcf5ekHk+XpBAPp6QR36ekE6+npBVvp6QXP6ekGQ+npBrPp6Qcn6ekHm+npBAvt6QR/7ekE8+3pBWft6QXX7ekGS+3pBr/t6Qcv7ekHo+3pBBfx6QSH8ekE+/HpBW/x6QXf8ekGU/HpBsfx6Qc38ekHq/HpBB/16QSP9ekFA/XpBXf16QXr9ekGW/XpBs/16QdD9ekHs/XpBCf56QSb+ekFC/npBX/56QXz+ekGY/npBtf56QdL+ekHu/npBC/96QSj/ekFE/3pBYf96QX7/ekGa/3pBt/96QdT/ekHw/3pBDQB7QSoAe0FGAHtBYwB7QYAAe0GcAHtBuQB7QdYAe0HyAHtBDwF7QSwBe0FIAXtBZQF7QYIBe0GeAXtBuwF7QdgBe0H0AXtBEQJ7QS4Ce0FKAntBZwJ7QYMCe0GgAntBvQJ7QdkCe0H2AntBEwN7QS8De0FMA3tBaQN7QYUDe0GiA3tBvwN7QdsDe0H4A3tBFQR7QTEEe0FOBHtBawR7QYcEe0GkBHtBwAR7Qd0Ee0H6BHtBFgV7QTMFe0FQBXtBbAV7QYkFe0GmBXtBwgV7Qd8Fe0H8BXtBGAZ7QTUGe0FRBntBbgZ7QYsGe0GnBntBxAZ7QeEGe0H9BntBGgd7QTYHe0FTB3tBcAd7QYwHe0GpB3tBxgd7QeIHe0H/B3tBHAh7QTgIe0FVCHtBcQh7QY4Ie0GrCHtBxwh7QeQIe0EBCXtBHQl7QToJe0FWCXtBcwl7QZAJe0GsCXtByQl7QeUJe0ECCntBHwp7QTsKe0FYCntBdQp7QZEKe0GuCntBygp7QecKe0EEC3tBIAt7QT0Le0FZC3tBdgt7QZMLe0GvC3tBzAt7QegLe0EFDHtBIgx7QT4Me0FbDHtBeAx7QZQMe0GxDHtBzQx7QeoMe0EHDXtBIw17QUANe0FcDXtBeQ17QZYNe0GyDXtBzw17QesNe0EIDntBJQ57QUEOe0FeDntBeg57QZcOe0G0DntB0A57Qe0Oe0EJD3tBJg97QUMPe0FfD3tBfA97QZgPe0G1D3tB0Q97Qe4Pe0ELEHtBJxB7QUQQe0FgEHtBfRB7QZoQe0G2EHtB0xB7Qe8Qe0EMEXtBKBF7QUURe0FiEXtBfhF7QZsRe0G3EXtB1BF7QfERe0ENEntBKhJ7QUYSe0FjEntBfxJ7QZwSe0G5EntB1RJ7QfISe0EOE3tBKxN7QUcTe0FkE3tBgRN7QZ0Te0G6E3tB1hN7QfMTe0EPFHtBLBR7QUkUe0FlFHtBghR7QZ4Ue0G7FHtB1xR7QfQUe0ERFXtBLRV7QUoVe0FmFXtBgxV7QZ8Ve0G8FXtB2BV7QfUVe0ESFntBLhZ7QUsWe0FnFntBhBZ7QaAWe0G9FntB2hZ7QfYWe0ETF3tBLxd7QUwXe0FoF3tBhRd7QaEXe0G+F3tB2hd7QfcXe0EUGHtBMBh7QU0Ye0FpGHtBhhh7QaIYe0G/GHtB2xh7QfgYe0EVGXtBMRl7QU4Ze0FqGXtBhxl7QaMZe0HAGXtB3Bl7QfkZe0EVGntBMhp7QU4ae0FrGntBiBp7QaQae0HBGntB3Rp7Qfoae0EWG3tBMxt7QU8be0FsG3tBiBt7QaUbe0HBG3tB3ht7Qfobe0EXHHtBNBx7QVAce0FtHHtBiRx7QaYce0HCHHtB3xx7Qfsce0EYHXtBNB17QVEde0FtHXtBih17QaYde0HDHXtB3x17Qfwde0EYHntBNR57QVIee0FuHntBix57Qacee0HEHntB4B57Qf0ee0EZH3tBNh97QVIfe0FvH3tBix97Qagfe0HEH3tB4R97Qf0fe0EaIHtBNiB7QVMge0FvIHtBjCB7Qagge0HFIHtB4SB7Qf4ge0EaIXtBNyF7QVMhe0FwIXtBjCF7Qakhe0HFIXtB4iF7Qf4he0EbIntBNyJ7QVQie0FwIntBjSJ7Qakie0HGIntB4iJ7Qf8ie0EbI3tBOCN7QVQje0FxI3tBjSN7Qaoje0HGI3tB4yN7Qf8je0EcJHtBOCR7QVUke0FxJHtBjiR7Qaoke0HHJHtB4yR7QQAle0EcJXtBOSV7QVUle0FyJXtBjiV7Qasle0HHJXtB5CV7QQAme0EdJntBOSZ7QVYme0FyJntBjiZ7Qasme0HHJntB5CZ7QQAne0EdJ3tBOSd7QVYne0FyJ3tBjyd7Qasne0HIJ3tB5Cd7QQEoe0EdKHtBOih7QVYoe0FzKHtBjyh7Qasoe0HIKHtB5Ch7QQEpe0EdKXtBOil7QVYpe0FzKXtBjyl7Qawpe0HIKXtB5Sl7QQEqe0EeKntBOip7QVYqe0FzKntBjyp7Qawqe0HIKntB5Sp7QQEre0EeK3tBOit7QVcre0FzK3tBjyt7Qawre0HIK3tB5St7QQEse0EeLHtBOix7QVcse0FzLHtBkCx7Qawse0HILHtB5Sx7QQEte0EeLXtBOi17QVcte0FzLXtBkC17Qawte0HJLXtB5S17QQEue0EeLntBOi57QVcue0FzLntBkC57Qawue0HILntB5S57QQEve0EeL3tBOi97QVcve0FzL3tBkC97Qawve0HIL3tB5S97QQEwe0EeMHtBOjB7QVcwe0FzMHtBjzB7Qawwe0HIMHtB5TB7QQExe0EeMXtBOjF7QVYxe0FzMXtBjzF7Qawxe0HIMXtB5TF7QQEye0EdMntBOjJ7QVYye0FzMntBjzJ7Qawye0HIMntB5DJ7QQEze0EdM3tBOjN7QVYze0FyM3tBjzN7Qasze0HIM3tB5DN7QQE0e0EdNHtBOTR7QVY0e0FyNHtBjzR7Qas0e0HHNHtB5DR7QQA1e0EdNXtBOTV7QVY1e0FyNXtBjjV7Qas1e0HHNXtB5DV7QQA2e0EcNntBOTZ7QVU2e0FyNntBjjZ7Qao2e0HHNntB4zZ7QQA3e0EcN3tBODd7QVU3e0FxN3tBjjd7Qao3e0HGN3tB4zd7Qf83e0EcOHtBODh7QVQ4e0FxOHtBjTh7Qao4e0HGOHtB4jh7Qf84e0EbOXtBNzl7QVQ5e0FwOXtBjTl7Qak5e0HFOXtB4jl7Qf45e0EbOntBNzp7QVM6e0FwOntBjDp7Qag6e0HFOntB4Tp7Qf46e0EaO3tBNjt7QVM7e0FvO3tBjDt7Qag7e0HEO3tB4Tt7Qf07e0EZPHtBNjx7QVI8e0FvPHtBizx7Qac8e0HEPHtB4Dx7Qfw8e0EZPXtBNT17QVI9e0FuPXtBij17Qac9e0HDPXtB3z17Qfw9e0EYPntBND57QVE+e0FtPntBij57QaY+e0HCPntB3z57Qfs+e0EXP3tBND97QVA/e0FsP3tBiT97QaU/e0HCP3tB3j97Qfo/e0EXQHtBM0B7QU9Ae0FsQHtBiEB7QaRAe0HBQHtB3UB7QflAe0EWQXtBMkF7QU9Be0FrQXtBh0F7QaRBe0HAQXtB3EF7QflBe0EVQntBMUJ7QU5Ce0FqQntBhkJ7QaNCe0G/QntB20J7QfhCe0EUQ3tBMEN7QU1De0FpQ3tBhUN7QaJDe0G+Q3tB2kN7QfdDe0ETRHtBL0R7QUxEe0FoRHtBhER7QaFEe0G9RHtB2UR7QfZEe0ESRXtBLkV7QUtFe0FnRXtBg0V7QaBFe0G8RXtB2EV7QfVFe0ERRntBLUZ7QUpGe0FmRntBgkZ7QZ9Ge0G7RntB10Z7QfRGe0EQR3tBLEd7QUlHe0FlR3tBgUd7QZ5He0G6R3tB1kd7QfNHe0EPSHtBK0h7QUhIe0FkSHtBgEh7QZ1Ie0G5SHtB1Uh7QfFIe0EOSXtBKkl7QUZJe0FjSXtBf0l7QZtJe0G4SXtB1El7QfBJe0ENSntBKUp7QUVKe0FhSntBfkp7QZpKe0G2SntB00p7Qe9Ke0ELS3tBKEt7QURLe0FgS3tBfUt7QZlLe0G1S3tB0Ut7Qe5Le0EKTHtBJkx7QUNMe0FfTHtBe0x7QZhMe0G0THtB0Ex7QexMe0EJTXtBJU17QUFNe0FeTXtBek17QZZNe0GyTXtBz017QetNe0EHTntBJE57QUBOe0FcTntBeU57QZVOe0GxTntBzU57QepOe0EGT3tBIk97QT9Pe0FbT3tBd097QZNPe0GwT3tBzE97QehPe0EEUHtBIVB7QT1Qe0FZUHtBdlB7QZJQe0GuUHtBylB7QedQe0EDUXtBH1F7QTxRe0FYUXtBdFF7QZBRe0GtUXtByVF7QeVRe0EBUntBHlJ7QTpSe0FWUntBc1J7QY9Se0GrUntBx1J7QeRSe0EAU3tBHFN7QThTe0FVU3tBcVN7QY1Te0GpU3tBxlN7QeJTe0H+U3tBGlR7QTdUe0FTVHtBb1R7QYxUe0GoVHtBxFR7QeBUe0H9VHtBGVV7QTVVe0FRVXtBblV7QYpVe0GmVXtBwlV7Qd9Ve0H7VXtBF1Z7QTNWe0FQVntBbFZ7QYhWe0GkVntBwVZ7Qd1We0H5VntBFVd7QTJXe0FOV3tBald7QYZXe0GjV3tBv1d7QdtXe0H3V3tBFFh7QTBYe0FMWHtBaFh7QYVYe0GhWHtBvVh7QdlYe0H1WHtBEll7QS5Ze0FKWXtBZll7QYNZe0GfWXtBu1l7QddZe0H0WXtBEFp7QSxae0FIWntBZVp7QYFae0GdWntBuVp7QdVae0HyWntBDlt7QSpbe0FGW3tBY1t7QX9be0GbW3tBt1t7QdNbe0HwW3tBDFx7QShce0FEXHtBYVx7QX1ce0GZXHtBtVx7QdFce0HuXHtBCl17QSZde0FCXXtBX117QXtde0GXXXtBs117Qc9de0HsXXtBCF57QSRee0FAXntBXF57QXlee0GVXntBsV57Qc1ee0HqXntBBl97QSJfe0E+X3tBWl97QXdfe0GTX3tBr197Qctfe0HnX3tBBGB7QSBge0E8YHtBWGB7QXRge0GRYHtBrWB7Qclge0HlYHtBAWF7QR5he0E6YXtBVmF7QXJhe0GOYXtBq2F7Qcdhe0HjYXtB/2F7QRtie0E4YntBVGJ7QXBie0GMYntBqGJ7QcVie0HhYntB/WJ7QRlje0E1Y3tBUWN7QW5je0GKY3tBpmN7QcJje0HeY3tB+2N7QRdke0EzZHtBT2R7QWtke0GIZHtBpGR7QcBke0HcZHtB+GR7QRRle0ExZXtBTWV7QWlle0GFZXtBoWV7Qb1le0HaZXtB9mV7QRJme0EuZntBSmZ7QWdme0GDZntBn2Z7Qbtme0HXZntB82Z7QRBne0EsZ3tBSGd7QWRne0GAZ3tBnGd7Qblne0HVZ3tB8Wd7QQ1oe0EpaHtBRWh7QWJoe0F+aHtBmmh7QbZoe0HSaHtB7mh7QQtpe0EnaXtBQ2l7QV9pe0F7aXtBl2l7QbRpe0HQaXtB7Gl7QQhqe0EkantBQGp7QVxqe0F5antBlWp7QbFqe0HNantB6Wp7QQVre0Eia3tBPmt7QVpre0F2a3tBkmt7Qa5re0HKa3tB52t7QQNse0EfbHtBO2x7QVdse0FzbHtBj2x7Qaxse0HIbHtB5Gx7QQBte0EcbXtBOG17QVRte0FxbXtBjW17Qalte0HFbXtB4W17Qf1te0EZbntBNm57QVJue0FubntBim57QaZue0HCbntB3m57Qfpue0EXb3tBM297QU9ve0Frb3tBh297QaNve0G/b3tB3G97Qfhve0EUcHtBMHB7QUxwe0FocHtBhHB7QaBwe0G9cHtB2XB7QfVwe0ERcXtBLXF7QUlxe0FlcXtBgXF7QZ5xe0G6cXtB1nF7QfJxe0EOcntBKnJ7QUZye0FicntBfnJ7QZtye0G3cntB03J7Qe9ye0ELc3tBJ3N7QUNze0Ffc3tBe3N7QZhze0G0c3tB0HN7Qexze0EIdHtBJHR7QUB0e0FcdHtBeHR7QZV0e0GxdHtBzXR7Qel0e0EFdXtBIXV7QT11e0FZdXtBdXV7QZF1e0GudXtBynV7QeZ1e0ECdntBHnZ7QTp2e0FW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2HtBadh7QYTYe0Gg2HtBvNh7QdfYe0Hz2HtBDtl7QSrZe0FG2XtBYdl7QX3Ze0GZ2XtBtNl7QdDZe0Hr2XtBB9p7QSPae0E+2ntBWtp7QXbae0GR2ntBrdp7Qcjae0Hk2ntBANt7QRvbe0E323tBU9t7QW7be0GK23tBpdt7QcHbe0Hd23tB+Nt7QRTce0Ew3HtBS9x7QWfce0GC3HtBntx7Qbrce0HV3HtB8dx7QQzde0Eo3XtBRN17QV/de0F73XtBl917QbLde0HO3XtB6d17QQXee0Eh3ntBPN57QVjee0Fz3ntBj957Qavee0HG3ntB4t57Qf3ee0EZ33tBNd97QVDfe0Fs33tBh997QaPfe0G/33tB2t97Qfbfe0ER4HtBLeB7QUnge0Fk4HtBgOB7QZvge0G34HtB0+B7Qe7ge0EK4XtBJeF7QUHhe0Fd4XtBeOF7QZThe0Gv4XtBy+F7Qefhe0EC4ntBHuJ7QTnie0FV4ntBceJ7QYzie0Go4ntBw+J7Qd/ie0H64ntBFuN7QTLje0FN43tBaeN7QYTje0Gg43tBvON7Qdfje0Hz43tBDuR7QSrke0FF5HtBYeR7QX3ke0GY5HtBtOR7Qc/ke0Hr5HtBB+V7QSLle0E+5XtBWeV7QXXle0GQ5XtBrOV7Qcjle0Hj5XtB/+V7QRrme0E25ntBUeZ7QW3me0GJ5ntBpOZ7QcDme0Hb5ntB9+Z7QRLne0Eu53tBSed7QWXne0GB53tBnOd7Qbjne0HT53tB7+d7QQroe0Em6HtBQuh7QV3oe0F56HtBlOh7QbDoe0HL6HtB5+h7QQLpe0Ee6XtBOul7QVXpe0Fx6XtBjOl7Qajpe0HD6XtB3+l7Qfrpe0EW6ntBMup7QU3qe0Fp6ntBhOp7QaDqe0G76ntB1+p7QfLqe0EO63tBKut7QUXre0Fh63tBfOt7QZjre0Gz63tBz+t7Qerre0EG7HtBIex7QT3se0FZ7HtBdOx7QZDse0Gr7HtBx+x7QeLse0H+7HtBGe17QTXte0FQ7XtBbO17QYfte0Gj7XtBv+17Qdrte0H27XtBEe57QS3ue0FI7ntBZO57QX/ue0Gb7ntBtu57QdLue0Ht7ntBCe97QSTve0FA73tBXO97QXfve0GT73tBru97Qcrve0Hl73tBAfB7QRzwe0E48HtBU/B7QW/we0GK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UHxBn1B8QbpQfEHVUHxB8FB8QQtRfEEmUXxBQVF8QV1RfEF4UXxBk1F8Qa5RfEHJUXxB5FF8Qf9RfEEaUnxBNVJ8QVBSfEFrUnxBhlJ8QaFSfEG8UnxB2FJ8QfNSfEEOU3xBKVN8QURTfEFfU3xBelN8QZVTfEGwU3xBy1N8QeZTfEEBVHxBHFR8QTdUfEFSVHxBblR8QYlUfEGkVHxBv1R8QdpUfEH1VHxBEFV8QStVfEFGVXxBYVV8QXxVfEGXVXxBslV8Qc1VfEHoVXxBA1Z8QR5WfEE6VnxBVVZ8QXBWfEGLVnxBplZ8QcFWfEHcVnxB91Z8QRJXfEEtV3xBSFd8QWNXfEF+V3xBmVd8QbRXfEHPV3xB6ld8QQVYfEEgWHxBO1h8QVZYfEFyWHxBjVh8QahYfEHDWHxB3lh8QflYfEEUWXxBL1l8QUpZfEFlWXxBgFl8QZtZfEG2WXxB0Vl8QexZfEEHWnxBIlp8QT1afEFYWnxBc1p8QY5afEGpWnxBxFp8Qd9afEH6WnxBFVt8QTBbfEFLW3xBZ1t8QYJbfEGdW3xBuFt8QdNbfEHuW3xBCVx8QSRcfEE/XHxBWlx8QXVcfEGQXHxBq1x8QcZcfEHhXHxB/Fx8QRddfEEyXXxBTV18QWhdfEGDXXxBnl18QbldfEHUXXxB7118QQpefEElXnxBQF58QVtefEF2XnxBkV58QaxefEHHXnxB4l58Qf1efEEYX3xBM198QU5ffEFpX3xBhF98QZ9ffEG6X3xB1V98QfBffEELYHxBJmB8QUFgfEFcYHxBd2B8QZJgfEGtYHxByGB8QeNgfEH+YHxBGWF8QTRhfEFPYXxBamF8QYVhfEGgYXxBu2F8QdZhfEHxYXxBDGJ8QSdifEFCYnxBXWJ8QXhifEGTYnxBrmJ8QclifEHkYnxB/2J8QRpjfEE1Y3xBUGN8QWtjfEGGY3xBoWN8QbxjfEHXY3xB8mN8QQ1kfEEoZHxBQ2R8QV5kfEF5ZHxBlGR8Qa9kfEHKZHxB5WR8QQBlfEEbZXxBNmV8QVFlfEFsZXxBh2V8QaJlfEG9ZXxB2GV8QfNlfEEOZnxBKWZ8QURmfEFfZnxBemZ8QZVmfEGwZnxBy2Z8QeZmfEEBZ3xBHGd8QTdnfEFSZ3xBbWd8QYhnfEGjZ3xBvmd8QdlnfEH0Z3xBD2h8QSpofEFF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l3xBmJd8QbKXfEHNl3xB6Jd8QQOYfEEdmHxBOJh8QVOYfEFumHxBiJh8QaOYfEG+mHxB2Zh8QfOYfEEOmXxBKZl8QUSZfEFemXxBeZl8QZSZfEGvmXxByZl8QeSZfEH/mXxBGpp8QTSafEFPmnxBapp8QYWafEGfmnxBupp8QdWafEHvmnxBCpt8QSWbfEFAm3xBWpt8QXWbfEGQm3xBq5t8QcWbfEHgm3xB+5t8QRacfEEwnHxBS5x8QWacfEGBnHxBm5x8QbacfEHRnHxB65x8QQadfEEhnXxBPJ18QVadfEFxnXxBjJ18QaedfEHBnXxB3J18QfedfEERnnxBLJ58QUeefEFinnxBfJ58QZeefEGynnxBzZ58QeeefEECn3xBHZ98QTeffEFSn3xBbZ98QYiffEGin3xBvZ98QdiffEHyn3xBDaB8QSigfEFDoHxBXaB8QXigfEGToHxBraB8QcigfEHjoHxB/qB8QRihfEEzoXxBTqF8QWihfEGDoXxBnqF8QbmhfEHToXxB7qF8QQmifEEjonxBPqJ8QVmifEF0onxBjqJ8QamifEHEonxB3qJ8QfmifEEUo3xBL6N8QUmjfEFko3xBf6N8QZmjfEG0o3xBz6N8QemjfEEEpHxBH6R8QTqkfEFUpHxBb6R8QYqkfEGkpHxBv6R8QdqkfEH0pHxBD6V8QSqlfEFEpXxBX6V8QXqlfEGVpXxBr6V8QcqlfEHlpXxB/6V8QRqmfEE1pnxBT6Z8QWqmfEGFpnxBn6Z8QbqmfEHVpnxB8KZ8QQqnfEElp3xBQKd8QVqnfEF1p3xBkKd8QaqnfEHFp3xB4Kd8QfqnfEEVqHxBMKh8QUqofEFlqHxBgKh8QZqofEG1qHxB0Kh8QeqofEEFqXxBIKl8QTqpfEFVqXxBcKl8QYupfEGlqXxBwKl8QdupfEH1qXxBEKp8QSuqfEFFqnxBYKp8QXuqfEGVqnxBsKp8QcuqfEHlqnxBAKt8QRurfEE1q3xBUKt8QWurfEGFq3xBoKt8QburfEHVq3xB8Kt8QQusfEElrHxBQKx8QVusfEF1rHxBkKx8QausfEHFrHxB4Kx8QfqsfEEVrXxBMK18QUqtfEFlrXxBgK18QZqtfEG1rXxB0K18QeqtfEEFrnxBIK58QTqufEFVrnxBcK58QYqufEGlrnxBwK58QdqufEH1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3XxBuN18QdPdfEHt3XxBCN58QSLefEE93nxBV958QXLefEGM3nxBpt58QcHefEHb3nxB9t58QRDffEEr33xBRd98QV/ffEF633xBlN98Qa/ffEHJ33xB5N98Qf7ffEEY4HxBM+B8QU3gfEFo4HxBguB8QZ3gfEG34HxB0eB8QezgfEEG4XxBIeF8QTvhfEFW4XxBcOF8QYrhfEGl4XxBv+F8QdrhfEH04XxBD+J8QSnifEFD4nxBXuJ8QXjifEGT4nxBreJ8QcfifEHi4nxB/OJ8QRfjfEEx43xBTON8QWbjfEGA43xBm+N8QbXjfEHQ43xB6uN8QQTkfEEf5HxBOeR8QVTkfEFu5HxBieR8QaPkfEG95HxB2OR8QfLkfEEN5XxBJ+V8QUHlfEFc5XxBduV8QZHlfEGr5XxBxeV8QeDlfEH65XxBFeZ8QS/mfEFJ5nxBZOZ8QX7mfEGZ5nxBs+Z8Qc3mfEHo5nxBAud8QR3nfEE353xBUed8QWznfEGG53xBoed8QbvnfEHV53xB8Od8QQrofEEl6HxBP+h8QVnofEF06HxBjuh8QanofEHD6HxB3eh8QfjofEES6XxBLOl8QUfpfEFh6XxBfOl8QZbpfEGw6XxBy+l8QeXpfEEA6nxBGup8QTTqfEFP6nxBaep8QYPqfEGe6nxBuOp8QdPqfEHt6nxBB+t8QSLrfEE863xBV+t8QXHrfEGL63xBput8QcDrfEHa63xB9et8QQ/sfEEq7HxBROx8QV7sfEF57HxBk+x8Qa3sfEHI7HxB4ux8Qf3sfEEX7XxBMe18QUztfEFm7XxBgO18QZvtfEG17XxBz+18QertfEEE7nxBH+58QTnufEFT7nxBbu58QYjufEGi7nxBve58QdfufEHx7nxBDO98QSbvfEFB73xBW+98QXXvfEGQ73xBqu98QcTvfEHf73xB+e98QRPwfEEu8HxBSPB8QWPwfEF98HxBl/B8QbLwfEHM8HxB5vB8QQHxfEEb8XxBNfF8QVDxfEFq8XxBhPF8QZ/xfEG58XxB0/F8Qe7xfEEI8nxBI/J8QT3yfEFX8nxBcvJ8QYzyfEGm8nxBwfJ8QdvyfEH18nxBEPN8QSrzfEFE83xBX/N8QXnzfEGT83xBrvN8QcjzfEHi83xB/fN8QRf0fEEx9HxBTPR8QWb0fEGA9HxBm/R8QbX0fEHP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UH1ByVB9QeJQfUH8UH1BFlF9QTBRfUFKUX1BZFF9QX5RfUGYUX1BslF9QcxRfUHmUX1BAFJ9QRpSfUE0Un1BTVJ9QWdSfUGBUn1Bm1J9QbVSfUHPUn1B6VJ9QQNTfUEdU31BN1N9QVFTfUFrU31BhFN9QZ5TfUG4U31B0lN9QexTfUEGVH1BIFR9QTpUfUFUVH1BblR9QYhUfUGiVH1Bu1R9QdVUfUHvVH1BCVV9QSNVfUE9VX1BV1V9QXFVfUGLVX1BpVV9Qb9VfUHYVX1B8lV9QQxWfUEmVn1BQFZ9QVpWfUF0Vn1BjlZ9QahWfUHCVn1B3FZ9QfVWfUEPV31BKVd9QUNXfUFdV31Bd1d9QZFXfUGrV31BxVd9Qd9XfUH4V31BElh9QSxYfUFGWH1BYFh9QXpYfUGUWH1Brlh9QchYfUHiWH1B+1h9QRVZfUEvWX1BSVl9QWNZfUF9WX1Bl1l9QbFZfUHLWX1B5Fl9Qf5ZfUEYWn1BMlp9QUxafUFmWn1BgFp9QZpafUG0Wn1BzVp9QedafUEBW31BG1t9QTVbfUFPW31BaVt9QYNbfUGcW31Btlt9QdBbfUHqW31BBFx9QR5cfUE4XH1BUlx9QWxcfUGFXH1Bn1x9QblcfUHTXH1B7Vx9QQddfUEhXX1BO119QVRdfUFuXX1BiF19QaJdfUG8XX1B1l19QfBdfUEKXn1BI159QT1efUFXXn1BcV59QYtefUGlXn1Bv159QdlefUHyXn1BDF99QSZffUFAX31BWl99QXRffUGOX31Bp199QcFffUHbX31B9V99QQ9gfUEpYH1BQ2B9QVxgfUF2YH1BkGB9QapgfUHEYH1B3mB9QfhgfUERYX1BK2F9QUVhfUFfYX1BeWF9QZNhfUGtYX1BxmF9QeBhfUH6YX1BFGJ9QS5ifUFIYn1BYmJ9QXtifUGVYn1Br2J9QclifUHjYn1B/WJ9QRdjfUEwY31BSmN9QWRjfUF+Y31BmGN9QbJjfUHMY31B5WN9Qf9jfUEZZH1BM2R9QU1kfUFnZH1BgGR9QZpkfUG0ZH1BzmR9QehkfUECZX1BG2V9QTVlfUFPZX1BaWV9QYNlfUGdZX1Bt2V9QdBlfUHqZX1BBGZ9QR5mfUE4Zn1BUmZ9QWtmfUGFZn1Bn2Z9QblmfUHTZn1B7WZ9QQZnfUEgZ31BOmd9QVRnfUFu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lH1Bw5R9QdyUfUH2lH1BEJV9QSmVfUFDlX1BXZV9QXaVfUGQlX1BqZV9QcOVfUHdlX1B9pV9QRCWfUEqln1BQ5Z9QV2WfUF2ln1BkJZ9QaqWfUHDln1B3ZZ9QfeWfUEQl31BKpd9QUOXfUFdl31Bd5d9QZCXfUGql31BxJd9Qd2XfUH3l31BEJh9QSqYfUFEmH1BXZh9QXeYfUGQmH1Bqph9QcSYfUHdmH1B95h9QRGZfUEqmX1BRJl9QV2ZfUF3mX1BkZl9QaqZfUHEmX1B3Zl9QfeZfUERmn1BKpp9QUSafUFemn1Bd5p9QZGafUGqmn1BxJp9Qd6afUH3mn1BEZt9QSqbfUFEm31BXpt9QXebfUGRm31Bqpt9QcSbfUHem31B95t9QRGcfUEqnH1BRJx9QV6cfUF3nH1BkZx9QaqcfUHEnH1B3px9QfecfUERnX1BKp19QUSdfUFenX1Bd519QZGdfUGqnX1BxJ19Qd6dfUH3nX1BEZ59QSqefUFEnn1BXp59QXeefUGRnn1Bqp59QcSefUHdnn1B9559QRGffUEqn31BRJ99QV2ffUF3n31BkZ99QaqffUHEn31B3Z99QfeffUERoH1BKqB9QUSgfUFdoH1Bd6B9QZCgfUGqoH1BxKB9Qd2gfUH3oH1BEKF9QSqhfUFEoX1BXaF9QXehfUGQoX1BqqF9QcOhfUHdoX1B96F9QRCifUEqon1BQ6J9QV2ifUF2on1BkKJ9QaqifUHDon1B3aJ9QfaifUEQo31BKaN9QUOjfUFdo31BdqN9QZCjfUGpo31Bw6N9QdyjfUH2o31BEKR9QSmkfUFDpH1BXKR9QXakfUGPpH1BqaR9QcOkfUHcpH1B9qR9QQ+lfUEppX1BQqV9QVylfUF1pX1Bj6V9QamlfUHCpX1B3KV9QfWlfUEPpn1BKKZ9QUKmfUFbpn1BdaZ9QY+mfUGopn1BwqZ9QdumfUH1pn1BDqd9QSinfUFBp31BW6d9QXWnfUGOp31BqKd9QcGnfUHbp31B9Kd9QQ6ofUEnqH1BQah9QVuofUF0qH1Bjqh9QaeofUHBqH1B2qh9QfSofUENqX1BJ6l9QUCpfUFaqX1BdKl9QY2pfUGnqX1BwKl9QdqpfUHzqX1BDap9QSaqfUFAqn1BWap9QXOqfUGMqn1Bpqp9QcCqfUHZqn1B86p9QQyrfUEm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131B99d9QRDYfUEq2H1BQ9h9QVzYfUF22H1Bj9h9QajYfUHC2H1B29h9QfTYfUEO2X1BJ9l9QUDZfUFa2X1Bc9l9QYzZfUGm2X1Bv9l9QdjZfUHy2X1BC9p9QSTafUE+2n1BV9p9QXDafUGK2n1Bo9p9QbzafUHW2n1B79p9QQjbfUEi231BO9t9QVTbfUFu231Bh9t9QaDbfUG6231B09t9QezbfUEG3H1BH9x9QTjcfUFS3H1Ba9x9QYTcfUGe3H1Bt9x9QdDcfUHq3H1BA919QRzdfUE23X1BT919QWjdfUGC3X1Bm919QbTdfUHO3X1B5919QQDefUEZ3n1BM959QUzefUFl3n1Bf959QZjefUGx3n1By959QeTefUH93n1BF999QTDffUFJ331BY999QXzffUGV331Br999QcjffUHh331B+t99QRTgfUEt4H1BRuB9QWDgfUF54H1BkuB9QazgfUHF4H1B3uB9QfjgfUER4X1BKuF9QUPhfUFd4X1BduF9QY/hfUGp4X1BwuF9QdvhfUH14X1BDuJ9QSfifUFA4n1BWuJ9QXPifUGM4n1BpuJ9Qb/ifUHY4n1B8uJ9QQvjfUEk431BPeN9QVfjfUFw431BieN9QaPjfUG8431B1eN9Qe7jfUEI5H1BIeR9QTrkfUFU5H1BbeR9QYbkfUGf5H1BueR9QdLkfUHr5H1BBeV9QR7lfUE35X1BUeV9QWrlfUGD5X1BnOV9QbblfUHP5X1B6OV9QQLmfUEb5n1BNOZ9QU3mfUFn5n1BgOZ9QZnmfUGy5n1BzOZ9QeXmfUH+5n1BGOd9QTHnfUFK531BY+d9QX3nfUGW531Br+d9QcnnfUHi531B++d9QRTofUEu6H1BR+h9QWDofUF56H1Bk+h9QazofUHF6H1B3+h9QfjofUER6X1BKul9QUTpfUFd6X1Bdul9QY/pfUGp6X1Bwul9QdvpfUH16X1BDup9QSfqfUFA6n1BWup9QXPqfUGM6n1Bpep9Qb/qfUHY6n1B8ep9QQrrfUEk631BPet9QVbrfUFv631Biet9QaLrfUG7631B1Ot9Qe7rfUEH7H1BIOx9QTrsfUFT7H1BbOx9QYXsfUGf7H1BuOx9QdHsfUHq7H1BBO19QR3tfUE27X1BT+19QWntfUGC7X1Bm+19QbTtfUHO7X1B5+19QQDufUEZ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Gn5Bahp+QYMafkGcGn5BtRp+Qc4afkHnGn5BABt+QRkbfkEyG35BSxt+QWQbfkF9G35Blxt+QbAbfkHJG35B4ht+QfsbfkEUHH5BLRx+QUYcfkFfHH5BeBx+QZEcfkGqHH5Bwxx+QdwcfkH1HH5BDh1+QScdfkFAHX5BWR1+QXIdfkGMHX5BpR1+Qb4dfkHXHX5B8B1+QQkefkEiHn5BOx5+QVQefkFtHn5Bhh5+QZ8efkG4Hn5B0R5+QeoefkEDH35BHB9+QTUffkFOH35BZx9+QYAffkGZH35Bsh9+QcwffkHlH35B/h9+QRcgfkEwIH5BSSB+QWIgfkF7IH5BlCB+Qa0gfkHGIH5B3yB+QfggfkERIX5BKiF+QUMhfkFcIX5BdSF+QY4hfkGnIX5BwCF+QdkhfkHyIX5BCyJ+QSQifkE9In5BViJ+QW8ifkGIIn5BoSJ+QboifkHTIn5B7CJ+QQYjfkEfI35BOCN+QVEjfkFqI35BgyN+QZwjfkG1I35BziN+QecjfkEAJH5BGSR+QTIkfkFLJH5BZCR+QX0kfkGWJH5BryR+QcgkfkHhJH5B+iR+QRMlfkEsJX5BRSV+QV4lfkF3JX5BkCV+QaklfkHCJX5B2yV+QfQlfkENJn5BJiZ+QT8mfkFYJn5BcSZ+QYomfkGjJn5BvCZ+QdUmfkHuJn5BByd+QSAnfkE5J35BUid+QWsnfkGEJ35BnSd+QbYnfkHPJ35B6Cd+QQEofkEaKH5BMyh+QUwofkFlKH5Bfih+QZcofkGwKH5BySh+QeIofkH7KH5BFCl+QS0pfkFGKX5BXyl+QXgpfkGRKX5Bqil+QcMpfkHcKX5B9Sl+QQ4qfkEnKn5BQCp+QVkqfkFyKn5Biyp+QaQqfkG9Kn5B1ip+Qe8qfkEIK35BISt+QTorfkFTK35BbCt+QYUrfkGeK35Btyt+QdArfkHpK35BAix+QRssfkE0LH5BTSx+QWYsfkF/LH5BmCx+QbEsfkHKLH5B4yx+QfwsfkEVLX5BLi1+QUctfkFgLX5BeS1+QZItfkGrLX5BxC1+Qd0tfkH2LX5BDy5+QSgufkFALn5BWS5+QXIufkGLLn5BpC5+Qb0ufkHWLn5B7y5+QQgvfkEhL35BOi9+QVMvfkFsL35BhS9+QZ4vfkG3L35B0C9+QekvfkECMH5BGzB+QTQwfkFNMH5BZjB+QX8wfkGYMH5BsTB+QcowfkHjMH5B/DB+QRUxfkEuMX5BRzF+QWAxfkF4MX5BkTF+QaoxfkHDMX5B3DF+QfUxfkEOMn5BJzJ+QUAyfkFZMn5BcjJ+QYsyfkGkMn5BvTJ+QdYyfkHvMn5BCDN+QSEzfkE6M35BUzN+QWwzfkGFM35BnjN+QbczfkHPM35B6DN+QQE0fkEaNH5BMzR+QUw0fkFlNH5BfjR+QZc0fkGwNH5ByTR+QeI0fkH7NH5BFDV+QS01fkFGNX5BXzV+QXg1fkGRNX5BqTV+QcI1fkHbNX5B9DV+QQ02fkEmNn5BPzZ+QVg2fkFxNn5BijZ+QaM2fkG8Nn5B1TZ+Qe42fkEHN35BIDd+QTk3fkFRN35Bajd+QYM3fkGcN35BtTd+Qc43fkHnN35BADh+QRk4fkEyOH5BSzh+QWQ4fkF9OH5Bljh+Qa84fkHIOH5B4Dh+Qfk4fkESOX5BKzl+QUQ5fkFdOX5Bdjl+QY85fkGoOX5BwTl+Qdo5fkHzOX5BDDp+QSU6fkE9On5BVjp+QW86fkGIOn5BoTp+Qbo6fkHTOn5B7Dp+QQU7fkEeO35BNzt+QVA7fkFpO35BgTt+QZo7fkGzO35BzDt+QeU7fkH+O35BFzx+QTA8fkFJPH5BYjx+QXs8fkGUPH5BrDx+QcU8fkHePH5B9zx+QRA9fkEpPX5BQj1+QVs9fkF0PX5BjT1+QaY9fkG+PX5B1z1+QfA9fkEJPn5BIj5+QTs+fkFUPn5BbT5+QYY+fkGfPn5BuD5+QdA+fkHpPn5BAj9+QRs/fkE0P35BTT9+QWY/fkF/P35BmD9+QbE/fkHKP35B4j9+Qfs/fkEUQH5BLUB+QUZAfkFfQH5BeEB+QZFAfkGqQH5Bw0B+QdtAfkH0QH5BDUF+QSZBfkE/QX5BWEF+QXFBfkGKQX5Bo0F+QbtBfkHUQX5B7UF+QQZCfkEfQn5BOEJ+QVFCfkFqQn5Bg0J+QZxCfkG0Qn5BzUJ+QeZCfkH/Qn5BGEN+QTFDfkFKQ35BY0N+QXtDfkGUQ35BrUN+QcZDfkHfQ35B+EN+QRFEfkEqRH5BQ0R+QVtEfkF0RH5BjUR+QaZEfkG/RH5B2ER+QfFEfkEKRX5BI0V+QTtFfkFURX5BbUV+QYZFfkGfRX5BuEV+QdFFfkHqRX5BAkZ+QRtGfkE0Rn5BTUZ+QWZGfkF/Rn5BmEZ+QbFGfkHJRn5B4kZ+QftGfkEUR35BLUd+QUZHfkFfR35BeEd+QZBHfkGpR35Bwkd+QdtHfkH0R35BDUh+QSZIfkE+SH5BV0h+QXBIfkGJSH5Bokh+QbtIfkHUSH5B7Uh+QQVJfkEeSX5BN0l+QVBJfkFpSX5Bgkl+QZtJfkGzSX5BzEl+QeVJfkH+SX5BF0p+QTBKfkFJSn5BYUp+QXpKfkGTSn5BrEp+QcVKfkHeSn5B90p+QQ9LfkEoS35BQUt+QVpLfkFzS35BjEt+QaVLfkG9S35B1kt+Qe9LfkEITH5BIUx+QTpMfkFSTH5Ba0x+QYRMfkGdTH5Btkx+Qc9MfkHoTH5BAE1+QRlNfkEyTX5BS01+QWRNfkF9TX5BlU1+Qa5NfkHHTX5B4E1+QflNfkESTn5BK05+QUNOfkFcTn5BdU5+QY5OfkGnTn5BwE5+QdhOfkHxTn5BCk9+QSNPfkE8T35BVU9+QW1PfkGGT35Bn09+QbhPfkHRT35B6k9+QQJQfkEbUH5BNFB+QU1QfkFmUH5Bf1B+QZdQfkGwUH5ByVB+QeJQfkH7UH5BFFF+QSxRfkFFUX5BXlF+QXdRfkGQUX5BqVF+QcFRfkHaUX5B81F+QQxSfkElUn5BPlJ+QVZSfkFvUn5BiFJ+QaFSfkG6Un5B0lJ+QetSfkEEU35BHVN+QTZTfkFPU35BZ1N+QYBTfkGZU35BslN+QctTfkHjU35B/FN+QRVUfkEuVH5BR1R+QWBUfkF4VH5BkVR+QapUfkHDVH5B3FR+QfRUfkENVX5BJlV+QT9VfkFYVX5BcVV+QYlVfkGiVX5Bu1V+QdRVfkHtVX5BBVZ+QR5WfkE3Vn5BUFZ+QWlWfkGBVn5BmlZ+QbNWfkHMVn5B5VZ+Qf1WfkEWV35BL1d+QUhXfkFhV35BeVd+QZJXfkGrV35BxFd+Qd1XfkH1V35BDlh+QSdYfkFAWH5BWVh+QXFYfkGKWH5Bo1h+QbxYfkHVWH5B7Vh+QQZZfkEfWX5BOFl+QVFZfkFpWX5Bgll+QZtZfkG0WX5BzVl+QeVZfkH+WX5BF1p+QTBafkFJWn5BYVp+QXpafkGTWn5BrFp+QcRafkHdWn5B9lp+QQ9bfkEoW35BQFt+QVlbfkFyW35Bi1t+QaRbfkG8W35B1Vt+Qe5bfkEHXH5BH1x+QThcfkFRXH5Balx+QYNcfkGbXH5BtFx+Qc1cfkHmXH5B/1x+QRddfkEwXX5BSV1+QWJdfkF6XX5Bk11+QaxdfkHFXX5B3l1+QfZdfkEPXn5BKF5+QUFefkFZXn5Bcl5+QYtefkGkXn5BvF5+QdVefkHuXn5BB19+QSBffkE4X35BUV9+QWpffkGDX35Bm19+QbRffkHNX35B5l9+Qf5ffkEXYH5BMGB+QUlgfkFiYH5BemB+QZNgfkGsYH5BxWB+Qd1gfkH2YH5BD2F+QShhfkFAYX5BWWF+QXJhfkGLYX5Bo2F+QbxhfkHVYX5B7mF+QQdifkEfYn5BOGJ+QVFifkFqYn5BgmJ+QZtifkG0Yn5BzWJ+QeVifkH+Yn5BF2N+QTBjfkFIY35BYWN+QXpjfkGTY35Bq2N+QcRjfkHdY35B9mN+QQ5kfkEnZH5BQGR+QVlkfkFxZH5BimR+QaNkfkG8ZH5B1GR+Qe1kfkEGZX5BH2V+QTdlfkFQZX5BaWV+QYJlfkGaZX5Bs2V+QcxlfkHlZX5B/WV+QRZmfkEvZn5BR2Z+QWBmfkF5Zn5BkmZ+QapmfkHDZn5B3GZ+QfVmfkENZ35BJmd+QT9nfkFYZ35BcGd+QYlnfkGiZ35Bu2d+QdNnfkHsZ35BBWh+QR1ofkE2aH5BT2h+QWhofkGAaH5BmWh+QbJofkHLaH5B42h+QfxofkEVaX5BLml+QUZpfkFfaX5BeGl+QZBpfkGpaX5Bwml+QdtpfkHzaX5BDGp+QSVqfkE9an5BVmp+QW9qfkGIan5BoGp+QblqfkHSan5B62p+QQNrfkEca35BNWt+QU1rfkFma35Bf2t+QZhrfkGwa35ByWt+QeJrfkH6a35BE2x+QSxsfkFFbH5BXWx+QXZsfkGPbH5Bp2x+QcBsfkHZbH5B8mx+QQptfkEjbX5BPG1+QVRtfkFtbX5Bhm1+QZ9tfkG3bX5B0G1+QeltfkEBbn5BGm5+QTNufkFMbn5BZG5+QX1ufkGWbn5Brm5+QcdufkHgbn5B+G5+QRFvfkEqb35BQ29+QVtvfkF0b35BjW9+QaVvfkG+b35B129+Qe9vfkEIcH5BIXB+QTpwfkFScH5Ba3B+QYRwfkGccH5BtXB+Qc5wfkHmcH5B/3B+QRhxfkExcX5BSXF+QWJxfkF7cX5Bk3F+QaxxfkHF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nX5BHJ1+QTWdfkFNnX5BZp1+QX6dfkGXnX5Br51+QcidfkHgnX5B+Z1+QRGefkEqnn5BQp5+QVuefkFznn5BjJ5+QaSefkG9nn5B1Z5+Qe6efkEGn35BH59+QTeffkFQn35BaJ9+QYGffkGZn35Bsp9+QcqffkHjn35B+59+QRSgfkEsoH5BRaB+QV2gfkF2oH5BjqB+QaegfkG/oH5B2KB+QfCgfkEJoX5BIaF+QTqhfkFSoX5Ba6F+QYOhfkGcoX5BtKF+Qc2hfkHloX5B/qF+QRaifkEvon5BR6J+QWCifkF4on5BkaJ+QamifkHCon5B2qJ+QfOifkELo35BJKN+QTyjfkFVo35BbaN+QYajfkGeo35Bt6N+Qc+jfkHoo35BAKR+QRikfkExpH5BSaR+QWKkfkF6pH5Bk6R+QaukfkHEpH5B3KR+QfWkfkENpX5BJqV+QT6lfkFXpX5Bb6V+QYilfkGgpX5BuaV+QdGlfkHqpX5BAqZ+QRumfkEzpn5BS6Z+QWSmfkF8pn5BlaZ+Qa2mfkHGpn5B3qZ+QfemfkEPp35BKKd+QUCnfkFZp35Bcad+QYqnfkGip35Bu6d+QdOnfkHrp35BBKh+QRyofkE1qH5BTah+QWaofkF+qH5Bl6h+Qa+ofkHIqH5B4Kh+QfmofkERqX5BKql+QUKpfkFaqX5Bc6l+QYupfkGkqX5BvKl+QdWpfkHtqX5BBqp+QR6qfkE3qn5BT6p+QWeqfkGAqn5BmKp+QbGqfkHJqn5B4qp+QfqqfkETq35BK6t+QUSrfkFcq35BdKt+QY2rfkGlq35Bvqt+QdarfkHvq35BB6x+QSCsfkE4rH5BUax+QWmsfkGBrH5Bmqx+QbKsfkHLrH5B46x+QfysfkEUrX5BLa1+QUWtfkFdrX5Bdq1+QY6tfkGnrX5Bv61+QditfkHwrX5BCa5+QSGufkE5rn5BUq5+QWqufkGDrn5Bm65+QbSufkHMrn5B5a5+Qf2ufkEVr35BLq9+QUavfkFfr35Bd69+QZCvfkGor35BwK9+QdmvfkHxr35BCrB+QSKwfkE7sH5BU7B+QWuwfkGEsH5BnLB+QbWwfkHNsH5B5rB+Qf6wfkEWsX5BL7F+QUexfkFgsX5BeLF+QZGxfkGpsX5BwbF+QdqxfkHysX5BC7J+QSOyfkE8sn5BVLJ+QWyyfkGF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3X5BZN1+QXzdfkGU3X5Brd1+QcXdfkHd3X5B9d1+QQ7efkEm3n5BPt5+QVbefkFv3n5Bh95+QZ/efkG33n5B0N5+QejefkEA335BGN9+QTDffkFJ335BYd9+QXnffkGR335Bqt9+QcLffkHa335B8t9+QQvgfkEj4H5BO+B+QVPgfkFs4H5BhOB+QZzgfkG04H5BzOB+QeXgfkH94H5BFeF+QS3hfkFG4X5BXuF+QXbhfkGO4X5Bp+F+Qb/hfkHX4X5B7+F+QQfifkEg4n5BOOJ+QVDifkFo4n5BgeJ+QZnifkGx4n5ByeJ+QeLifkH64n5BEuN+QSrjfkFC435BW+N+QXPjfkGL435Bo+N+QbzjfkHU435B7ON+QQTkfkEc5H5BNeR+QU3kfkFl5H5BfeR+QZXkfkGu5H5BxuR+Qd7kfkH25H5BD+V+QSflfkE/5X5BV+V+QW/lfkGI5X5BoOV+QbjlfkHQ5X5B6OV+QQHmfkEZ5n5BMeZ+QUnmfkFi5n5BeuZ+QZLmfkGq5n5BwuZ+QdvmfkHz5n5BC+d+QSPnfkE7535BVOd+QWznfkGE535BnOd+QbTnfkHN535B5ed+Qf3nfkEV6H5BLeh+QUbofkFe6H5Bduh+QY7ofkGm6H5Bv+h+QdfofkHv6H5BB+l+QR/pfkE46X5BUOl+QWjpfkGA6X5BmOl+QbHpfkHJ6X5B4el+QfnpfkER6n5BKup+QULqfkFa6n5Bcup+QYrqfkGj6n5Bu+p+QdPqfkHr6n5BA+t+QRzrfkE0635BTOt+QWTrfkF8635BlOt+Qa3rfkHF635B3et+QfXrfkEN7H5BJux+QT7sfkFW7H5Bbux+QYbsfkGf7H5Bt+x+Qc/sfkHn7H5B/+x+QRftfkEw7X5BSO1+QWDtfkF47X5BkO1+QantfkHB7X5B2e1+QfHtfkEJ7n5BIe5+QTrufkFS7n5Bau5+QYLufkGa7n5Bs+5+QcvufkHj7n5B++5+QRPvfkEr735BRO9+QVzvfkF0735BjO9+QaTvfkG8735B1e9+Qe3vfkEF8H5BHfB+QTXwfkFN8H5BZvB+QX7wfkGW8H5BrvB+QcbwfkHe8H5B9/B+QQ/xfkEn8X5BP/F+QVfxfkFv8X5BiPF+QaDxfkG48X5B0PF+QejxfkEA8n5BGfJ+QTHyfkFJ8n5BYfJ+QXnyfkGR8n5BqvJ+QcLyfkHa8n5B8vJ+QQrzfkEi835BO/N+QVPzfkFr835Bg/N+QZvzfkGz835By/N+QeTzfkH8835BFPR+QSz0fkFE9H5BXPR+QXX0fkGN9H5BpfR+Qb30fkHV9H5B7fR+QQX1fkEe9X5BNvV+QU71fkFm9X5BfvV+QZb1fkGu9X5Bx/V+Qd/1fkH39X5BD/Z+QSf2fkE/9n5BV/Z+QXD2fkGI9n5BoPZ+Qbj2fkHQ9n5B6PZ+QQD3fkEZ935BMfd+QUn3fkFh935Befd+QZH3fkGp935Bwvd+Qdr3fkHy935BCvh+QSL4fkE6+H5BUvh+QWv4fkGD+H5Bm/h+QbP4fkHL+H5B4/h+Qfv4fkEU+X5BLPl+QUT5fkFc+X5BdPl+QYz5fkGk+X5BvPl+QdX5fkHt+X5BBfp+QR36fkE1+n5BTfp+QWX6fkF9+n5Blvp+Qa76fkHG+n5B3vp+Qfb6fkEO+35BJvt+QT77fkFX+35Bb/t+QYf7fkGf+35Bt/t+Qc/7fkHn+35B//t+QRj8fkEw/H5BSPx+QWD8fkF4/H5BkPx+Qaj8fkHA/H5B2fx+QfH8fkEJ/X5BIf1+QTn9fkFR/X5Baf1+QYH9fkGZ/X5Bsv1+Qcr9fkHi/X5B+v1+QRL+fkEq/n5BQv5+QVr+fkFy/n5Bi/5+QaP+fkG7/n5B0/5+Qev+fkED/35BG/9+QTP/fkFL/35BZP9+QXz/fkGU/35BrP9+QcT/fkHc/35B9P9+QQwAf0EkAH9BPQB/QVUAf0FtAH9BhQB/QZ0Af0G1AH9BzQB/QeUAf0H9AH9BFQF/QS4Bf0FGAX9BXgF/QXYBf0GOAX9BpgF/Qb4Bf0HWAX9B7gF/QQYCf0EfAn9BNwJ/QU8Cf0FnAn9BfwJ/QZcCf0GvAn9BxwJ/Qd8Cf0H3An9BDwN/QSgDf0FAA39BWAN/QXADf0GIA39BoAN/QbgDf0HQA39B6AN/QQAEf0EYBH9BMQR/QUkEf0FhBH9BeQR/QZEEf0GpBH9BwQR/QdkEf0HxBH9BCQV/QSEFf0E6BX9BUgV/QWoFf0GCBX9BmgV/QbIFf0HKBX9B4gV/QfoFf0ESBn9BKgZ/QUIGf0FaBn9BcwZ/QYsGf0GjBn9BuwZ/QdMGf0HrBn9BAwd/QRsHf0EzB39BSwd/QWMHf0F7B39Bkwd/QawHf0HEB39B3Ad/QfQHf0EMCH9BJAh/QTwIf0FUCH9BbAh/QYQIf0GcCH9BtAh/QcwIf0HkCH9B/Qh/QRUJf0EtCX9BRQl/QV0Jf0F1CX9BjQl/QaUJf0G9CX9B1Ql/Qe0Jf0EFCn9BHQp/QTUKf0FNCn9BZgp/QX4Kf0GWCn9Brgp/QcYKf0HeCn9B9gp/QQ4Lf0EmC39BPgt/QVYLf0FuC39Bhgt/QZ4Lf0G2C39Bzgt/QeYLf0H/C39BFwx/QS8Mf0FHDH9BXwx/QXcMf0GPDH9Bpwx/Qb8Mf0HXDH9B7wx/QQcNf0EfDX9BNw1/QU8Nf0FnDX9Bfw1/QZcNf0GwDX9ByA1/QeANf0H4DX9BEA5/QSgOf0FADn9BWA5/QXAOf0GIDn9BoA5/QbgOf0HQDn9B6A5/QQAPf0EYD39BMA9/QUgPf0FgD39BeA9/QZAPf0GoD39BwA9/QdkPf0HxD39BCRB/QSEQf0E5EH9BURB/QWkQf0GBEH9BmRB/QbEQf0HJEH9B4RB/QfkQf0EREX9BKRF/QUERf0FZEX9BcRF/QYkRf0GhEX9BuRF/QdERf0HpEX9BARJ/QRkSf0ExEn9BSRJ/QWESf0F6En9BkhJ/QaoSf0HCEn9B2hJ/QfISf0EKE39BIhN/QToTf0FSE39BahN/QYITf0GaE39BshN/QcoTf0HiE39B+hN/QRIUf0EqFH9BQhR/QVoUf0FyFH9BihR/QaIUf0G6FH9B0hR/QeoUf0ECFX9BGhV/QTIVf0FKFX9BYhV/QXoVf0GSFX9BqhV/QcIVf0HaFX9B8hV/QQoWf0EiFn9BOhZ/QVIWf0FqFn9BghZ/QZoWf0GyFn9ByhZ/QeMWf0H7Fn9BExd/QSsXf0FDF39BWxd/QXMXf0GLF39Boxd/QbsXf0HTF39B6xd/QQMYf0EbGH9BMxh/QUsYf0FjGH9Bexh/QZMYf0GrGH9Bwxh/QdsYf0HzGH9BCxl/QSMZf0E7GX9BUxl/QWsZf0GDGX9Bmxl/QbMZf0HLGX9B4xl/QfsZf0ETGn9BKxp/QUMaf0FbGn9Bcxp/QYsaf0GjGn9Buxp/QdMaf0HrGn9BAxt/QRsbf0EzG39BSxt/QWMbf0F7G39Bkxt/Qasbf0HDG39B2xt/QfMbf0ELHH9BIxx/QTscf0FTHH9Baxx/QYMcf0GbHH9Bsxx/Qcscf0HiHH9B+hx/QRIdf0EqHX9BQh1/QVodf0FyHX9Bih1/QaIdf0G6HX9B0h1/Qeodf0ECHn9BGh5/QTIef0FKHn9BYh5/QXoef0GSHn9Bqh5/QcIef0HaHn9B8h5/QQoff0EiH39BOh9/QVIff0FqH39Bgh9/QZoff0GyH39Byh9/QeIff0H6H39BEiB/QSogf0FCIH9BWiB/QXIgf0GKIH9BoiB/Qbogf0HSIH9B6iB/QQIhf0EaIX9BMiF/QUkhf0FhIX9BeSF/QZEhf0GpIX9BwSF/Qdkhf0HxIX9BCSJ/QSEif0E5In9BUSJ/QWkif0GBIn9BmSJ/QbEif0HJIn9B4SJ/Qfkif0ERI39BKSN/QUEjf0FZI39BcSN/QYkjf0GhI39BuSN/QdEjf0HoI39BACR/QRgkf0EwJH9BSCR/QWAkf0F4JH9BkCR/Qagkf0HAJH9B2CR/QfAkf0EIJX9BICV/QTglf0FQJX9BaCV/QYAlf0GYJX9BsCV/Qcglf0HgJX9B9yV/QQ8mf0EnJn9BPyZ/QVcmf0FvJn9BhyZ/QZ8mf0G3Jn9BzyZ/Qecmf0H/Jn9BFyd/QS8nf0FHJ39BXyd/QXcnf0GPJ39Bpyd/Qb4nf0HWJ39B7id/QQYof0EeKH9BNih/QU4of0FmKH9Bfih/QZYof0GuKH9Bxih/Qd4of0H2KH9BDil/QSYpf0E+KX9BVSl/QW0pf0GFKX9BnSl/QbUpf0HNKX9B5Sl/Qf0pf0EVKn9BLSp/QUUqf0FdKn9BdSp/QY0qf0GlKn9BvCp/QdQqf0HsKn9BBCt/QRwrf0E0K39BTCt/QWQrf0F8K39BlCt/Qawrf0HEK39B3Ct/QfQrf0ELLH9BIyx/QTssf0FTLH9Bayx/QYMsf0GbLH9Bsyx/Qcssf0HjLH9B+yx/QRMtf0ErLX9BQi1/QVotf0FyLX9Bii1/QaItf0G6LX9B0i1/Qeotf0ECLn9BGi5/QTIuf0FKLn9BYi5/QXkuf0GRLn9BqS5/QcEuf0HZLn9B8S5/QQkvf0EhL39BOS9/QVEvf0FpL39BgC9/QZgvf0GwL39ByC9/QeAvf0H4L39BEDB/QSgwf0FAMH9BWDB/QXAwf0GIMH9BnzB/Qbcwf0HPMH9B5zB/Qf8wf0EXMX9BLzF/QUcxf0FfMX9BdzF/QY4xf0GmMX9BvjF/QdYxf0HuMX9BBjJ/QR4yf0E2Mn9BTjJ/QWYyf0F9Mn9BlTJ/Qa0yf0HFMn9B3TJ/QfUyf0ENM39BJTN/QT0zf0FVM39BbDN/QYQzf0GcM39BtDN/Qcwzf0HkM39B/DN/QRQ0f0EsNH9BRDR/QVs0f0FzNH9BizR/QaM0f0G7NH9B0zR/Qes0f0EDNX9BGzV/QTI1f0FKNX9BYjV/QXo1f0GSNX9BqjV/QcI1f0HaNX9B8jV/QQk2f0EhNn9BOTZ/QVE2f0FpNn9BgTZ/QZk2f0GxNn9ByDZ/QeA2f0H4Nn9BEDd/QSg3f0FAN39BWDd/QXA3f0GIN39Bnzd/Qbc3f0HPN39B5zd/Qf83f0EXOH9BLzh/QUc4f0FeOH9Bdjh/QY44f0GmOH9Bvjh/QdY4f0HuOH9BBjl/QR05f0E1OX9BTTl/QWU5f0F9OX9BlTl/Qa05f0HFOX9B3Dl/QfQ5f0EMOn9BJDp/QTw6f0FUOn9BbDp/QYM6f0GbOn9Bszp/Qcs6f0HjOn9B+zp/QRM7f0ErO39BQjt/QVo7f0FyO39Bijt/QaI7f0G6O39B0jt/Qek7f0EBPH9BGTx/QTE8f0FJPH9BYTx/QXk8f0GQPH9BqDx/QcA8f0HYPH9B8Dx/QQg9f0EgPX9BOD1/QU89f0FnPX9Bfz1/QZc9f0GvPX9Bxz1/Qd49f0H2PX9BDj5/QSY+f0E+Pn9BVj5/QW4+f0GFPn9BnT5/QbU+f0HNPn9B5T5/Qf0+f0EVP39BLD9/QUQ/f0FcP39BdD9/QYw/f0GkP39Buz9/QdM/f0HrP39BA0B/QRtAf0EzQH9BS0B/QWJAf0F6QH9BkkB/QapAf0HCQH9B2kB/QfFAf0EJQX9BIUF/QTlBf0FRQX9BaUF/QYFBf0GYQX9BsEF/QchBf0HgQX9B+EF/QRBCf0EnQn9BP0J/QVdCf0FvQn9Bh0J/QZ9Cf0G2Qn9BzkJ/QeZCf0H+Qn9BFkN/QS5Df0FFQ39BXUN/QXVDf0GNQ39BpUN/Qb1Df0HUQ39B7EN/QQREf0EcRH9BNER/QUxEf0FjRH9Be0R/QZNEf0GrRH9Bw0R/QdpEf0HyRH9BCkV/QSJFf0E6RX9BUkV/QWlFf0GBRX9BmUV/QbFFf0HJRX9B4UV/QfhFf0EQRn9BKEZ/QUBGf0FYRn9Bb0Z/QYdGf0GfRn9Bt0Z/Qc9Gf0HnRn9B/kZ/QRZHf0EuR39BRkd/QV5Hf0F1R39BjUd/QaVHf0G9R39B1Ud/Qe1Hf0EESH9BHEh/QTRIf0FMSH9BZEh/QXtIf0GTSH9Bq0h/QcNIf0HbSH9B8kh/QQpJf0EiSX9BOkl/QVJJf0FqSX9BgUl/QZlJf0GxSX9ByUl/QeFJf0H4SX9BEEp/QShKf0FASn9BWEp/QW9Kf0GHSn9Bn0p/QbdKf0HPSn9B5kp/Qf5Kf0EWS39BLkt/QUZLf0FdS39BdUt/QY1Lf0GlS39BvUt/QdRLf0HsS39BBEx/QRxMf0E0TH9BS0x/QWNMf0F7TH9Bk0x/QatMf0HCTH9B2kx/QfJMf0EKTX9BIk1/QTlNf0FRTX9BaU1/QYFNf0GYTX9BsE1/QchNf0HgTX9B+E1/QQ9Of0EnTn9BP05/QVdOf0FvTn9Bhk5/QZ5Of0G2Tn9Bzk5/QeVOf0H9Tn9BFU9/QS1Pf0FFT39BXE9/QXRPf0GMT39BpE9/QbxPf0HTT39B609/QQNQf0EbUH9BMlB/QUpQf0FiUH9BelB/QZJQf0GpUH9BwVB/QdlQf0HxUH9BCFF/QSBRf0E4UX9BUFF/QWhRf0F/UX9Bl1F/Qa9Rf0HHUX9B3lF/QfZRf0EOUn9BJlJ/QT5Sf0FVUn9BbVJ/QYVSf0GdUn9BtFJ/QcxSf0HkUn9B/FJ/QRNTf0ErU39BQ1N/QVtTf0FzU39BilN/QaJTf0G6U39B0lN/QelTf0EBVH9BGVR/QTFUf0FIVH9BYFR/QXhUf0GQVH9Bp1R/Qb9Uf0HXVH9B71R/QQdVf0EeVX9BNlV/QU5Vf0FmVX9BfVV/QZVVf0GtVX9BxVV/QdxVf0H0VX9BDFZ/QSRWf0E7Vn9BU1Z/QWtWf0GDVn9BmlZ/QbJWf0HKVn9B4lZ/QflWf0ERV39BKVd/QUFXf0FYV39BcFd/QYhXf0GgV39Bt1d/Qc9Xf0HnV39B/1d/QRZYf0EuWH9BRlh/QV5Yf0F1WH9BjVh/QaVYf0G9WH9B1Fh/QexYf0EEWX9BHFl/QTNZf0FLWX9BY1l/QXtZf0GSWX9Bqll/QcJZf0HaWX9B8Vl/QQlaf0EhWn9BOVp/QVBaf0FoWn9BgFp/QZdaf0GvWn9Bx1p/Qd9af0H2Wn9BDlt/QSZbf0E+W39BVVt/QW1bf0GFW39BnVt/QbRbf0HMW39B5Ft/Qfxbf0ETXH9BK1x/QUNcf0FaXH9Bclx/QYpcf0GiXH9BuVx/QdFcf0HpXH9BAV1/QRhdf0EwXX9BSF1/QV9df0F3XX9Bj11/Qaddf0G+XX9B1l1/Qe5df0EGXn9BHV5/QTVef0FNXn9BZF5/QXxef0GUXn9BrF5/QcNef0HbXn9B815/QQtff0EiX39BOl9/QVJff0FpX39BgV9/QZlff0GxX39ByF9/QeBff0H4X39BD2B/QSdgf0E/YH9BV2B/QW5gf0GGYH9BnmB/QbVgf0HNYH9B5WB/Qf1gf0EUYX9BLGF/QURhf0FbYX9Bc2F/QYthf0GjYX9BumF/QdJhf0HqYX9BAWJ/QRlif0ExYn9BSGJ/QWBif0F4Yn9BkGJ/Qadif0G/Yn9B12J/Qe5if0EGY39BHmN/QTZjf0FNY39BZWN/QX1jf0GUY39BrGN/QcRjf0HbY39B82N/QQtkf0EjZH9BOmR/QVJkf0FqZH9BgWR/QZlkf0GxZH9ByGR/QeBkf0H4ZH9BEGV/QSdlf0E/ZX9BV2V/QW5lf0GGZX9BnmV/QbVlf0HNZX9B5WV/Qfxlf0EUZn9BLGZ/QURmf0FbZn9Bc2Z/QYtmf0GiZn9BumZ/QdJmf0HpZn9BAWd/QRlnf0EwZ39BSGd/QWBnf0F4Z39Bj2d/Qadnf0G/Z39B1md/Qe5nf0EGaH9BHWh/QTVof0FNaH9BZGh/QXxof0GUaH9Bq2h/QcNof0HbaH9B8mh/QQppf0EiaX9BOml/QVFpf0FpaX9BgWl/QZhpf0GwaX9ByGl/Qd9pf0H3aX9BD2p/QSZqf0E+an9BVmp/QW1qf0GFan9BnWp/QbRqf0HMan9B5Gp/Qftqf0ETa39BK2t/QUJrf0Faa39Bcmt/QYlrf0Gha39BuWt/QdBrf0Hoa39BAGx/QRdsf0EvbH9BR2x/QV5sf0F2bH9Bjmx/QaVsf0G9bH9B1Wx/Qexsf0EEbX9BHG1/QTNtf0FLbX9BY21/QXptf0GSbX9Bqm1/QcFtf0HZbX9B8W1/QQhuf0Egbn9BOG5/QU9uf0Fnbn9Bf25/QZZuf0Gubn9Bxm5/Qd1uf0H1bn9BDW9/QSRvf0E8b39BVG9/QWtvf0GDb39Bm29/QbJvf0HKb39B4W9/Qflvf0ERcH9BKHB/QUBwf0FYcH9Bb3B/QYdwf0Gf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mn9BI5p/QTuaf0FSmn9Bapp/QYGaf0GZmn9BsJp/Qciaf0Hfmn9B95p/QQ6bf0Emm39BPZt/QVWbf0Fsm39BhJt/QZubf0Gzm39Bypt/QeKbf0H5m39BEZx/QSicf0E/nH9BV5x/QW6cf0GGnH9BnZx/QbWcf0HMnH9B5Jx/Qfucf0ETnX9BKp1/QUKdf0FZnX9BcZ1/QYidf0GgnX9Bt51/Qc+df0HmnX9B/Z1/QRWef0Esnn9BRJ5/QVuef0Fznn9Bip5/QaKef0G5nn9B0Z5/Qeief0EAn39BF59/QS+ff0FGn39BXZ9/QXWff0GMn39BpJ9/Qbuff0HTn39B6p9/QQKgf0EZoH9BMaB/QUigf0FgoH9Bd6B/QY6gf0GmoH9BvaB/QdWgf0HsoH9BBKF/QRuhf0EzoX9BSqF/QWKhf0F5oX9BkKF/Qaihf0G/oX9B16F/Qe6hf0EGon9BHaJ/QTWif0FMon9BZKJ/QXuif0GSon9BqqJ/QcGif0HZon9B8KJ/QQijf0Efo39BN6N/QU6jf0Fmo39BfaN/QZSjf0Gso39Bw6N/Qdujf0Hyo39BCqR/QSGkf0E5pH9BUKR/QWekf0F/pH9BlqR/Qa6kf0HFpH9B3aR/QfSkf0EMpX9BI6V/QTqlf0FSpX9BaaV/QYGlf0GYpX9BsKV/Qcelf0HepX9B9qV/QQ2mf0Elpn9BPKZ/QVSmf0Frpn9Bg6Z/QZqmf0Gxpn9ByaZ/QeCmf0H4pn9BD6d/QSenf0E+p39BVad/QW2nf0GEp39BnKd/QbOnf0HLp39B4qd/Qfmnf0ERqH9BKKh/QUCof0FXqH9Bb6h/QYaof0GdqH9Btah/Qcyof0HkqH9B+6h/QROpf0EqqX9BQal/QVmpf0FwqX9BiKl/QZ+pf0G3qX9Bzql/QeWpf0H9qX9BFKp/QSyqf0FDqn9BWqp/QXKqf0GJqn9Boap/Qbiqf0HQqn9B56p/Qf6qf0EWq39BLat/QUWrf0Fcq39BdKt/QYurf0Giq39Buqt/QdGrf0Hpq39BAKx/QResf0EvrH9BRqx/QV6sf0F1rH9BjKx/QaSsf0G7rH9B06x/Qeqsf0ECrX9BGa1/QTCtf0FIrX9BX61/QXetf0GOrX9Bpa1/Qb2tf0HUrX9B7K1/QQOuf0Earn9BMq5/QUmuf0Fhrn9BeK5/QY+uf0Gn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139Bvdd/QdTXf0Hr139BA9h/QRrYf0Ex2H9BSNh/QWDYf0F32H9Bjth/QaXYf0G92H9B1Nh/QevYf0EC2X9BGtl/QTHZf0FI2X9BX9l/QXbZf0GO2X9Bpdl/QbzZf0HT2X9B69l/QQLaf0EZ2n9BMNp/QUjaf0Ff2n9Bdtp/QY3af0Gl2n9BvNp/QdPaf0Hq2n9BAdt/QRnbf0Ew239BR9t/QV7bf0F2239Bjdt/QaTbf0G7239B0tt/Qerbf0EB3H9BGNx/QS/cf0FH3H9BXtx/QXXcf0GM3H9Bo9x/Qbvcf0HS3H9B6dx/QQDdf0EY3X9BL91/QUbdf0Fd3X9BdN1/QYzdf0Gj3X9But1/QdHdf0Hp3X9BAN5/QRfef0Eu3n9BRd5/QV3ef0F03n9Bi95/QaLef0G53n9B0d5/Qejef0H/3n9BFt9/QS7ff0FF339BXN9/QXPff0GK339Bot9/Qbnff0HQ339B599/Qf7ff0EW4H9BLeB/QUTgf0Fb4H9BcuB/QYrgf0Gh4H9BuOB/Qc/gf0Hm4H9B/uB/QRXhf0Es4X9BQ+F/QVvhf0Fy4X9BieF/QaDhf0G34X9Bz+F/Qebhf0H94X9BFOJ/QSvif0FD4n9BWuJ/QXHif0GI4n9Bn+J/Qbfif0HO4n9B5eJ/Qfzif0ET439BK+N/QULjf0FZ439BcON/QYfjf0Ge439BtuN/Qc3jf0Hk439B++N/QRLkf0Eq5H9BQeR/QVjkf0Fv5H9BhuR/QZ7kf0G15H9BzOR/QePkf0H65H9BEuV/QSnlf0FA5X9BV+V/QW7lf0GF5X9BneV/QbTlf0HL5X9B4uV/Qfnlf0ER5n9BKOZ/QT/mf0FW5n9BbeZ/QYXmf0Gc5n9Bs+Z/Qcrmf0Hh5n9B+OZ/QRDnf0En539BPud/QVXnf0Fs539BhOd/QZvnf0Gy539Byed/QeDnf0H3539BD+h/QSbof0E96H9BVOh/QWvof0GC6H9Bmuh/QbHof0HI6H9B3+h/Qfbof0EN6X9BJel/QTzpf0FT6X9Baul/QYHpf0GZ6X9BsOl/Qcfpf0He6X9B9el/QQzqf0Ek6n9BO+p/QVLqf0Fp6n9BgOp/QZfqf0Gv6n9Bxup/Qd3qf0H06n9BC+t/QSLrf0E6639BUet/QWjrf0F/639Blut/Qa3rf0HF639B3Ot/QfPrf0EK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0BgAYQAAAB4GAAAcAAAADNAYAGEAAAB1BgAAGAAAAAzQGABhAAAArwYAAA8AAAAM0BgAYQAAALEGAAAFAAAADNAYAGEAAADQBgAASQAAAAzQGABhAAAA0gYAABcAAAAM0BgAYQAAANIGAABMAAAADNAYAGEAAADuBgAAJQAAAAzQGABhAAAALAcAABAAAAAM0BgAYQAAADAHAAAHAAAADNAYAGEAAABFBwAABQAAAAzQGABhAAAARgcAAAUAAAAM0BgAYQAAAEkHAAAHAAAADNAYAGEAAABJBwAAXAAAAAzQGABhAAAAXQcAABwAAAAM0BgAYQAAAPEHAAAbAAAADNAYAGEAAAD2BwAAGQAAAAAAAgAAAAAAAAADAAAAAAEAAAQAAAAAAgAABQAAAAADAAAGAAAAAAMAAAcAAAAAAwAACAAAAAADAAAJAAAAAAMBAAIAAAAAAAEAAwAAAAABAQAEAAAAAAIBAAUAAAAAAwEABgAAAAADAQAHAAAAAAMBAAgAAAAAAwEACQAAAAADAgACAAAAAAACAAMAAAAAAQIABAAAAAACAgAFAAAAAAMCAAYAAAAAAwIABwAAAAADAgAIAAAAAAMCAAkAAAAAAwMAAgAAAAAAAwADAAAAAAEDAAQAAAAAAgMABQAAAAADAwAGAAAAAAMDAAcAAAAAAwMACAAAAAADAwAJAAAAAAMEAAIAAAAAAAQAAwAAAAABBAAEAAAAAAIEAAUAAAAAAwQABgAAAAADBAAHAAAAAAMEAAgAAAAAAwQACQAAAAADBQACAAAAAAAFAAMAAAAAAQUABAAAAAACBQAFAAAAAAMFAAYAAAAAAwUABwAAAAADBQAIAAAAAAMFAAkAAAAAAwYAAgABAAAABgADAAEAAAEGAAQAAQAAAgYABQABAAADBgAGAAEAAAMGAAcAAQAAAwYACAABAAADBgAJAAEAAAMIAAIAAQAAAAgAAwABAAABCAAEAAEAAAIIAAUAAQAAAwgABgABAAADCAAHAAEAAAMIAAgAAQAAAwgACQABAAADAAAKAAABAAMAAAwAAAEAAwAADgAAAgADAAASAAACAAMAABYAAAMAAwAAHgAAAwADAAAmAAAEAAMAADYAAAQAAwEACgAAAQADAQAMAAABAAMBAA4AAAIAAwEAEgAAAgADAQAWAAADAAMBAB4AAAMAAwEAJgAABAADAQA2AAAEAAMCAAoAAAEAAwIADAAAAQADAgAOAAACAAMCABIAAAIAAwIAFgAAAwADAgAeAAADAAMCACYAAAQAAwIANgAABAADAwAKAAABAAMDAAwAAAEAAwMADgAAAgADAwASAAACAAMDABYAAAMAAwMAHgAAAwADAwAmAAAEAAMDADYAAAQAAwQACgAAAQADBAAMAAABAAMEAA4AAAIAAwQAEgAAAgADBAAWAAADAAMEAB4AAAMAAwQAJgAABAADBAA2AAAEAAMFAAoAAAEAAwUADAAAAQADBQAOAAACAAMFABIAAAIAAwUAFgAAAwADBQAeAAADAAMFACYAAAQAAwUANgAABAADBgAKAAEBAAMGAAwAAQEAAwYADgABAgADBgASAAECAAMGABYAAQMAAwYAHgABAwADBgAmAAEEAAMGADYAAQQAAwgACgABAQADCAAMAAEBAAMIAA4AAQIAAwgAEgABAgADCAAWAAEDAAMIAB4AAQMAAwgAJgABBAADCAA2AAEEAAMAAAIAAAD/AAAAAwAAAP8BAAAEAAAA/wIAAAUAAAD/AwAABgAAAP8DAAAHAAAA/wMAAAgAAAD/AwAACQAAAP8DAQACAAAA/wABAAMAAAD/AQEABAAAAP8CAQAFAAAA/wMBAAYAAAD/AwEABwAAAP8DAQAIAAAA/wMBAAkAAAD/AwIAAgAAAP8AAgADAAAA/wECAAQAAAD/AgIABQAAAP8DAgAGAAAA/wMCAAcAAAD/AwIACAAAAP8DAgAJAAAA/wMDAAIAAAD/AAMAAwAAAP8BAwAEAAAA/wIDAAUAAAD/AwMABgAAAP8DAwAHAAAA/wMDAAgAAAD/AwMACQAAAP8DBAACAAAA/wAEAAMAAAD/AQQABAAAAP8CBAAFAAAA/wMEAAYAAAD/AwQABwAAAP8DBAAIAAAA/wMEAAkAAAD/AwUAAgAAAP8ABQADAAAA/wEFAAQAAAD/AgUABQAAAP8DBQAGAAAA/wMFAAcAAAD/AwUACAAAAP8DBQAJAAAA/wMGAAIAAQD/AAYAAwABAP8BBgAEAAEA/wIGAAUAAQD/AwYABgABAP8DBgAHAAEA/wMGAAgAAQD/AwYACQABAP8DCAACAAEA/wAIAAMAAQD/AQgABAABAP8CCAAFAAEA/wMIAAYAAQD/AwgABwABAP8DCAAIAAEA/wMI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ABoAAAAM0BgAYQAAACgJAAAaAAAADNAYAGEAAABGCQAAGQAAAAzQGABhAAAAVQkAAA8AAAAM0BgAYQAAAEkKAAARAAAADNAYAGEAAAB6CgAABwAAAAzQGABhAAAAewoAABsAAAAM0BgAYQAAAKUKAAAgAAAADNAYAGEAAACmCgAAEQAAAAzQGABhAAAAqQoAABwAAAAM0BgAYQAAAKkKAAARAAAADNAYAGEAAAC/CgAAQwAAAAzQGABhAAAAvwoAABEAAAAM0BgAYQAAAKMLAAAuAAAADNAYAGEAAACvCwAACwAAAAzQGABhAAAAdwsAAB8AAAAM0BgAYQAAAGILAAAmAAAADNAYAGEAAABpCwAACwAAAAzQGABhAAAAawsAAA4AAABCAAAABAAAAAQAAABDAAAAQgAAAAQAAAAEAAAAQQAAAHRpbWVkb3dubGlmZWxlZnRiYWNrY29kZWRhdGFzaG93b25seXNpdGVjaXR5b3Blbmp1c3RsaWtlZnJlZXdvcmt0ZXh0eWVhcm92ZXJib2R5bG92ZWZvcm1ib29rcGxheWxpdmVsaW5laGVscGhvbWVzaWRlbW9yZXdvcmRsb25ndGhlbXZpZXdmaW5kcGFnZWRheXNmdWxsaGVhZHRlcm1lYWNoYXJlYWZyb210cnVlbWFya2FibGV1cG9uaGlnaGRhdGVsYW5kbmV3c2V2ZW5uZXh0Y2FzZWJvdGhwb3N0dXNlZG1hZGVoYW5kaGVyZXdoYXRuYW1lTGlua2Jsb2dzaXplYmFzZWhlbGRtYWtlbWFpbnVzZXInKSAraG9sZGVuZHN3aXRoTmV3c3JlYWR3ZXJlc2lnbnRha2VoYXZlZ2FtZXNlZW5jYWxscGF0aHdlbGxwbHVzbWVudWZpbG1wYXJ0am9pbnRoaXNsaXN0Z29vZG5lZWR3YXlzd2VzdGpvYnNtaW5kYWxzb2xvZ29yaWNodXNlc2xhc3R0ZWFtYXJteWZvb2RraW5nd2lsbGVhc3R3YXJkYmVzdGZpcmVQYWdla25vd2F3YXkucG5nbW92ZXRoYW5sb2FkZ2l2ZXNlbGZub3RlbXVjaGZlZWRtYW55cm9ja2ljb25vbmNlbG9va2hpZGVkaWVkSG9tZXJ1bGVob3N0YWpheGluZm9jbHVibGF3c2xlc3NoYWxmc29tZXN1Y2h6b25lMTAwJW9uZXNjYXJlVGltZXJhY2VibHVlZm91cndlZWtmYWNlaG9wZWdhdmVoYXJkbG9zdHdoZW5wYXJra2VwdHBhc3NzaGlwcm9vbUhUTUxwbGFuVHlwZWRvbmVzYXZla2VlcGZsYWdsaW5rc29sZGZpdmV0b29rcmF0ZXRvd25qdW1wdGh1c2RhcmtjYXJkZmlsZWZlYXJzdGF5a2lsbHRoYXRmYWxsYXV0b2V2ZXIuY29tdGFsa3Nob3B2b3RlZGVlcG1vZGVyZXN0dHVybmJvcm5iYW5kZmVsbHJvc2V1cmwoc2tpbnJvbGVjb21lYWN0c2FnZXNtZWV0Z29sZC5qcGdpdGVtdmFyeWZlbHR0aGVuc2VuZGRyb3BWaWV3Y29weTEuMCI8L2E+c3RvcGVsc2VsaWVzdG91cnBhY2suZ2lmcGFzdGNzcz9ncmF5bWVhbiZndDtyaWRlc2hvdGxhdGVzYWlkcm9hZHZhciBmZWVsam9obnJpY2twb3J0ZmFzdCdVQS1kZWFkPC9iPnBvb3JiaWxsdHlwZVUuUy53b29kbXVzdDJweDtJbmZvcmFua3dpZGV3YW50d2FsbGxlYWRbMF07cGF1bHdhdmVzdXJlJCgnI3dhaXRtYXNzYXJtc2dvZXNnYWlubGFuZ3BhaWQhLS0gbG9ja3VuaXRyb290d2Fsa2Zpcm13aWZleG1sInNvbmd0ZXN0MjBweGtpbmRyb3dzdG9vbGZvbnRtYWlsc2FmZXN0YXJtYXBzY29yZXJhaW5mbG93YmFieXNwYW5zYXlzNHB4OzZweDthcnRzZm9vdHJlYWx3aWtpaGVhdHN0ZXB0cmlwb3JnL2xha2V3ZWFrdG9sZEZvcm1jYXN0ZmFuc2Jhbmt2ZXJ5cnVuc2p1bHl0YXNrMXB4O2dvYWxncmV3c2xvd2VkZ2VpZD0ic2V0czVweDsuanM/NDBweGlmIChzb29uc2VhdG5vbmV0dWJlemVyb3NlbnRyZWVkZmFjdGludG9naWZ0aGFybTE4cHhjYW1laGlsbGJvbGR6b29tdm9pZGVhc3lyaW5nZmlsbHBlYWtpbml0Y29zdDNweDtqYWNrdGFnc2JpdHNyb2xsZWRpdGtuZXduZWFyPCEtLWdyb3dKU09OZHV0eU5hbWVzYWxleW91IGxvdHNwYWluamF6emNvbGRleWVzZmlzaHd3dy5yaXNrdGFic3ByZXYxMHB4cmlzZTI1cHhCbHVlZGluZzMwMCxiYWxsZm9yZGVhcm53aWxkYm94LmZhaXJsYWNrdmVyc3BhaXJqdW5ldGVjaGlmKCFwaWNrZXZpbCQoIiN3YXJtbG9yZGRvZXNwdWxsLDAwMGlkZWFkcmF3aHVnZXNwb3RmdW5kYnVybmhyZWZjZWxsa2V5c3RpY2tob3VybG9zc2Z1ZWwxMnB4c3VpdGRlYWxSU1MiYWdlZGdyZXlHRVQiZWFzZWFpbXNnaXJsYWlkczhweDtuYXZ5Z3JpZHRpcHMjOTk5d2Fyc2xhZHljYXJzKTsgfXBocD9oZWxsdGFsbHdob216aDrlKi8NCiAxMDBoYWxsLgoKQTdweDtwdXNoY2hhdDBweDtjcmV3Ki88L2hhc2g3NXB4ZmxhdHJhcmUgJiYgdGVsbGNhbXBvbnRvbGFpZG1pc3Nza2lwdGVudGZpbmVtYWxlZ2V0c3Bsb3Q0MDAsDQoNCmNvb2xmZWV0LnBocDxicj5lcmljbW9zdGd1aWRiZWxsZGVzY2hhaXJtYXRoYXRvbS9pbWcmIzgybHVja2NlbnQwMDA7dGlueWdvbmVodG1sc2VsbGRydWdGUkVFbm9kZW5pY2s/aWQ9bG9zZW51bGx2YXN0d2luZFJTUyB3ZWFycmVseWJlZW5zYW1lZHVrZW5hc2FjYXBld2lzaGd1bGZUMjM6aGl0c3Nsb3RnYXRla2lja2JsdXJ0aGV5MTVweCcnKTspOyI+bXNpZXdpbnNiaXJkc29ydGJldGFzZWVrVDE4Om9yZHN0cmVlbWFsbDYwcHhmYXJt4oCZc2JveXNbMF0uJyk7IlBPU1RiZWFya2lkcyk7fX1tYXJ5dGVuZChVSylxdWFkemg65i1zaXotLS0tcHJvcCcpOw1saWZ0VDE5OnZpY2VhbmR5ZGVidD5SU1Nwb29sbmVja2Jsb3dUMTY6ZG9vcmV2YWxUMTc6bGV0c2ZhaWxvcmFscG9sbG5vdmFjb2xzZ2VuZSDigJRzb2Z0cm9tZXRpbGxyb3NzPGgzPnBvdXJmYWRlcGluazx0cj5taW5pKXwhKG1pbmV6aDroYmFyc2hlYXIwMCk7bWlsayAtLT5pcm9uZnJlZGRpc2t3ZW50c29pbHB1dHMvanMvaG9seVQyMjpJU0JOVDIwOmFkYW1zZWVzPGgyPmpzb24nLCAnY29udFQyMTogUlNTbG9vcGFzaWFtb29uPC9wPnNvdWxMSU5FZm9ydGNhcnRUMTQ6PGgxPjgwcHghLS08OXB4O1QwNDptaWtlOjQ2Wm5pY2VpbmNoWW9ya3JpY2V6aDrkJykpO3B1cmVtYWdlcGFyYXRvbmVib25kOjM3Wl9vZl8nXSk7MDAwLHpoOud0YW5reWFyZGJvd2xidXNoOjU2WkphdmEzMHB4Cnx9CiVDMyU6MzRaamVmZkVYUEljYXNodmlzYWdvbGZzbm93emg66XF1ZXIuY3Nzc2lja21lYXRtaW4uYmluZGRlbGxoaXJlcGljc3JlbnQ6MzZaSFRUUC0yMDFmb3Rvd29sZkVORCB4Ym94OjU0WkJPRFlkaWNrOwp9CmV4aXQ6MzVadmFyc2JlYXQnfSk7ZGlldDk5OTthbm5lfX08L1tpXS5MYW5na23CsndpcmV0b3lzYWRkc3NlYWxhbGV4OwoJfWVjaG9uaW5lLm9yZzAwNSl0b255amV3c3NhbmRsZWdzcm9vZjAwMCkgMjAwd2luZWdlYXJkb2dzYm9vdGdhcnljdXRzdHlsZXRlbXB0aW9uLnhtbGNvY2tnYW5nJCgnLjUwcHhQaC5EbWlzY2FsYW5sb2FuZGVza21pbGVyeWFudW5peGRpc2MpO30KZHVzdGNsaXApLgoKNzBweC0yMDBEVkRzN10+PHRhcGVkZW1vaSsrKXdhZ2VldXJvcGhpbG9wdHNob2xlRkFRc2FzaW4tMjZUbGFic3BldHNVUkwgYnVsa2Nvb2s7fQ0KSEVBRFswXSlhYmJyanVhbigxOThsZXNodHdpbjwvaT5zb255Z3V5c2Z1Y2twaXBlfC0KITAwMiluZG93WzFdO1tdOwpMb2cgc2FsdA0KCQliYW5ndHJpbWJhdGgpew0KMDBweAp9KTtrbzrsZmVlc2FkPg1zOi8vIFtdO3RvbGxwbHVnKCl7CnsNCiAuanMnMjAwcGR1YWxib2F0LkpQRyk7Cn1xdW90KTsKCicpOwoNCn0NMjAxNDIwMTUyMDE2MjAxNzIwMTgyMDE5MjAyMDIwMjEyMDIyMjAyMzIwMjQyMDI1MjAyNjIwMjcyMDI4MjAyOTIwMzAyMDMxMjAzMjIwMzMyMDM0MjAzNTIwMzYyMDM3MjAxMzIwMTIyMDExMjAxMDIwMDkyMDA4MjAwNzIwMDYyMDA1MjAwNDIwMDMyMDAyMjAwMTIwMDAxOTk5MTk5ODE5OTcxOTk2MTk5NTE5OTQxOTkzMTk5MjE5OTExOTkwMTk4OTE5ODgxOTg3MTk4NjE5ODUxOTg0MTk4MzE5ODIxOTgxMTk4MDE5NzkxOTc4MTk3NzE5NzYxOTc1MTk3NDE5NzMxOTcyMTk3MTE5NzAxOTY5MTk2ODE5NjcxOTY2MTk2NTE5NjQxOTYzMTk2MjE5NjExOTYwMTk1OTE5NTgxOTU3MTk1NjE5NTUxOTU0MTk1MzE5NTIxOTUxMTk1MDEwMDAxMDI0MTM5NDAwMDA5OTk5Y29tb23DoXNlc3RlZXN0YXBlcm90b2RvaGFjZWNhZGFhw7FvYmllbmTDrWFhc8OtdmlkYWNhc29vdHJvZm9yb3NvbG9vdHJhY3VhbGRpam9zaWRvZ3JhbnRpcG90ZW1hZGViZWFsZ29xdcOpZXN0b25hZGF0cmVzcG9jb2Nhc2FiYWpvdG9kYXNpbm9hZ3VhcHVlc3Vub3NhbnRlZGljZWx1aXNlbGxhbWF5b3pvbmFhbW9ycGlzb29icmFjbGljZWxsb2Rpb3Nob3JhY2FzadC30LDQvdCw0L7QvNGA0LDRgNGD0YLQsNC90LXQv9C+0L7RgtC40LfQvdC+0LTQvtGC0L7QttC10L7QvdC40YXQndCw0LXQtdCx0YvQvNGL0JLRi9GB0L7QstGL0LLQvtCd0L7QvtCx0J/QvtC70LjQvdC40KDQpNCd0LXQnNGL0YLRi9Ce0L3QuNC80LTQsNCX0LDQlNCw0J3Rg9Ce0LHRgtC10JjQt9C10LnQvdGD0LzQvNCi0YvRg9C22YHZitij2YbZhdin2YXYudmD2YTYo9mI2LHYr9mK2KfZgdmJ2YfZiNmE2YXZhNmD2KfZiNmE2YfYqNiz2KfZhNil2YbZh9mK2KPZitmC2K/Zh9mE2KvZhdio2YfZhNmI2YTZitio2YTYp9mK2KjZg9i02YrYp9mF2KPZhdmG2KrYqNmK2YTZhtit2KjZh9mF2YXYtNmI2LRmaXJzdHZpZGVvbGlnaHR3b3JsZG1lZGlhd2hpdGVjbG9zZWJsYWNrcmlnaHRzbWFsbGJvb2tzcGxhY2VtdXNpY2ZpZWxkb3JkZXJwb2ludHZhbHVlbGV2ZWx0YWJsZWJvYXJkaG91c2Vncm91cHdvcmtzeWVhcnNzdGF0ZXRvZGF5d2F0ZXJzdGFydHN0eWxlZGVhdGhwb3dlcnBob25lbmlnaHRlcnJvcmlucHV0YWJvdXR0ZXJtc3RpdGxldG9vbHNldmVudGxvY2FsdGltZXNsYXJnZXdvcmRzZ2FtZXNzaG9ydHNwYWNlZm9jdXNjbGVhcm1vZGVsYmxvY2tndWlkZXJhZGlvc2hhcmV3b21lbmFnYWlubW9uZXlpbWFnZW5hbWVzeW91bmdsaW5lc2xhdGVyY29sb3JncmVlbmZyb250JmFtcDt3YXRjaGZvcmNlcHJpY2VydWxlc2JlZ2luYWZ0ZXJ2aXNpdGlzc3VlYXJlYXNiZWxvd2luZGV4dG90YWxob3Vyc2xhYmVscHJpbnRwcmVzc2J1aWx0bGlua3NzcGVlZHN0dWR5dHJhZGVmb3VuZHNlbnNldW5kZXJzaG93bmZvcm1zcmFuZ2VhZGRlZHN0aWxsbW92ZWR0YWtlbmFib3ZlZmxhc2hmaXhlZG9mdGVub3RoZXJ2aWV3c2NoZWNrbGVnYWxyaXZlcml0ZW1zcXVpY2tzaGFwZWh1bWFuZXhpc3Rnb2luZ21vdmlldGhpcmRiYXNpY3BlYWNlc3RhZ2V3aWR0aGxvZ2luaWRlYXN3cm90ZXBhZ2VzdXNlcnNkcml2ZXN0b3JlYnJlYWtzb3V0aHZvaWNlc2l0ZXNtb250aHdoZXJlYnVpbGR3aGljaGVhcnRoZm9ydW10aHJlZXNwb3J0cGFydHlDbGlja2xvd2VybGl2ZXNjbGFzc2xheWVyZW50cnlzdG9yeXVzYWdlc291bmRjb3VydHlvdXIgYmlydGhwb3B1cHR5cGVzYXBwbHlJbWFnZWJlaW5ndXBwZXJub3Rlc2V2ZXJ5c2hvd3NtZWFuc2V4dHJhbWF0Y2h0cmFja2tub3duZWFybHliZWdhbnN1cGVycGFwZXJub3J0aGxlYXJuZ2l2ZW5uYW1lZGVuZGVkVGVybXNwYXJ0c0dyb3VwYnJhbmR1c2luZ3dvbWFuZmFsc2VyZWFkeWF1ZGlvdGFrZXN3aGlsZS5jb20vbGl2ZWRjYXNlc2RhaWx5Y2hpbGRncmVhdGp1ZGdldGhvc2V1bml0c25ldmVyYnJvYWRjb2FzdGNvdmVyYXBwbGVmaWxlc2N5Y2xlc2NlbmVwbGFuc2NsaWNrd3JpdGVxdWVlbnBpZWNlZW1haWxmcmFtZW9sZGVycGhvdG9saW1pdGNhY2hlY2l2aWxzY2FsZWVudGVydGhlbWV0aGVyZXRvdWNoYm91bmRyb3lhbGFza2Vkd2hvbGVzaW5jZXN0b2NrIG5hbWVmYWl0aGhlYXJ0ZW1wdHlvZmZlcnNjb3Blb3duZWRtaWdodGFsYnVtdGhpbmtibG9vZGFycmF5bWFqb3J0cnVzdGNhbm9udW5pb25jb3VudHZhbGlkc3RvbmVTdHlsZUxvZ2luaGFwcHlvY2N1cmxlZnQ6ZnJlc2hxdWl0ZWZpbG1zZ3JhZGVuZWVkc3VyYmFuZmlnaHRiYXNpc2hvdmVyYXV0bztyb3V0ZS5odG1sbWl4ZWRmaW5hbFlvdXIgc2xpZGV0b3BpY2Jyb3duYWxvbmVkcmF3bnNwbGl0cmVhY2hSaWdodGRhdGVzbWFyY2hxdW90ZWdvb2RzTGlua3Nkb3VidGFzeW5jdGh1bWJhbGxvd2NoaWVmeW91dGhub3ZlbDEwcHg7c2VydmV1bnRpbGhhbmRzQ2hlY2tTcGFjZXF1ZXJ5amFtZXNlcXVhbHR3aWNlMCwwMDBTdGFydHBhbmVsc29uZ3Nyb3VuZGVpZ2h0c2hpZnR3b3J0aHBvc3RzbGVhZHN3ZWVrc2F2b2lkdGhlc2VtaWxlc3BsYW5lc21hcnRhbHBoYXBsYW50bWFya3NyYXRlc3BsYXlzY2xhaW1zYWxlc3RleHRzc3RhcnN3cm9uZzwvaDM+dGhpbmcub3JnL211bHRpaGVhcmRQb3dlcnN0YW5kdG9rZW5zb2xpZCh0aGlzYnJpbmdzaGlwc3N0YWZmdHJpZWRjYWxsc2Z1bGx5ZmFjdHNhZ2VudFRoaXMgLy8tLT5hZG1pbmVneXB0RXZlbnQxNXB4O0VtYWlsdHJ1ZSJjcm9zc3NwZW50YmxvZ3Nib3giPm5vdGVkbGVhdmVjaGluYXNpemVzZ3Vlc3Q8L2g0PnJvYm90aGVhdnl0cnVlLHNldmVuZ3JhbmRjcmltZXNpZ25zYXdhcmVkYW5jZXBoYXNlPjwhLS1lbl9VUyYjMzk7MjAwcHhfbmFtZWxhdGluZW5qb3lhamF4LmF0aW9uc21pdGhVLlMuIGhvbGRzcGV0ZXJpbmRpYW5hdiI+Y2hhaW5zY29yZWNvbWVzZG9pbmdwcmlvclNoYXJlMTk5MHNyb21hbmxpc3RzamFwYW5mYWxsc3RyaWFsb3duZXJhZ3JlZTwvaDI+YWJ1c2VhbGVydG9wZXJhIi0vL1djYXJkc2hpbGxzdGVhbXNQaG90b3RydXRoY2xlYW4ucGhwP3NhaW50bWV0YWxsb3Vpc21lYW50cHJvb2ZicmllZnJvdyI+Z2VucmV0cnVja2xvb2tzVmFsdWVGcmFtZS5uZXQvLS0+Cjx0cnkgewp2YXIgbWFrZXNjb3N0c3BsYWluYWR1bHRxdWVzdHRyYWlubGFib3JoZWxwc2NhdXNlbWFnaWNtb3RvcnRoZWlyMjUwcHhsZWFzdHN0ZXBzQ291bnRjb3VsZGdsYXNzc2lkZXNmdW5kc2hvdGVsYXdhcmRtb3V0aG1vdmVzcGFyaXNnaXZlc2R1dGNodGV4YXNmcnVpdG51bGwsfHxbXTt0b3AiPgo8IS0tUE9TVCJvY2Vhbjxici8+Zmxvb3JzcGVha2RlcHRoIHNpemViYW5rc2NhdGNoY2hhcnQyMHB4O2FsaWduZGVhbHN3b3VsZDUwcHg7dXJsPSJwYXJrc21vdXNlTW9zdCAuLi48L2Ftb25nYnJhaW5ib2R5IG5vbmU7YmFzZWRjYXJyeWRyYWZ0cmVmZXJwYWdlX2hvbWUubWV0ZXJkZWxheWRyZWFtcHJvdmVqb2ludDwvdHI+ZHJ1Z3M8IS0tIGFwcmlsaWRlYWxhbGxlbmV4YWN0Zm9ydGhjb2Rlc2xvZ2ljVmlldyBzZWVtc2JsYW5rcG9ydHMgKDIwMHNhdmVkX2xpbmtnb2Fsc2dyYW50Z3JlZWtob21lc3JpbmdzcmF0ZWQzMHB4O3dob3NlcGFyc2UoKTsiIEJsb2NrbGludXhqb25lc3BpeGVsJyk7Ij4pO2lmKC1sZWZ0ZGF2aWRob3JzZUZvY3VzcmFpc2Vib3hlc1RyYWNrZW1lbnQ8L2VtPmJhciI+LnNyYz10b3dlcmFsdD0iY2FibGVoZW5yeTI0cHg7c2V0dXBpdGFseXNoYXJwbWlub3J0YXN0ZXdhbnRzdGhpcy5yZXNldHdoZWVsZ2lybHMvY3NzLzEwMCU7Y2x1YnNzdHVmZmJpYmxldm90ZXMgMTAwMGtvcmVhfSk7DQpiYW5kc3F1ZXVlPSB7fTs4MHB4O2NraW5new0KCQlhaGVhZGNsb2NraXJpc2hsaWtlIHJhdGlvc3RhdHNGb3JtInlhaG9vKVswXTtBYm91dGZpbmRzPC9oMT5kZWJ1Z3Rhc2tzVVJMID1jZWxsc30pKCk7MTJweDtwcmltZXRlbGxzdHVybnMweDYwMC5qcGcic3BhaW5iZWFjaHRheGVzbWljcm9hbmdlbC0tPjwvZ2lmdHNzdGV2ZS1saW5rYm9keS59KTsKCW1vdW50ICgxOTlGQVE8L3JvZ2VyZnJhbmtDbGFzczI4cHg7ZmVlZHM8aDE+PHNjb3R0dGVzdHMyMnB4O2RyaW5rKSB8fCBsZXdpc3NoYWxsIzAzOTsgZm9yIGxvdmVkd2FzdGUwMHB4O2phOuOCc2ltb248Zm9udHJlcGx5bWVldHN1bnRlcmNoZWFwdGlnaHRCcmFuZCkgIT0gZHJlc3NjbGlwc3Jvb21zb25rZXltb2JpbG1haW4uTmFtZSBwbGF0ZWZ1bm55dHJlZXNjb20vIjEuanBnd21vZGVwYXJhbVNUQVJUbGVmdCBpZGRlbiwgMjAxKTsKfQpmb3JtLnZpcnVzY2hhaXJ0cmFuc3dvcnN0UGFnZXNpdGlvbnBhdGNoPCEtLQpvLWNhY2Zpcm1zdG91cnMsMDAwIGFzaWFuaSsrKXthZG9iZScpWzBdaWQ9MTBib3RoO21lbnUgLjIubWkucG5nImtldmluY29hY2hDaGlsZGJydWNlMi5qcGdVUkwpKy5qcGd8c3VpdGVzbGljZWhhcnJ5MTIwIiBzd2VldHRyPg0KbmFtZT1kaWVnb3BhZ2Ugc3dpc3MtLT4KCiNmZmY7Ij5Mb2cuY29tInRyZWF0c2hlZXQpICYmIDE0cHg7c2xlZXBudGVudGZpbGVkamE644NpZD0iY05hbWUid29yc2VzaG90cy1ib3gtZGVsdGEKJmx0O2JlYXJzOjQ4WjxkYXRhLXJ1cmFsPC9hPiBzcGVuZGJha2Vyc2hvcHM9ICIiO3BocCI+Y3Rpb24xM3B4O2JyaWFuaGVsbG9zaXplPW89JTJGIGpvaW5tYXliZTxpbWcgaW1nIj4sIGZqc2ltZyIgIilbMF1NVG9wQlR5cGUibmV3bHlEYW5za2N6ZWNodHJhaWxrbm93czwvaDU+ZmFxIj56aC1jbjEwKTsKLTEiKTt0eXBlPWJsdWVzdHJ1bHlkYXZpcy5qcyc7Pg0KPCFzdGVlbCB5b3UgaDI+DQpmb3JtIGplc3VzMTAwJSBtZW51Lg0KCQ0Kd2FsZXNyaXNrc3VtZW50ZGRpbmdiLWxpa3RlYWNoZ2lmIiB2ZWdhc2RhbnNrZWVzdGlzaHFpcHN1b21pc29icmVkZXNkZWVudHJldG9kb3NwdWVkZWHDsW9zZXN0w6F0aWVuZWhhc3Rhb3Ryb3NwYXJ0ZWRvbmRlbnVldm9oYWNlcmZvcm1hbWlzbW9tZWpvcm11bmRvYXF1w61kw61hc3PDs2xvYXl1ZGFmZWNoYXRvZGFzdGFudG9tZW5vc2RhdG9zb3RyYXNzaXRpb211Y2hvYWhvcmFsdWdhcm1heW9yZXN0b3Nob3Jhc3RlbmVyYW50ZXNmb3Rvc2VzdGFzcGHDrXNudWV2YXNhbHVkZm9yb3NtZWRpb3F1aWVubWVzZXNwb2RlcmNoaWxlc2Vyw6F2ZWNlc2RlY2lyam9zw6llc3RhcnZlbnRhZ3J1cG9oZWNob2VsbG9zdGVuZ29hbWlnb2Nvc2Fzbml2ZWxnZW50ZW1pc21hYWlyZXNqdWxpb3RlbWFzaGFjaWFmYXZvcmp1bmlvbGlicmVwdW50b2J1ZW5vYXV0b3JhYnJpbGJ1ZW5hdGV4dG9tYXJ6b3NhYmVybGlzdGFsdWVnb2PDs21vZW5lcm9qdWVnb3BlcsO6aGFiZXJlc3RveW51bmNhbXVqZXJ2YWxvcmZ1ZXJhbGlicm9ndXN0YWlndWFsdm90b3NjYXNvc2d1w61hcHVlZG9zb21vc2F2aXNvdXN0ZWRkZWJlbm5vY2hlYnVzY2FmYWx0YWV1cm9zc2VyaWVkaWNob2N1cnNvY2xhdmVjYXNhc2xlw7NucGxhem9sYXJnb29icmFzdmlzdGFhcG95b2p1bnRvdHJhdGF2aXN0b2NyZWFyY2FtcG9oZW1vc2NpbmNvY2FyZ29waXNvc29yZGVuaGFjZW7DoXJlYWRpc2NvcGVkcm9jZXJjYXB1ZWRhcGFwZWxtZW5vcsO6dGlsY2xhcm9qb3JnZWNhbGxlcG9uZXJ0YXJkZW5hZGllbWFyY2FzaWd1ZWVsbGFzc2lnbG9jb2NoZW1vdG9zbWFkcmVjbGFzZXJlc3RvbmnDsW9xdWVkYXBhc2FyYmFuY29oaWpvc3ZpYWplcGFibG/DqXN0ZXZpZW5lcmVpbm9kZWphcmZvbmRvY2FuYWxub3J0ZWxldHJhY2F1c2F0b21hcm1hbm9zbHVuZXNhdXRvc3ZpbGxhdmVuZG9wZXNhcnRpcG9zdGVuZ2FtYXJjb2xsZXZhcGFkcmV1bmlkb3ZhbW9zem9uYXNhbWJvc2JhbmRhbWFyaWFhYnVzb211Y2hhc3ViaXJyaW9qYXZpdmlyZ3JhZG9jaGljYWFsbMOtam92ZW5kaWNoYWVzdGFudGFsZXNzYWxpcnN1ZWxvcGVzb3NmaW5lc2xsYW1hYnVzY2/DqXN0YWxsZWdhbmVncm9wbGF6YWh1bW9ycGFnYXJqdW50YWRvYmxlaXNsYXNib2xzYWJhw7FvaGFibGFsdWNoYcOBcmVhZGljZW5qdWdhcm5vdGFzdmFsbGVhbGzDoWNhcmdhZG9sb3JhYmFqb2VzdMOpZ3VzdG9tZW50ZW1hcmlvZmlybWFjb3N0b2ZpY2hhcGxhdGFob2dhcmFydGVzbGV5ZXNhcXVlbG11c2VvYmFzZXNwb2Nvc21pdGFkY2llbG9jaGljb21pZWRvZ2FuYXJzYW50b2V0YXBhZGViZXNwbGF5YXJlZGVzc2lldGVjb3J0ZWNvcmVhZHVkYXNkZXNlb3ZpZWpvZGVzZWFhZ3VhcyZxdW90O2RvbWFpbmNvbW1vbnN0YXR1c2V2ZW50c21hc3RlcnN5c3RlbWFjdGlvbmJhbm5lcnJlbW92ZXNjcm9sbHVwZGF0ZWdsb2JhbG1lZGl1bWZpbHRlcm51bWJlcmNoYW5nZXJlc3VsdHB1YmxpY3NjcmVlbmNob29zZW5vcm1hbHRyYXZlbGlzc3Vlc3NvdXJjZXRhcmdldHNwcmluZ21vZHVsZW1vYmlsZXN3aXRjaHBob3Rvc2JvcmRlcnJlZ2lvbml0c2VsZnNvY2lhbGFjdGl2ZWNvbHVtbnJlY29yZGZvbGxvd3RpdGxlPmVpdGhlcmxlbmd0aGZhbWlseWZyaWVuZGxheW91dGF1dGhvcmNyZWF0ZXJldmlld3N1bW1lcnNlcnZlcnBsYXllZHBsYXllcmV4cGFuZHBvbGljeWZvcm1hdGRvdWJsZXBvaW50c3Nlcmllc3BlcnNvbmxpdmluZ2Rlc2lnbm1vbnRoc2ZvcmNlc3VuaXF1ZXdlaWdodHBlb3BsZWVuZXJneW5hdHVyZXNlYXJjaGZpZ3VyZWhhdmluZ2N1c3RvbW9mZnNldGxldHRlcndpbmRvd3N1Ym1pdHJlbmRlcmdyb3Vwc3VwbG9hZGhlYWx0aG1ldGhvZHZpZGVvc3NjaG9vbGZ1dHVyZXNoYWRvd2RlYmF0ZXZhbHVlc09iamVjdG90aGVyc3JpZ2h0c2xlYWd1ZWNocm9tZXNpbXBsZW5vdGljZXNoYXJlZGVuZGluZ3NlYXNvbnJlcG9ydG9ubGluZXNxdWFyZWJ1dHRvbmltYWdlc2VuYWJsZW1vdmluZ2xhdGVzdHdpbnRlckZyYW5jZXBlcmlvZHN0cm9uZ3JlcGVhdExvbmRvbmRldGFpbGZvcm1lZGRlbWFuZHNlY3VyZXBhc3NlZHRvZ2dsZXBsYWNlc2RldmljZXN0YXRpY2NpdGllc3N0cmVhbXllbGxvd2F0dGFja3N0cmVldGZsaWdodGhpZGRlbmluZm8iPm9wZW5lZHVzZWZ1bHZhbGxleWNhdXNlc2xlYWRlcnNlY3JldHNlY29uZGRhbWFnZXNwb3J0c2V4Y2VwdHJhdGluZ3NpZ25lZHRoaW5nc2VmZmVjdGZpZWxkc3N0YXRlc29mZmljZXZpc3VhbGVkaXRvcnZvbHVtZVJlcG9ydG11c2V1bW1vdmllc3BhcmVudGFjY2Vzc21vc3RseW1vdGhlciIgaWQ9Im1hcmtldGdyb3VuZGNoYW5jZXN1cnZleWJlZm9yZXN5bWJvbG1vbWVudHNwZWVjaG1vdGlvbmluc2lkZW1hdHRlckNlbnRlcm9iamVjdGV4aXN0c21pZGRsZUV1cm9wZWdyb3d0aGxlZ2FjeW1hbm5lcmVub3VnaGNhcmVlcmFuc3dlcm9yaWdpbnBvcnRhbGNsaWVudHNlbGVjdHJhbmRvbWNsb3NlZHRvcGljc2NvbWluZ2ZhdGhlcm9wdGlvbnNpbXBseXJhaXNlZGVzY2FwZWNob3NlbmNodXJjaGRlZmluZXJlYXNvbmNvcm5lcm91dHB1dG1lbW9yeWlmcmFtZXBvbGljZW1vZGVsc051bWJlcmR1cmluZ29mZmVyc3N0eWxlc2tpbGxlZGxpc3RlZGNhbGxlZHNpbHZlcm1hcmdpbmRlbGV0ZWJldHRlcmJyb3dzZWxpbWl0c0dsb2JhbHNpbmdsZXdpZGdldGNlbnRlcmJ1ZGdldG5vd3JhcGNyZWRpdGNsYWltc2VuZ2luZXNhZmV0eWNob2ljZXNwaXJpdC1zdHlsZXNwcmVhZG1ha2luZ25lZWRlZHJ1c3NpYXBsZWFzZWV4dGVudFNjcmlwdGJyb2tlbmFsbG93c2NoYXJnZWRpdmlkZWZhY3Rvcm1lbWJlci1iYXNlZHRoZW9yeWNvbmZpZ2Fyb3VuZHdvcmtlZGhlbHBlZENodXJjaGltcGFjdHNob3VsZGFsd2F5c2xvZ28iIGJvdHRvbWxpc3QiPil7dmFyIHByZWZpeG9yYW5nZUhlYWRlci5wdXNoKGNvdXBsZWdhcmRlbmJyaWRnZWxhdW5jaFJldmlld3Rha2luZ3Zpc2lvbmxpdHRsZWRhdGluZ0J1dHRvbmJlYXV0eXRoZW1lc2ZvcmdvdFNlYXJjaGFuY2hvcmFsbW9zdGxvYWRlZENoYW5nZXJldHVybnN0cmluZ3JlbG9hZE1vYmlsZWluY29tZXN1cHBseVNvdXJjZW9yZGVyc3ZpZXdlZCZuYnNwO2NvdXJzZUFib3V0IGlzbGFuZDxodG1sIGNvb2tpZW5hbWU9ImFtYXpvbm1vZGVybmFkdmljZWluPC9hPjogVGhlIGRpYWxvZ2hvdXNlc0JFR0lOIE1leGljb3N0YXJ0c2NlbnRyZWhlaWdodGFkZGluZ0lzbGFuZGFzc2V0c0VtcGlyZVNjaG9vbGVmZm9ydGRpcmVjdG5lYXJseW1hbnVhbFNlbGVjdC4KCk9uZWpvaW5lZG1lbnUiPlBoaWxpcGF3YXJkc2hhbmRsZWltcG9ydE9mZmljZXJlZ2FyZHNraWxsc25hdGlvblNwb3J0c2RlZ3JlZXdlZWtseSAoZS5nLmJlaGluZGRvY3RvcmxvZ2dlZHVuaXRlZDwvYj48L2JlZ2luc3BsYW50c2Fzc2lzdGFydGlzdGlzc3VlZDMwMHB4fGNhbmFkYWFnZW5jeXNjaGVtZXJlbWFpbkJyYXppbHNhbXBsZWxvZ28iPmJleW9uZC1zY2FsZWFjY2VwdHNlcnZlZG1hcmluZUZvb3RlcmNhbWVyYTwvaDE+Cl9mb3JtImxlYXZlc3N0cmVzcyIgLz4NCi5naWYiIG9ubG9hZGxvYWRlck94Zm9yZHNpc3RlcnN1cnZpdmxpc3RlbmZlbWFsZURlc2lnbnNpemU9ImFwcGVhbHRleHQiPmxldmVsc3RoYW5rc2hpZ2hlcmZvcmNlZGFuaW1hbGFueW9uZUFmcmljYWFncmVlZHJlY2VudFBlb3BsZTxiciAvPndvbmRlcnByaWNlc3R1cm5lZHx8IHt9O21haW4iPmlubGluZXN1bmRheXdyYXAiPmZhaWxlZGNlbnN1c21pbnV0ZWJlYWNvbnF1b3RlczE1MHB4fGVzdGF0ZXJlbW90ZWVtYWlsImxpbmtlZHJpZ2h0O3NpZ25hbGZvcm1hbDEuaHRtbHNpZ251cHByaW5jZWZsb2F0Oi5wbmciIGZvcnVtLkFjY2Vzc3BhcGVyc3NvdW5kc2V4dGVuZEhlaWdodHNsaWRlclVURi04IiZhbXA7IEJlZm9yZS4gV2l0aHN0dWRpb293bmVyc21hbmFnZXByb2ZpdGpRdWVyeWFubnVhbHBhcmFtc2JvdWdodGZhbW91c2dvb2dsZWxvbmdlcmkrKykge2lzcmFlbHNheWluZ2RlY2lkZWhvbWUiPmhlYWRlcmVuc3VyZWJyYW5jaHBpZWNlc2Jsb2NrO3N0YXRlZHRvcCI+PHJhY2luZ3Jlc2l6ZS0tJmd0O3BhY2l0eXNleHVhbGJ1cmVhdS5qcGciIDEwLDAwMG9idGFpbnRpdGxlc2Ftb3VudCwgSW5jLmNvbWVkeW1lbnUiIGx5cmljc3RvZGF5LmluZGVlZGNvdW50eV9sb2dvLkZhbWlseWxvb2tlZE1hcmtldGxzZSBpZlBsYXllcnR1cmtleSk7dmFyIGZvcmVzdGdpdmluZ2Vycm9yc0RvbWFpbn1lbHNle2luc2VydEJsb2c8L2Zvb3RlcmxvZ2luLmZhc3RlcmFnZW50czxib2R5IDEwcHggMHByYWdtYWZyaWRheWp1bmlvcmRvbGxhcnBsYWNlZGNvdmVyc3BsdWdpbjUsMDAwIHBhZ2UiPmJvc3Rvbi50ZXN0KGF2YXRhcnRlc3RlZF9jb3VudGZvcnVtc3NjaGVtYWluZGV4LGZpbGxlZHNoYXJlc3JlYWRlcmFsZXJ0KGFwcGVhclN1Ym1pdGxpbmUiPmJvZHkiPgoqIFRoZVRob3VnaHNlZWluZ2plcnNleU5ld3M8L3ZlcmlmeWV4cGVydGluanVyeXdpZHRoPUNvb2tpZVNUQVJUIGFjcm9zc19pbWFnZXRocmVhZG5hdGl2ZXBvY2tldGJveCI+ClN5c3RlbSBEYXZpZGNhbmNlcnRhYmxlc3Byb3ZlZEFwcmlsIHJlYWxseWRyaXZlcml0ZW0iPm1vcmUiPmJvYXJkc2NvbG9yc2NhbXB1c2ZpcnN0IHx8IFtdO21lZGlhLmd1aXRhcmZpbmlzaHdpZHRoOnNob3dlZE90aGVyIC5waHAiIGFzc3VtZWxheWVyc3dpbHNvbnN0b3Jlc3JlbGllZnN3ZWRlbkN1c3RvbWVhc2lseSB5b3VyIFN0cmluZwoKV2hpbHRheWxvcmNsZWFyOnJlc29ydGZyZW5jaHRob3VnaCIpICsgIjxib2R5PmJ1eWluZ2JyYW5kc01lbWJlcm5hbWUiPm9wcGluZ3NlY3RvcjVweDsiPnZzcGFjZXBvc3Rlcm1ham9yIGNvZmZlZW1hcnRpbm1hdHVyZWhhcHBlbjwvbmF2PmthbnNhc2xpbmsiPkltYWdlcz1mYWxzZXdoaWxlIGhzcGFjZTAmYW1wOyAKCkluICBwb3dlclBvbHNraS1jb2xvcmpvcmRhbkJvdHRvbVN0YXJ0IC1jb3VudDIuaHRtbG5ld3MiPjAxLmpwZ09ubGluZS1yaWdodG1pbGxlcnNlbmlvcklTQk4gMDAsMDAwIGd1aWRlc3ZhbHVlKWVjdGlvbnJlcGFpci54bWwiICByaWdodHMuaHRtbC1ibG9ja3JlZ0V4cDpob3ZlcndpdGhpbnZpcmdpbnBob25lczwvdHI+DXVzaW5nIAoJdmFyID4nKTsKCTwvdGQ+CjwvdHI+CmJhaGFzYWJyYXNpbGdhbGVnb21hZ3lhcnBvbHNraXNycHNradix2K/ZiOS4reaWh+eugOS9k+e5gemrlOS/oeaBr+S4reWbveaIkeS7rOS4gOS4quWFrOWPuOeuoeeQhuiuuuWdm+WPr+S7peacjeWKoeaXtumXtOS4quS6uuS6p+WTgeiHquW3seS8geS4muafpeeci+W3peS9nOiBlOezu+ayoeaciee9keermeaJgOacieivhOiuuuS4reW/g+aWh+eroOeUqOaIt+mmlumhteS9nOiAheaKgOacr+mXrumimOebuOWFs+S4i+i9veaQnOe0ouS9v+eUqOi9r+S7tuWcqOe6v+S4u+mimOi1hOaWmeinhumikeWbnuWkjeazqOWGjOe9kee7nOaUtuiXj+WGheWuueaOqOiNkOW4guWcuua2iOaBr+epuumXtOWPkeW4g+S7gOS5iOWlveWPi+eUn+a0u+WbvueJh+WPkeWxleWmguaenOaJi+acuuaWsOmXu+acgOaWsOaWueW8j+WMl+S6rOaPkOS+m+WFs+S6juabtOWkmui/meS4quezu+e7n+efpemBk+a4uOaIj+W5v+WRiuWFtuS7luWPkeihqOWuieWFqOesrOS4gOS8muWRmOi/m+ihjOeCueWHu+eJiOadg+eUteWtkOS4lueVjOiuvuiuoeWFjei0ueaVmeiCsuWKoOWFpea0u+WKqOS7luS7rOWVhuWTgeWNmuWuoueOsOWcqOS4iua1t+WmguS9leW3sue7j+eVmeiogOivpue7huekvuWMuueZu+W9leacrOermemcgOimgeS7t+agvOaUr+aMgeWbvemZhemTvuaOpeWbveWutuW7uuiuvuaci+WPi+mYheivu+azleW+i+S9jee9rue7j+a1jumAieaLqei/meagt+W9k+WJjeWIhuexu+aOkuihjOWboOS4uuS6pOaYk+acgOWQjumfs+S5kOS4jeiDvemAmui/h+ihjOS4muenkeaKgOWPr+iDveiuvuWkh+WQiOS9nOWkp+WutuekvuS8mueglOeptuS4k+S4muWFqOmDqOmhueebrui/memHjOi/mOaYr+W8gOWni+aDheWGteeUteiEkeaWh+S7tuWTgeeJjOW4ruWKqeaWh+WMlui1hOa6kOWkp+WtpuWtpuS5oOWcsOWdgOa1j+iniOaKlei1hOW3peeoi+imgeaxguaAjuS5iOaXtuWAmeWKn+iDveS4u+imgeebruWJjei1hOiur+WfjuW4guaWueazleeUteW9seaLm+iBmOWjsOaYjuS7u+S9leWBpeW6t+aVsOaNrue+juWbveaxvei9puS7i+e7jeS9huaYr+S6pOa1geeUn+S6p+aJgOS7peeUteivneaYvuekuuS4gOS6m+WNleS9jeS6uuWRmOWIhuaekOWcsOWbvuaXhea4uOW3peWFt+WtpueUn+ezu+WIl+e9keWPi+W4luWtkOWvhueggemikemBk+aOp+WItuWcsOWMuuWfuuacrOWFqOWbvee9keS4iumHjeimgeesrOS6jOWWnOasoui/m+WFpeWPi+aDhei/meS6m+iAg+ivleWPkeeOsOWfueiureS7peS4iuaUv+W6nOaIkOS4uueOr+Wig+mmmea4r+WQjOaXtuWoseS5kOWPkemAgeS4gOWumuW8gOWPkeS9nOWTgeagh+WHhuasoui/juino+WGs+WcsOaWueS4gOS4i+S7peWPiui0o+S7u+aIluiAheWuouaIt+S7o+ihqOenr+WIhuWls+S6uuaVsOeggemUgOWUruWHuueOsOemu+e6v+W6lOeUqOWIl+ihqOS4jeWQjOe8lui+kee7n+iuoeafpeivouS4jeimgeacieWFs+acuuaehOW+iOWkmuaSreaUvue7hOe7h+aUv+etluebtOaOpeiDveWKm+adpea6kOaZgumWk+eci+WIsOeDremXqOWFs+mUruS4k+WMuumdnuW4uOiLseivreeZvuW6puW4jOacm+e+juWls+avlOi+g+efpeivhuinhOWumuW7uuiurumDqOmXqOaEj+ingeeyvuW9qeaXpeacrOaPkOmrmOWPkeiogOaWuemdouWfuumHkeWkhOeQhuadg+mZkOW9seeJh+mTtuihjOi/mOacieWIhuS6q+eJqeWTgee7j+iQpea3u+WKoOS4k+Wutui/meenjeivnemimOi1t+adpeS4muWKoeWFrOWRiuiusOW9leeugOS7i+i0qOmHj+eUt+S6uuW9seWTjeW8leeUqOaKpeWRiumDqOWIhuW/q+mAn+WSqOivouaXtuWwmuazqOaEj+eUs+ivt+WtpuagoeW6lOivpeWOhuWPsuWPquaYr+i/lOWbnui0reS5sOWQjeensOS4uuS6huaIkOWKn+ivtOaYjuS+m+W6lOWtqeWtkOS4k+mimOeoi+W6j+S4gOiIrOacg+WToeWPquacieWFtuWug+S/neaKpOiAjOS4lOS7iuWkqeeql+WPo+WKqOaAgeeKtuaAgeeJueWIq+iupOS4uuW/hemhu+abtOaWsOWwj+ivtOaIkeWAkeS9nOS4uuWqkuS9k+WMheaLrOmCo+S5iOS4gOagt+WbveWGheaYr+WQpuagueaNrueUteinhuWtpumZouWFt+aciei/h+eoi+eUseS6juS6uuaJjeWHuuadpeS4jei/h+ato+WcqOaYjuaYn+aVheS6i+WFs+ezu+agh+mimOWVhuWKoei+k+WFpeS4gOebtOWfuuehgOaVmeWtpuS6huino+W7uuetkee7k+aenOWFqOeQg+mAmuefpeiuoeWIkuWvueS6juiJuuacr+ebuOWGjOWPkeeUn+ecn+eahOW7uueri+etiee6p+exu+Wei+e7j+mqjOWunueOsOWItuS9nOadpeiHquagh+etvuS7peS4i+WOn+WIm+aXoOazleWFtuS4reWAi+S6uuS4gOWIh+aMh+WNl+WFs+mXrembhuWbouesrOS4ieWFs+azqOWboOatpOeFp+eJh+a3seWcs+WVhuS4muW5v+W3nuaXpeacn+mrmOe6p+acgOi/kee7vOWQiOihqOekuuS4k+i+keihjOS4uuS6pOmAmuivhOS7t+inieW+l+eyvuWNjuWutuW6reWujOaIkOaEn+inieWuieijheW+l+WIsOmCruS7tuWItuW6pumjn+WTgeiZveeEtui9rOi9veaKpeS7t+iusOiAheaWueahiOihjOaUv+S6uuawkeeUqOWTgeS4nOilv+aPkOWHuumFkuW6l+eEtuWQjuS7mOasvueDreeCueS7peWJjeWujOWFqOWPkeW4luiuvue9rumihuWvvOW3peS4muWMu+mZoueci+eci+e7j+WFuOWOn+WboOW5s+WPsOWQhOenjeWinuWKoOadkOaWmeaWsOWinuS5i+WQjuiBjOS4muaViOaenOS7iuW5tOiuuuaWh+aIkeWbveWRiuivieeJiOS4u+S/ruaUueWPguS4juaJk+WNsOW/q+S5kOacuuaisOingueCueWtmOWcqOeyvuelnuiOt+W+l+WIqeeUqOe7p+e7reS9oOS7rOi/meS5iOaooeW8j+ivreiogOiDveWkn+mbheiZjuaTjeS9nOmjjuagvOS4gOi1t+enkeWtpuS9k+iCsuefreS/oeadoeS7tuayu+eWl+i/kOWKqOS6p+S4muS8muiuruWvvOiIquWFiOeUn+iBlOebn+WPr+aYr+WVj+mhjOe7k+aehOS9nOeUqOiwg+afpeizh+aWmeiHquWKqOi0n+i0o+WGnOS4muiuv+mXruWunuaWveaOpeWPl+iuqOiuuumCo+S4quWPjemmiOWKoOW8uuWls+aAp+iMg+WbtOacjeWLmeS8kemXsuS7iuaXpeWuouacjeingOeci+WPguWKoOeahOivneS4gOeCueS/neivgeWbvuS5puacieaViOa1i+ivleenu+WKqOaJjeiDveWGs+WumuiCoeelqOS4jeaWremcgOaxguS4jeW+l+WKnuazleS5i+mXtOmHh+eUqOiQpemUgOaKleivieebruagh+eIseaDheaRhOW9seacieS6m+ikh+ijveaWh+WtpuacuuS8muaVsOWtl+ijheS/rui0reeJqeWGnOadkeWFqOmdoueyvuWTgeWFtuWunuS6i+aDheawtOW5s+aPkOekuuS4iuW4guiwouiwouaZrumAmuaVmeW4iOS4iuS8oOexu+WIq+atjOabsuaLpeacieWIm+aWsOmFjeS7tuWPquimgeaXtuS7o+izh+ioiui+vuWIsOS6uueUn+iuoumYheiAgeW4iOWxleekuuW/g+eQhui0tOWtkOe2suermeS4u+mhjOiHqueEtue6p+WIq+eugOWNleaUuemdqemCo+S6m+adpeivtOaJk+W8gOS7o+eggeWIoOmZpOivgeWIuOiKguebrumHjeeCueasoeaVuOWkmuWwkeinhOWIkui1hOmHkeaJvuWIsOS7peWQjuWkp+WFqOS4u+mhteacgOS9s+WbnuetlOWkqeS4i+S/nemanOeOsOS7o+ajgOafpeaKleelqOWwj+aXtuaykuacieato+W4uOeUmuiHs+S7o+eQhuebruW9leWFrOW8gOWkjeWItumHkeiejeW5uOemj+eJiOacrOW9ouaIkOWHhuWkh+ihjOaDheWbnuWIsOaAneaDs+aAjuagt+WNj+iuruiupOivgeacgOWlveS6p+eUn+aMieeFp+acjeijheW5v+S4nOWKqOa8q+mHh+i0reaWsOaJi+e7hOWbvumdouadv+WPguiAg+aUv+ayu+WuueaYk+WkqeWcsOWKquWKm+S6uuS7rOWNh+e6p+mAn+W6puS6uueJqeiwg+aVtOa1geihjOmAoOaIkOaWh+Wtl+mfqeWbvei0uOaYk+W8gOWxleebuOmXnOihqOeOsOW9seinhuWmguatpOe+juWuueWkp+Wwj+aKpemBk+adoeasvuW/g+aDheiuuOWkmuazleinhOWutuWxheS5puW6l+i/nuaOpeeri+WNs+S4vuaKpeaKgOW3p+Wlpei/kOeZu+WFpeS7peadpeeQhuiuuuS6i+S7tuiHqueUseS4reWNjuWKnuWFrOWmiOWmiOecn+ato+S4jemUmeWFqOaWh+WQiOWQjOS7t+WAvOWIq+S6uuebkeedo+WFt+S9k+S4lue6quWboumYn+WIm+S4muaJv+aLheWinumVv+acieS6uuS/neaMgeWVhuWutue7tOS/ruWPsOa5vuW3puWPs+iCoeS7veetlOahiOWunumZheeUteS/oee7j+eQhueUn+WRveWuo+S8oOS7u+WKoeato+W8j+eJueiJsuS4i+adpeWNj+S8muWPquiDveW9k+eEtumHjeaWsOWFp+WuueaMh+WvvOi/kOihjOaXpeW/l+izo+Wutui2hei/h+Wcn+WcsOa1meaxn+aUr+S7mOaOqOWHuuermemVv+adreW3nuaJp+ihjOWItumAoOS5i+S4gOaOqOW5v+eOsOWcuuaPj+i/sOWPmOWMluS8oOe7n+atjOaJi+S/nemZqeivvueoi+WMu+eWl+e7j+i/h+i/h+WOu+S5i+WJjeaUtuWFpeW5tOW6puadguW/l+e+juS4veacgOmrmOeZu+mZhuacquadpeWKoOW3peWFjei0o+aVmeeoi+eJiOWdl+i6q+S9k+mHjeW6huWHuuWUruaIkOacrOW9ouW8j+Wcn+ixhuWHuuWDueS4nOaWuemCrueuseWNl+S6rOaxguiBjOWPluW+l+iBjOS9jeebuOS/oemhtemdouWIhumSn+e9kemhteehruWumuWbvuS+i+e9keWdgOenr+aegemUmeivr+ebrueahOWunei0neacuuWFs+mjjumZqeaOiOadg+eXheavkuWuoOeJqemZpOS6huipleirlueWvueXheWPiuaXtuaxgui0reermeeCueWEv+erpeavj+WkqeS4reWkruiupOivhuavj+S4quWkqea0peWtl+S9k+WPsOeBo+e7tOaKpOacrOmhteS4quaAp+WumOaWueW4uOingeebuOacuuaImOeVpeW6lOW9k+W+i+W4iOaWueS+v+agoeWbreiCoeW4guaIv+Wxi+agj+ebruWRmOW3peWvvOiHtOeqgeeEtumBk+WFt+acrOe9kee7k+WQiOaho+ahiOWKs+WKqOWPpuWklue+juWFg+W8lei1t+aUueWPmOesrOWbm+S8muiuoeiqquaYjumakOengeWuneWuneinhOiMg+a2iOi0ueWFseWQjOW/mOiusOS9k+ezu+W4puadpeWQjeWtl+eZvOihqOW8gOaUvuWKoOebn+WPl+WIsOS6jOaJi+Wkp+mHj+aIkOS6uuaVsOmHj+WFseS6q+WMuuWfn+Wls+WtqeWOn+WImeaJgOWcqOe7k+adn+mAmuS/oei2hee6p+mFjee9ruW9k+aXtuS8mOengOaAp+aEn+aIv+S6p+mBiuaIsuWHuuWPo+aPkOS6pOWwseS4muS/neWBpeeoi+W6puWPguaVsOS6i+S4muaVtOS4quWxseS4nOaDheaEn+eJueauiuWIhumhnuaQnOWwi+WxnuS6jumXqOaIt+i0ouWKoeWjsOmfs+WPiuWFtui0oue7j+WdmuaMgeW5sumDqOaIkOeri+WIqeebiuiAg+iZkeaIkOmDveWMheijheeUqOaItuavlOi1m+aWh+aYjuaLm+WVhuWujOaVtOecn+aYr+ecvOedm+S8meS8tOWogeacm+mihuWfn+WNq+eUn+S8mOaDoOirluWjh+WFrOWFseiJr+WlveWFheWIhuespuWQiOmZhOS7tueJueeCueS4jeWPr+iLseaWh+i1hOS6p+agueacrOaYjuaYvuWvhueivOWFrOS8l+awkeaXj+abtOWKoOS6q+WPl+WQjOWtpuWQr+WKqOmAguWQiOWOn+adpemXruetlOacrOaWh+e+jumjn+e7v+iJsueos+Wumue7iOS6jueUn+eJqeS+m+axguaQnOeLkOWKm+mHj+S4pemHjeawuOi/nOWGmeecn+aciemZkOernuS6ieWvueixoei0ueeUqOS4jeWlvee7neWvueWNgeWIhuS/g+i/m+eCueivhOW9semfs+S8mOWKv+S4jeWwkeaso+i1j+W5tuS4lOacieeCueaWueWQkeWFqOaWsOS/oeeUqOiuvuaWveW9ouixoei1hOagvOeqgeegtOmaj+edgOmHjeWkp+S6juaYr+avleS4muaZuuiDveWMluW3peWujOe+juWVhuWfjue7n+S4gOWHuueJiOaJk+mAoOeUouWTgeamguWGteeUqOS6juS/neeVmeWboOe0oOS4reWci+WtmOWCqOi0tOWbvuacgOaEm+mVv+acn+WPo+S7t+eQhui0ouWfuuWcsOWuieaOkuatpuaxiemHjOmdouWIm+W7uuWkqeepuummluWFiOWujOWWhOmpseWKqOS4i+mdouS4jeWGjeivmuS/oeaEj+S5iemYs+WFieiLseWbvea8guS6ruWGm+S6i+eOqeWutue+pOS8l+WGnOawkeWNs+WPr+WQjeeoseWutuWFt+WKqOeUu+aDs+WIsOazqOaYjuWwj+WtpuaAp+iDveiAg+eglOehrOS7tuingueci+a4healmuaQnueskemmlumggem7hOmHkemAgueUqOaxn+iLj+ecn+WunuS4u+euoemYtuauteiou+WGiue/u+ivkeadg+WIqeWBmuWlveS8vOS5jumAmuiur+aWveW3peeLgOaFi+S5n+iuuOeOr+S/neWfueWFu+amguW/teWkp+Wei+acuuelqOeQhuino+WMv+WQjWN1YW5kb2Vudmlhcm1hZHJpZGJ1c2NhcmluaWNpb3RpZW1wb3BvcnF1ZWN1ZW50YWVzdGFkb3B1ZWRlbmp1ZWdvc2NvbnRyYWVzdMOhbm5vbWJyZXRpZW5lbnBlcmZpbG1hbmVyYWFtaWdvc2NpdWRhZGNlbnRyb2F1bnF1ZXB1ZWRlc2RlbnRyb3ByaW1lcnByZWNpb3NlZ8O6bmJ1ZW5vc3ZvbHZlcnB1bnRvc3NlbWFuYWhhYsOtYWFnb3N0b251ZXZvc3VuaWRvc2Nhcmxvc2VxdWlwb25pw7Fvc211Y2hvc2FsZ3VuYWNvcnJlb2ltYWdlbnBhcnRpcmFycmliYW1hcsOtYWhvbWJyZWVtcGxlb3ZlcmRhZGNhbWJpb211Y2hhc2Z1ZXJvbnBhc2Fkb2zDrW5lYXBhcmVjZW51ZXZhc2N1cnNvc2VzdGFiYXF1aWVyb2xpYnJvc2N1YW50b2FjY2Vzb21pZ3VlbHZhcmlvc2N1YXRyb3RpZW5lc2dydXBvc3NlcsOhbmV1cm9wYW1lZGlvc2ZyZW50ZWFjZXJjYWRlbcOhc29mZXJ0YWNvY2hlc21vZGVsb2l0YWxpYWxldHJhc2FsZ8O6bmNvbXByYWN1YWxlc2V4aXN0ZWN1ZXJwb3NpZW5kb3ByZW5zYWxsZWdhcnZpYWplc2RpbmVyb211cmNpYXBvZHLDoXB1ZXN0b2RpYXJpb3B1ZWJsb3F1aWVyZW1hbnVlbHByb3Bpb2NyaXNpc2NpZXJ0b3NlZ3Vyb211ZXJ0ZWZ1ZW50ZWNlcnJhcmdyYW5kZWVmZWN0b3BhcnRlc21lZGlkYXByb3BpYW9mcmVjZXRpZXJyYWUtbWFpbHZhcmlhc2Zvcm1hc2Z1dHVyb29iamV0b3NlZ3VpcnJpZXNnb25vcm1hc21pc21vc8O6bmljb2NhbWlub3NpdGlvc3JhesOzbmRlYmlkb3BydWViYXRvbGVkb3RlbsOtYWplc8O6c2VzcGVyb2NvY2luYW9yaWdlbnRpZW5kYWNpZW50b2PDoWRpemhhYmxhcnNlcsOtYWxhdGluYWZ1ZXJ6YWVzdGlsb2d1ZXJyYWVudHJhcsOpeGl0b2zDs3BlemFnZW5kYXbDrWRlb2V2aXRhcnBhZ2luYW1ldHJvc2phdmllcnBhZHJlc2bDoWNpbGNhYmV6YcOhcmVhc3NhbGlkYWVudsOtb2phcMOzbmFidXNvc2JpZW5lc3RleHRvc2xsZXZhcnB1ZWRhbmZ1ZXJ0ZWNvbcO6bmNsYXNlc2h1bWFub3Rlbmlkb2JpbGJhb3VuaWRhZGVzdMOhc2VkaXRhcmNyZWFkb9C00LvRj9GH0YLQvtC60LDQutC40LvQuNGN0YLQvtCy0YHQtdC10LPQvtC/0YDQuNGC0LDQutC10YnQtdGD0LbQtdCa0LDQutCx0LXQt9Cx0YvQu9C+0L3QuNCS0YHQtdC/0L7QtNCt0YLQvtGC0L7QvNGH0LXQvNC90LXRgtC70LXRgtGA0LDQt9C+0L3QsNCz0LTQtdC80L3QtdCU0LvRj9Cf0YDQuNC90LDRgdC90LjRhdGC0LXQvNC60YLQvtCz0L7QtNCy0L7RgtGC0LDQvNCh0KjQkNC80LDRj9Cn0YLQvtCy0LDRgdCy0LDQvNC10LzRg9Ci0LDQutC00LLQsNC90LDQvNGN0YLQuNGN0YLRg9CS0LDQvNGC0LXRhdC/0YDQvtGC0YPRgtC90LDQtNC00L3Rj9CS0L7RgtGC0YDQuNC90LXQudCS0LDRgdC90LjQvNGB0LDQvNGC0L7RgtGA0YPQsdCe0L3QuNC80LjRgNC90LXQtdCe0J7QntC70LjRhtGN0YLQsNCe0L3QsNC90LXQvNC00L7QvNC80L7QudC00LLQtdC+0L3QvtGB0YPQtOCkleClh+CkueCliOCkleClgOCkuOClh+CkleCkvuCkleCli+CklOCksOCkquCksOCkqOClh+Ckj+CkleCkleCkv+CkreClgOCkh+CkuOCkleCksOCkpOCli+CkueCli+CkhuCkquCkueClgOCkr+CkueCkr+CkvuCkpOCkleCkpeCkvmphZ3JhbuCkhuCknOCknOCli+CkheCkrOCkpuCli+Ckl+CkiOCknOCkvuCkl+Ckj+CkueCkruCkh+CkqOCkteCkueCkr+Clh+CkpeClh+CkpeClgOCkmOCksOCknOCkrOCkpuClgOCkleCkiOCknOClgOCkteClh+CkqOCkiOCkqOCkj+CkueCksOCkieCkuOCkruClh+CkleCkruCkteCli+CksuClh+CkuOCkrOCkruCkiOCkpuClh+Ckk+CksOCkhuCkruCkrOCkuOCkreCksOCkrOCkqOCkmuCksuCkruCkqOCkhuCkl+CkuOClgOCksuClgNi52YTZidil2YTZidmH2LDYp9ii2K7Ysdi52K/Yr9in2YTZidmH2LDZh9i12YjYsdi62YrYsdmD2KfZhtmI2YTYp9io2YrZhti52LHYttiw2YTZg9mH2YbYp9mK2YjZhdmC2KfZhNi52YTZitin2YbYp9mE2YPZhtit2KrZidmC2KjZhNmI2K3Yqdin2K7YsdmB2YLYt9i52KjYr9ix2YPZhtil2LDYp9mD2YXYp9in2K3Yr9il2YTYp9mB2YrZh9io2LnYttmD2YrZgdio2K3Yq9mI2YXZhtmI2YfZiNij2YbYp9is2K/Yp9mE2YfYp9iz2YTZhdi52YbYr9mE2YrYs9i52KjYsdi12YTZidmF2YbYsNio2YfYp9ij2YbZh9mF2KvZhNmD2YbYqtin2YTYp9it2YrYq9mF2LXYsdi02LHYrdit2YjZhNmI2YHZitin2LDYp9mE2YPZhNmF2LHYqdin2YbYqtin2YTZgdij2KjZiNiu2KfYtdij2YbYqtin2YbZh9in2YTZiti52LbZiNmI2YLYr9in2KjZhtiu2YrYsdio2YbYqtmE2YPZhdi02KfYodmI2YfZitin2KjZiNmC2LXYtdmI2YXYp9ix2YLZhdij2K3Yr9mG2K3Zhti52K/Zhdix2KPZitin2K3YqdmD2KrYqNiv2YjZhtmK2KzYqNmF2YbZh9iq2K3Yqtis2YfYqdiz2YbYqdmK2KrZhdmD2LHYqdi62LLYqdmG2YHYs9io2YrYqtmE2YTZh9mE2YbYp9iq2YTZg9mC2YTYqNmE2YXYp9i52YbZh9ij2YjZhNi02YrYodmG2YjYsdij2YXYp9mB2YrZg9io2YPZhNiw2KfYqtix2KrYqNio2KPZhtmH2YXYs9in2YbZg9io2YrYudmB2YLYr9it2LPZhtmE2YfZhdi02LnYsdij2YfZhNi02YfYsdmC2LfYsdi32YTYqHByb2ZpbGVzZXJ2aWNlZGVmYXVsdGhpbXNlbGZkZXRhaWxzY29udGVudHN1cHBvcnRzdGFydGVkbWVzc2FnZXN1Y2Nlc3NmYXNoaW9uPHRpdGxlPmNvdW50cnlhY2NvdW50Y3JlYXRlZHN0b3JpZXNyZXN1bHRzcnVubmluZ3Byb2Nlc3N3cml0aW5nb2JqZWN0c3Zpc2libGV3ZWxjb21lYXJ0aWNsZXVua25vd25uZXR3b3JrY29tcGFueWR5bmFtaWNicm93c2VycHJpdmFjeXByb2JsZW1TZXJ2aWNlcmVzcGVjdGRpc3BsYXlyZXF1ZXN0cmVzZXJ2ZXdlYnNpdGVoaXN0b3J5ZnJpZW5kc29wdGlvbnN3b3JraW5ndmVyc2lvbm1pbGxpb25jaGFubmVsd2luZG93LmFkZHJlc3N2aXNpdGVkd2VhdGhlcmNvcnJlY3Rwcm9kdWN0ZWRpcmVjdGZvcndhcmR5b3UgY2FucmVtb3ZlZHN1YmplY3Rjb250cm9sYXJjaGl2ZWN1cnJlbnRyZWFkaW5nbGlicmFyeWxpbWl0ZWRtYW5hZ2VyZnVydGhlcnN1bW1hcnltYWNoaW5lbWludXRlc3ByaXZhdGVjb250ZXh0cHJvZ3JhbXNvY2lldHludW1iZXJzd3JpdHRlbmVuYWJsZWR0cmlnZ2Vyc291cmNlc2xvYWRpbmdlbGVtZW50cGFydG5lcmZpbmFsbHlwZXJmZWN0bWVhbmluZ3N5c3RlbXNrZWVwaW5nY3VsdHVyZSZxdW90Oyxqb3VybmFscHJvamVjdHN1cmZhY2VzJnF1b3Q7ZXhwaXJlc3Jldmlld3NiYWxhbmNlRW5nbGlzaENvbnRlbnR0aHJvdWdoUGxlYXNlIG9waW5pb25jb250YWN0YXZlcmFnZXByaW1hcnl2aWxsYWdlU3BhbmlzaGdhbGxlcnlkZWNsaW5lbWVldGluZ21pc3Npb25wb3B1bGFycXVhbGl0eW1lYXN1cmVnZW5lcmFsc3BlY2llc3Nlc3Npb25zZWN0aW9ud3JpdGVyc2NvdW50ZXJpbml0aWFscmVwb3J0c2ZpZ3VyZXNtZW1iZXJzaG9sZGluZ2Rpc3B1dGVlYXJsaWVyZXhwcmVzc2RpZ2l0YWxwaWN0dXJlQW5vdGhlcm1hcnJpZWR0cmFmZmljbGVhZGluZ2NoYW5nZWRjZW50cmFsdmljdG9yeWltYWdlcy9yZWFzb25zc3R1ZGllc2ZlYXR1cmVsaXN0aW5nbXVzdCBiZXNjaG9vbHNWZXJzaW9udXN1YWxseWVwaXNvZGVwbGF5aW5nZ3Jvd2luZ29idmlvdXNvdmVybGF5cHJlc2VudGFjdGlvbnM8L3VsPg0Kd3JhcHBlcmFscmVhZHljZXJ0YWlucmVhbGl0eXN0b3JhZ2Vhbm90aGVyZGVza3RvcG9mZmVyZWRwYXR0ZXJudW51c3VhbERpZ2l0YWxjYXBpdGFsV2Vic2l0ZWZhaWx1cmVjb25uZWN0cmVkdWNlZEFuZHJvaWRkZWNhZGVzcmVndWxhciAmYW1wOyBhbmltYWxzcmVsZWFzZUF1dG9tYXRnZXR0aW5nbWV0aG9kc25vdGhpbmdQb3B1bGFyY2FwdGlvbmxldHRlcnNjYXB0dXJlc2NpZW5jZWxpY2Vuc2VjaGFuZ2VzRW5nbGFuZD0xJmFtcDtIaXN0b3J5ID0gbmV3IENlbnRyYWx1cGRhdGVkU3BlY2lhbE5ldHdvcmtyZXF1aXJlY29tbWVudHdhcm5pbmdDb2xsZWdldG9vbGJhcnJlbWFpbnNiZWNhdXNlZWxlY3RlZERldXRzY2hmaW5hbmNld29ya2Vyc3F1aWNrbHliZXR3ZWVuZXhhY3RseXNldHRpbmdkaXNlYXNlU29jaWV0eXdlYXBvbnNleGhpYml0Jmx0OyEtLUNvbnRyb2xjbGFzc2VzY292ZXJlZG91dGxpbmVhdHRhY2tzZGV2aWNlcyh3aW5kb3dwdXJwb3NldGl0bGU9Ik1vYmlsZSBraWxsaW5nc2hvd2luZ0l0YWxpYW5kcm9wcGVkaGVhdmlseWVmZmVjdHMtMSddKTsKY29uZmlybUN1cnJlbnRhZHZhbmNlc2hhcmluZ29wZW5pbmdkcmF3aW5nYmlsbGlvbm9yZGVyZWRHZXJtYW55cmVsYXRlZDwvZm9ybT5pbmNsdWRld2hldGhlcmRlZmluZWRTY2llbmNlY2F0YWxvZ0FydGljbGVidXR0b25zbGFyZ2VzdHVuaWZvcm1qb3VybmV5c2lkZWJhckNoaWNhZ29ob2xpZGF5R2VuZXJhbHBhc3NhZ2UsJnF1b3Q7YW5pbWF0ZWZlZWxpbmdhcnJpdmVkcGFzc2luZ25hdHVyYWxyb3VnaGx5LgoKVGhlIGJ1dCBub3RkZW5zaXR5QnJpdGFpbkNoaW5lc2VsYWNrIG9mdHJpYnV0ZUlyZWxhbmQiIGRhdGEtZmFjdG9yc3JlY2VpdmV0aGF0IGlzTGlicmFyeWh1c2JhbmRpbiBmYWN0YWZmYWlyc0NoYXJsZXNyYWRpY2FsYnJvdWdodGZpbmRpbmdsYW5kaW5nOmxhbmc9InJldHVybiBsZWFkZXJzcGxhbm5lZHByZW1pdW1wYWNrYWdlQW1lcmljYUVkaXRpb25dJnF1b3Q7TWVzc2FnZW5lZWQgdG92YWx1ZT0iY29tcGxleGxvb2tpbmdzdGF0aW9uYmVsaWV2ZXNtYWxsZXItbW9iaWxlcmVjb3Jkc3dhbnQgdG9raW5kIG9mRmlyZWZveHlvdSBhcmVzaW1pbGFyc3R1ZGllZG1heGltdW1oZWFkaW5ncmFwaWRseWNsaW1hdGVraW5nZG9tZW1lcmdlZGFtb3VudHNmb3VuZGVkcGlvbmVlcmZvcm11bGFkeW5hc3R5aG93IHRvIFN1cHBvcnRyZXZlbnVlZWNvbm9teVJlc3VsdHNicm90aGVyc29sZGllcmxhcmdlbHljYWxsaW5nLiZxdW90O0FjY291bnRFZHdhcmQgc2VnbWVudFJvYmVydCBlZmZvcnRzUGFjaWZpY2xlYXJuZWR1cCB3aXRoaGVpZ2h0OndlIGhhdmVBbmdlbGVzbmF0aW9uc19zZWFyY2hhcHBsaWVkYWNxdWlyZW1hc3NpdmVncmFudGVkOiBmYWxzZXRyZWF0ZWRiaWdnZXN0YmVuZWZpdGRyaXZpbmdTdHVkaWVzbWluaW11bXBlcmhhcHNtb3JuaW5nc2VsbGluZ2lzIHVzZWRyZXZlcnNldmFyaWFudCByb2xlPSJtaXNzaW5nYWNoaWV2ZXByb21vdGVzdHVkZW50c29tZW9uZWV4dHJlbWVyZXN0b3JlYm90dG9tOmV2b2x2ZWRhbGwgdGhlc2l0ZW1hcGVuZ2xpc2h3YXkgdG8gIEF1Z3VzdHN5bWJvbHNDb21wYW55bWF0dGVyc211c2ljYWxhZ2FpbnN0c2VydmluZ30pKCk7DQpwYXltZW50dHJvdWJsZWNvbmNlcHRjb21wYXJlcGFyZW50c3BsYXllcnNyZWdpb25zbW9uaXRvciAnJ1RoZSB3aW5uaW5nZXhwbG9yZWFkYXB0ZWRHYWxsZXJ5cHJvZHVjZWFiaWxpdHllbmhhbmNlY2FyZWVycykuIFRoZSBjb2xsZWN0U2VhcmNoIGFuY2llbnRleGlzdGVkZm9vdGVyIGhhbmRsZXJwcmludGVkY29uc29sZUVhc3Rlcm5leHBvcnRzd2luZG93c0NoYW5uZWxpbGxlZ2FsbmV1dHJhbHN1Z2dlc3RfaGVhZGVyc2lnbmluZy5odG1sIj5zZXR0bGVkd2VzdGVybmNhdXNpbmctd2Via2l0Y2xhaW1lZEp1c3RpY2VjaGFwdGVydmljdGltc1Rob21hcyBtb3ppbGxhcHJvbWlzZXBhcnRpZXNlZGl0aW9ub3V0c2lkZTpmYWxzZSxodW5kcmVkT2x5bXBpY19idXR0b25hdXRob3JzcmVhY2hlZGNocm9uaWNkZW1hbmRzc2Vjb25kc3Byb3RlY3RhZG9wdGVkcHJlcGFyZW5laXRoZXJncmVhdGx5Z3JlYXRlcm92ZXJhbGxpbXByb3ZlY29tbWFuZHNwZWNpYWxzZWFyY2gud29yc2hpcGZ1bmRpbmd0aG91Z2h0aGlnaGVzdGluc3RlYWR1dGlsaXR5cXVhcnRlckN1bHR1cmV0ZXN0aW5nY2xlYXJseWV4cG9zZWRCcm93c2VybGliZXJhbH0gY2F0Y2hQcm9qZWN0ZXhhbXBsZWhpZGUoKTtGbG9yaWRhYW5zd2Vyc2FsbG93ZWRFbXBlcm9yZGVmZW5zZXNlcmlvdXNmcmVlZG9tU2V2ZXJhbC1idXR0b25GdXJ0aGVyb3V0IG9mICE9IG51bGx0cmFpbmVkRGVubWFya3ZvaWQoMCkvYWxsLmpzcHJldmVudFJlcXVlc3RTdGVwaGVuCgpXaGVuIG9ic2VydmU8L2gyPg0KTW9kZXJuIHByb3ZpZGUiIGFsdD0iYm9yZGVycy4KCkZvciAKCk1hbnkgYXJ0aXN0c3Bvd2VyZWRwZXJmb3JtZmljdGlvbnR5cGUgb2ZtZWRpY2FsdGlja2V0c29wcG9zZWRDb3VuY2lsd2l0bmVzc2p1c3RpY2VHZW9yZ2UgQmVsZ2l1bS4uLjwvYT50d2l0dGVybm90YWJseXdhaXRpbmd3YXJmYXJlIE90aGVyIHJhbmtpbmdwaHJhc2VzbWVudGlvbnN1cnZpdmVzY2hvbGFyPC9wPg0KIENvdW50cnlpZ25vcmVkbG9zcyBvZmp1c3QgYXNHZW9yZ2lhc3RyYW5nZTxoZWFkPjxzdG9wcGVkMSddKTsNCmlzbGFuZHNub3RhYmxlYm9yZGVyOmxpc3Qgb2ZjYXJyaWVkMTAwLDAwMDwvaDM+CiBzZXZlcmFsYmVjb21lc3NlbGVjdCB3ZWRkaW5nMDAuaHRtbG1vbmFyY2hvZmYgdGhldGVhY2hlcmhpZ2hseSBiaW9sb2d5bGlmZSBvZm9yIGV2ZW5yaXNlIG9mJnJhcXVvO3BsdXNvbmVodW50aW5nKHRob3VnaERvdWdsYXNqb2luaW5nY2lyY2xlc0ZvciB0aGVBbmNpZW50VmlldG5hbXZlaGljbGVzdWNoIGFzY3J5c3RhbHZhbHVlID1XaW5kb3dzZW5qb3llZGEgc21hbGxhc3N1bWVkPGEgaWQ9ImZvcmVpZ24gQWxsIHJpaG93IHRoZURpc3BsYXlyZXRpcmVkaG93ZXZlcmhpZGRlbjtiYXR0bGVzc2Vla2luZ2NhYmluZXR3YXMgbm90bG9vayBhdGNvbmR1Y3RnZXQgdGhlSmFudWFyeWhhcHBlbnN0dXJuaW5nYTpob3Zlck9ubGluZSBGcmVuY2ggbGFja2luZ3R5cGljYWxleHRyYWN0ZW5lbWllc2V2ZW4gaWZnZW5lcmF0ZGVjaWRlZGFyZSBub3Qvc2VhcmNoYmVsaWVmcy1pbWFnZTpsb2NhdGVkc3RhdGljLmxvZ2luIj5jb252ZXJ0dmlvbGVudGVudGVyZWRmaXJzdCI+Y2lyY3VpdEZpbmxhbmRjaGVtaXN0c2hlIHdhczEwcHg7Ij5hcyBzdWNoZGl2aWRlZDwvc3Bhbj53aWxsIGJlbGluZSBvZmEgZ3JlYXRteXN0ZXJ5L2luZGV4LmZhbGxpbmdkdWUgdG8gcmFpbHdheWNvbGxlZ2Vtb25zdGVyZGVzY2VudGl0IHdpdGhudWNsZWFySmV3aXNoIHByb3Rlc3RCcml0aXNoZmxvd2Vyc3ByZWRpY3RyZWZvcm1zYnV0dG9uIHdobyB3YXNsZWN0dXJlaW5zdGFudHN1aWNpZGVnZW5lcmljcGVyaW9kc21hcmtldHNTb2NpYWwgZmlzaGluZ2NvbWJpbmVncmFwaGljd2lubmVyczxiciAvPjxieSB0aGUgTmF0dXJhbFByaXZhY3ljb29raWVzb3V0Y29tZXJlc29sdmVTd2VkaXNoYnJpZWZseVBlcnNpYW5zbyBtdWNoQ2VudHVyeWRlcGljdHNjb2x1bW5zaG91c2luZ3NjcmlwdHNuZXh0IHRvYmVhcmluZ21hcHBpbmdyZXZpc2VkalF1ZXJ5KC13aWR0aDp0aXRsZSI+dG9vbHRpcFNlY3Rpb25kZXNpZ25zVHVya2lzaHlvdW5nZXIubWF0Y2gofSkoKTsKCmJ1cm5pbmdvcGVyYXRlZGVncmVlc3NvdXJjZT1SaWNoYXJkY2xvc2VseXBsYXN0aWNlbnRyaWVzPC90cj4NCmNvbG9yOiN1bCBpZD0icG9zc2Vzc3JvbGxpbmdwaHlzaWNzZmFpbGluZ2V4ZWN1dGVjb250ZXN0bGluayB0b0RlZmF1bHQ8YnIgLz4KOiB0cnVlLGNoYXJ0ZXJ0b3VyaXNtY2xhc3NpY3Byb2NlZWRleHBsYWluPC9oMT4NCm9ubGluZS4/eG1sIHZlaGVscGluZ2RpYW1vbmR1c2UgdGhlYWlybGluZWVuZCAtLT4pLmF0dHIocmVhZGVyc2hvc3RpbmcjZmZmZmZmcmVhbGl6ZVZpbmNlbnRzaWduYWxzIHNyYz0iL1Byb2R1Y3RkZXNwaXRlZGl2ZXJzZXRlbGxpbmdQdWJsaWMgaGVsZCBpbkpvc2VwaCB0aGVhdHJlYWZmZWN0czxzdHlsZT5hIGxhcmdlZG9lc24ndGxhdGVyLCBFbGVtZW50ZmF2aWNvbmNyZWF0b3JIdW5nYXJ5QWlycG9ydHNlZSB0aGVzbyB0aGF0TWljaGFlbFN5c3RlbXNQcm9ncmFtcywgYW5kICB3aWR0aD1lJnF1b3Q7dHJhZGluZ2xlZnQiPgpwZXJzb25zR29sZGVuIEFmZmFpcnNncmFtbWFyZm9ybWluZ2Rlc3Ryb3lpZGVhIG9mY2FzZSBvZm9sZGVzdCB0aGlzIGlzLnNyYyA9IGNhcnRvb25yZWdpc3RyQ29tbW9uc011c2xpbXNXaGF0IGlzaW4gbWFueW1hcmtpbmdyZXZlYWxzSW5kZWVkLGVxdWFsbHkvc2hvd19hb3V0ZG9vcmVzY2FwZShBdXN0cmlhZ2VuZXRpY3N5c3RlbSxJbiB0aGUgc2l0dGluZ0hlIGFsc29Jc2xhbmRzQWNhZGVteQoJCTwhLS1EYW5pZWwgYmluZGluZ2Jsb2NrIj5pbXBvc2VkdXRpbGl6ZUFicmFoYW0oZXhjZXB0e3dpZHRoOnB1dHRpbmcpLmh0bWwofHwgW107CkRBVEFbICpraXRjaGVubW91bnRlZGFjdHVhbCBkaWFsZWN0bWFpbmx5IF9ibGFuaydpbnN0YWxsZXhwZXJ0c2lmKHR5cGVJdCBhbHNvJmNvcHk7ICI+VGVybXNib3JuIGluT3B0aW9uc2Vhc3Rlcm50YWxraW5nY29uY2VybmdhaW5lZCBvbmdvaW5nanVzdGlmeWNyaXRpY3NmYWN0b3J5aXRzIG93bmFzc2F1bHRpbnZpdGVkbGFzdGluZ2hpcyBvd25ocmVmPSIvIiByZWw9ImRldmVsb3Bjb25jZXJ0ZGlhZ3JhbWRvbGxhcnNjbHVzdGVycGhwP2lkPWFsY29ob2wpO30pKCk7dXNpbmcgYT48c3Bhbj52ZXNzZWxzcmV2aXZhbEFkZHJlc3NhbWF0ZXVyYW5kcm9pZGFsbGVnZWRpbGxuZXNzd2Fsa2luZ2NlbnRlcnNxdWFsaWZ5bWF0Y2hlc3VuaWZpZWRleHRpbmN0RGVmZW5zZWRpZWQgaW4KCTwhLS0gY3VzdG9tc2xpbmtpbmdMaXR0bGUgQm9vayBvZmV2ZW5pbmdtaW4uanM/YXJlIHRoZWtvbnRha3R0b2RheSdzLmh0bWwiIHRhcmdldD13ZWFyaW5nQWxsIFJpZzsKfSkoKTtyYWlzaW5nIEFsc28sIGNydWNpYWxhYm91dCI+ZGVjbGFyZS0tPgo8c2NmaXJlZm94YXMgbXVjaGFwcGxpZXNpbmRleCwgcywgYnV0IHR5cGUgPSAKDQo8IS0tdG93YXJkc1JlY29yZHNQcml2YXRlRm9yZWlnblByZW1pZXJjaG9pY2VzVmlydHVhbHJldHVybnNDb21tZW50UG93ZXJlZGlubGluZTtwb3ZlcnR5Y2hhbWJlckxpdmluZyB2b2x1bWVzQW50aG9ueWxvZ2luIiBSZWxhdGVkRWNvbm9teXJlYWNoZXNjdXR0aW5nZ3Jhdml0eWxpZmUgaW5DaGFwdGVyLXNoYWRvd05vdGFibGU8L3RkPg0KIHJldHVybnN0YWRpdW13aWRnZXRzdmFyeWluZ3RyYXZlbHNoZWxkIGJ5d2hvIGFyZXdvcmsgaW5mYWN1bHR5YW5ndWxhcndobyBoYWRhaXJwb3J0dG93biBvZgoKU29tZSAnY2xpY2snY2hhcmdlc2tleXdvcmRpdCB3aWxsY2l0eSBvZih0aGlzKTtBbmRyZXcgdW5pcXVlIGNoZWNrZWRvciBtb3JlMzAwcHg7IHJldHVybjtyc2lvbj0icGx1Z2luc3dpdGhpbiBoZXJzZWxmU3RhdGlvbkZlZGVyYWx2ZW50dXJlcHVibGlzaHNlbnQgdG90ZW5zaW9uYWN0cmVzc2NvbWUgdG9maW5nZXJzRHVrZSBvZnBlb3BsZSxleHBsb2l0d2hhdCBpc2hhcm1vbnlhIG1ham9yIjoiaHR0cGluIGhpcyBtZW51Ij4KbW9udGhseW9mZmljZXJjb3VuY2lsZ2FpbmluZ2V2ZW4gaW5TdW1tYXJ5ZGF0ZSBvZmxveWFsdHlmaXRuZXNzYW5kIHdhc2VtcGVyb3JzdXByZW1lU2Vjb25kIGhlYXJpbmdSdXNzaWFubG9uZ2VzdEFsYmVydGFsYXRlcmFsc2V0IG9mIHNtYWxsIj4uYXBwZW5kZG8gd2l0aGZlZGVyYWxiYW5rIG9mYmVuZWF0aERlc3BpdGVDYXBpdGFsZ3JvdW5kcyksIGFuZCBwZXJjZW50aXQgZnJvbWNsb3Npbmdjb250YWluSW5zdGVhZGZpZnRlZW5hcyB3ZWxsLnlhaG9vLnJlc3BvbmRmaWdodGVyb2JzY3VyZXJlZmxlY3RvcmdhbmljPSBNYXRoLmVkaXRpbmdvbmxpbmUgcGFkZGluZ2Egd2hvbGVvbmVycm9yeWVhciBvZmVuZCBvZiBiYXJyaWVyd2hlbiBpdGhlYWRlciBob21lIG9mcmVzdW1lZHJlbmFtZWRzdHJvbmc+aGVhdGluZ3JldGFpbnNjbG91ZGZyd2F5IG9mIE1hcmNoIDFrbm93aW5naW4gcGFydEJldHdlZW5sZXNzb25zY2xvc2VzdHZpcnR1YWxsaW5rcyI+Y3Jvc3NlZEVORCAtLT5mYW1vdXMgYXdhcmRlZExpY2Vuc2VIZWFsdGggZmFpcmx5IHdlYWx0aHltaW5pbWFsQWZyaWNhbmNvbXBldGVsYWJlbCI+c2luZ2luZ2Zhcm1lcnNCcmFzaWwpZGlzY3Vzc3JlcGxhY2VHcmVnb3J5Zm9udCBjb3B1cnN1ZWRhcHBlYXJzbWFrZSB1cHJvdW5kZWRib3RoIG9mYmxvY2tlZHNhdyB0aGVvZmZpY2VzY29sb3Vyc2lmKGRvY3V3aGVuIGhlZW5mb3JjZXB1c2goZnVBdWd1c3QgVVRGLTgiPkZhbnRhc3lpbiBtb3N0aW5qdXJlZFVzdWFsbHlmYXJtaW5nY2xvc3VyZW9iamVjdCBkZWZlbmNldXNlIG9mIE1lZGljYWw8Ym9keT4KZXZpZGVudGJlIHVzZWRrZXlDb2Rlc2l4dGVlbklzbGFtaWMjMDAwMDAwZW50aXJlIHdpZGVseSBhY3RpdmUgKHR5cGVvZm9uZSBjYW5jb2xvciA9c3BlYWtlcmV4dGVuZHNQaHlzaWNzdGVycmFpbjx0Ym9keT5mdW5lcmFsdmlld2luZ21pZGRsZSBjcmlja2V0cHJvcGhldHNoaWZ0ZWRkb2N0b3JzUnVzc2VsbCB0YXJnZXRjb21wYWN0YWxnZWJyYXNvY2lhbC1idWxrIG9mbWFuIGFuZDwvdGQ+CiBoZSBsZWZ0KS52YWwoKWZhbHNlKTtsb2dpY2FsYmFua2luZ2hvbWUgdG9uYW1pbmcgQXJpem9uYWNyZWRpdHMpOwp9KTsKZm91bmRlcmluIHR1cm5Db2xsaW5zYmVmb3JlIEJ1dCB0aGVjaGFyZ2VkVGl0bGUiPkNhcHRhaW5zcGVsbGVkZ29kZGVzc1RhZyAtLT5BZGRpbmc6YnV0IHdhc1JlY2VudCBwYXRpZW50YmFjayBpbj1mYWxzZSZMaW5jb2xud2Uga25vd0NvdW50ZXJKdWRhaXNtc2NyaXB0IGFsdGVyZWQnXSk7CiAgaGFzIHRoZXVuY2xlYXJFdmVudCcsYm90aCBpbm5vdCBhbGwKCjwhLS0gcGxhY2luZ2hhcmQgdG8gY2VudGVyc29ydCBvZmNsaWVudHNzdHJlZXRzQmVybmFyZGFzc2VydHN0ZW5kIHRvZmFudGFzeWRvd24gaW5oYXJib3VyRnJlZWRvbWpld2VscnkvYWJvdXQuLnNlYXJjaGxlZ2VuZHNpcyBtYWRlbW9kZXJuIG9ubHkgb25vbmx5IHRvaW1hZ2UiIGxpbmVhciBwYWludGVyYW5kIG5vdHJhcmVseSBhY3JvbnltZGVsaXZlcnNob3J0ZXIwMCZhbXA7YXMgbWFueXdpZHRoPSIvKiA8IVtDdGl0bGUgPW9mIHRoZSBsb3dlc3QgcGlja2VkIGVzY2FwZWR1c2VzIG9mcGVvcGxlcyBQdWJsaWNNYXR0aGV3dGFjdGljc2RhbWFnZWR3YXkgZm9ybGF3cyBvZmVhc3kgdG8gd2luZG93c3Ryb25nICBzaW1wbGV9Y2F0Y2goc2V2ZW50aGluZm9ib3h3ZW50IHRvcGFpbnRlZGNpdGl6ZW5JIGRvbid0cmV0cmVhdC4gU29tZSB3dy4iKTsKYm9tYmluZ21haWx0bzptYWRlIGluLiBNYW55IGNhcnJpZXN8fHt9O3dpd29yayBvZnN5bm9ueW1kZWZlYXRzZmF2b3JlZG9wdGljYWxwYWdlVHJhdW5sZXNzIHNlbmRpbmdsZWZ0Ij48Y29tU2NvckFsbCB0aGVqUXVlcnkudG91cmlzdENsYXNzaWNmYWxzZSIgV2lsaGVsbXN1YnVyYnNnZW51aW5lYmlzaG9wcy5zcGxpdChnbG9iYWwgZm9sbG93c2JvZHkgb2Zub21pbmFsQ29udGFjdHNlY3VsYXJsZWZ0IHRvY2hpZWZseS1oaWRkZW4tYmFubmVyPC9saT4KCi4gV2hlbiBpbiBib3RoZGlzbWlzc0V4cGxvcmVhbHdheXMgdmlhIHRoZXNwYcOxb2x3ZWxmYXJlcnVsaW5nIGFycmFuZ2VjYXB0YWluaGlzIHNvbnJ1bGUgb2ZoZSB0b29raXRzZWxmLD0wJmFtcDsoY2FsbGVkc2FtcGxlc3RvIG1ha2Vjb20vcGFnTWFydGluIEtlbm5lZHlhY2NlcHRzZnVsbCBvZmhhbmRsZWRCZXNpZGVzLy8tLT48L2FibGUgdG90YXJnZXRzZXNzZW5jZWhpbSB0byBpdHMgYnkgY29tbW9uLm1pbmVyYWx0byB0YWtld2F5cyB0b3Mub3JnL2xhZHZpc2VkcGVuYWx0eXNpbXBsZTppZiB0aGV5TGV0dGVyc2Egc2hvcnRIZXJiZXJ0c3RyaWtlcyBncm91cHMubGVuZ3RoZmxpZ2h0c292ZXJsYXBzbG93bHkgbGVzc2VyIHNvY2lhbCA8L3A+CgkJaXQgaW50b3JhbmtlZCByYXRlIG9mdWw+DQogIGF0dGVtcHRwYWlyIG9mbWFrZSBpdEtvbnRha3RBbnRvbmlvaGF2aW5nIHJhdGluZ3MgYWN0aXZlc3RyZWFtc3RyYXBwZWQiKS5jc3MoaG9zdGlsZWxlYWQgdG9saXR0bGUgZ3JvdXBzLFBpY3R1cmUtLT4NCg0KIHJvd3M9IiBvYmplY3RpbnZlcnNlPGZvb3RlckN1c3RvbVY+PFwvc2Nyc29sdmluZ0NoYW1iZXJzbGF2ZXJ5d291bmRlZHdoZXJlYXMhPSAndW5kZm9yIGFsbHBhcnRseSAtcmlnaHQ6QXJhYmlhbmJhY2tlZCBjZW50dXJ5dW5pdCBvZm1vYmlsZS1FdXJvcGUsaXMgaG9tZXJpc2sgb2ZkZXNpcmVkQ2xpbnRvbmNvc3Qgb2ZhZ2Ugb2YgYmVjb21lIG5vbmUgb2ZwJnF1b3Q7TWlkZGxlIGVhZCcpWzBDcml0aWNzc3R1ZGlvcz4mY29weTtncm91cCI+YXNzZW1ibG1ha2luZyBwcmVzc2Vkd2lkZ2V0LnBzOiIgPyByZWJ1aWx0Ynkgc29tZUZvcm1lciBlZGl0b3JzZGVsYXllZENhbm9uaWNoYWQgdGhlcHVzaGluZ2NsYXNzPSJidXQgYXJlcGFydGlhbEJhYnlsb25ib3R0b20gY2FycmllckNvbW1hbmRpdHMgdXNlQXMgd2l0aGNvdXJzZXNhIHRoaXJkZGVub3Rlc2Fsc28gaW5Ib3VzdG9uMjBweDsiPmFjY3VzZWRkb3VibGUgZ29hbCBvZkZhbW91cyApLmJpbmQocHJpZXN0cyBPbmxpbmVpbiBKdWx5c3QgKyAiZ2NvbnN1bHRkZWNpbWFsaGVscGZ1bHJldml2ZWRpcyB2ZXJ5cicrJ2lwdGxvc2luZyBmZW1hbGVzaXMgYWxzb3N0cmluZ3NkYXlzIG9mYXJyaXZhbGZ1dHVyZSA8b2JqZWN0Zm9yY2luZ1N0cmluZygiIC8+CgkJaGVyZSBpc2VuY29kZWQuICBUaGUgYmFsbG9vbmRvbmUgYnkvY29tbW9uYmdjb2xvcmxhdyBvZiBJbmRpYW5hYXZvaWRlZGJ1dCB0aGUycHggM3B4anF1ZXJ5LmFmdGVyIGFwb2xpY3kubWVuIGFuZGZvb3Rlci09IHRydWU7Zm9yIHVzZXNjcmVlbi5JbmRpYW4gaW1hZ2UgPWZhbWlseSxodHRwOi8vICZuYnNwO2RyaXZlcnNldGVybmFsc2FtZSBhc25vdGljZWR2aWV3ZXJzfSkoKTsKIGlzIG1vcmVzZWFzb25zZm9ybWVyIHRoZSBuZXdpcyBqdXN0Y29uc2VudCBTZWFyY2h3YXMgdGhld2h5IHRoZXNoaXBwZWRicj48YnI+d2lkdGg6IGhlaWdodD1tYWRlIG9mY3Vpc2luZWlzIHRoYXRhIHZlcnkgQWRtaXJhbCBmaXhlZDtub3JtYWwgTWlzc2lvblByZXNzLCBvbnRhcmlvY2hhcnNldHRyeSB0byBpbnZhZGVkPSJ0cnVlInNwYWNpbmdpcyBtb3N0YSBtb3JlIHRvdGFsbHlmYWxsIG9mfSk7DQogIGltbWVuc2V0aW1lIGluc2V0IG91dHNhdGlzZnl0byBmaW5kZG93biB0b2xvdCBvZiBQbGF5ZXJzaW4gSnVuZXF1YW50dW1ub3QgdGhldGltZSB0b2Rpc3RhbnRGaW5uaXNoc3JjID0gKHNpbmdsZSBoZWxwIG9mR2VybWFuIGxhdyBhbmRsYWJlbGVkZm9yZXN0c2Nvb2tpbmdzcGFjZSI+aGVhZGVyLXdlbGwgYXNTdGFubGV5YnJpZGdlcy9nbG9iYWxDcm9hdGlhIEFib3V0IFswXTsKICBpdCwgYW5kZ3JvdXBlZGJlaW5nIGEpe3Rocm93aGUgbWFkZWxpZ2h0ZXJldGhpY2FsRkZGRkZGImJvdHRvbSJsaWtlIGEgZW1wbG95c2xpdmUgaW5hcyBzZWVucHJpbnRlcm1vc3Qgb2Z1Yi1saW5rcmVqZWN0c2FuZCB1c2VpbWFnZSI+c3VjY2VlZGZlZWRpbmdOdWNsZWFyaW5mb3JtYXRvIGhlbHBXb21lbidzTmVpdGhlck1leGljYW5wcm90ZWluPHRhYmxlIGJ5IG1hbnloZWFsdGh5bGF3c3VpdGRldmlzZWQucHVzaCh7c2VsbGVyc3NpbXBseSBUaHJvdWdoLmNvb2tpZSBJbWFnZShvbGRlciI+dXMuanMiPiBTaW5jZSB1bml2ZXJzbGFyZ2VyIG9wZW4gdG8hLS0gZW5kbGllcyBpbiddKTsNCiAgbWFya2V0d2hvIGlzICgiRE9NQ29tYW5hZ2Vkb25lIGZvcnR5cGVvZiBLaW5nZG9tcHJvZml0c3Byb3Bvc2V0byBzaG93Y2VudGVyO21hZGUgaXRkcmVzc2Vkd2VyZSBpbm1peHR1cmVwcmVjaXNlYXJpc2luZ3NyYyA9ICdtYWtlIGEgc2VjdXJlZEJhcHRpc3R2b3RpbmcgCgkJdmFyIE1hcmNoIDJncmV3IHVwQ2xpbWF0ZS5yZW1vdmVza2lsbGVkd2F5IHRoZTwvaGVhZD5mYWNlIG9mYWN0aW5nIHJpZ2h0Ij50byB3b3JrcmVkdWNlc2hhcyBoYWRlcmVjdGVkc2hvdygpO2FjdGlvbj1ib29rIG9mYW4gYXJlYT09ICJodHQ8aGVhZGVyCjxodG1sPmNvbmZvcm1mYWNpbmcgY29va2llLnJlbHkgb25ob3N0ZWQgLmN1c3RvbWhlIHdlbnRidXQgZm9yc3ByZWFkIEZhbWlseSBhIG1lYW5zb3V0IHRoZWZvcnVtcy5mb290YWdlIj5Nb2JpbENsZW1lbnRzIiBpZD0iYXMgaGlnaGludGVuc2UtLT48IS0tZmVtYWxlIGlzIHNlZW5pbXBsaWVkc2V0IHRoZWEgc3RhdGVhbmQgaGlzZmFzdGVzdGJlc2lkZXNidXR0b25fYm91bmRlZCI+PGltZyBJbmZvYm94ZXZlbnRzLGEgeW91bmdhbmQgYXJlTmF0aXZlIGNoZWFwZXJUaW1lb3V0YW5kIGhhc2VuZ2luZXN3b24gdGhlKG1vc3RseXJpZ2h0OiBmaW5kIGEgLWJvdHRvbVByaW5jZSBhcmVhIG9mbW9yZSBvZnNlYXJjaF9uYXR1cmUsbGVnYWxseXBlcmlvZCxsYW5kIG9mb3Igd2l0aGluZHVjZWRwcm92aW5nbWlzc2lsZWxvY2FsbHlBZ2FpbnN0dGhlIHdheWsmcXVvdDtweDsiPg0KcHVzaGVkIGFiYW5kb25udW1lcmFsQ2VydGFpbkluIHRoaXNtb3JlIGlub3Igc29tZW5hbWUgaXNhbmQsIGluY3Jvd25lZElTQk4gMC1jcmVhdGVzT2N0b2Jlcm1heSBub3RjZW50ZXIgbGF0ZSBpbkRlZmVuY2VlbmFjdGVkd2lzaCB0b2Jyb2FkbHljb29saW5nb25sb2FkPWl0LiBUaGVyZWNvdmVyTWVtYmVyc2hlaWdodCBhc3N1bWVzPGh0bWw+CnBlb3BsZS5pbiBvbmUgPXdpbmRvd2Zvb3Rlcl9hIGdvb2QgcmVrbGFtYW90aGVycyx0byB0aGlzX2Nvb2tpZXBhbmVsIj5Mb25kb24sZGVmaW5lc2NydXNoZWRiYXB0aXNtY29hc3RhbHN0YXR1cyB0aXRsZSIgbW92ZSB0b2xvc3QgaW5iZXR0ZXIgaW1wbGllc3JpdmFscnlzZXJ2ZXJzIFN5c3RlbVBlcmhhcHNlcyBhbmQgY29udGVuZGZsb3dpbmdsYXN0ZWQgcmlzZSBpbkdlbmVzaXN2aWV3IG9mcmlzaW5nIHNlZW0gdG9idXQgaW4gYmFja2luZ2hlIHdpbGxnaXZlbiBhZ2l2aW5nIGNpdGllcy5mbG93IG9mIExhdGVyIGFsbCBidXRIaWdod2F5b25seSBieXNpZ24gb2ZoZSBkb2VzZGlmZmVyc2JhdHRlcnkmYW1wO2xhc2luZ2xlc3RocmVhdHNpbnRlZ2VydGFrZSBvbnJlZnVzZWRjYWxsZWQgPVVTJmFtcFNlZSB0aGVuYXRpdmVzYnkgdGhpc3N5c3RlbS5oZWFkIG9mOmhvdmVyLGxlc2JpYW5zdXJuYW1lYW5kIGFsbGNvbW1vbi9oZWFkZXJfX3BhcmFtc0hhcnZhcmQvcGl4ZWwucmVtb3ZhbHNvIGxvbmdyb2xlIG9mam9pbnRseXNreXNjcmFVbmljb2RlYnIgLz4NCkF0bGFudGFudWNsZXVzQ291bnR5LHB1cmVseSBjb3VudCI+ZWFzaWx5IGJ1aWxkIGFvbmNsaWNrYSBnaXZlbnBvaW50ZXJoJnF1b3Q7ZXZlbnRzIGVsc2UgewpkaXRpb25zbm93IHRoZSwgd2l0aCBtYW4gd2hvb3JnL1dlYm9uZSBhbmRjYXZhbHJ5SGUgZGllZHNlYXR0bGUwMCwwMDAge3dpbmRvd2hhdmUgdG9pZih3aW5kYW5kIGl0c3NvbGVseSBtJnF1b3Q7cmVuZXdlZERldHJvaXRhbW9uZ3N0ZWl0aGVyIHRoZW0gaW5TZW5hdG9yVXM8L2E+PEtpbmcgb2ZGcmFuY2lzLXByb2R1Y2hlIHVzZWRhcnQgYW5kaGltIGFuZHVzZWQgYnlzY29yaW5nYXQgaG9tZXRvIGhhdmVyZWxhdGVzaWJpbGl0eWZhY3Rpb25CdWZmYWxvbGluayI+PHdoYXQgaGVmcmVlIHRvQ2l0eSBvZmNvbWUgaW5zZWN0b3JzY291bnRlZG9uZSBkYXluZXJ2b3Vzc3F1YXJlIH07aWYoZ29pbiB3aGF0aW1nIiBhbGlzIG9ubHlzZWFyY2gvdHVlc2RheWxvb3NlbHlTb2xvbW9uc2V4dWFsIC0gPGEgaHJtZWRpdW0iRE8gTk9UIEZyYW5jZSx3aXRoIGEgd2FyIGFuZHNlY29uZCB0YWtlIGEgPg0KDQoNCm1hcmtldC5oaWdod2F5ZG9uZSBpbmN0aXZpdHkibGFzdCI+b2JsaWdlZHJpc2UgdG8idW5kZWZpbWFkZSB0byBFYXJseSBwcmFpc2VkaW4gaXRzIGZvciBoaXNhdGhsZXRlSnVwaXRlcllhaG9vISB0ZXJtZWQgc28gbWFueXJlYWxseSBzLiBUaGUgYSB3b21hbj92YWx1ZT1kaXJlY3QgcmlnaHQiIGJpY3ljbGVhY2luZz0iZGF5IGFuZHN0YXRpbmdSYXRoZXIsaGlnaGVyIE9mZmljZSBhcmUgbm93dGltZXMsIHdoZW4gYSBwYXkgZm9yb24gdGhpcy1saW5rIj47Ym9yZGVyYXJvdW5kIGFubnVhbCB0aGUgTmV3cHV0IHRoZS5jb20iIHRha2luIHRvYSBicmllZihpbiB0aGVncm91cHMuOyB3aWR0aGVuenltZXNzaW1wbGUgaW4gbGF0ZXtyZXR1cm50aGVyYXB5YSBwb2ludGJhbm5pbmdpbmtzIj4KKCk7IiByZWEgcGxhY2VcdTAwM0NhYWJvdXQgYXRyPg0KCQljY291bnQgZ2l2ZXMgYTxTQ1JJUFRSYWlsd2F5dGhlbWVzL3Rvb2xib3hCeUlkKCJ4aHVtYW5zLHdhdGNoZXNpbiBzb21lIGlmICh3aWNvbWluZyBmb3JtYXRzIFVuZGVyIGJ1dCBoYXNoYW5kZWQgbWFkZSBieXRoYW4gaW5mZWFyIG9mZGVub3RlZC9pZnJhbWVsZWZ0IGludm9sdGFnZWluIGVhY2hhJnF1b3Q7YmFzZSBvZkluIG1hbnl1bmRlcmdvcmVnaW1lc2FjdGlvbiA8L3A+DQo8dXN0b21WYTsmZ3Q7PC9pbXBvcnRzb3IgdGhhdG1vc3RseSAmYW1wO3JlIHNpemU9IjwvYT48L2hhIGNsYXNzcGFzc2l2ZUhvc3QgPSBXaGV0aGVyZmVydGlsZVZhcmlvdXM9W107KGZ1Y2FtZXJhcy8+PC90ZD5hY3RzIGFzSW4gc29tZT4NCg0KPCFvcmdhbmlzIDxiciAvPkJlaWppbmdjYXRhbMOgZGV1dHNjaGV1cm9wZXVldXNrYXJhZ2FlaWxnZXN2ZW5za2Flc3Bhw7FhbWVuc2FqZXVzdWFyaW90cmFiYWpvbcOpeGljb3DDoWdpbmFzaWVtcHJlc2lzdGVtYW9jdHVicmVkdXJhbnRlYcOxYWRpcmVtcHJlc2Ftb21lbnRvbnVlc3Ryb3ByaW1lcmF0cmF2w6lzZ3JhY2lhc251ZXN0cmFwcm9jZXNvZXN0YWRvc2NhbGlkYWRwZXJzb25hbsO6bWVyb2FjdWVyZG9tw7pzaWNhbWllbWJyb29mZXJ0YXNhbGd1bm9zcGHDrXNlc2VqZW1wbG9kZXJlY2hvYWRlbcOhc3ByaXZhZG9hZ3JlZ2FyZW5sYWNlc3Bvc2libGVob3RlbGVzc2V2aWxsYXByaW1lcm/Dumx0aW1vZXZlbnRvc2FyY2hpdm9jdWx0dXJhbXVqZXJlc2VudHJhZGFhbnVuY2lvZW1iYXJnb21lcmNhZG9ncmFuZGVzZXN0dWRpb21lam9yZXNmZWJyZXJvZGlzZcOxb3R1cmlzbW9jw7NkaWdvcG9ydGFkYWVzcGFjaW9mYW1pbGlhYW50b25pb3Blcm1pdGVndWFyZGFyYWxndW5hc3ByZWNpb3NhbGd1aWVuc2VudGlkb3Zpc2l0YXN0w610dWxvY29ub2NlcnNlZ3VuZG9jb25zZWpvZnJhbmNpYW1pbnV0b3NzZWd1bmRhdGVuZW1vc2VmZWN0b3Ntw6FsYWdhc2VzacOzbnJldmlzdGFncmFuYWRhY29tcHJhcmluZ3Jlc29nYXJjw61hYWNjacOzbmVjdWFkb3JxdWllbmVzaW5jbHVzb2RlYmVyw6FtYXRlcmlhaG9tYnJlc211ZXN0cmFwb2Ryw61hbWHDsWFuYcO6bHRpbWFlc3RhbW9zb2ZpY2lhbHRhbWJpZW5uaW5nw7puc2FsdWRvc3BvZGVtb3NtZWpvcmFycG9zaXRpb25idXNpbmVzc2hvbWVwYWdlc2VjdXJpdHlsYW5ndWFnZXN0YW5kYXJkY2FtcGFpZ25mZWF0dXJlc2NhdGVnb3J5ZXh0ZXJuYWxjaGlsZHJlbnJlc2VydmVkcmVzZWFyY2hleGNoYW5nZWZhdm9yaXRldGVtcGxhdGVtaWxpdGFyeWluZHVzdHJ5c2VydmljZXNtYXRlcmlhbHByb2R1Y3Rzei1pbmRleDpjb21tZW50c3NvZnR3YXJlY29tcGxldGVjYWxlbmRhcnBsYXRmb3JtYXJ0aWNsZXNyZXF1aXJlZG1vdmVtZW50cXVlc3Rpb25idWlsZGluZ3BvbGl0aWNzcG9zc2libGVyZWxpZ2lvbnBoeXNpY2FsZmVlZGJhY2tyZWdpc3RlcnBpY3R1cmVzZGlzYWJsZWRwcm90b2NvbGF1ZGllbmNlc2V0dGluZ3NhY3Rpdml0eWVsZW1lbnRzbGVhcm5pbmdhbnl0aGluZ2Fic3RyYWN0cHJvZ3Jlc3NvdmVydmlld21hZ2F6aW5lZWNvbm9taWN0cmFpbmluZ3ByZXNzdXJldmFyaW91cyA8c3Ryb25nPnByb3BlcnR5c2hvcHBpbmd0b2dldGhlcmFkdmFuY2VkYmVoYXZpb3Jkb3dubG9hZGZlYXR1cmVkZm9vdGJhbGxzZWxlY3RlZExhbmd1YWdlZGlzdGFuY2VyZW1lbWJlcnRyYWNraW5ncGFzc3dvcmRtb2RpZmllZHN0dWRlbnRzZGlyZWN0bHlmaWdodGluZ25vcnRoZXJuZGF0YWJhc2VmZXN0aXZhbGJyZWFraW5nbG9jYXRpb25pbnRlcm5ldGRyb3Bkb3ducHJhY3RpY2VldmlkZW5jZWZ1bmN0aW9ubWFycmlhZ2VyZXNwb25zZXByb2JsZW1zbmVnYXRpdmVwcm9ncmFtc2FuYWx5c2lzcmVsZWFzZWRiYW5uZXIiPnB1cmNoYXNlcG9saWNpZXNyZWdpb25hbGNyZWF0aXZlYXJndW1lbnRib29rbWFya3JlZmVycmVyY2hlbWljYWxkaXZpc2lvbmNhbGxiYWNrc2VwYXJhdGVwcm9qZWN0c2NvbmZsaWN0aGFyZHdhcmVpbnRlcmVzdGRlbGl2ZXJ5bW91bnRhaW5vYnRhaW5lZD0gZmFsc2U7Zm9yKHZhciBhY2NlcHRlZGNhcGFjaXR5Y29tcHV0ZXJpZGVudGl0eWFpcmNyYWZ0ZW1wbG95ZWRwcm9wb3NlZGRvbWVzdGljaW5jbHVkZXNwcm92aWRlZGhvc3BpdGFsdmVydGljYWxjb2xsYXBzZWFwcHJvYWNocGFydG5lcnNsb2dvIj48YWRhdWdodGVyYXV0aG9yIiBjdWx0dXJhbGZhbWlsaWVzL2ltYWdlcy9hc3NlbWJseXBvd2VyZnVsdGVhY2hpbmdmaW5pc2hlZGRpc3RyaWN0Y3JpdGljYWxjZ2ktYmluL3B1cnBvc2VzcmVxdWlyZXNlbGVjdGlvbmJlY29taW5ncHJvdmlkZXNhY2FkZW1pY2V4ZXJjaXNlYWN0dWFsbHltZWRpY2luZWNvbnN0YW50YWNjaWRlbnRNYWdhemluZWRvY3VtZW50c3RhcnRpbmdib3R0b20iPm9ic2VydmVkOiAmcXVvdDtleHRlbmRlZHByZXZpb3VzU29mdHdhcmVjdXN0b21lcmRlY2lzaW9uc3RyZW5ndGhkZXRhaWxlZHNsaWdodGx5cGxhbm5pbmd0ZXh0YXJlYWN1cnJlbmN5ZXZlcnlvbmVzdHJhaWdodHRyYW5zZmVycG9zaXRpdmVwcm9kdWNlZGhlcml0YWdlc2hpcHBpbmdhYnNvbHV0ZXJlY2VpdmVkcmVsZXZhbnRidXR0b24iIHZpb2xlbmNlYW55d2hlcmViZW5lZml0c2xhdW5jaGVkcmVjZW50bHlhbGxpYW5jZWZvbGxvd2VkbXVsdGlwbGVidWxsZXRpbmluY2x1ZGVkb2NjdXJyZWRpbnRlcm5hbCQodGhpcykucmVwdWJsaWM+PHRyPjx0ZGNvbmdyZXNzcmVjb3JkZWR1bHRpbWF0ZXNvbHV0aW9uPHVsIGlkPSJkaXNjb3ZlckhvbWU8L2E+d2Vic2l0ZXNuZXR3b3Jrc2FsdGhvdWdoZW50aXJlbHltZW1vcmlhbG1lc3NhZ2VzY29udGludWVhY3RpdmUiPnNvbWV3aGF0dmljdG9yaWFXZXN0ZXJuICB0aXRsZT0iTG9jYXRpb25jb250cmFjdHZpc2l0b3JzRG93bmxvYWR3aXRob3V0IHJpZ2h0Ij4KbWVhc3VyZXN3aWR0aCA9IHZhcmlhYmxlaW52b2x2ZWR2aXJnaW5pYW5vcm1hbGx5aGFwcGVuZWRhY2NvdW50c3N0YW5kaW5nbmF0aW9uYWxSZWdpc3RlcnByZXBhcmVkY29udHJvbHNhY2N1cmF0ZWJpcnRoZGF5c3RyYXRlZ3lvZmZpY2lhbGdyYXBoaWNzY3JpbWluYWxwb3NzaWJseWNvbnN1bWVyUGVyc29uYWxzcGVha2luZ3ZhbGlkYXRlYWNoaWV2ZWQuanBnIiAvPm1hY2hpbmVzPC9oMj4KICBrZXl3b3Jkc2ZyaWVuZGx5YnJvdGhlcnNjb21iaW5lZG9yaWdpbmFsY29tcG9zZWRleHBlY3RlZGFkZXF1YXRlcGFraXN0YW5mb2xsb3ciIHZhbHVhYmxlPC9sYWJlbD5yZWxhdGl2ZWJyaW5naW5naW5jcmVhc2Vnb3Zlcm5vcnBsdWdpbnMvTGlzdCBvZiBIZWFkZXIiPiIgbmFtZT0iICgmcXVvdDtncmFkdWF0ZTwvaGVhZD4KY29tbWVyY2VtYWxheXNpYWRpcmVjdG9ybWFpbnRhaW47aGVpZ2h0OnNjaGVkdWxlY2hhbmdpbmdiYWNrIHRvIGNhdGhvbGljcGF0dGVybnNjb2xvcjogI2dyZWF0ZXN0c3VwcGxpZXNyZWxpYWJsZTwvdWw+CgkJPHNlbGVjdCBjaXRpemVuc2Nsb3RoaW5nd2F0Y2hpbmc8bGkgaWQ9InNwZWNpZmljY2FycnlpbmdzZW50ZW5jZTxjZW50ZXI+Y29udHJhc3R0aGlua2luZ2NhdGNoKGUpc291dGhlcm5NaWNoYWVsIG1lcmNoYW50Y2Fyb3VzZWxwYWRkaW5nOmludGVyaW9yLnNwbGl0KCJsaXphdGlvbk9jdG9iZXIgKXtyZXR1cm5pbXByb3ZlZC0tJmd0OwoKY292ZXJhZ2VjaGFpcm1hbi5wbmciIC8+c3ViamVjdHNSaWNoYXJkIHdoYXRldmVycHJvYmFibHlyZWNvdmVyeWJhc2ViYWxsanVkZ21lbnRjb25uZWN0Li5jc3MiIC8+IHdlYnNpdGVyZXBvcnRlZGRlZmF1bHQiLz48L2E+DQplbGVjdHJpY3Njb3RsYW5kY3JlYXRpb25xdWFudGl0eS4gSVNCTiAwZGlkIG5vdCBpbnN0YW5jZS1zZWFyY2gtIiBsYW5nPSJzcGVha2Vyc0NvbXB1dGVyY29udGFpbnNhcmNoaXZlc21pbmlzdGVycmVhY3Rpb25kaXNjb3VudEl0YWxpYW5vY3JpdGVyaWFzdHJvbmdseTogJ2h0dHA6J3NjcmlwdCdjb3ZlcmluZ29mZmVyaW5nYXBwZWFyZWRCcml0aXNoIGlkZW50aWZ5RmFjZWJvb2tudW1lcm91c3ZlaGljbGVzY29uY2VybnNBbWVyaWNhbmhhbmRsaW5nZGl2IGlkPSJXaWxsaWFtIHByb3ZpZGVyX2NvbnRlbnRhY2N1cmFjeXNlY3Rpb24gYW5kZXJzb25mbGV4aWJsZUNhdGVnb3J5bGF3cmVuY2U8c2NyaXB0PmxheW91dD0iYXBwcm92ZWQgbWF4aW11bWhlYWRlciI+PC90YWJsZT5TZXJ2aWNlc2hhbWlsdG9uY3VycmVudCBjYW5hZGlhbmNoYW5uZWxzL3RoZW1lcy8vYXJ0aWNsZW9wdGlvbmFscG9ydHVnYWx2YWx1ZT0iImludGVydmFsd2lyZWxlc3NlbnRpdGxlZGFnZW5jaWVzU2VhcmNoIiBtZWFzdXJlZHRob3VzYW5kc3BlbmRpbmcmaGVsbGlwO25ldyBEYXRlIiBzaXplPSJwYWdlTmFtZW1pZGRsZSIgIiAvPjwvYT5oaWRkZW4iPnNlcXVlbmNlcGVyc29uYWxvdmVyZmxvd29waW5pb25zaWxsaW5vaXNsaW5rcyI+Cgk8dGl0bGU+dmVyc2lvbnNzYXR1cmRheXRlcm1pbmFsaXRlbXByb3BlbmdpbmVlcnNlY3Rpb25zZGVzaWduZXJwcm9wb3NhbD0iZmFsc2UiRXNwYcOxb2xyZWxlYXNlc3N1Ym1pdCIgZXImcXVvdDthZGRpdGlvbnN5bXB0b21zb3JpZW50ZWRyZXNvdXJjZXJpZ2h0Ij48cGxlYXN1cmVzdGF0aW9uc2hpc3RvcnkubGVhdmluZyAgYm9yZGVyPWNvbnRlbnRzY2VudGVyIj4uCgpTb21lIGRpcmVjdGVkc3VpdGFibGVidWxnYXJpYS5zaG93KCk7ZGVzaWduZWRHZW5lcmFsIGNvbmNlcHRzRXhhbXBsZXN3aWxsaWFtc09yaWdpbmFsIj48c3Bhbj5zZWFyY2giPm9wZXJhdG9ycmVxdWVzdHNhICZxdW90O2FsbG93aW5nRG9jdW1lbnRyZXZpc2lvbi4gCgpUaGUgeW91cnNlbGZDb250YWN0IG1pY2hpZ2FuRW5nbGlzaCBjb2x1bWJpYXByaW9yaXR5cHJpbnRpbmdkcmlua2luZ2ZhY2lsaXR5cmV0dXJuZWRDb250ZW50IG9mZmljZXJzUnVzc2lhbiBnZW5lcmF0ZS04ODU5LTEiaW5kaWNhdGVmYW1pbGlhciBxdWFsaXR5bWFyZ2luOjAgY29udGVudHZpZXdwb3J0Y29udGFjdHMtdGl0bGUiPnBvcnRhYmxlLmxlbmd0aCBlbGlnaWJsZWludm9sdmVzYXRsYW50aWNvbmxvYWQ9ImRlZmF1bHQuc3VwcGxpZWRwYXltZW50c2dsb3NzYXJ5CgpBZnRlciBndWlkYW5jZTwvdGQ+PHRkZW5jb2RpbmdtaWRkbGUiPmNhbWUgdG8gZGlzcGxheXNzY290dGlzaGpvbmF0aGFubWFqb3JpdHl3aWRnZXRzLmNsaW5pY2FsdGhhaWxhbmR0ZWFjaGVyczxoZWFkPgoJYWZmZWN0ZWRzdXBwb3J0c3BvaW50ZXI7dG9TdHJpbmc8L3NtYWxsPm9rbGFob21hd2lsbCBiZSBpbnZlc3RvcjAiIGFsdD0iaG9saWRheXNSZXNvdXJjZWxpY2Vuc2VkICh3aGljaCAuIEFmdGVyIGNvbnNpZGVydmlzaXRpbmdleHBsb3JlcnByaW1hcnkgc2VhcmNoIiBhbmRyb2lkInF1aWNrbHkgbWVldGluZ3Nlc3RpbWF0ZTtyZXR1cm4gO2NvbG9yOiMgaGVpZ2h0PWFwcHJvdmFsLCAmcXVvdDsgY2hlY2tlZC5taW4uanMibWFnbmV0aWM+PC9hPjwvaGZvcmVjYXN0LiBXaGlsZSB0aHVyc2RheWR2ZXJ0aXNlJmVhY3V0ZTtoYXNDbGFzc2V2YWx1YXRlb3JkZXJpbmdleGlzdGluZ3BhdGllbnRzIE9ubGluZSBjb2xvcmFkb09wdGlvbnMiY2FtcGJlbGw8IS0tIGVuZDwvc3Bhbj48PGJyIC8+DQpfcG9wdXBzfHNjaWVuY2VzLCZxdW90OyBxdWFsaXR5IFdpbmRvd3MgYXNzaWduZWRoZWlnaHQ6IDxiIGNsYXNzbGUmcXVvdDsgdmFsdWU9IiBDb21wYW55ZXhhbXBsZXM8aWZyYW1lIGJlbGlldmVzcHJlc2VudHNtYXJzaGFsbHBhcnQgb2YgcHJvcGVybHkpLgoKVGhlIHRheG9ub215bXVjaCBvZiA8L3NwYW4+CiIgZGF0YS1zcnR1Z3XDqnNzY3JvbGxUbyBwcm9qZWN0PGhlYWQ+DQphdHRvcm5leWVtcGhhc2lzc3BvbnNvcnNmYW5jeWJveHdvcmxkJ3Mgd2lsZGxpZmVjaGVja2VkPXNlc3Npb25zcHJvZ3JhbW1weDtmb250LSBQcm9qZWN0am91cm5hbHNiZWxpZXZlZHZhY2F0aW9udGhvbXBzb25saWdodGluZ2FuZCB0aGUgc3BlY2lhbCBib3JkZXI9MGNoZWNraW5nPC90Ym9keT48YnV0dG9uIENvbXBsZXRlY2xlYXJmaXgKPGhlYWQ+CmFydGljbGUgPHNlY3Rpb25maW5kaW5nc3JvbGUgaW4gcG9wdWxhciAgT2N0b2JlcndlYnNpdGUgZXhwb3N1cmV1c2VkIHRvICBjaGFuZ2Vzb3BlcmF0ZWRjbGlja2luZ2VudGVyaW5nY29tbWFuZHNpbmZvcm1lZCBudW1iZXJzICA8L2Rpdj5jcmVhdGluZ29uU3VibWl0bWFyeWxhbmRjb2xsZWdlc2FuYWx5dGljbGlzdGluZ3Njb250YWN0LmxvZ2dlZEluYWR2aXNvcnlzaWJsaW5nc2NvbnRlbnQicyZxdW90OylzLiBUaGlzIHBhY2thZ2VzY2hlY2tib3hzdWdnZXN0c3ByZWduYW50dG9tb3Jyb3dzcGFjaW5nPWljb24ucG5namFwYW5lc2Vjb2RlYmFzZWJ1dHRvbiI+Z2FtYmxpbmdzdWNoIGFzICwgd2hpbGUgPC9zcGFuPiBtaXNzb3VyaXNwb3J0aW5ndG9wOjFweCAuPC9zcGFuPnRlbnNpb25zd2lkdGg9IjJsYXp5bG9hZG5vdmVtYmVydXNlZCBpbiBoZWlnaHQ9ImNyaXB0Ij4KJm5ic3A7PC88dHI+PHRkIGhlaWdodDoyL3Byb2R1Y3Rjb3VudHJ5IGluY2x1ZGUgZm9vdGVyIiAmbHQ7IS0tIHRpdGxlIj48L2pxdWVyeS48L2Zvcm0+CijnroDkvZMpKOe5gemrlClocnZhdHNraWl0YWxpYW5vcm9tw6JuxIN0w7xya8OnZdin2LHYr9mIdGFtYmnDqW5ub3RpY2lhc21lbnNhamVzcGVyc29uYXNkZXJlY2hvc25hY2lvbmFsc2VydmljaW9jb250YWN0b3VzdWFyaW9zcHJvZ3JhbWFnb2JpZXJub2VtcHJlc2FzYW51bmNpb3N2YWxlbmNpYWNvbG9tYmlhZGVzcHXDqXNkZXBvcnRlc3Byb3llY3RvcHJvZHVjdG9ww7pibGljb25vc290cm9zaGlzdG9yaWFwcmVzZW50ZW1pbGxvbmVzbWVkaWFudGVwcmVndW50YWFudGVyaW9ycmVjdXJzb3Nwcm9ibGVtYXNhbnRpYWdvbnVlc3Ryb3NvcGluacOzbmltcHJpbWlybWllbnRyYXNhbcOpcmljYXZlbmRlZG9yc29jaWVkYWRyZXNwZWN0b3JlYWxpemFycmVnaXN0cm9wYWxhYnJhc2ludGVyw6lzZW50b25jZXNlc3BlY2lhbG1pZW1icm9zcmVhbGlkYWRjw7NyZG9iYXphcmFnb3phcMOhZ2luYXNzb2NpYWxlc2Jsb3F1ZWFyZ2VzdGnDs25hbHF1aWxlcnNpc3RlbWFzY2llbmNpYXNjb21wbGV0b3ZlcnNpw7NuY29tcGxldGFlc3R1ZGlvc3DDumJsaWNhb2JqZXRpdm9hbGljYW50ZWJ1c2NhZG9yY2FudGlkYWRlbnRyYWRhc2FjY2lvbmVzYXJjaGl2b3NzdXBlcmlvcm1heW9yw61hYWxlbWFuaWFmdW5jacOzbsO6bHRpbW9zaGFjaWVuZG9hcXVlbGxvc2VkaWNpw7NuZmVybmFuZG9hbWJpZW50ZWZhY2Vib29rbnVlc3RyYXNjbGllbnRlc3Byb2Nlc29zYmFzdGFudGVwcmVzZW50YXJlcG9ydGFyY29uZ3Jlc29wdWJsaWNhcmNvbWVyY2lvY29udHJhdG9qw7N2ZW5lc2Rpc3RyaXRvdMOpY25pY2Fjb25qdW50b2VuZXJnw61hdHJhYmFqYXJhc3R1cmlhc3JlY2llbnRldXRpbGl6YXJib2xldMOtbnNhbHZhZG9yY29ycmVjdGF0cmFiYWpvc3ByaW1lcm9zbmVnb2Npb3NsaWJlcnRhZGRldGFsbGVzcGFudGFsbGFwcsOzeGltb2FsbWVyw61hYW5pbWFsZXNxdWnDqW5lc2NvcmF6w7Nuc2VjY2nDs25idXNjYW5kb29wY2lvbmVzZXh0ZXJpb3Jjb25jZXB0b3RvZGF2w61hZ2FsZXLDrWFlc2NyaWJpcm1lZGljaW5hbGljZW5jaWFjb25zdWx0YWFzcGVjdG9zY3LDrXRpY2Fkw7NsYXJlc2p1c3RpY2lhZGViZXLDoW5wZXLDrW9kb25lY2VzaXRhbWFudGVuZXJwZXF1ZcOxb3JlY2liaWRhdHJpYnVuYWx0ZW5lcmlmZWNhbmNpw7NuY2FuYXJpYXNkZXNjYXJnYWRpdmVyc29zbWFsbG9yY2FyZXF1aWVyZXTDqWNuaWNvZGViZXLDrWF2aXZpZW5kYWZpbmFuemFzYWRlbGFudGVmdW5jaW9uYWNvbnNlam9zZGlmw61jaWxjaXVkYWRlc2FudGlndWFzYXZhbnphZGF0w6lybWlub3VuaWRhZGVzc8OhbmNoZXpjYW1wYcOxYXNvZnRvbmljcmV2aXN0YXNjb250aWVuZXNlY3RvcmVzbW9tZW50b3NmYWN1bHRhZGNyw6lkaXRvZGl2ZXJzYXNzdXB1ZXN0b2ZhY3RvcmVzc2VndW5kb3NwZXF1ZcOxYdCz0L7QtNCw0LXRgdC70LjQtdGB0YLRjNCx0YvQu9C+0LHRi9GC0YzRjdGC0L7QvNCV0YHQu9C40YLQvtCz0L7QvNC10L3Rj9Cy0YHQtdGF0Y3RgtC+0LnQtNCw0LbQtdCx0YvQu9C40LPQvtC00YPQtNC10L3RjNGN0YLQvtGC0LHRi9C70LDRgdC10LHRj9C+0LTQuNC90YHQtdCx0LXQvdCw0LTQvtGB0LDQudGC0YTQvtGC0L7QvdC10LPQvtGB0LLQvtC40YHQstC+0LnQuNCz0YDRi9GC0L7QttC10LLRgdC10LzRgdCy0L7RjtC70LjRiNGM0Y3RgtC40YXQv9C+0LrQsNC00L3QtdC50LTQvtC80LDQvNC40YDQsNC70LjQsdC+0YLQtdC80YPRhdC+0YLRj9C00LLRg9GF0YHQtdGC0LjQu9GO0LTQuNC00LXQu9C+0LzQuNGA0LXRgtC10LHRj9GB0LLQvtC10LLQuNC00LXRh9C10LPQvtGN0YLQuNC80YHRh9C10YLRgtC10LzRi9GG0LXQvdGL0YHRgtCw0LvQstC10LTRjNGC0LXQvNC10LLQvtC00YvRgtC10LHQtdCy0YvRiNC10L3QsNC80LjRgtC40L/QsNGC0L7QvNGD0L/RgNCw0LLQu9C40YbQsNC+0LTQvdCw0LPQvtC00YvQt9C90LDRjtC80L7Qs9GD0LTRgNGD0LPQstGB0LXQudC40LTQtdGC0LrQuNC90L7QvtC00L3QvtC00LXQu9Cw0LTQtdC70LXRgdGA0L7QutC40Y7QvdGP0LLQtdGB0YzQldGB0YLRjNGA0LDQt9Cw0L3QsNGI0LjYp9mE2YTZh9in2YTYqtmK2KzZhdmK2LnYrtin2LXYqdin2YTYsNmK2LnZhNmK2YfYrNiv2YrYr9in2YTYotmG2KfZhNix2K/Yqtit2YPZhdi12YHYrdip2YPYp9mG2KrYp9mE2YTZitmK2YPZiNmG2LTYqNmD2KnZgdmK2YfYp9io2YbYp9iq2K3ZiNin2KHYo9mD2KvYsdiu2YTYp9mE2KfZhNit2KjYr9mE2YrZhNiv2LHZiNiz2KfYtti62LfYqtmD2YjZhtmH2YbYp9mD2LPYp9it2KnZhtin2K/Zitin2YTYt9io2LnZhNmK2YPYtNmD2LHYp9mK2YXZg9mG2YXZhtmH2KfYtNix2YPYqdix2KbZitiz2YbYtNmK2LfZhdin2LDYp9in2YTZgdmG2LTYqNin2KjYqti52KjYsdix2K3Zhdip2YPYp9mB2KnZitmC2YjZhNmF2LHZg9iy2YPZhNmF2KnYo9it2YXYr9mC2YTYqNmK2YrYudmG2YrYtdmI2LHYqdi32LHZitmC2LTYp9ix2YPYrNmI2KfZhNij2K7YsdmJ2YXYudmG2KfYp9io2K3Yq9i52LHZiNi22KjYtNmD2YTZhdiz2KzZhNio2YbYp9mG2K7Yp9mE2K/Zg9iq2KfYqNmD2YTZitip2KjYr9mI2YbYo9mK2LbYp9mK2YjYrNiv2YHYsdmK2YLZg9iq2KjYqtij2YHYttmE2YXYt9io2K7Yp9mD2KvYsdio2KfYsdmD2KfZgdi22YTYp9it2YTZidmG2YHYs9mH2KPZitin2YXYsdiv2YjYr9ij2YbZh9in2K/ZitmG2KfYp9mE2KfZhtmF2LnYsdi22KrYudmE2YXYr9in2K7ZhNmF2YXZg9mGAEH0suYAC1wBAAEAAQABAAIAAgACAAIABAAEAAQABAAAAQIDBAUGBwcGBQQDAgEACAkKCwwNDg8PDg0MCwoJCBAREhMUFRYXFxYVFBMSERAYGRobHB0eHx8eHRwbGhkY/////wBB2LPmAAvk6QT/////AQAAAAIAAAACAAAAAQAAAAEAAAADAAAA//8AAQAAAAEAAP//AAEAAAAIAAgACAAIAAAAAQACAAMABAAFAAYAB3Jlc291cmNlc2NvdW50cmllc3F1ZXN0aW9uc2VxdWlwbWVudGNvbW11bml0eWF2YWlsYWJsZWhpZ2hsaWdodERURC94aHRtbG1hcmtldGluZ2tub3dsZWRnZXNvbWV0aGluZ2NvbnRhaW5lcmRpcmVjdGlvbnN1YnNjcmliZWFkdmVydGlzZWNoYXJhY3RlciIgdmFsdWU9Ijwvc2VsZWN0PkF1c3RyYWxpYSIgY2xhc3M9InNpdHVhdGlvbmF1dGhvcml0eWZvbGxvd2luZ3ByaW1hcmlseW9wZXJhdGlvbmNoYWxsZW5nZWRldmVsb3BlZGFub255bW91c2Z1bmN0aW9uIGZ1bmN0aW9uc2NvbXBhbmllc3N0cnVjdHVyZWFncmVlbWVudCIgdGl0bGU9InBvdGVudGlhbGVkdWNhdGlvbmFyZ3VtZW50c3NlY29uZGFyeWNvcHlyaWdodGxhbmd1YWdlc2V4Y2x1c2l2ZWNvbmRpdGlvbjwvZm9ybT4NCnN0YXRlbWVudGF0dGVudGlvbkJpb2dyYXBoeX0gZWxzZSB7CnNvbHV0aW9uc3doZW4gdGhlIEFuYWx5dGljc3RlbXBsYXRlc2Rhbmdlcm91c3NhdGVsbGl0ZWRvY3VtZW50c3B1Ymxpc2hlcmltcG9ydGFudHByb3RvdHlwZWluZmx1ZW5jZSZyYXF1bzs8L2VmZmVjdGl2ZWdlbmVyYWxseXRyYW5zZm9ybWJlYXV0aWZ1bHRyYW5zcG9ydG9yZ2FuaXplZHB1Ymxpc2hlZHByb21pbmVudHVudGlsIHRoZXRodW1ibmFpbE5hdGlvbmFsIC5mb2N1cygpO292ZXIgdGhlIG1pZ3JhdGlvbmFubm91bmNlZGZvb3RlciI+CmV4Y2VwdGlvbmxlc3MgdGhhbmV4cGVuc2l2ZWZvcm1hdGlvbmZyYW1ld29ya3RlcnJpdG9yeW5kaWNhdGlvbmN1cnJlbnRseWNsYXNzTmFtZWNyaXRpY2lzbXRyYWRpdGlvbmVsc2V3aGVyZUFsZXhhbmRlcmFwcG9pbnRlZG1hdGVyaWFsc2Jyb2FkY2FzdG1lbnRpb25lZGFmZmlsaWF0ZTwvb3B0aW9uPnRyZWF0bWVudGRpZmZlcmVudC9kZWZhdWx0LlByZXNpZGVudG9uY2xpY2s9ImJpb2dyYXBoeW90aGVyd2lzZXBlcm1hbmVudEZyYW7Dp2Fpc0hvbGx5d29vZGV4cGFuc2lvbnN0YW5kYXJkczwvc3R5bGU+CnJlZHVjdGlvbkRlY2VtYmVyIHByZWZlcnJlZENhbWJyaWRnZW9wcG9uZW50c0J1c2luZXNzIGNvbmZ1c2lvbj4KPHRpdGxlPnByZXNlbnRlZGV4cGxhaW5lZGRvZXMgbm90IHdvcmxkd2lkZWludGVyZmFjZXBvc2l0aW9uc25ld3NwYXBlcjwvdGFibGU+Cm1vdW50YWluc2xpa2UgdGhlIGVzc2VudGlhbGZpbmFuY2lhbHNlbGVjdGlvbmFjdGlvbj0iL2FiYW5kb25lZEVkdWNhdGlvbnBhcnNlSW50KHN0YWJpbGl0eXVuYWJsZSB0bzwvdGl0bGU+CnJlbGF0aW9uc05vdGUgdGhhdGVmZmljaWVudHBlcmZvcm1lZHR3byB5ZWFyc1NpbmNlIHRoZXRoZXJlZm9yZXdyYXBwZXIiPmFsdGVybmF0ZWluY3JlYXNlZEJhdHRsZSBvZnBlcmNlaXZlZHRyeWluZyB0b25lY2Vzc2FyeXBvcnRyYXllZGVsZWN0aW9uc0VsaXphYmV0aDwvaWZyYW1lPmRpc2NvdmVyeWluc3VyYW5jZXMubGVuZ3RoO2xlZ2VuZGFyeUdlb2dyYXBoeWNhbmRpZGF0ZWNvcnBvcmF0ZXNvbWV0aW1lc3NlcnZpY2VzLmluaGVyaXRlZDwvc3Ryb25nPkNvbW11bml0eXJlbGlnaW91c2xvY2F0aW9uc0NvbW1pdHRlZWJ1aWxkaW5nc3RoZSB3b3JsZG5vIGxvbmdlcmJlZ2lubmluZ3JlZmVyZW5jZWNhbm5vdCBiZWZyZXF1ZW5jeXR5cGljYWxseWludG8gdGhlIHJlbGF0aXZlO3JlY29yZGluZ3ByZXNpZGVudGluaXRpYWxseXRlY2huaXF1ZXRoZSBvdGhlcml0IGNhbiBiZWV4aXN0ZW5jZXVuZGVybGluZXRoaXMgdGltZXRlbGVwaG9uZWl0ZW1zY29wZXByYWN0aWNlc2FkdmFudGFnZSk7cmV0dXJuIEZvciBvdGhlcnByb3ZpZGluZ2RlbW9jcmFjeWJvdGggdGhlIGV4dGVuc2l2ZXN1ZmZlcmluZ3N1cHBvcnRlZGNvbXB1dGVycyBmdW5jdGlvbnByYWN0aWNhbHNhaWQgdGhhdGl0IG1heSBiZUVuZ2xpc2g8L2Zyb20gdGhlIHNjaGVkdWxlZGRvd25sb2FkczwvbGFiZWw+CnN1c3BlY3RlZG1hcmdpbjogMHNwaXJpdHVhbDwvaGVhZD4KCm1pY3Jvc29mdGdyYWR1YWxseWRpc2N1c3NlZGhlIGJlY2FtZWV4ZWN1dGl2ZWpxdWVyeS5qc2hvdXNlaG9sZGNvbmZpcm1lZHB1cmNoYXNlZGxpdGVyYWxseWRlc3Ryb3llZHVwIHRvIHRoZXZhcmlhdGlvbnJlbWFpbmluZ2l0IGlzIG5vdGNlbnR1cmllc0phcGFuZXNlIGFtb25nIHRoZWNvbXBsZXRlZGFsZ29yaXRobWludGVyZXN0c3JlYmVsbGlvbnVuZGVmaW5lZGVuY291cmFnZXJlc2l6YWJsZWludm9sdmluZ3NlbnNpdGl2ZXVuaXZlcnNhbHByb3Zpc2lvbihhbHRob3VnaGZlYXR1cmluZ2NvbmR1Y3RlZCksIHdoaWNoIGNvbnRpbnVlZC1oZWFkZXIiPkZlYnJ1YXJ5IG51bWVyb3VzIG92ZXJmbG93OmNvbXBvbmVudGZyYWdtZW50c2V4Y2VsbGVudGNvbHNwYW49InRlY2huaWNhbG5lYXIgdGhlIEFkdmFuY2VkIHNvdXJjZSBvZmV4cHJlc3NlZEhvbmcgS29uZyBGYWNlYm9va211bHRpcGxlIG1lY2hhbmlzbWVsZXZhdGlvbm9mZmVuc2l2ZTwvZm9ybT4KCXNwb25zb3JlZGRvY3VtZW50Lm9yICZxdW90O3RoZXJlIGFyZXRob3NlIHdob21vdmVtZW50c3Byb2Nlc3Nlc2RpZmZpY3VsdHN1Ym1pdHRlZHJlY29tbWVuZGNvbnZpbmNlZHByb21vdGluZyIgd2lkdGg9Ii5yZXBsYWNlKGNsYXNzaWNhbGNvYWxpdGlvbmhpcyBmaXJzdGRlY2lzaW9uc2Fzc2lzdGFudGluZGljYXRlZGV2b2x1dGlvbi13cmFwcGVyImVub3VnaCB0b2Fsb25nIHRoZWRlbGl2ZXJlZC0tPg0KPCEtLUFtZXJpY2FuIHByb3RlY3RlZE5vdmVtYmVyIDwvc3R5bGU+PGZ1cm5pdHVyZUludGVybmV0ICBvbmJsdXI9InN1c3BlbmRlZHJlY2lwaWVudGJhc2VkIG9uIE1vcmVvdmVyLGFib2xpc2hlZGNvbGxlY3RlZHdlcmUgbWFkZWVtb3Rpb25hbGVtZXJnZW5jeW5hcnJhdGl2ZWFkdm9jYXRlc3B4O2JvcmRlcmNvbW1pdHRlZGRpcj0ibHRyImVtcGxveWVlc3Jlc2VhcmNoLiBzZWxlY3RlZHN1Y2Nlc3NvcmN1c3RvbWVyc2Rpc3BsYXllZFNlcHRlbWJlcmFkZENsYXNzKEZhY2Vib29rIHN1Z2dlc3RlZGFuZCBsYXRlcm9wZXJhdGluZ2VsYWJvcmF0ZVNvbWV0aW1lc0luc3RpdHV0ZWNlcnRhaW5seWluc3RhbGxlZGZvbGxvd2Vyc0plcnVzYWxlbXRoZXkgaGF2ZWNvbXB1dGluZ2dlbmVyYXRlZHByb3ZpbmNlc2d1YXJhbnRlZWFyYml0cmFyeXJlY29nbml6ZXdhbnRlZCB0b3B4O3dpZHRoOnRoZW9yeSBvZmJlaGF2aW91cldoaWxlIHRoZWVzdGltYXRlZGJlZ2FuIHRvIGl0IGJlY2FtZW1hZ25pdHVkZW11c3QgaGF2ZW1vcmUgdGhhbkRpcmVjdG9yeWV4dGVuc2lvbnNlY3JldGFyeW5hdHVyYWxseW9jY3VycmluZ3ZhcmlhYmxlc2dpdmVuIHRoZXBsYXRmb3JtLjwvbGFiZWw+PGZhaWxlZCB0b2NvbXBvdW5kc2tpbmRzIG9mIHNvY2lldGllc2Fsb25nc2lkZSAtLSZndDsKCnNvdXRod2VzdHRoZSByaWdodHJhZGlhdGlvbm1heSBoYXZlIHVuZXNjYXBlKHNwb2tlbiBpbiIgaHJlZj0iL3Byb2dyYW1tZW9ubHkgdGhlIGNvbWUgZnJvbWRpcmVjdG9yeWJ1cmllZCBpbmEgc2ltaWxhcnRoZXkgd2VyZTwvZm9udD48L05vcndlZ2lhbnNwZWNpZmllZHByb2R1Y2luZ3Bhc3NlbmdlcihuZXcgRGF0ZXRlbXBvcmFyeWZpY3Rpb25hbEFmdGVyIHRoZWVxdWF0aW9uc2Rvd25sb2FkLnJlZ3VsYXJseWRldmVsb3BlcmFib3ZlIHRoZWxpbmtlZCB0b3BoZW5vbWVuYXBlcmlvZCBvZnRvb2x0aXAiPnN1YnN0YW5jZWF1dG9tYXRpY2FzcGVjdCBvZkFtb25nIHRoZWNvbm5lY3RlZGVzdGltYXRlc0FpciBGb3JjZXN5c3RlbSBvZm9iamVjdGl2ZWltbWVkaWF0ZW1ha2luZyBpdHBhaW50aW5nc2NvbnF1ZXJlZGFyZSBzdGlsbHByb2NlZHVyZWdyb3d0aCBvZmhlYWRlZCBieUV1cm9wZWFuIGRpdmlzaW9uc21vbGVjdWxlc2ZyYW5jaGlzZWludGVudGlvbmF0dHJhY3RlZGNoaWxkaG9vZGFsc28gdXNlZGRlZGljYXRlZHNpbmdhcG9yZWRlZ3JlZSBvZmZhdGhlciBvZmNvbmZsaWN0czwvYT48L3A+CmNhbWUgZnJvbXdlcmUgdXNlZG5vdGUgdGhhdHJlY2VpdmluZ0V4ZWN1dGl2ZWV2ZW4gbW9yZWFjY2VzcyB0b2NvbW1hbmRlclBvbGl0aWNhbG11c2ljaWFuc2RlbGljaW91c3ByaXNvbmVyc2FkdmVudCBvZlVURi04IiAvPjwhW0NEQVRBWyI+Q29udGFjdFNvdXRoZXJuIGJnY29sb3I9InNlcmllcyBvZi4gSXQgd2FzIGluIEV1cm9wZXBlcm1pdHRlZHZhbGlkYXRlLmFwcGVhcmluZ29mZmljaWFsc3NlcmlvdXNseS1sYW5ndWFnZWluaXRpYXRlZGV4dGVuZGluZ2xvbmctdGVybWluZmxhdGlvbnN1Y2ggdGhhdGdldENvb2tpZW1hcmtlZCBieTwvYnV0dG9uPmltcGxlbWVudGJ1dCBpdCBpc2luY3JlYXNlc2Rvd24gdGhlIHJlcXVpcmluZ2RlcGVuZGVudC0tPgo8IS0tIGludGVydmlld1dpdGggdGhlIGNvcGllcyBvZmNvbnNlbnN1c3dhcyBidWlsdFZlbmV6dWVsYShmb3JtZXJseXRoZSBzdGF0ZXBlcnNvbm5lbHN0cmF0ZWdpY2Zhdm91ciBvZmludmVudGlvbldpa2lwZWRpYWNvbnRpbmVudHZpcnR1YWxseXdoaWNoIHdhc3ByaW5jaXBsZUNvbXBsZXRlIGlkZW50aWNhbHNob3cgdGhhdHByaW1pdGl2ZWF3YXkgZnJvbW1vbGVjdWxhcnByZWNpc2VseWRpc3NvbHZlZFVuZGVyIHRoZXZlcnNpb249Ij4mbmJzcDs8L0l0IGlzIHRoZSBUaGlzIGlzIHdpbGwgaGF2ZW9yZ2FuaXNtc3NvbWUgdGltZUZyaWVkcmljaHdhcyBmaXJzdHRoZSBvbmx5IGZhY3QgdGhhdGZvcm0gaWQ9InByZWNlZGluZ1RlY2huaWNhbHBoeXNpY2lzdG9jY3VycyBpbm5hdmlnYXRvcnNlY3Rpb24iPnNwYW4gaWQ9InNvdWdodCB0b2JlbG93IHRoZXN1cnZpdmluZ308L3N0eWxlPmhpcyBkZWF0aGFzIGluIHRoZWNhdXNlZCBieXBhcnRpYWxseWV4aXN0aW5nIHVzaW5nIHRoZXdhcyBnaXZlbmEgbGlzdCBvZmxldmVscyBvZm5vdGlvbiBvZk9mZmljaWFsIGRpc21pc3NlZHNjaWVudGlzdHJlc2VtYmxlc2R1cGxpY2F0ZWV4cGxvc2l2ZXJlY292ZXJlZGFsbCBvdGhlcmdhbGxlcmllc3twYWRkaW5nOnBlb3BsZSBvZnJlZ2lvbiBvZmFkZHJlc3Nlc2Fzc29jaWF0ZWltZyBhbHQ9ImluIG1vZGVybnNob3VsZCBiZW1ldGhvZCBvZnJlcG9ydGluZ3RpbWVzdGFtcG5lZWRlZCB0b3RoZSBHcmVhdHJlZ2FyZGluZ3NlZW1lZCB0b3ZpZXdlZCBhc2ltcGFjdCBvbmlkZWEgdGhhdHRoZSBXb3JsZGhlaWdodCBvZmV4cGFuZGluZ1RoZXNlIGFyZWN1cnJlbnQiPmNhcmVmdWxseW1haW50YWluc2NoYXJnZSBvZkNsYXNzaWNhbGFkZHJlc3NlZHByZWRpY3RlZG93bmVyc2hpcDxkaXYgaWQ9InJpZ2h0Ij4NCnJlc2lkZW5jZWxlYXZlIHRoZWNvbnRlbnQiPmFyZSBvZnRlbiAgfSkoKTsNCnByb2JhYmx5IFByb2Zlc3Nvci1idXR0b24iIHJlc3BvbmRlZHNheXMgdGhhdGhhZCB0byBiZXBsYWNlZCBpbkh1bmdhcmlhbnN0YXR1cyBvZnNlcnZlcyBhc1VuaXZlcnNhbGV4ZWN1dGlvbmFnZ3JlZ2F0ZWZvciB3aGljaGluZmVjdGlvbmFncmVlZCB0b2hvd2V2ZXIsIHBvcHVsYXIiPnBsYWNlZCBvbmNvbnN0cnVjdGVsZWN0b3JhbHN5bWJvbCBvZmluY2x1ZGluZ3JldHVybiB0b2FyY2hpdGVjdENocmlzdGlhbnByZXZpb3VzIGxpdmluZyBpbmVhc2llciB0b3Byb2Zlc3NvcgombHQ7IS0tIGVmZmVjdCBvZmFuYWx5dGljc3dhcyB0YWtlbndoZXJlIHRoZXRvb2sgb3ZlcmJlbGllZiBpbkFmcmlrYWFuc2FzIGZhciBhc3ByZXZlbnRlZHdvcmsgd2l0aGEgc3BlY2lhbDxmaWVsZHNldENocmlzdG1hc1JldHJpZXZlZAoKSW4gdGhlIGJhY2sgaW50b25vcnRoZWFzdG1hZ2F6aW5lcz48c3Ryb25nPmNvbW1pdHRlZWdvdmVybmluZ2dyb3VwcyBvZnN0b3JlZCBpbmVzdGFibGlzaGEgZ2VuZXJhbGl0cyBmaXJzdHRoZWlyIG93bnBvcHVsYXRlZGFuIG9iamVjdENhcmliYmVhbmFsbG93IHRoZWRpc3RyaWN0c3dpc2NvbnNpbmxvY2F0aW9uLjsgd2lkdGg6IGluaGFiaXRlZFNvY2lhbGlzdEphbnVhcnkgMTwvZm9vdGVyPnNpbWlsYXJseWNob2ljZSBvZnRoZSBzYW1lIHNwZWNpZmljIGJ1c2luZXNzIFRoZSBmaXJzdC5sZW5ndGg7IGRlc2lyZSB0b2RlYWwgd2l0aHNpbmNlIHRoZXVzZXJBZ2VudGNvbmNlaXZlZGluZGV4LnBocGFzICZxdW90O2VuZ2FnZSBpbnJlY2VudGx5LGZldyB5ZWFyc3dlcmUgYWxzbwo8aGVhZD4KPGVkaXRlZCBieWFyZSBrbm93bmNpdGllcyBpbmFjY2Vzc2tleWNvbmRlbW5lZGFsc28gaGF2ZXNlcnZpY2VzLGZhbWlseSBvZlNjaG9vbCBvZmNvbnZlcnRlZG5hdHVyZSBvZiBsYW5ndWFnZW1pbmlzdGVyczwvb2JqZWN0PnRoZXJlIGlzIGEgcG9wdWxhcnNlcXVlbmNlc2Fkdm9jYXRlZFRoZXkgd2VyZWFueSBvdGhlcmxvY2F0aW9uPWVudGVyIHRoZW11Y2ggbW9yZXJlZmxlY3RlZHdhcyBuYW1lZG9yaWdpbmFsIGEgdHlwaWNhbHdoZW4gdGhleWVuZ2luZWVyc2NvdWxkIG5vdHJlc2lkZW50c3dlZG5lc2RheXRoZSB0aGlyZCBwcm9kdWN0c0phbnVhcnkgMndoYXQgdGhleWEgY2VydGFpbnJlYWN0aW9uc3Byb2Nlc3NvcmFmdGVyIGhpc3RoZSBsYXN0IGNvbnRhaW5lZCI+PC9kaXY+CjwvYT48L3RkPmRlcGVuZCBvbnNlYXJjaCI+CnBpZWNlcyBvZmNvbXBldGluZ1JlZmVyZW5jZXRlbm5lc3NlZXdoaWNoIGhhcyB2ZXJzaW9uPTwvc3Bhbj4gPDwvaGVhZGVyPmdpdmVzIHRoZWhpc3RvcmlhbnZhbHVlPSIiPnBhZGRpbmc6MHZpZXcgdGhhdHRvZ2V0aGVyLHRoZSBtb3N0IHdhcyBmb3VuZHN1YnNldCBvZmF0dGFjayBvbmNoaWxkcmVuLHBvaW50cyBvZnBlcnNvbmFsIHBvc2l0aW9uOmFsbGVnZWRseUNsZXZlbGFuZHdhcyBsYXRlcmFuZCBhZnRlcmFyZSBnaXZlbndhcyBzdGlsbHNjcm9sbGluZ2Rlc2lnbiBvZm1ha2VzIHRoZW11Y2ggbGVzc0FtZXJpY2Fucy4KCkFmdGVyICwgYnV0IHRoZU11c2V1bSBvZmxvdWlzaWFuYShmcm9tIHRoZW1pbm5lc290YXBhcnRpY2xlc2EgcHJvY2Vzc0RvbWluaWNhbnZvbHVtZSBvZnJldHVybmluZ2RlZmVuc2l2ZTAwcHh8cmlnaG1hZGUgZnJvbW1vdXNlb3ZlciIgc3R5bGU9InN0YXRlcyBvZih3aGljaCBpc2NvbnRpbnVlc0ZyYW5jaXNjb2J1aWxkaW5nIHdpdGhvdXQgYXdpdGggc29tZXdobyB3b3VsZGEgZm9ybSBvZmEgcGFydCBvZmJlZm9yZSBpdGtub3duIGFzICBTZXJ2aWNlc2xvY2F0aW9uIGFuZCBvZnRlbm1lYXN1cmluZ2FuZCBpdCBpc3BhcGVyYmFja3ZhbHVlcyBvZg0KPHRpdGxlPj0gd2luZG93LmRldGVybWluZWVyJnF1b3Q7IHBsYXllZCBieWFuZCBlYXJseTwvY2VudGVyPmZyb20gdGhpc3RoZSB0aHJlZXBvd2VyIGFuZG9mICZxdW90O2lubmVySFRNTDxhIGhyZWY9Ink6aW5saW5lO0NodXJjaCBvZnRoZSBldmVudHZlcnkgaGlnaG9mZmljaWFsIC1oZWlnaHQ6IGNvbnRlbnQ9Ii9jZ2ktYmluL3RvIGNyZWF0ZWFmcmlrYWFuc2VzcGVyYW50b2ZyYW7Dp2Fpc2xhdHZpZcWhdWxpZXR1dmnFs8SMZcWhdGluYcSNZcWhdGluYeC5hOC4l+C4ouaXpeacrOiqnueugOS9k+Wtl+e5gemrlOWtl+2VnOq1reyWtOS4uuS7gOS5iOiuoeeul+acuueslOiusOacrOiojuirluWNgOacjeWKoeWZqOS6kuiBlOe9keaIv+WcsOS6p+S/seS5kOmDqOWHuueJiOekvuaOkuihjOamnOmDqOiQveagvOi/m+S4gOatpeaUr+S7mOWunemqjOivgeeggeWnlOWRmOS8muaVsOaNruW6k+a2iOi0ueiAheWKnuWFrOWupOiuqOiuuuWMuua3seWcs+W4guaSreaUvuWZqOWMl+S6rOW4guWkp+WtpueUn+i2iuadpei2iueuoeeQhuWRmOS/oeaBr+e9kXNlcnZpY2lvc2FydMOtY3Vsb2FyZ2VudGluYWJhcmNlbG9uYWN1YWxxdWllcnB1YmxpY2Fkb3Byb2R1Y3Rvc3BvbMOtdGljYXJlc3B1ZXN0YXdpa2lwZWRpYXNpZ3VpZW50ZWLDunNxdWVkYWNvbXVuaWRhZHNlZ3VyaWRhZHByaW5jaXBhbHByZWd1bnRhc2NvbnRlbmlkb3Jlc3BvbmRlcnZlbmV6dWVsYXByb2JsZW1hc2RpY2llbWJyZXJlbGFjacOzbm5vdmllbWJyZXNpbWlsYXJlc3Byb3llY3Rvc3Byb2dyYW1hc2luc3RpdHV0b2FjdGl2aWRhZGVuY3VlbnRyYWVjb25vbcOtYWltw6FnZW5lc2NvbnRhY3RhcmRlc2Nhcmdhcm5lY2VzYXJpb2F0ZW5jacOzbnRlbMOpZm9ub2NvbWlzacOzbmNhbmNpb25lc2NhcGFjaWRhZGVuY29udHJhcmFuw6FsaXNpc2Zhdm9yaXRvc3TDqXJtaW5vc3Byb3ZpbmNpYWV0aXF1ZXRhc2VsZW1lbnRvc2Z1bmNpb25lc3Jlc3VsdGFkb2NhcsOhY3RlcnByb3BpZWRhZHByaW5jaXBpb25lY2VzaWRhZG11bmljaXBhbGNyZWFjacOzbmRlc2Nhcmdhc3ByZXNlbmNpYWNvbWVyY2lhbG9waW5pb25lc2VqZXJjaWNpb2VkaXRvcmlhbHNhbGFtYW5jYWdvbnrDoWxlemRvY3VtZW50b3BlbMOtY3VsYXJlY2llbnRlc2dlbmVyYWxlc3RhcnJhZ29uYXByw6FjdGljYW5vdmVkYWRlc3Byb3B1ZXN0YXBhY2llbnRlc3TDqWNuaWNhc29iamV0aXZvc2NvbnRhY3Rvc+CkruClh+CkguCksuCkv+Ckj+CkueCliOCkguCkl+Ckr+CkvuCkuOCkvuCkpeCkj+CkteCkguCksOCkueClh+CkleCli+CkiOCkleClgeCkm+CksOCkueCkvuCkrOCkvuCkpuCkleCkueCkvuCkuOCkreClgOCkueClgeCkj+CksOCkueClgOCkruCliOCkguCkpuCkv+CkqOCkrOCkvuCkpGRpcGxvZG9jc+CkuOCkruCkr+CksOClguCkquCkqOCkvuCkruCkquCkpOCkvuCkq+Ckv+CksOCklOCkuOCkpOCkpOCksOCkueCksuCli+Ckl+CkueClgeCkhuCkrOCkvuCksOCkpuClh+CktuCkueClgeCkiOCkluClh+CksuCkr+CkpuCkv+CkleCkvuCkruCkteClh+CkrOCkpOClgOCkqOCkrOClgOCkmuCkruCljOCkpOCkuOCkvuCksuCksuClh+CkluCknOClieCkrOCkruCkpuCkpuCkpOCkpeCkvuCkqOCkueClgOCktuCkueCksOCkheCksuCkl+CkleCkreClgOCkqOCkl+CksOCkquCkvuCkuOCksOCkvuCkpOCkleCkv+Ckj+CkieCkuOClh+Ckl+Ckr+ClgOCkueClguCkgeCkhuCkl+Clh+Ckn+ClgOCkruCkluCli+CknOCkleCkvuCksOCkheCkreClgOCkl+Ckr+Clh+CkpOClgeCkruCkteCli+Ckn+CkpuClh+CkguCkheCkl+CksOCkkOCkuOClh+CkruClh+CksuCksuCkl+CkvuCkueCkvuCksuCkiuCkquCksOCkmuCkvuCksOCkkOCkuOCkvuCkpuClh+CksOCknOCkv+CkuOCkpuCkv+CksuCkrOCkguCkpuCkrOCkqOCkvuCkueClguCkguCksuCkvuCkluCknOClgOCkpOCkrOCkn+CkqOCkruCkv+CksuCkh+CkuOClh+CkhuCkqOClh+CkqOCkr+CkvuCkleClgeCksuCksuClieCkl+CkreCkvuCkl+CksOClh+CksuCknOCkl+CkueCksOCkvuCkruCksuCkl+Clh+CkquClh+CknOCkueCkvuCkpeCkh+CkuOClgOCkuOCkueClgOCkleCksuCkvuCkoOClgOCkleCkueCkvuCkgeCkpuClguCksOCkpOCkueCkpOCkuOCkvuCkpOCkr+CkvuCkpuCkhuCkr+CkvuCkquCkvuCkleCkleCljOCkqOCktuCkvuCkruCkpuClh+CkluCkr+CkueClgOCksOCkvuCkr+CkluClgeCkpuCksuCkl+ClgGNhdGVnb3JpZXNleHBlcmllbmNlPC90aXRsZT4NCkNvcHlyaWdodCBqYXZhc2NyaXB0Y29uZGl0aW9uc2V2ZXJ5dGhpbmc8cCBjbGFzcz0idGVjaG5vbG9neWJhY2tncm91bmQ8YSBjbGFzcz0ibWFuYWdlbWVudCZjb3B5OyAyMDFqYXZhU2NyaXB0Y2hhcmFjdGVyc2JyZWFkY3J1bWJ0aGVtc2VsdmVzaG9yaXpvbnRhbGdvdmVybm1lbnRDYWxpZm9ybmlhYWN0aXZpdGllc2Rpc2NvdmVyZWROYXZpZ2F0aW9udHJhbnNpdGlvbmNvbm5lY3Rpb25uYXZpZ2F0aW9uYXBwZWFyYW5jZTwvdGl0bGU+PG1jaGVja2JveCIgdGVjaG5pcXVlc3Byb3RlY3Rpb25hcHBhcmVudGx5YXMgd2VsbCBhc3VudCcsICdVQS1yZXNvbHV0aW9ub3BlcmF0aW9uc3RlbGV2aXNpb250cmFuc2xhdGVkV2FzaGluZ3Rvbm5hdmlnYXRvci4gPSB3aW5kb3cuaW1wcmVzc2lvbiZsdDticiZndDtsaXRlcmF0dXJlcG9wdWxhdGlvbmJnY29sb3I9IiNlc3BlY2lhbGx5IGNvbnRlbnQ9InByb2R1Y3Rpb25uZXdzbGV0dGVycHJvcGVydGllc2RlZmluaXRpb25sZWFkZXJzaGlwVGVjaG5vbG9neVBhcmxpYW1lbnRjb21wYXJpc29udWwgY2xhc3M9Ii5pbmRleE9mKCJjb25jbHVzaW9uZGlzY3Vzc2lvbmNvbXBvbmVudHNiaW9sb2dpY2FsUmV2b2x1dGlvbl9jb250YWluZXJ1bmRlcnN0b29kbm9zY3JpcHQ+PHBlcm1pc3Npb25lYWNoIG90aGVyYXRtb3NwaGVyZSBvbmZvY3VzPSI8Zm9ybSBpZD0icHJvY2Vzc2luZ3RoaXMudmFsdWVnZW5lcmF0aW9uQ29uZmVyZW5jZXN1YnNlcXVlbnR3ZWxsLWtub3dudmFyaWF0aW9uc3JlcHV0YXRpb25waGVub21lbm9uZGlzY2lwbGluZWxvZ28ucG5nIiAoZG9jdW1lbnQsYm91bmRhcmllc2V4cHJlc3Npb25zZXR0bGVtZW50QmFja2dyb3VuZG91dCBvZiB0aGVlbnRlcnByaXNlKCJodHRwczoiIHVuZXNjYXBlKCJwYXNzd29yZCIgZGVtb2NyYXRpYzxhIGhyZWY9Ii93cmFwcGVyIj4KbWVtYmVyc2hpcGxpbmd1aXN0aWNweDtwYWRkaW5ncGhpbG9zb3BoeWFzc2lzdGFuY2V1bml2ZXJzaXR5ZmFjaWxpdGllc3JlY29nbml6ZWRwcmVmZXJlbmNlaWYgKHR5cGVvZm1haW50YWluZWR2b2NhYnVsYXJ5aHlwb3RoZXNpcy5zdWJtaXQoKTsmYW1wO25ic3A7YW5ub3RhdGlvbmJlaGluZCB0aGVGb3VuZGF0aW9ucHVibGlzaGVyImFzc3VtcHRpb25pbnRyb2R1Y2VkY29ycnVwdGlvbnNjaWVudGlzdHNleHBsaWNpdGx5aW5zdGVhZCBvZmRpbWVuc2lvbnMgb25DbGljaz0iY29uc2lkZXJlZGRlcGFydG1lbnRvY2N1cGF0aW9uc29vbiBhZnRlcmludmVzdG1lbnRwcm9ub3VuY2VkaWRlbnRpZmllZGV4cGVyaW1lbnRNYW5hZ2VtZW50Z2VvZ3JhcGhpYyIgaGVpZ2h0PSJsaW5rIHJlbD0iLnJlcGxhY2UoL2RlcHJlc3Npb25jb25mZXJlbmNlcHVuaXNobWVudGVsaW1pbmF0ZWRyZXNpc3RhbmNlYWRhcHRhdGlvbm9wcG9zaXRpb253ZWxsIGtub3duc3VwcGxlbWVudGRldGVybWluZWRoMSBjbGFzcz0iMHB4O21hcmdpbm1lY2hhbmljYWxzdGF0aXN0aWNzY2VsZWJyYXRlZEdvdmVybm1lbnQKCkR1cmluZyB0ZGV2ZWxvcGVyc2FydGlmaWNpYWxlcXVpdmFsZW50b3JpZ2luYXRlZENvbW1pc3Npb25hdHRhY2htZW50PHNwYW4gaWQ9InRoZXJlIHdlcmVOZWRlcmxhbmRzYmV5b25kIHRoZXJlZ2lzdGVyZWRqb3VybmFsaXN0ZnJlcXVlbnRseWFsbCBvZiB0aGVsYW5nPSJlbiIgPC9zdHlsZT4NCmFic29sdXRlOyBzdXBwb3J0aW5nZXh0cmVtZWx5IG1haW5zdHJlYW08L3N0cm9uZz4gcG9wdWxhcml0eWVtcGxveW1lbnQ8L3RhYmxlPg0KIGNvbHNwYW49IjwvZm9ybT4KICBjb252ZXJzaW9uYWJvdXQgdGhlIDwvcD48L2Rpdj5pbnRlZ3JhdGVkIiBsYW5nPSJlblBvcnR1Z3Vlc2VzdWJzdGl0dXRlaW5kaXZpZHVhbGltcG9zc2libGVtdWx0aW1lZGlhYWxtb3N0IGFsbHB4IHNvbGlkICNhcGFydCBmcm9tc3ViamVjdCB0b2luIEVuZ2xpc2hjcml0aWNpemVkZXhjZXB0IGZvcmd1aWRlbGluZXNvcmlnaW5hbGx5cmVtYXJrYWJsZXRoZSBzZWNvbmRoMiBjbGFzcz0iPGEgdGl0bGU9IihpbmNsdWRpbmdwYXJhbWV0ZXJzcHJvaGliaXRlZD0gImh0dHA6Ly9kaWN0aW9uYXJ5cGVyY2VwdGlvbnJldm9sdXRpb25mb3VuZGF0aW9ucHg7aGVpZ2h0OnN1Y2Nlc3NmdWxzdXBwb3J0ZXJzbWlsbGVubml1bWhpcyBmYXRoZXJ0aGUgJnF1b3Q7bm8tcmVwZWF0O2NvbW1lcmNpYWxpbmR1c3RyaWFsZW5jb3VyYWdlZGFtb3VudCBvZiB1bm9mZmljaWFsZWZmaWNpZW5jeVJlZmVyZW5jZXNjb29yZGluYXRlZGlzY2xhaW1lcmV4cGVkaXRpb25kZXZlbG9waW5nY2FsY3VsYXRlZHNpbXBsaWZpZWRsZWdpdGltYXRlc3Vic3RyaW5nKDAiIGNsYXNzPSJjb21wbGV0ZWx5aWxsdXN0cmF0ZWZpdmUgeWVhcnNpbnN0cnVtZW50UHVibGlzaGluZzEiIGNsYXNzPSJwc3ljaG9sb2d5Y29uZmlkZW5jZW51bWJlciBvZiBhYnNlbmNlIG9mZm9jdXNlZCBvbmpvaW5lZCB0aGVzdHJ1Y3R1cmVzcHJldmlvdXNseT48L2lmcmFtZT5vbmNlIGFnYWluYnV0IHJhdGhlcmltbWlncmFudHNvZiBjb3Vyc2UsYSBncm91cCBvZkxpdGVyYXR1cmVVbmxpa2UgdGhlPC9hPiZuYnNwOwpmdW5jdGlvbiBpdCB3YXMgdGhlQ29udmVudGlvbmF1dG9tb2JpbGVQcm90ZXN0YW50YWdncmVzc2l2ZWFmdGVyIHRoZSBTaW1pbGFybHksIiAvPjwvZGl2PmNvbGxlY3Rpb24NCmZ1bmN0aW9udmlzaWJpbGl0eXRoZSB1c2Ugb2Z2b2x1bnRlZXJzYXR0cmFjdGlvbnVuZGVyIHRoZSB0aHJlYXRlbmVkKjwhW0NEQVRBW2ltcG9ydGFuY2VpbiBnZW5lcmFsdGhlIGxhdHRlcjwvZm9ybT4KPC8uaW5kZXhPZignaSA9IDA7IGkgPGRpZmZlcmVuY2VkZXZvdGVkIHRvdHJhZGl0aW9uc3NlYXJjaCBmb3J1bHRpbWF0ZWx5dG91cm5hbWVudGF0dHJpYnV0ZXNzby1jYWxsZWQgfQo8L3N0eWxlPmV2YWx1YXRpb25lbXBoYXNpemVkYWNjZXNzaWJsZTwvc2VjdGlvbj5zdWNjZXNzaW9uYWxvbmcgd2l0aE1lYW53aGlsZSxpbmR1c3RyaWVzPC9hPjxiciAvPmhhcyBiZWNvbWVhc3BlY3RzIG9mVGVsZXZpc2lvbnN1ZmZpY2llbnRiYXNrZXRiYWxsYm90aCBzaWRlc2NvbnRpbnVpbmdhbiBhcnRpY2xlPGltZyBhbHQ9ImFkdmVudHVyZXNoaXMgbW90aGVybWFuY2hlc3RlcnByaW5jaXBsZXNwYXJ0aWN1bGFyY29tbWVudGFyeWVmZmVjdHMgb2ZkZWNpZGVkIHRvIj48c3Ryb25nPnB1Ymxpc2hlcnNKb3VybmFsIG9mZGlmZmljdWx0eWZhY2lsaXRhdGVhY2NlcHRhYmxlc3R5bGUuY3NzIglmdW5jdGlvbiBpbm5vdmF0aW9uPkNvcHlyaWdodHNpdHVhdGlvbnN3b3VsZCBoYXZlYnVzaW5lc3Nlc0RpY3Rpb25hcnlzdGF0ZW1lbnRzb2Z0ZW4gdXNlZHBlcnNpc3RlbnRpbiBKYW51YXJ5Y29tcHJpc2luZzwvdGl0bGU+CglkaXBsb21hdGljY29udGFpbmluZ3BlcmZvcm1pbmdleHRlbnNpb25zbWF5IG5vdCBiZWNvbmNlcHQgb2Ygb25jbGljaz0iSXQgaXMgYWxzb2ZpbmFuY2lhbCBtYWtpbmcgdGhlTHV4ZW1ib3VyZ2FkZGl0aW9uYWxhcmUgY2FsbGVkZW5nYWdlZCBpbiJzY3JpcHQiKTtidXQgaXQgd2FzZWxlY3Ryb25pY29uc3VibWl0PSIKPCEtLSBFbmQgZWxlY3RyaWNhbG9mZmljaWFsbHlzdWdnZXN0aW9udG9wIG9mIHRoZXVubGlrZSB0aGVBdXN0cmFsaWFuT3JpZ2luYWxseXJlZmVyZW5jZXMKPC9oZWFkPg0KcmVjb2duaXNlZGluaXRpYWxpemVsaW1pdGVkIHRvQWxleGFuZHJpYXJldGlyZW1lbnRBZHZlbnR1cmVzZm91ciB5ZWFycwoKJmx0OyEtLSBpbmNyZWFzaW5nZGVjb3JhdGlvbmgzIGNsYXNzPSJvcmlnaW5zIG9mb2JsaWdhdGlvbnJlZ3VsYXRpb25jbGFzc2lmaWVkKGZ1bmN0aW9uKGFkdmFudGFnZXNiZWluZyB0aGUgaGlzdG9yaWFuczxiYXNlIGhyZWZyZXBlYXRlZGx5d2lsbGluZyB0b2NvbXBhcmFibGVkZXNpZ25hdGVkbm9taW5hdGlvbmZ1bmN0aW9uYWxpbnNpZGUgdGhlcmV2ZWxhdGlvbmVuZCBvZiB0aGVzIGZvciB0aGUgYXV0aG9yaXplZHJlZnVzZWQgdG90YWtlIHBsYWNlYXV0b25vbW91c2NvbXByb21pc2Vwb2xpdGljYWwgcmVzdGF1cmFudHR3byBvZiB0aGVGZWJydWFyeSAycXVhbGl0eSBvZnN3Zm9iamVjdC51bmRlcnN0YW5kbmVhcmx5IGFsbHdyaXR0ZW4gYnlpbnRlcnZpZXdzIiB3aWR0aD0iMXdpdGhkcmF3YWxmbG9hdDpsZWZ0aXMgdXN1YWxseWNhbmRpZGF0ZXNuZXdzcGFwZXJzbXlzdGVyaW91c0RlcGFydG1lbnRiZXN0IGtub3ducGFybGlhbWVudHN1cHByZXNzZWRjb252ZW5pZW50cmVtZW1iZXJlZGRpZmZlcmVudCBzeXN0ZW1hdGljaGFzIGxlZCB0b3Byb3BhZ2FuZGFjb250cm9sbGVkaW5mbHVlbmNlc2NlcmVtb25pYWxwcm9jbGFpbWVkUHJvdGVjdGlvbmxpIGNsYXNzPSJTY2llbnRpZmljY2xhc3M9Im5vLXRyYWRlbWFya3Ntb3JlIHRoYW4gd2lkZXNwcmVhZExpYmVyYXRpb250b29rIHBsYWNlZGF5IG9mIHRoZWFzIGxvbmcgYXNpbXByaXNvbmVkQWRkaXRpb25hbAo8aGVhZD4KPG1MYWJvcmF0b3J5Tm92ZW1iZXIgMmV4Y2VwdGlvbnNJbmR1c3RyaWFsdmFyaWV0eSBvZmZsb2F0OiBsZWZEdXJpbmcgdGhlYXNzZXNzbWVudGhhdmUgYmVlbiBkZWFscyB3aXRoU3RhdGlzdGljc29jY3VycmVuY2UvdWw+PC9kaXY+Y2xlYXJmaXgiPnRoZSBwdWJsaWNtYW55IHllYXJzd2hpY2ggd2VyZW92ZXIgdGltZSxzeW5vbnltb3VzY29udGVudCI+CnByZXN1bWFibHloaXMgZmFtaWx5dXNlckFnZW50LnVuZXhwZWN0ZWRpbmNsdWRpbmcgY2hhbGxlbmdlZGEgbWlub3JpdHl1bmRlZmluZWQiYmVsb25ncyB0b3Rha2VuIGZyb21pbiBPY3RvYmVycG9zaXRpb246IHNhaWQgdG8gYmVyZWxpZ2lvdXMgRmVkZXJhdGlvbiByb3dzcGFuPSJvbmx5IGEgZmV3bWVhbnQgdGhhdGxlZCB0byB0aGUtLT4NCjxkaXYgPGZpZWxkc2V0PkFyY2hiaXNob3AgY2xhc3M9Im5vYmVpbmcgdXNlZGFwcHJvYWNoZXNwcml2aWxlZ2Vzbm9zY3JpcHQ+CnJlc3VsdHMgaW5tYXkgYmUgdGhlRWFzdGVyIGVnZ21lY2hhbmlzbXNyZWFzb25hYmxlUG9wdWxhdGlvbkNvbGxlY3Rpb25zZWxlY3RlZCI+bm9zY3JpcHQ+DS9pbmRleC5waHBhcnJpdmFsIG9mLWpzc2RrJykpO21hbmFnZWQgdG9pbmNvbXBsZXRlY2FzdWFsdGllc2NvbXBsZXRpb25DaHJpc3RpYW5zU2VwdGVtYmVyIGFyaXRobWV0aWNwcm9jZWR1cmVzbWlnaHQgaGF2ZVByb2R1Y3Rpb25pdCBhcHBlYXJzUGhpbG9zb3BoeWZyaWVuZHNoaXBsZWFkaW5nIHRvZ2l2aW5nIHRoZXRvd2FyZCB0aGVndWFyYW50ZWVkZG9jdW1lbnRlZGNvbG9yOiMwMDB2aWRlbyBnYW1lY29tbWlzc2lvbnJlZmxlY3RpbmdjaGFuZ2UgdGhlYXNzb2NpYXRlZHNhbnMtc2VyaWZvbmtleXByZXNzOyBwYWRkaW5nOkhlIHdhcyB0aGV1bmRlcmx5aW5ndHlwaWNhbGx5ICwgYW5kIHRoZSBzcmNFbGVtZW50c3VjY2Vzc2l2ZXNpbmNlIHRoZSBzaG91bGQgYmUgbmV0d29ya2luZ2FjY291bnRpbmd1c2Ugb2YgdGhlbG93ZXIgdGhhbnNob3dzIHRoYXQ8L3NwYW4+CgkJY29tcGxhaW50c2NvbnRpbnVvdXNxdWFudGl0aWVzYXN0cm9ub21lcmhlIGRpZCBub3RkdWUgdG8gaXRzYXBwbGllZCB0b2FuIGF2ZXJhZ2VlZmZvcnRzIHRvdGhlIGZ1dHVyZWF0dGVtcHQgdG9UaGVyZWZvcmUsY2FwYWJpbGl0eVJlcHVibGljYW53YXMgZm9ybWVkRWxlY3Ryb25pY2tpbG9tZXRlcnNjaGFsbGVuZ2VzcHVibGlzaGluZ3RoZSBmb3JtZXJpbmRpZ2Vub3VzZGlyZWN0aW9uc3N1YnNpZGlhcnljb25zcGlyYWN5ZGV0YWlscyBvZmFuZCBpbiB0aGVhZmZvcmRhYmxlc3Vic3RhbmNlc3JlYXNvbiBmb3Jjb252ZW50aW9uaXRlbXR5cGU9ImFic29sdXRlbHlzdXBwb3NlZGx5cmVtYWluZWQgYWF0dHJhY3RpdmV0cmF2ZWxsaW5nc2VwYXJhdGVseWZvY3VzZXMgb25lbGVtZW50YXJ5YXBwbGljYWJsZWZvdW5kIHRoYXRzdHlsZXNoZWV0bWFudXNjcmlwdHN0YW5kcyBmb3Igbm8tcmVwZWF0KHNvbWV0aW1lc0NvbW1lcmNpYWxpbiBBbWVyaWNhdW5kZXJ0YWtlbnF1YXJ0ZXIgb2ZhbiBleGFtcGxlcGVyc29uYWxseWluZGV4LnBocD88L2J1dHRvbj4KcGVyY2VudGFnZWJlc3Qta25vd25jcmVhdGluZyBhIiBkaXI9Imx0ckxpZXV0ZW5hbnQKPGRpdiBpZD0idGhleSB3b3VsZGFiaWxpdHkgb2ZtYWRlIHVwIG9mbm90ZWQgdGhhdGNsZWFyIHRoYXRhcmd1ZSB0aGF0dG8gYW5vdGhlcmNoaWxkcmVuJ3NwdXJwb3NlIG9mZm9ybXVsYXRlZGJhc2VkIHVwb250aGUgcmVnaW9uc3ViamVjdCBvZnBhc3NlbmdlcnNwb3NzZXNzaW9uLgoKSW4gdGhlIEJlZm9yZSB0aGVhZnRlcndhcmRzY3VycmVudGx5IGFjcm9zcyB0aGVzY2llbnRpZmljY29tbXVuaXR5LmNhcGl0YWxpc21pbiBHZXJtYW55cmlnaHQtd2luZ3RoZSBzeXN0ZW1Tb2NpZXR5IG9mcG9saXRpY2lhbmRpcmVjdGlvbjp3ZW50IG9uIHRvcmVtb3ZhbCBvZiBOZXcgWW9yayBhcGFydG1lbnRzaW5kaWNhdGlvbmR1cmluZyB0aGV1bmxlc3MgdGhlaGlzdG9yaWNhbGhhZCBiZWVuIGFkZWZpbml0aXZlaW5ncmVkaWVudGF0dGVuZGFuY2VDZW50ZXIgZm9ycHJvbWluZW5jZXJlYWR5U3RhdGVzdHJhdGVnaWVzYnV0IGluIHRoZWFzIHBhcnQgb2Zjb25zdGl0dXRlY2xhaW0gdGhhdGxhYm9yYXRvcnljb21wYXRpYmxlZmFpbHVyZSBvZiwgc3VjaCBhcyBiZWdhbiB3aXRodXNpbmcgdGhlIHRvIHByb3ZpZGVmZWF0dXJlIG9mZnJvbSB3aGljaC8iIGNsYXNzPSJnZW9sb2dpY2Fsc2V2ZXJhbCBvZmRlbGliZXJhdGVpbXBvcnRhbnQgaG9sZHMgdGhhdGluZyZxdW90OyB2YWxpZ249dG9wdGhlIEdlcm1hbm91dHNpZGUgb2ZuZWdvdGlhdGVkaGlzIGNhcmVlcnNlcGFyYXRpb25pZD0ic2VhcmNod2FzIGNhbGxlZHRoZSBmb3VydGhyZWNyZWF0aW9ub3RoZXIgdGhhbnByZXZlbnRpb253aGlsZSB0aGUgZWR1Y2F0aW9uLGNvbm5lY3RpbmdhY2N1cmF0ZWx5d2VyZSBidWlsdHdhcyBraWxsZWRhZ3JlZW1lbnRzbXVjaCBtb3JlIER1ZSB0byB0aGV3aWR0aDogMTAwc29tZSBvdGhlcktpbmdkb20gb2Z0aGUgZW50aXJlZmFtb3VzIGZvcnRvIGNvbm5lY3RvYmplY3RpdmVzdGhlIEZyZW5jaHBlb3BsZSBhbmRmZWF0dXJlZCI+aXMgc2FpZCB0b3N0cnVjdHVyYWxyZWZlcmVuZHVtbW9zdCBvZnRlbmEgc2VwYXJhdGUtPgo8ZGl2IGlkIE9mZmljaWFsIHdvcmxkd2lkZS5hcmlhLWxhYmVsdGhlIHBsYW5ldGFuZCBpdCB3YXNkIiB2YWx1ZT0ibG9va2luZyBhdGJlbmVmaWNpYWxhcmUgaW4gdGhlbW9uaXRvcmluZ3JlcG9ydGVkbHl0aGUgbW9kZXJud29ya2luZyBvbmFsbG93ZWQgdG93aGVyZSB0aGUgaW5ub3ZhdGl2ZTwvYT48L2Rpdj5zb3VuZHRyYWNrc2VhcmNoRm9ybXRlbmQgdG8gYmVpbnB1dCBpZD0ib3BlbmluZyBvZnJlc3RyaWN0ZWRhZG9wdGVkIGJ5YWRkcmVzc2luZ3RoZW9sb2dpYW5tZXRob2RzIG9mdmFyaWFudCBvZkNocmlzdGlhbiB2ZXJ5IGxhcmdlYXV0b21vdGl2ZWJ5IGZhciB0aGVyYW5nZSBmcm9tcHVyc3VpdCBvZmZvbGxvdyB0aGVicm91Z2h0IHRvaW4gRW5nbGFuZGFncmVlIHRoYXRhY2N1c2VkIG9mY29tZXMgZnJvbXByZXZlbnRpbmdkaXYgc3R5bGU9aGlzIG9yIGhlcnRyZW1lbmRvdXNmcmVlZG9tIG9mY29uY2VybmluZzAgMWVtIDFlbTtCYXNrZXRiYWxsL3N0eWxlLmNzc2FuIGVhcmxpZXJldmVuIGFmdGVyLyIgdGl0bGU9Ii5jb20vaW5kZXh0YWtpbmcgdGhlcGl0dHNidXJnaGNvbnRlbnQiPg08c2NyaXB0PihmdHVybmVkIG91dGhhdmluZyB0aGU8L3NwYW4+DQogb2NjYXNpb25hbGJlY2F1c2UgaXRzdGFydGVkIHRvcGh5c2ljYWxseT48L2Rpdj4KICBjcmVhdGVkIGJ5Q3VycmVudGx5LCBiZ2NvbG9yPSJ0YWJpbmRleD0iZGlzYXN0cm91c0FuYWx5dGljcyBhbHNvIGhhcyBhPjxkaXYgaWQ9Ijwvc3R5bGU+CjxjYWxsZWQgZm9yc2luZ2VyIGFuZC5zcmMgPSAiLy92aW9sYXRpb25zdGhpcyBwb2ludGNvbnN0YW50bHlpcyBsb2NhdGVkcmVjb3JkaW5nc2QgZnJvbSB0aGVuZWRlcmxhbmRzcG9ydHVndcOqc9ei15HXqNeZ16rZgdin2LHYs9uMZGVzYXJyb2xsb2NvbWVudGFyaW9lZHVjYWNpw7Nuc2VwdGllbWJyZXJlZ2lzdHJhZG9kaXJlY2Npw7NudWJpY2FjacOzbnB1YmxpY2lkYWRyZXNwdWVzdGFzcmVzdWx0YWRvc2ltcG9ydGFudGVyZXNlcnZhZG9zYXJ0w61jdWxvc2RpZmVyZW50ZXNzaWd1aWVudGVzcmVww7pibGljYXNpdHVhY2nDs25taW5pc3RlcmlvcHJpdmFjaWRhZGRpcmVjdG9yaW9mb3JtYWNpw7NucG9ibGFjacOzbnByZXNpZGVudGVjb250ZW5pZG9zYWNjZXNvcmlvc3RlY2hub3JhdGlwZXJzb25hbGVzY2F0ZWdvcsOtYWVzcGVjaWFsZXNkaXNwb25pYmxlYWN0dWFsaWRhZHJlZmVyZW5jaWF2YWxsYWRvbGlkYmlibGlvdGVjYXJlbGFjaW9uZXNjYWxlbmRhcmlvcG9sw610aWNhc2FudGVyaW9yZXNkb2N1bWVudG9zbmF0dXJhbGV6YW1hdGVyaWFsZXNkaWZlcmVuY2lhZWNvbsOzbWljYXRyYW5zcG9ydGVyb2Ryw61ndWV6cGFydGljaXBhcmVuY3VlbnRyYW5kaXNjdXNpw7NuZXN0cnVjdHVyYWZ1bmRhY2nDs25mcmVjdWVudGVzcGVybWFuZW50ZXRvdGFsbWVudGXQvNC+0LbQvdC+0LHRg9C00LXRgtC80L7QttC10YLQstGA0LXQvNGP0YLQsNC60LbQtdGH0YLQvtCx0YvQsdC+0LvQtdC10L7Rh9C10L3RjNGN0YLQvtCz0L7QutC+0LPQtNCw0L/QvtGB0LvQtdCy0YHQtdCz0L7RgdCw0LnRgtC10YfQtdGA0LXQt9C80L7Qs9GD0YLRgdCw0LnRgtCw0LbQuNC30L3QuNC80LXQttC00YPQsdGD0LTRg9GC0J/QvtC40YHQutC30LTQtdGB0YzQstC40LTQtdC+0YHQstGP0LfQuNC90YPQttC90L7RgdCy0L7QtdC50LvRjtC00LXQudC/0L7RgNC90L7QvNC90L7Qs9C+0LTQtdGC0LXQudGB0LLQvtC40YXQv9GA0LDQstCw0YLQsNC60L7QudC80LXRgdGC0L7QuNC80LXQtdGC0LbQuNC30L3RjNC+0LTQvdC+0LnQu9GD0YfRiNC10L/QtdGA0LXQtNGH0LDRgdGC0LjRh9Cw0YHRgtGM0YDQsNCx0L7RgtC90L7QstGL0YXQv9GA0LDQstC+0YHQvtCx0L7QudC/0L7RgtC+0LzQvNC10L3QtdC10YfQuNGB0LvQtdC90L7QstGL0LXRg9GB0LvRg9Cz0L7QutC+0LvQvtC90LDQt9Cw0LTRgtCw0LrQvtC10YLQvtCz0LTQsNC/0L7Rh9GC0LjQn9C+0YHQu9C10YLQsNC60LjQtdC90L7QstGL0LnRgdGC0L7QuNGC0YLQsNC60LjRhdGB0YDQsNC30YPQodCw0L3QutGC0YTQvtGA0YPQvNCa0L7Qs9C00LDQutC90LjQs9C40YHQu9C+0LLQsNC90LDRiNC10LnQvdCw0LnRgtC40YHQstC+0LjQvNGB0LLRj9C30YzQu9GO0LHQvtC50YfQsNGB0YLQvtGB0YDQtdC00LjQmtGA0L7QvNC10KTQvtGA0YPQvNGA0YvQvdC60LXRgdGC0LDQu9C40L/QvtC40YHQutGC0YvRgdGP0YfQvNC10YHRj9GG0YbQtdC90YLRgNGC0YDRg9C00LDRgdCw0LzRi9GF0YDRi9C90LrQsNCd0L7QstGL0LnRh9Cw0YHQvtCy0LzQtdGB0YLQsNGE0LjQu9GM0LzQvNCw0YDRgtCw0YHRgtGA0LDQvdC80LXRgdGC0LXRgtC10LrRgdGC0L3QsNGI0LjRhdC80LjQvdGD0YLQuNC80LXQvdC40LjQvNC10Y7RgtC90L7QvNC10YDQs9C+0YDQvtC00YHQsNC80L7QvNGN0YLQvtC80YPQutC+0L3RhtC10YHQstC+0LXQvNC60LDQutC+0LnQkNGA0YXQuNCy2YXZhtiq2K/Zidil2LHYs9in2YTYsdiz2KfZhNip2KfZhNi52KfZhdmD2KrYqNmH2KfYqNix2KfZhdis2KfZhNmK2YjZhdin2YTYtdmI2LHYrNiv2YrYr9ip2KfZhNi52LbZiNil2LbYp9mB2KnYp9mE2YLYs9mF2KfZhNi52KfYqNiq2K3ZhdmK2YTZhdmE2YHYp9iq2YXZhNiq2YLZidiq2LnYr9mK2YTYp9mE2LTYudix2KPYrtio2KfYsdiq2LfZiNmK2LHYudmE2YrZg9mF2KXYsdmB2KfZgti32YTYqNin2KrYp9mE2YTYutip2KrYsdiq2YrYqNin2YTZhtin2LPYp9mE2LTZitiu2YXZhtiq2K/Zitin2YTYudix2KjYp9mE2YLYtdi12KfZgdmE2KfZhdi52YTZitmH2KfYqtit2K/Zitir2KfZhNmE2YfZhdin2YTYudmF2YTZhdmD2KrYqNip2YrZhdmD2YbZg9in2YTYt9mB2YTZgdmK2K/ZitmI2KXYr9in2LHYqdiq2KfYsdmK2K7Yp9mE2LXYrdip2KrYs9is2YrZhNin2YTZiNmC2KrYudmG2K/Zhdin2YXYr9mK2YbYqdiq2LXZhdmK2YXYo9ix2LTZitmB2KfZhNiw2YrZhti52LHYqNmK2KnYqNmI2KfYqNip2KPZhNi52KfYqNin2YTYs9mB2LHZhdi02KfZg9mE2KrYudin2YTZidin2YTYo9mI2YTYp9mE2LPZhtip2KzYp9mF2LnYqdin2YTYtdit2YHYp9mE2K/ZitmG2YPZhNmF2KfYqtin2YTYrtin2LXYp9mE2YXZhNmB2KPYudi22KfYodmD2KrYp9io2KnYp9mE2K7Zitix2LHYs9in2KbZhNin2YTZgtmE2KjYp9mE2KPYr9io2YXZgtin2LfYudmF2LHYp9iz2YTZhdmG2LfZgtip2KfZhNmD2KrYqNin2YTYsdis2YTYp9i02KrYsdmD2KfZhNmC2K/ZhdmK2LnYt9mK2YNzQnlUYWdOYW1lKC5qcGciIGFsdD0iMXB4IHNvbGlkICMuZ2lmIiBhbHQ9InRyYW5zcGFyZW50aW5mb3JtYXRpb25hcHBsaWNhdGlvbiIgb25jbGljaz0iZXN0YWJsaXNoZWRhZHZlcnRpc2luZy5wbmciIGFsdD0iZW52aXJvbm1lbnRwZXJmb3JtYW5jZWFwcHJvcHJpYXRlJmFtcDttZGFzaDtpbW1lZGlhdGVseTwvc3Ryb25nPjwvcmF0aGVyIHRoYW50ZW1wZXJhdHVyZWRldmVsb3BtZW50Y29tcGV0aXRpb25wbGFjZWhvbGRlcnZpc2liaWxpdHk6Y29weXJpZ2h0Ij4wIiBoZWlnaHQ9ImV2ZW4gdGhvdWdocmVwbGFjZW1lbnRkZXN0aW5hdGlvbkNvcnBvcmF0aW9uPHVsIGNsYXNzPSJBc3NvY2lhdGlvbmluZGl2aWR1YWxzcGVyc3BlY3RpdmVzZXRUaW1lb3V0KHVybChodHRwOi8vbWF0aGVtYXRpY3NtYXJnaW4tdG9wOmV2ZW50dWFsbHkgZGVzY3JpcHRpb24pIG5vLXJlcGVhdGNvbGxlY3Rpb25zLkpQR3x0aHVtYnxwYXJ0aWNpcGF0ZS9oZWFkPjxib2R5ZmxvYXQ6bGVmdDs8bGkgY2xhc3M9Imh1bmRyZWRzIG9mCgpIb3dldmVyLCBjb21wb3NpdGlvbmNsZWFyOmJvdGg7Y29vcGVyYXRpb253aXRoaW4gdGhlIGxhYmVsIGZvcj0iYm9yZGVyLXRvcDpOZXcgWmVhbGFuZHJlY29tbWVuZGVkcGhvdG9ncmFwaHlpbnRlcmVzdGluZyZsdDtzdXAmZ3Q7Y29udHJvdmVyc3lOZXRoZXJsYW5kc2FsdGVybmF0aXZlbWF4bGVuZ3RoPSJzd2l0emVybGFuZERldmVsb3BtZW50ZXNzZW50aWFsbHkKCkFsdGhvdWdoIDwvdGV4dGFyZWE+dGh1bmRlcmJpcmRyZXByZXNlbnRlZCZhbXA7bmRhc2g7c3BlY3VsYXRpb25jb21tdW5pdGllc2xlZ2lzbGF0aW9uZWxlY3Ryb25pY3MKCTxkaXYgaWQ9ImlsbHVzdHJhdGVkZW5naW5lZXJpbmd0ZXJyaXRvcmllc2F1dGhvcml0aWVzZGlzdHJpYnV0ZWQ2IiBoZWlnaHQ9InNhbnMtc2VyaWY7Y2FwYWJsZSBvZiBkaXNhcHBlYXJlZGludGVyYWN0aXZlbG9va2luZyBmb3JpdCB3b3VsZCBiZUFmZ2hhbmlzdGFud2FzIGNyZWF0ZWRNYXRoLmZsb29yKHN1cnJvdW5kaW5nY2FuIGFsc28gYmVvYnNlcnZhdGlvbm1haW50ZW5hbmNlZW5jb3VudGVyZWQ8aDIgY2xhc3M9Im1vcmUgcmVjZW50aXQgaGFzIGJlZW5pbnZhc2lvbiBvZikuZ2V0VGltZSgpZnVuZGFtZW50YWxEZXNwaXRlIHRoZSI+PGRpdiBpZD0iaW5zcGlyYXRpb25leGFtaW5hdGlvbnByZXBhcmF0aW9uZXhwbGFuYXRpb248aW5wdXQgaWQ9IjwvYT48L3NwYW4+dmVyc2lvbnMgb2ZpbnN0cnVtZW50c2JlZm9yZSB0aGUgID0gJ2h0dHA6Ly9EZXNjcmlwdGlvbnJlbGF0aXZlbHkgLnN1YnN0cmluZyhlYWNoIG9mIHRoZWV4cGVyaW1lbnRzaW5mbHVlbnRpYWxpbnRlZ3JhdGlvbm1hbnkgcGVvcGxlZHVlIHRvIHRoZSBjb21iaW5hdGlvbmRvIG5vdCBoYXZlTWlkZGxlIEVhc3Q8bm9zY3JpcHQ+PGNvcHlyaWdodCIgcGVyaGFwcyB0aGVpbnN0aXR1dGlvbmluIERlY2VtYmVyYXJyYW5nZW1lbnRtb3N0IGZhbW91c3BlcnNvbmFsaXR5Y3JlYXRpb24gb2ZsaW1pdGF0aW9uc2V4Y2x1c2l2ZWx5c292ZXJlaWdudHktY29udGVudCI+Cjx0ZCBjbGFzcz0idW5kZXJncm91bmRwYXJhbGxlbCB0b2RvY3RyaW5lIG9mb2NjdXBpZWQgYnl0ZXJtaW5vbG9neVJlbmFpc3NhbmNlYSBudW1iZXIgb2ZzdXBwb3J0IGZvcmV4cGxvcmF0aW9ucmVjb2duaXRpb25wcmVkZWNlc3NvcjxpbWcgc3JjPSIvPGgxIGNsYXNzPSJwdWJsaWNhdGlvbm1heSBhbHNvIGJlc3BlY2lhbGl6ZWQ8L2ZpZWxkc2V0PnByb2dyZXNzaXZlbWlsbGlvbnMgb2ZzdGF0ZXMgdGhhdGVuZm9yY2VtZW50YXJvdW5kIHRoZSBvbmUgYW5vdGhlci5wYXJlbnROb2RlYWdyaWN1bHR1cmVBbHRlcm5hdGl2ZXJlc2VhcmNoZXJzdG93YXJkcyB0aGVNb3N0IG9mIHRoZW1hbnkgb3RoZXIgKGVzcGVjaWFsbHk8dGQgd2lkdGg9Ijt3aWR0aDoxMDAlaW5kZXBlbmRlbnQ8aDMgY2xhc3M9IiBvbmNoYW5nZT0iKS5hZGRDbGFzcyhpbnRlcmFjdGlvbk9uZSBvZiB0aGUgZGF1Z2h0ZXIgb2ZhY2Nlc3Nvcmllc2JyYW5jaGVzIG9mDQo8ZGl2IGlkPSJ0aGUgbGFyZ2VzdGRlY2xhcmF0aW9ucmVndWxhdGlvbnNJbmZvcm1hdGlvbnRyYW5zbGF0aW9uZG9jdW1lbnRhcnlpbiBvcmRlciB0byI+CjxoZWFkPgo8IiBoZWlnaHQ9IjFhY3Jvc3MgdGhlIG9yaWVudGF0aW9uKTs8L3NjcmlwdD5pbXBsZW1lbnRlZGNhbiBiZSBzZWVudGhlcmUgd2FzIGFkZW1vbnN0cmF0ZWNvbnRhaW5lciI+Y29ubmVjdGlvbnN0aGUgQnJpdGlzaHdhcyB3cml0dGVuIWltcG9ydGFudDtweDsgbWFyZ2luLWZvbGxvd2VkIGJ5YWJpbGl0eSB0byBjb21wbGljYXRlZGR1cmluZyB0aGUgaW1taWdyYXRpb25hbHNvIGNhbGxlZDxoNCBjbGFzcz0iZGlzdGluY3Rpb25yZXBsYWNlZCBieWdvdmVybm1lbnRzbG9jYXRpb24gb2ZpbiBOb3ZlbWJlcndoZXRoZXIgdGhlPC9wPgo8L2Rpdj5hY3F1aXNpdGlvbmNhbGxlZCB0aGUgcGVyc2VjdXRpb25kZXNpZ25hdGlvbntmb250LXNpemU6YXBwZWFyZWQgaW5pbnZlc3RpZ2F0ZWV4cGVyaWVuY2VkbW9zdCBsaWtlbHl3aWRlbHkgdXNlZGRpc2N1c3Npb25zcHJlc2VuY2Ugb2YgKGRvY3VtZW50LmV4dGVuc2l2ZWx5SXQgaGFzIGJlZW5pdCBkb2VzIG5vdGNvbnRyYXJ5IHRvaW5oYWJpdGFudHNpbXByb3ZlbWVudHNjaG9sYXJzaGlwY29uc3VtcHRpb25pbnN0cnVjdGlvbmZvciBleGFtcGxlb25lIG9yIG1vcmVweDsgcGFkZGluZ3RoZSBjdXJyZW50YSBzZXJpZXMgb2ZhcmUgdXN1YWxseXJvbGUgaW4gdGhlcHJldmlvdXNseSBkZXJpdmF0aXZlc2V2aWRlbmNlIG9mZXhwZXJpZW5jZXNjb2xvcnNjaGVtZXN0YXRlZCB0aGF0Y2VydGlmaWNhdGU8L2E+PC9kaXY+CiBzZWxlY3RlZD0iaGlnaCBzY2hvb2xyZXNwb25zZSB0b2NvbWZvcnRhYmxlYWRvcHRpb24gb2Z0aHJlZSB5ZWFyc3RoZSBjb3VudHJ5aW4gRmVicnVhcnlzbyB0aGF0IHRoZXBlb3BsZSB3aG8gcHJvdmlkZWQgYnk8cGFyYW0gbmFtZWFmZmVjdGVkIGJ5aW4gdGVybXMgb2ZhcHBvaW50bWVudElTTy04ODU5LTEid2FzIGJvcm4gaW5oaXN0b3JpY2FsIHJlZ2FyZGVkIGFzbWVhc3VyZW1lbnRpcyBiYXNlZCBvbiBhbmQgb3RoZXIgOiBmdW5jdGlvbihzaWduaWZpY2FudGNlbGVicmF0aW9udHJhbnNtaXR0ZWQvanMvanF1ZXJ5LmlzIGtub3duIGFzdGhlb3JldGljYWwgdGFiaW5kZXg9Iml0IGNvdWxkIGJlPG5vc2NyaXB0PgpoYXZpbmcgYmVlbg0KPGhlYWQ+DQo8ICZxdW90O1RoZSBjb21waWxhdGlvbmhlIGhhZCBiZWVucHJvZHVjZWQgYnlwaGlsb3NvcGhlcmNvbnN0cnVjdGVkaW50ZW5kZWQgdG9hbW9uZyBvdGhlcmNvbXBhcmVkIHRvdG8gc2F5IHRoYXRFbmdpbmVlcmluZ2EgZGlmZmVyZW50cmVmZXJyZWQgdG9kaWZmZXJlbmNlc2JlbGllZiB0aGF0cGhvdG9ncmFwaHNpZGVudGlmeWluZ0hpc3Rvcnkgb2YgUmVwdWJsaWMgb2ZuZWNlc3NhcmlseXByb2JhYmlsaXR5dGVjaG5pY2FsbHlsZWF2aW5nIHRoZXNwZWN0YWN1bGFyZnJhY3Rpb24gb2ZlbGVjdHJpY2l0eWhlYWQgb2YgdGhlcmVzdGF1cmFudHNwYXJ0bmVyc2hpcGVtcGhhc2lzIG9ubW9zdCByZWNlbnRzaGFyZSB3aXRoIHNheWluZyB0aGF0ZmlsbGVkIHdpdGhkZXNpZ25lZCB0b2l0IGlzIG9mdGVuIj48L2lmcmFtZT5hcyBmb2xsb3dzOm1lcmdlZCB3aXRodGhyb3VnaCB0aGVjb21tZXJjaWFsIHBvaW50ZWQgb3V0b3Bwb3J0dW5pdHl2aWV3IG9mIHRoZXJlcXVpcmVtZW50ZGl2aXNpb24gb2Zwcm9ncmFtbWluZ2hlIHJlY2VpdmVkc2V0SW50ZXJ2YWwiPjwvc3Bhbj48L2luIE5ldyBZb3JrYWRkaXRpb25hbCBjb21wcmVzc2lvbgoKPGRpdiBpZD0iaW5jb3Jwb3JhdGU7PC9zY3JpcHQ+PGF0dGFjaEV2ZW50YmVjYW1lIHRoZSAiIHRhcmdldD0iX2NhcnJpZWQgb3V0U29tZSBvZiB0aGVzY2llbmNlIGFuZHRoZSB0aW1lIG9mQ29udGFpbmVyIj5tYWludGFpbmluZ0NocmlzdG9waGVyTXVjaCBvZiB0aGV3cml0aW5ncyBvZiIgaGVpZ2h0PSIyc2l6ZSBvZiB0aGV2ZXJzaW9uIG9mIG1peHR1cmUgb2YgYmV0d2VlbiB0aGVFeGFtcGxlcyBvZmVkdWNhdGlvbmFsY29tcGV0aXRpdmUgb25zdWJtaXQ9ImRpcmVjdG9yIG9mZGlzdGluY3RpdmUvRFREIFhIVE1MIHJlbGF0aW5nIHRvdGVuZGVuY3kgdG9wcm92aW5jZSBvZndoaWNoIHdvdWxkZGVzcGl0ZSB0aGVzY2llbnRpZmljIGxlZ2lzbGF0dXJlLmlubmVySFRNTCBhbGxlZ2F0aW9uc0FncmljdWx0dXJld2FzIHVzZWQgaW5hcHByb2FjaCB0b2ludGVsbGlnZW50eWVhcnMgbGF0ZXIsc2Fucy1zZXJpZmRldGVybWluaW5nUGVyZm9ybWFuY2VhcHBlYXJhbmNlcywgd2hpY2ggaXMgZm91bmRhdGlvbnNhYmJyZXZpYXRlZGhpZ2hlciB0aGFucyBmcm9tIHRoZSBpbmRpdmlkdWFsIGNvbXBvc2VkIG9mc3VwcG9zZWQgdG9jbGFpbXMgdGhhdGF0dHJpYnV0aW9uZm9udC1zaXplOjFlbGVtZW50cyBvZkhpc3RvcmljYWwgaGlzIGJyb3RoZXJhdCB0aGUgdGltZWFubml2ZXJzYXJ5Z292ZXJuZWQgYnlyZWxhdGVkIHRvIHVsdGltYXRlbHkgaW5ub3ZhdGlvbnNpdCBpcyBzdGlsbGNhbiBvbmx5IGJlZGVmaW5pdGlvbnN0b0dNVFN0cmluZ0EgbnVtYmVyIG9maW1nIGNsYXNzPSJFdmVudHVhbGx5LHdhcyBjaGFuZ2Vkb2NjdXJyZWQgaW5uZWlnaGJvcmluZ2Rpc3Rpbmd1aXNod2hlbiBoZSB3YXNpbnRyb2R1Y2luZ3RlcnJlc3RyaWFsTWFueSBvZiB0aGVhcmd1ZXMgdGhhdGFuIEFtZXJpY2FuY29ucXVlc3Qgb2Z3aWRlc3ByZWFkIHdlcmUga2lsbGVkc2NyZWVuIGFuZCBJbiBvcmRlciB0b2V4cGVjdGVkIHRvZGVzY2VuZGFudHNhcmUgbG9jYXRlZGxlZ2lzbGF0aXZlZ2VuZXJhdGlvbnMgYmFja2dyb3VuZG1vc3QgcGVvcGxleWVhcnMgYWZ0ZXJ0aGVyZSBpcyBub3RoZSBoaWdoZXN0ZnJlcXVlbnRseSB0aGV5IGRvIG5vdGFyZ3VlZCB0aGF0c2hvd2VkIHRoYXRwcmVkb21pbmFudHRoZW9sb2dpY2FsYnkgdGhlIHRpbWVjb25zaWRlcmluZ3Nob3J0LWxpdmVkPC9zcGFuPjwvYT5jYW4gYmUgdXNlZHZlcnkgbGl0dGxlb25lIG9mIHRoZSBoYWQgYWxyZWFkeWludGVycHJldGVkY29tbXVuaWNhdGVmZWF0dXJlcyBvZmdvdmVybm1lbnQsPC9ub3NjcmlwdD5lbnRlcmVkIHRoZSIgaGVpZ2h0PSIzSW5kZXBlbmRlbnRwb3B1bGF0aW9uc2xhcmdlLXNjYWxlLiBBbHRob3VnaCB1c2VkIGluIHRoZWRlc3RydWN0aW9ucG9zc2liaWxpdHlzdGFydGluZyBpbnR3byBvciBtb3JlZXhwcmVzc2lvbnNzdWJvcmRpbmF0ZWxhcmdlciB0aGFuaGlzdG9yeSBhbmQ8L29wdGlvbj4NCkNvbnRpbmVudGFsZWxpbWluYXRpbmd3aWxsIG5vdCBiZXByYWN0aWNlIG9maW4gZnJvbnQgb2ZzaXRlIG9mIHRoZWVuc3VyZSB0aGF0dG8gY3JlYXRlIGFtaXNzaXNzaXBwaXBvdGVudGlhbGx5b3V0c3RhbmRpbmdiZXR0ZXIgdGhhbndoYXQgaXMgbm93c2l0dWF0ZWQgaW5tZXRhIG5hbWU9IlRyYWRpdGlvbmFsc3VnZ2VzdGlvbnNUcmFuc2xhdGlvbnRoZSBmb3JtIG9mYXRtb3NwaGVyaWNpZGVvbG9naWNhbGVudGVycHJpc2VzY2FsY3VsYXRpbmdlYXN0IG9mIHRoZXJlbW5hbnRzIG9mcGx1Z2luc3BhZ2UvaW5kZXgucGhwP3JlbWFpbmVkIGludHJhbnNmb3JtZWRIZSB3YXMgYWxzb3dhcyBhbHJlYWR5c3RhdGlzdGljYWxpbiBmYXZvciBvZk1pbmlzdHJ5IG9mbW92ZW1lbnQgb2Zmb3JtdWxhdGlvbmlzIHJlcXVpcmVkPGxpbmsgcmVsPSJUaGlzIGlzIHRoZSA8YSBocmVmPSIvcG9wdWxhcml6ZWRpbnZvbHZlZCBpbmFyZSB1c2VkIHRvYW5kIHNldmVyYWxtYWRlIGJ5IHRoZXNlZW1zIHRvIGJlbGlrZWx5IHRoYXRQYWxlc3Rpbmlhbm5hbWVkIGFmdGVyaXQgaGFkIGJlZW5tb3N0IGNvbW1vbnRvIHJlZmVyIHRvYnV0IHRoaXMgaXNjb25zZWN1dGl2ZXRlbXBvcmFyaWx5SW4gZ2VuZXJhbCxjb252ZW50aW9uc3Rha2VzIHBsYWNlc3ViZGl2aXNpb250ZXJyaXRvcmlhbG9wZXJhdGlvbmFscGVybWFuZW50bHl3YXMgbGFyZ2VseW91dGJyZWFrIG9maW4gdGhlIHBhc3Rmb2xsb3dpbmcgYSB4bWxuczpvZz0iPjxhIGNsYXNzPSJjbGFzcz0idGV4dENvbnZlcnNpb24gbWF5IGJlIHVzZWRtYW51ZmFjdHVyZWFmdGVyIGJlaW5nY2xlYXJmaXgiPgpxdWVzdGlvbiBvZndhcyBlbGVjdGVkdG8gYmVjb21lIGFiZWNhdXNlIG9mIHNvbWUgcGVvcGxlaW5zcGlyZWQgYnlzdWNjZXNzZnVsIGEgdGltZSB3aGVubW9yZSBjb21tb25hbW9uZ3N0IHRoZWFuIG9mZmljaWFsd2lkdGg6MTAwJTt0ZWNobm9sb2d5LHdhcyBhZG9wdGVkdG8ga2VlcCB0aGVzZXR0bGVtZW50c2xpdmUgYmlydGhzaW5kZXguaHRtbCJDb25uZWN0aWN1dGFzc2lnbmVkIHRvJmFtcDt0aW1lczthY2NvdW50IGZvcmFsaWduPXJpZ2h0dGhlIGNvbXBhbnlhbHdheXMgYmVlbnJldHVybmVkIHRvaW52b2x2ZW1lbnRCZWNhdXNlIHRoZXRoaXMgcGVyaW9kIiBuYW1lPSJxIiBjb25maW5lZCB0b2EgcmVzdWx0IG9mdmFsdWU9IiIgLz5pcyBhY3R1YWxseUVudmlyb25tZW50DQo8L2hlYWQ+DQpDb252ZXJzZWx5LD4KPGRpdiBpZD0iMCIgd2lkdGg9IjFpcyBwcm9iYWJseWhhdmUgYmVjb21lY29udHJvbGxpbmd0aGUgcHJvYmxlbWNpdGl6ZW5zIG9mcG9saXRpY2lhbnNyZWFjaGVkIHRoZWFzIGVhcmx5IGFzOm5vbmU7IG92ZXI8dGFibGUgY2VsbHZhbGlkaXR5IG9mZGlyZWN0bHkgdG9vbm1vdXNlZG93bndoZXJlIGl0IGlzd2hlbiBpdCB3YXNtZW1iZXJzIG9mIHJlbGF0aW9uIHRvYWNjb21tb2RhdGVhbG9uZyB3aXRoIEluIHRoZSBsYXRldGhlIEVuZ2xpc2hkZWxpY2lvdXMiPnRoaXMgaXMgbm90dGhlIHByZXNlbnRpZiB0aGV5IGFyZWFuZCBmaW5hbGx5YSBtYXR0ZXIgb2YNCgk8L2Rpdj4NCg0KPC9zY3JpcHQ+ZmFzdGVyIHRoYW5tYWpvcml0eSBvZmFmdGVyIHdoaWNoY29tcGFyYXRpdmV0byBtYWludGFpbmltcHJvdmUgdGhlYXdhcmRlZCB0aGVlciIgY2xhc3M9ImZyYW1lYm9yZGVycmVzdG9yYXRpb25pbiB0aGUgc2FtZWFuYWx5c2lzIG9mdGhlaXIgZmlyc3REdXJpbmcgdGhlIGNvbnRpbmVudGFsc2VxdWVuY2Ugb2ZmdW5jdGlvbigpe2ZvbnQtc2l6ZTogd29yayBvbiB0aGU8L3NjcmlwdD4KPGJlZ2lucyB3aXRoamF2YXNjcmlwdDpjb25zdGl0dWVudHdhcyBmb3VuZGVkZXF1aWxpYnJpdW1hc3N1bWUgdGhhdGlzIGdpdmVuIGJ5bmVlZHMgdG8gYmVjb29yZGluYXRlc3RoZSB2YXJpb3VzYXJlIHBhcnQgb2Zvbmx5IGluIHRoZXNlY3Rpb25zIG9maXMgYSBjb21tb250aGVvcmllcyBvZmRpc2NvdmVyaWVzYXNzb2NpYXRpb25lZGdlIG9mIHRoZXN0cmVuZ3RoIG9mcG9zaXRpb24gaW5wcmVzZW50LWRheXVuaXZlcnNhbGx5dG8gZm9ybSB0aGVidXQgaW5zdGVhZGNvcnBvcmF0aW9uYXR0YWNoZWQgdG9pcyBjb21tb25seXJlYXNvbnMgZm9yICZxdW90O3RoZSBjYW4gYmUgbWFkZXdhcyBhYmxlIHRvd2hpY2ggbWVhbnNidXQgZGlkIG5vdG9uTW91c2VPdmVyYXMgcG9zc2libGVvcGVyYXRlZCBieWNvbWluZyBmcm9tdGhlIHByaW1hcnlhZGRpdGlvbiBvZmZvciBzZXZlcmFsdHJhbnNmZXJyZWRhIHBlcmlvZCBvZmFyZSBhYmxlIHRvaG93ZXZlciwgaXRzaG91bGQgaGF2ZW11Y2ggbGFyZ2VyCgk8L3NjcmlwdD5hZG9wdGVkIHRoZXByb3BlcnR5IG9mZGlyZWN0ZWQgYnllZmZlY3RpdmVseXdhcyBicm91Z2h0Y2hpbGRyZW4gb2ZQcm9ncmFtbWluZ2xvbmdlciB0aGFubWFudXNjcmlwdHN3YXIgYWdhaW5zdGJ5IG1lYW5zIG9mYW5kIG1vc3Qgb2ZzaW1pbGFyIHRvIHByb3ByaWV0YXJ5b3JpZ2luYXRpbmdwcmVzdGlnaW91c2dyYW1tYXRpY2FsZXhwZXJpZW5jZS50byBtYWtlIHRoZUl0IHdhcyBhbHNvaXMgZm91bmQgaW5jb21wZXRpdG9yc2luIHRoZSBVLlMucmVwbGFjZSB0aGVicm91Z2h0IHRoZWNhbGN1bGF0aW9uZmFsbCBvZiB0aGV0aGUgZ2VuZXJhbHByYWN0aWNhbGx5aW4gaG9ub3Igb2ZyZWxlYXNlZCBpbnJlc2lkZW50aWFsYW5kIHNvbWUgb2ZraW5nIG9mIHRoZXJlYWN0aW9uIHRvMXN0IEVhcmwgb2ZjdWx0dXJlIGFuZHByaW5jaXBhbGx5PC90aXRsZT4KICB0aGV5IGNhbiBiZWJhY2sgdG8gdGhlc29tZSBvZiBoaXNleHBvc3VyZSB0b2FyZSBzaW1pbGFyZm9ybSBvZiB0aGVhZGRGYXZvcml0ZWNpdGl6ZW5zaGlwcGFydCBpbiB0aGVwZW9wbGUgd2l0aGluIHByYWN0aWNldG8gY29udGludWUmYW1wO21pbnVzO2FwcHJvdmVkIGJ5IHRoZSBmaXJzdCBhbGxvd2VkIHRoZWFuZCBmb3IgdGhlZnVuY3Rpb25pbmdwbGF5aW5nIHRoZXNvbHV0aW9uIHRvaGVpZ2h0PSIwIiBpbiBoaXMgYm9va21vcmUgdGhhbiBhZm9sbG93cyB0aGVjcmVhdGVkIHRoZXByZXNlbmNlIGluJm5ic3A7PC90ZD5uYXRpb25hbGlzdHRoZSBpZGVhIG9mYSBjaGFyYWN0ZXJ3ZXJlIGZvcmNlZCBjbGFzcz0iYnRuZGF5cyBvZiB0aGVmZWF0dXJlZCBpbnNob3dpbmcgdGhlaW50ZXJlc3QgaW5pbiBwbGFjZSBvZnR1cm4gb2YgdGhldGhlIGhlYWQgb2ZMb3JkIG9mIHRoZXBvbGl0aWNhbGx5aGFzIGl0cyBvd25FZHVjYXRpb25hbGFwcHJvdmFsIG9mc29tZSBvZiB0aGVlYWNoIG90aGVyLGJlaGF2aW9yIG9mYW5kIGJlY2F1c2VhbmQgYW5vdGhlcmFwcGVhcmVkIG9ucmVjb3JkZWQgaW5ibGFjayZxdW90O21heSBpbmNsdWRldGhlIHdvcmxkJ3NjYW4gbGVhZCB0b3JlZmVycyB0byBhYm9yZGVyPSIwIiBnb3Zlcm5tZW50IHdpbm5pbmcgdGhlcmVzdWx0ZWQgaW4gd2hpbGUgdGhlIFdhc2hpbmd0b24sdGhlIHN1YmplY3RjaXR5IGluIHRoZT48L2Rpdj4NCgkJcmVmbGVjdCB0aGV0byBjb21wbGV0ZWJlY2FtZSBtb3JlcmFkaW9hY3RpdmVyZWplY3RlZCBieXdpdGhvdXQgYW55aGlzIGZhdGhlcix3aGljaCBjb3VsZGNvcHkgb2YgdGhldG8gaW5kaWNhdGVhIHBvbGl0aWNhbGFjY291bnRzIG9mY29uc3RpdHV0ZXN3b3JrZWQgd2l0aGVyPC9hPjwvbGk+b2YgaGlzIGxpZmVhY2NvbXBhbmllZGNsaWVudFdpZHRocHJldmVudCB0aGVMZWdpc2xhdGl2ZWRpZmZlcmVudGx5dG9nZXRoZXIgaW5oYXMgc2V2ZXJhbGZvciBhbm90aGVydGV4dCBvZiB0aGVmb3VuZGVkIHRoZWUgd2l0aCB0aGUgaXMgdXNlZCBmb3JjaGFuZ2VkIHRoZXVzdWFsbHkgdGhlcGxhY2Ugd2hlcmV3aGVyZWFzIHRoZT4gPGEgaHJlZj0iIj48YSBocmVmPSJ0aGVtc2VsdmVzLGFsdGhvdWdoIGhldGhhdCBjYW4gYmV0cmFkaXRpb25hbHJvbGUgb2YgdGhlYXMgYSByZXN1bHRyZW1vdmVDaGlsZGRlc2lnbmVkIGJ5d2VzdCBvZiB0aGVTb21lIHBlb3BsZXByb2R1Y3Rpb24sc2lkZSBvZiB0aGVuZXdzbGV0dGVyc3VzZWQgYnkgdGhlZG93biB0byB0aGVhY2NlcHRlZCBieWxpdmUgaW4gdGhlYXR0ZW1wdHMgdG9vdXRzaWRlIHRoZWZyZXF1ZW5jaWVzSG93ZXZlciwgaW5wcm9ncmFtbWVyc2F0IGxlYXN0IGluYXBwcm94aW1hdGVhbHRob3VnaCBpdHdhcyBwYXJ0IG9mYW5kIHZhcmlvdXNHb3Zlcm5vciBvZnRoZSBhcnRpY2xldHVybmVkIGludG8+PGEgaHJlZj0iL3RoZSBlY29ub215aXMgdGhlIG1vc3Rtb3N0IHdpZGVseXdvdWxkIGxhdGVyYW5kIHBlcmhhcHNyaXNlIHRvIHRoZW9jY3VycyB3aGVudW5kZXIgd2hpY2hjb25kaXRpb25zLnRoZSB3ZXN0ZXJudGhlb3J5IHRoYXRpcyBwcm9kdWNlZHRoZSBjaXR5IG9maW4gd2hpY2ggaGVzZWVuIGluIHRoZXRoZSBjZW50cmFsYnVpbGRpbmcgb2ZtYW55IG9mIGhpc2FyZWEgb2YgdGhlaXMgdGhlIG9ubHltb3N0IG9mIHRoZW1hbnkgb2YgdGhldGhlIFdlc3Rlcm5UaGVyZSBpcyBub2V4dGVuZGVkIHRvU3RhdGlzdGljYWxjb2xzcGFuPTIgfHNob3J0IHN0b3J5cG9zc2libGUgdG90b3BvbG9naWNhbGNyaXRpY2FsIG9mcmVwb3J0ZWQgdG9hIENocmlzdGlhbmRlY2lzaW9uIHRvaXMgZXF1YWwgdG9wcm9ibGVtcyBvZlRoaXMgY2FuIGJlbWVyY2hhbmRpc2Vmb3IgbW9zdCBvZm5vIGV2aWRlbmNlZWRpdGlvbnMgb2ZlbGVtZW50cyBpbiZxdW90Oy4gVGhlY29tL2ltYWdlcy93aGljaCBtYWtlc3RoZSBwcm9jZXNzcmVtYWlucyB0aGVsaXRlcmF0dXJlLGlzIGEgbWVtYmVydGhlIHBvcHVsYXJ0aGUgYW5jaWVudHByb2JsZW1zIGludGltZSBvZiB0aGVkZWZlYXRlZCBieWJvZHkgb2YgdGhlYSBmZXcgeWVhcnNtdWNoIG9mIHRoZXRoZSB3b3JrIG9mQ2FsaWZvcm5pYSxzZXJ2ZWQgYXMgYWdvdmVybm1lbnQuY29uY2VwdHMgb2Ztb3ZlbWVudCBpbgkJPGRpdiBpZD0iaXQiIHZhbHVlPSJsYW5ndWFnZSBvZmFzIHRoZXkgYXJlcHJvZHVjZWQgaW5pcyB0aGF0IHRoZWV4cGxhaW4gdGhlZGl2PjwvZGl2PgpIb3dldmVyIHRoZWxlYWQgdG8gdGhlCTxhIGhyZWY9Ii93YXMgZ3JhbnRlZHBlb3BsZSBoYXZlY29udGludWFsbHl3YXMgc2VlbiBhc2FuZCByZWxhdGVkdGhlIHJvbGUgb2Zwcm9wb3NlZCBieW9mIHRoZSBiZXN0ZWFjaCBvdGhlci5Db25zdGFudGluZXBlb3BsZSBmcm9tZGlhbGVjdHMgb2Z0byByZXZpc2lvbndhcyByZW5hbWVkYSBzb3VyY2Ugb2Z0aGUgaW5pdGlhbGxhdW5jaGVkIGlucHJvdmlkZSB0aGV0byB0aGUgd2VzdHdoZXJlIHRoZXJlYW5kIHNpbWlsYXJiZXR3ZWVuIHR3b2lzIGFsc28gdGhlRW5nbGlzaCBhbmRjb25kaXRpb25zLHRoYXQgaXQgd2FzZW50aXRsZWQgdG90aGVtc2VsdmVzLnF1YW50aXR5IG9mcmFuc3BhcmVuY3l0aGUgc2FtZSBhc3RvIGpvaW4gdGhlY291bnRyeSBhbmR0aGlzIGlzIHRoZVRoaXMgbGVkIHRvYSBzdGF0ZW1lbnRjb250cmFzdCB0b2xhc3RJbmRleE9mdGhyb3VnaCBoaXNpcyBkZXNpZ25lZHRoZSB0ZXJtIGlzaXMgcHJvdmlkZWRwcm90ZWN0IHRoZW5nPC9hPjwvbGk+VGhlIGN1cnJlbnR0aGUgc2l0ZSBvZnN1YnN0YW50aWFsZXhwZXJpZW5jZSxpbiB0aGUgV2VzdHRoZXkgc2hvdWxkc2xvdmVuxI1pbmFjb21lbnRhcmlvc3VuaXZlcnNpZGFkY29uZGljaW9uZXNhY3RpdmlkYWRlc2V4cGVyaWVuY2lhdGVjbm9sb2fDrWFwcm9kdWNjacOzbnB1bnR1YWNpw7NuYXBsaWNhY2nDs25jb250cmFzZcOxYWNhdGVnb3LDrWFzcmVnaXN0cmFyc2Vwcm9mZXNpb25hbHRyYXRhbWllbnRvcmVnw61zdHJhdGVzZWNyZXRhcsOtYXByaW5jaXBhbGVzcHJvdGVjY2nDs25pbXBvcnRhbnRlc2ltcG9ydGFuY2lhcG9zaWJpbGlkYWRpbnRlcmVzYW50ZWNyZWNpbWllbnRvbmVjZXNpZGFkZXNzdXNjcmliaXJzZWFzb2NpYWNpw7NuZGlzcG9uaWJsZXNldmFsdWFjacOzbmVzdHVkaWFudGVzcmVzcG9uc2FibGVyZXNvbHVjacOzbmd1YWRhbGFqYXJhcmVnaXN0cmFkb3NvcG9ydHVuaWRhZGNvbWVyY2lhbGVzZm90b2dyYWbDrWFhdXRvcmlkYWRlc2luZ2VuaWVyw61hdGVsZXZpc2nDs25jb21wZXRlbmNpYW9wZXJhY2lvbmVzZXN0YWJsZWNpZG9zaW1wbGVtZW50ZWFjdHVhbG1lbnRlbmF2ZWdhY2nDs25jb25mb3JtaWRhZGxpbmUtaGVpZ2h0OmZvbnQtZmFtaWx5OiIgOiAiaHR0cDovL2FwcGxpY2F0aW9uc2xpbmsiIGhyZWY9InNwZWNpZmljYWxseS8vPCFbQ0RBVEFbCk9yZ2FuaXphdGlvbmRpc3RyaWJ1dGlvbjBweDsgaGVpZ2h0OnJlbGF0aW9uc2hpcGRldmljZS13aWR0aDxkaXYgY2xhc3M9IjxsYWJlbCBmb3I9InJlZ2lzdHJhdGlvbjwvbm9zY3JpcHQ+Ci9pbmRleC5odG1sIndpbmRvdy5vcGVuKCAhaW1wb3J0YW50O2FwcGxpY2F0aW9uL2luZGVwZW5kZW5jZS8vd3d3Lmdvb2dsZW9yZ2FuaXphdGlvbmF1dG9jb21wbGV0ZXJlcXVpcmVtZW50c2NvbnNlcnZhdGl2ZTxmb3JtIG5hbWU9ImludGVsbGVjdHVhbG1hcmdpbi1sZWZ0OjE4dGggY2VudHVyeWFuIGltcG9ydGFudGluc3RpdHV0aW9uc2FiYnJldmlhdGlvbjxpbWcgY2xhc3M9Im9yZ2FuaXNhdGlvbmNpdmlsaXphdGlvbjE5dGggY2VudHVyeWFyY2hpdGVjdHVyZWluY29ycG9yYXRlZDIwdGggY2VudHVyeS1jb250YWluZXIiPm1vc3Qgbm90YWJseS8+PC9hPjwvZGl2Pm5vdGlmaWNhdGlvbid1bmRlZmluZWQnKUZ1cnRoZXJtb3JlLGJlbGlldmUgdGhhdGlubmVySFRNTCA9IHByaW9yIHRvIHRoZWRyYW1hdGljYWxseXJlZmVycmluZyB0b25lZ290aWF0aW9uc2hlYWRxdWFydGVyc1NvdXRoIEFmcmljYXVuc3VjY2Vzc2Z1bFBlbm5zeWx2YW5pYUFzIGEgcmVzdWx0LDxodG1sIGxhbmc9IiZsdDsvc3VwJmd0O2RlYWxpbmcgd2l0aHBoaWxhZGVscGhpYWhpc3RvcmljYWxseSk7PC9zY3JpcHQ+CnBhZGRpbmctdG9wOmV4cGVyaW1lbnRhbGdldEF0dHJpYnV0ZWluc3RydWN0aW9uc3RlY2hub2xvZ2llc3BhcnQgb2YgdGhlID1mdW5jdGlvbigpe3N1YnNjcmlwdGlvbmwuZHRkIj4NCjxodGdlb2dyYXBoaWNhbENvbnN0aXR1dGlvbicsIGZ1bmN0aW9uKHN1cHBvcnRlZCBieWFncmljdWx0dXJhbGNvbnN0cnVjdGlvbnB1YmxpY2F0aW9uc2ZvbnQtc2l6ZTogMWEgdmFyaWV0eSBvZjxkaXYgc3R5bGU9IkVuY3ljbG9wZWRpYWlmcmFtZSBzcmM9ImRlbW9uc3RyYXRlZGFjY29tcGxpc2hlZHVuaXZlcnNpdGllc0RlbW9ncmFwaGljcyk7PC9zY3JpcHQ+PGRlZGljYXRlZCB0b2tub3dsZWRnZSBvZnNhdGlzZmFjdGlvbnBhcnRpY3VsYXJseTwvZGl2PjwvZGl2PkVuZ2xpc2ggKFVTKWFwcGVuZENoaWxkKHRyYW5zbWlzc2lvbnMuIEhvd2V2ZXIsIGludGVsbGlnZW5jZSIgdGFiaW5kZXg9ImZsb2F0OnJpZ2h0O0NvbW1vbndlYWx0aHJhbmdpbmcgZnJvbWluIHdoaWNoIHRoZWF0IGxlYXN0IG9uZXJlcHJvZHVjdGlvbmVuY3ljbG9wZWRpYTtmb250LXNpemU6MWp1cmlzZGljdGlvbmF0IHRoYXQgdGltZSI+PGEgY2xhc3M9IkluIGFkZGl0aW9uLGRlc2NyaXB0aW9uK2NvbnZlcnNhdGlvbmNvbnRhY3Qgd2l0aGlzIGdlbmVyYWxseXIiIGNvbnRlbnQ9InJlcHJlc2VudGluZyZsdDttYXRoJmd0O3ByZXNlbnRhdGlvbm9jY2FzaW9uYWxseTxpbWcgd2lkdGg9Im5hdmlnYXRpb24iPmNvbXBlbnNhdGlvbmNoYW1waW9uc2hpcG1lZGlhPSJhbGwiIHZpb2xhdGlvbiBvZnJlZmVyZW5jZSB0b3JldHVybiB0cnVlO1N0cmljdC8vRU4iIHRyYW5zYWN0aW9uc2ludGVydmVudGlvbnZlcmlmaWNhdGlvbkluZm9ybWF0aW9uIGRpZmZpY3VsdGllc0NoYW1waW9uc2hpcGNhcGFiaWxpdGllczwhW2VuZGlmXS0tPn0KPC9zY3JpcHQ+CkNocmlzdGlhbml0eWZvciBleGFtcGxlLFByb2Zlc3Npb25hbHJlc3RyaWN0aW9uc3N1Z2dlc3QgdGhhdHdhcyByZWxlYXNlZChzdWNoIGFzIHRoZXJlbW92ZUNsYXNzKHVuZW1wbG95bWVudHRoZSBBbWVyaWNhbnN0cnVjdHVyZSBvZi9pbmRleC5odG1sIHB1Ymxpc2hlZCBpbnNwYW4gY2xhc3M9IiI+PGEgaHJlZj0iL2ludHJvZHVjdGlvbmJlbG9uZ2luZyB0b2NsYWltZWQgdGhhdGNvbnNlcXVlbmNlczxtZXRhIG5hbWU9Ikd1aWRlIHRvIHRoZW92ZXJ3aGVsbWluZ2FnYWluc3QgdGhlIGNvbmNlbnRyYXRlZCwKLm5vbnRvdWNoIG9ic2VydmF0aW9uczwvYT4KPC9kaXY+CmYgKGRvY3VtZW50LmJvcmRlcjogMXB4IHtmb250LXNpemU6MXRyZWF0bWVudCBvZjAiIGhlaWdodD0iMW1vZGlmaWNhdGlvbkluZGVwZW5kZW5jZWRpdmlkZWQgaW50b2dyZWF0ZXIgdGhhbmFjaGlldmVtZW50c2VzdGFibGlzaGluZ0phdmFTY3JpcHQiIG5ldmVydGhlbGVzc3NpZ25pZmljYW5jZUJyb2FkY2FzdGluZz4mbmJzcDs8L3RkPmNvbnRhaW5lciI+CnN1Y2ggYXMgdGhlIGluZmx1ZW5jZSBvZmEgcGFydGljdWxhcnNyYz0naHR0cDovL25hdmlnYXRpb24iIGhhbGYgb2YgdGhlIHN1YnN0YW50aWFsICZuYnNwOzwvZGl2PmFkdmFudGFnZSBvZmRpc2NvdmVyeSBvZmZ1bmRhbWVudGFsIG1ldHJvcG9saXRhbnRoZSBvcHBvc2l0ZSIgeG1sOmxhbmc9ImRlbGliZXJhdGVseWFsaWduPWNlbnRlcmV2b2x1dGlvbiBvZnByZXNlcnZhdGlvbmltcHJvdmVtZW50c2JlZ2lubmluZyBpbkplc3VzIENocmlzdFB1YmxpY2F0aW9uc2Rpc2FncmVlbWVudHRleHQtYWxpZ246ciwgZnVuY3Rpb24oKXNpbWlsYXJpdGllc2JvZHk+PC9odG1sPmlzIGN1cnJlbnRseWFscGhhYmV0aWNhbGlzIHNvbWV0aW1lc3R5cGU9ImltYWdlL21hbnkgb2YgdGhlIGZsb3c6aGlkZGVuO2F2YWlsYWJsZSBpbmRlc2NyaWJlIHRoZWV4aXN0ZW5jZSBvZmFsbCBvdmVyIHRoZXRoZSBJbnRlcm5ldAk8dWwgY2xhc3M9Imluc3RhbGxhdGlvbm5laWdoYm9yaG9vZGFybWVkIGZvcmNlc3JlZHVjaW5nIHRoZWNvbnRpbnVlcyB0b05vbmV0aGVsZXNzLHRlbXBlcmF0dXJlcwoJCTxhIGhyZWY9ImNsb3NlIHRvIHRoZWV4YW1wbGVzIG9mIGlzIGFib3V0IHRoZShzZWUgYmVsb3cpLiIgaWQ9InNlYXJjaHByb2Zlc3Npb25hbGlzIGF2YWlsYWJsZXRoZSBvZmZpY2lhbAkJPC9zY3JpcHQ+CgoJCTxkaXYgaWQ9ImFjY2VsZXJhdGlvbnRocm91Z2ggdGhlIEhhbGwgb2YgRmFtZWRlc2NyaXB0aW9uc3RyYW5zbGF0aW9uc2ludGVyZmVyZW5jZSB0eXBlPSd0ZXh0L3JlY2VudCB5ZWFyc2luIHRoZSB3b3JsZHZlcnkgcG9wdWxhcntiYWNrZ3JvdW5kOnRyYWRpdGlvbmFsIHNvbWUgb2YgdGhlIGNvbm5lY3RlZCB0b2V4cGxvaXRhdGlvbmVtZXJnZW5jZSBvZmNvbnN0aXR1dGlvbkEgSGlzdG9yeSBvZnNpZ25pZmljYW50IG1hbnVmYWN0dXJlZGV4cGVjdGF0aW9ucz48bm9zY3JpcHQ+PGNhbiBiZSBmb3VuZGJlY2F1c2UgdGhlIGhhcyBub3QgYmVlbm5laWdoYm91cmluZ3dpdGhvdXQgdGhlIGFkZGVkIHRvIHRoZQk8bGkgY2xhc3M9Imluc3RydW1lbnRhbFNvdmlldCBVbmlvbmFja25vd2xlZGdlZHdoaWNoIGNhbiBiZW5hbWUgZm9yIHRoZWF0dGVudGlvbiB0b2F0dGVtcHRzIHRvIGRldmVsb3BtZW50c0luIGZhY3QsIHRoZTxsaSBjbGFzcz0iYWltcGxpY2F0aW9uc3N1aXRhYmxlIGZvcm11Y2ggb2YgdGhlIGNvbG9uaXphdGlvbnByZXNpZGVudGlhbGNhbmNlbEJ1YmJsZSBJbmZvcm1hdGlvbm1vc3Qgb2YgdGhlIGlzIGRlc2NyaWJlZHJlc3Qgb2YgdGhlIG1vcmUgb3IgbGVzc2luIFNlcHRlbWJlckludGVsbGlnZW5jZXNyYz0iaHR0cDovL3B4OyBoZWlnaHQ6IGF2YWlsYWJsZSB0b21hbnVmYWN0dXJlcmh1bWFuIHJpZ2h0c2xpbmsgaHJlZj0iL2F2YWlsYWJpbGl0eXByb3BvcnRpb25hbG91dHNpZGUgdGhlIGFzdHJvbm9taWNhbGh1bWFuIGJlaW5nc25hbWUgb2YgdGhlIGFyZSBmb3VuZCBpbmFyZSBiYXNlZCBvbnNtYWxsZXIgdGhhbmEgcGVyc29uIHdob2V4cGFuc2lvbiBvZmFyZ3VpbmcgdGhhdG5vdyBrbm93biBhc0luIHRoZSBlYXJseWludGVybWVkaWF0ZWRlcml2ZWQgZnJvbVNjYW5kaW5hdmlhbjwvYT48L2Rpdj4NCmNvbnNpZGVyIHRoZWFuIGVzdGltYXRlZHRoZSBOYXRpb25hbDxkaXYgaWQ9InBhZ3Jlc3VsdGluZyBpbmNvbW1pc3Npb25lZGFuYWxvZ291cyB0b2FyZSByZXF1aXJlZC91bD4KPC9kaXY+CndhcyBiYXNlZCBvbmFuZCBiZWNhbWUgYSZuYnNwOyZuYnNwO3QiIHZhbHVlPSIiIHdhcyBjYXB0dXJlZG5vIG1vcmUgdGhhbnJlc3BlY3RpdmVseWNvbnRpbnVlIHRvID4NCjxoZWFkPg0KPHdlcmUgY3JlYXRlZG1vcmUgZ2VuZXJhbGluZm9ybWF0aW9uIHVzZWQgZm9yIHRoZWluZGVwZW5kZW50IHRoZSBJbXBlcmlhbGNvbXBvbmVudCBvZnRvIHRoZSBub3J0aGluY2x1ZGUgdGhlIENvbnN0cnVjdGlvbnNpZGUgb2YgdGhlIHdvdWxkIG5vdCBiZWZvciBpbnN0YW5jZWludmVudGlvbiBvZm1vcmUgY29tcGxleGNvbGxlY3RpdmVseWJhY2tncm91bmQ6IHRleHQtYWxpZ246IGl0cyBvcmlnaW5hbGludG8gYWNjb3VudHRoaXMgcHJvY2Vzc2FuIGV4dGVuc2l2ZWhvd2V2ZXIsIHRoZXRoZXkgYXJlIG5vdHJlamVjdGVkIHRoZWNyaXRpY2lzbSBvZmR1cmluZyB3aGljaHByb2JhYmx5IHRoZXRoaXMgYXJ0aWNsZShmdW5jdGlvbigpe0l0IHNob3VsZCBiZWFuIGFncmVlbWVudGFjY2lkZW50YWxseWRpZmZlcnMgZnJvbUFyY2hpdGVjdHVyZWJldHRlciBrbm93bmFycmFuZ2VtZW50c2luZmx1ZW5jZSBvbmF0dGVuZGVkIHRoZWlkZW50aWNhbCB0b3NvdXRoIG9mIHRoZXBhc3MgdGhyb3VnaHhtbCIgdGl0bGU9IndlaWdodDpib2xkO2NyZWF0aW5nIHRoZWRpc3BsYXk6bm9uZXJlcGxhY2VkIHRoZTxpbWcgc3JjPSIvaWh0dHBzOi8vd3d3LldvcmxkIFdhciBJSXRlc3RpbW9uaWFsc2ZvdW5kIGluIHRoZXJlcXVpcmVkIHRvIGFuZCB0aGF0IHRoZWJldHdlZW4gdGhlIHdhcyBkZXNpZ25lZGNvbnNpc3RzIG9mIGNvbnNpZGVyYWJseXB1Ymxpc2hlZCBieXRoZSBsYW5ndWFnZUNvbnNlcnZhdGlvbmNvbnNpc3RlZCBvZnJlZmVyIHRvIHRoZWJhY2sgdG8gdGhlIGNzcyIgbWVkaWE9IlBlb3BsZSBmcm9tIGF2YWlsYWJsZSBvbnByb3ZlZCB0byBiZXN1Z2dlc3Rpb25zIndhcyBrbm93biBhc3ZhcmlldGllcyBvZmxpa2VseSB0byBiZWNvbXByaXNlZCBvZnN1cHBvcnQgdGhlIGhhbmRzIG9mIHRoZWNvdXBsZWQgd2l0aGNvbm5lY3QgYW5kIGJvcmRlcjpub25lO3BlcmZvcm1hbmNlc2JlZm9yZSBiZWluZ2xhdGVyIGJlY2FtZWNhbGN1bGF0aW9uc29mdGVuIGNhbGxlZHJlc2lkZW50cyBvZm1lYW5pbmcgdGhhdD48bGkgY2xhc3M9ImV2aWRlbmNlIGZvcmV4cGxhbmF0aW9uc2Vudmlyb25tZW50cyI+PC9hPjwvZGl2PndoaWNoIGFsbG93c0ludHJvZHVjdGlvbmRldmVsb3BlZCBieWEgd2lkZSByYW5nZW9uIGJlaGFsZiBvZnZhbGlnbj0idG9wInByaW5jaXBsZSBvZmF0IHRoZSB0aW1lLDwvbm9zY3JpcHQ+DXNhaWQgdG8gaGF2ZWluIHRoZSBmaXJzdHdoaWxlIG90aGVyc2h5cG90aGV0aWNhbHBoaWxvc29waGVyc3Bvd2VyIG9mIHRoZWNvbnRhaW5lZCBpbnBlcmZvcm1lZCBieWluYWJpbGl0eSB0b3dlcmUgd3JpdHRlbnNwYW4gc3R5bGU9ImlucHV0IG5hbWU9InRoZSBxdWVzdGlvbmludGVuZGVkIGZvcnJlamVjdGlvbiBvZmltcGxpZXMgdGhhdGludmVudGVkIHRoZXRoZSBzdGFuZGFyZHdhcyBwcm9iYWJseWxpbmsgYmV0d2VlbnByb2Zlc3NvciBvZmludGVyYWN0aW9uc2NoYW5naW5nIHRoZUluZGlhbiBPY2VhbiBjbGFzcz0ibGFzdHdvcmtpbmcgd2l0aCdodHRwOi8vd3d3LnllYXJzIGJlZm9yZVRoaXMgd2FzIHRoZXJlY3JlYXRpb25hbGVudGVyaW5nIHRoZW1lYXN1cmVtZW50c2FuIGV4dHJlbWVseXZhbHVlIG9mIHRoZXN0YXJ0IG9mIHRoZQo8L3NjcmlwdD4KCmFuIGVmZm9ydCB0b2luY3JlYXNlIHRoZXRvIHRoZSBzb3V0aHNwYWNpbmc9IjAiPnN1ZmZpY2llbnRseXRoZSBFdXJvcGVhbmNvbnZlcnRlZCB0b2NsZWFyVGltZW91dGRpZCBub3QgaGF2ZWNvbnNlcXVlbnRseWZvciB0aGUgbmV4dGV4dGVuc2lvbiBvZmVjb25vbWljIGFuZGFsdGhvdWdoIHRoZWFyZSBwcm9kdWNlZGFuZCB3aXRoIHRoZWluc3VmZmljaWVudGdpdmVuIGJ5IHRoZXN0YXRpbmcgdGhhdGV4cGVuZGl0dXJlczwvc3Bhbj48L2E+CnRob3VnaHQgdGhhdG9uIHRoZSBiYXNpc2NlbGxwYWRkaW5nPWltYWdlIG9mIHRoZXJldHVybmluZyB0b2luZm9ybWF0aW9uLHNlcGFyYXRlZCBieWFzc2Fzc2luYXRlZHMiIGNvbnRlbnQ9ImF1dGhvcml0eSBvZm5vcnRod2VzdGVybjwvZGl2Pgo8ZGl2ICI+PC9kaXY+DQogIGNvbnN1bHRhdGlvbmNvbW11bml0eSBvZnRoZSBuYXRpb25hbGl0IHNob3VsZCBiZXBhcnRpY2lwYW50cyBhbGlnbj0ibGVmdHRoZSBncmVhdGVzdHNlbGVjdGlvbiBvZnN1cGVybmF0dXJhbGRlcGVuZGVudCBvbmlzIG1lbnRpb25lZGFsbG93aW5nIHRoZXdhcyBpbnZlbnRlZGFjY29tcGFueWluZ2hpcyBwZXJzb25hbGF2YWlsYWJsZSBhdHN0dWR5IG9mIHRoZW9uIHRoZSBvdGhlcmV4ZWN1dGlvbiBvZkh1bWFuIFJpZ2h0c3Rlcm1zIG9mIHRoZWFzc29jaWF0aW9uc3Jlc2VhcmNoIGFuZHN1Y2NlZWRlZCBieWRlZmVhdGVkIHRoZWFuZCBmcm9tIHRoZWJ1dCB0aGV5IGFyZWNvbW1hbmRlciBvZnN0YXRlIG9mIHRoZXllYXJzIG9mIGFnZXRoZSBzdHVkeSBvZjx1bCBjbGFzcz0ic3BsYWNlIGluIHRoZXdoZXJlIGhlIHdhczxsaSBjbGFzcz0iZnRoZXJlIGFyZSBub3doaWNoIGJlY2FtZWhlIHB1Ymxpc2hlZGV4cHJlc3NlZCBpbnRvIHdoaWNoIHRoZWNvbW1pc3Npb25lcmZvbnQtd2VpZ2h0OnRlcnJpdG9yeSBvZmV4dGVuc2lvbnMiPlJvbWFuIEVtcGlyZWVxdWFsIHRvIHRoZUluIGNvbnRyYXN0LGhvd2V2ZXIsIGFuZGlzIHR5cGljYWxseWFuZCBoaXMgd2lmZShhbHNvIGNhbGxlZD48dWwgY2xhc3M9ImVmZmVjdGl2ZWx5IGV2b2x2ZWQgaW50b3NlZW0gdG8gaGF2ZXdoaWNoIGlzIHRoZXRoZXJlIHdhcyBub2FuIGV4Y2VsbGVudGFsbCBvZiB0aGVzZWRlc2NyaWJlZCBieUluIHByYWN0aWNlLGJyb2FkY2FzdGluZ2NoYXJnZWQgd2l0aHJlZmxlY3RlZCBpbnN1YmplY3RlZCB0b21pbGl0YXJ5IGFuZHRvIHRoZSBwb2ludGVjb25vbWljYWxseXNldFRhcmdldGluZ2FyZSBhY3R1YWxseXZpY3Rvcnkgb3ZlcigpOzwvc2NyaXB0PmNvbnRpbnVvdXNseXJlcXVpcmVkIGZvcmV2b2x1dGlvbmFyeWFuIGVmZmVjdGl2ZW5vcnRoIG9mIHRoZSwgd2hpY2ggd2FzIGZyb250IG9mIHRoZW9yIG90aGVyd2lzZXNvbWUgZm9ybSBvZmhhZCBub3QgYmVlbmdlbmVyYXRlZCBieWluZm9ybWF0aW9uLnBlcm1pdHRlZCB0b2luY2x1ZGVzIHRoZWRldmVsb3BtZW50LGVudGVyZWQgaW50b3RoZSBwcmV2aW91c2NvbnNpc3RlbnRseWFyZSBrbm93biBhc3RoZSBmaWVsZCBvZnRoaXMgdHlwZSBvZmdpdmVuIHRvIHRoZXRoZSB0aXRsZSBvZmNvbnRhaW5zIHRoZWluc3RhbmNlcyBvZmluIHRoZSBub3J0aGR1ZSB0byB0aGVpcmFyZSBkZXNpZ25lZGNvcnBvcmF0aW9uc3dhcyB0aGF0IHRoZW9uZSBvZiB0aGVzZW1vcmUgcG9wdWxhcnN1Y2NlZWRlZCBpbnN1cHBvcnQgZnJvbWluIGRpZmZlcmVudGRvbWluYXRlZCBieWRlc2lnbmVkIGZvcm93bmVyc2hpcCBvZmFuZCBwb3NzaWJseXN0YW5kYXJkaXplZHJlc3BvbnNlVGV4dHdhcyBpbnRlbmRlZHJlY2VpdmVkIHRoZWFzc3VtZWQgdGhhdGFyZWFzIG9mIHRoZXByaW1hcmlseSBpbnRoZSBiYXNpcyBvZmluIHRoZSBzZW5zZWFjY291bnRzIGZvcmRlc3Ryb3llZCBieWF0IGxlYXN0IHR3b3dhcyBkZWNsYXJlZGNvdWxkIG5vdCBiZVNlY3JldGFyeSBvZmFwcGVhciB0byBiZW1hcmdpbi10b3A6MS9eXHMrfFxzKyQvZ2Upe3Rocm93IGV9O3RoZSBzdGFydCBvZnR3byBzZXBhcmF0ZWxhbmd1YWdlIGFuZHdobyBoYWQgYmVlbm9wZXJhdGlvbiBvZmRlYXRoIG9mIHRoZXJlYWwgbnVtYmVycwk8bGluayByZWw9InByb3ZpZGVkIHRoZXRoZSBzdG9yeSBvZmNvbXBldGl0aW9uc2VuZ2xpc2ggKFVLKWVuZ2xpc2ggKFVTKdCc0L7QvdCz0L7Qu9Ch0YDQv9GB0LrQuNGB0YDQv9GB0LrQuNGB0YDQv9GB0LrQvtmE2LnYsdio2YrYqeato+mrlOS4reaWh+eugOS9k+S4reaWh+e5geS9k+S4reaWh+aciemZkOWFrOWPuOS6uuawkeaUv+W6nOmYv+mHjOW3tOW3tOekvuS8muS4u+S5ieaTjeS9nOezu+e7n+aUv+etluazleinhGluZm9ybWFjacOzbmhlcnJhbWllbnRhc2VsZWN0csOzbmljb2Rlc2NyaXBjacOzbmNsYXNpZmljYWRvc2Nvbm9jaW1pZW50b3B1YmxpY2FjacOzbnJlbGFjaW9uYWRhc2luZm9ybcOhdGljYXJlbGFjaW9uYWRvc2RlcGFydGFtZW50b3RyYWJhamFkb3Jlc2RpcmVjdGFtZW50ZWF5dW50YW1pZW50b21lcmNhZG9MaWJyZWNvbnTDoWN0ZW5vc2hhYml0YWNpb25lc2N1bXBsaW1pZW50b3Jlc3RhdXJhbnRlc2Rpc3Bvc2ljacOzbmNvbnNlY3VlbmNpYWVsZWN0csOzbmljYWFwbGljYWNpb25lc2Rlc2NvbmVjdGFkb2luc3RhbGFjacOzbnJlYWxpemFjacOzbnV0aWxpemFjacOzbmVuY2ljbG9wZWRpYWVuZmVybWVkYWRlc2luc3RydW1lbnRvc2V4cGVyaWVuY2lhc2luc3RpdHVjacOzbnBhcnRpY3VsYXJlc3N1YmNhdGVnb3JpYdGC0L7Qu9GM0LrQvtCg0L7RgdGB0LjQuNGA0LDQsdC+0YLRi9Cx0L7Qu9GM0YjQtdC/0YDQvtGB0YLQvtC80L7QttC10YLQtdC00YDRg9Cz0LjRhdGB0LvRg9GH0LDQtdGB0LXQudGH0LDRgdCy0YHQtdCz0LTQsNCg0L7RgdGB0LjRj9Cc0L7RgdC60LLQtdC00YDRg9Cz0LjQtdCz0L7RgNC+0LTQsNCy0L7Qv9GA0L7RgdC00LDQvdC90YvRhdC00L7Qu9C20L3Ri9C40LzQtdC90L3QvtCc0L7RgdC60LLRi9GA0YPQsdC70LXQudCc0L7RgdC60LLQsNGB0YLRgNCw0L3Ri9C90LjRh9C10LPQvtGA0LDQsdC+0YLQtdC00L7Qu9C20LXQvdGD0YHQu9GD0LPQuNGC0LXQv9C10YDRjNCe0LTQvdCw0LrQvtC/0L7RgtC+0LzRg9GA0LDQsdC+0YLRg9Cw0L/RgNC10LvRj9Cy0L7QvtCx0YnQtdC+0LTQvdC+0LPQvtGB0LLQvtC10LPQvtGB0YLQsNGC0YzQuNC00YDRg9Cz0L7QudGE0L7RgNGD0LzQtdGF0L7RgNC+0YjQvtC/0YDQvtGC0LjQstGB0YHRi9C70LrQsNC60LDQttC00YvQudCy0LvQsNGB0YLQuNCz0YDRg9C/0L/Ri9Cy0LzQtdGB0YLQtdGA0LDQsdC+0YLQsNGB0LrQsNC30LDQu9C/0LXRgNCy0YvQudC00LXQu9Cw0YLRjNC00LXQvdGM0LPQuNC/0LXRgNC40L7QtNCx0LjQt9C90LXRgdC+0YHQvdC+0LLQtdC80L7QvNC10L3RgtC60YPQv9C40YLRjNC00L7Qu9C20L3QsNGA0LDQvNC60LDRhdC90LDRh9Cw0LvQvtCg0LDQsdC+0YLQsNCi0L7Qu9GM0LrQvtGB0L7QstGB0LXQvNCy0YLQvtGA0L7QudC90LDRh9Cw0LvQsNGB0L/QuNGB0L7QutGB0LvRg9C20LHRi9GB0LjRgdGC0LXQvNC/0LXRh9Cw0YLQuNC90L7QstC+0LPQvtC/0L7QvNC+0YnQuNGB0LDQudGC0L7QstC/0L7Rh9C10LzRg9C/0L7QvNC+0YnRjNC00L7Qu9C20L3QvtGB0YHRi9C70LrQuNCx0YvRgdGC0YDQvtC00LDQvdC90YvQtdC80L3QvtCz0LjQtdC/0YDQvtC10LrRgtCh0LXQudGH0LDRgdC80L7QtNC10LvQuNGC0LDQutC+0LPQvtC+0L3Qu9Cw0LnQvdCz0L7RgNC+0LTQtdCy0LXRgNGB0LjRj9GB0YLRgNCw0L3QtdGE0LjQu9GM0LzRi9GD0YDQvtCy0L3Rj9GA0LDQt9C90YvRhdC40YHQutCw0YLRjNC90LXQtNC10LvRjtGP0L3QstCw0YDRj9C80LXQvdGM0YjQtdC80L3QvtCz0LjRhdC00LDQvdC90L7QudC30L3QsNGH0LjRgtC90LXQu9GM0LfRj9GE0L7RgNGD0LzQsNCi0LXQv9C10YDRjNC80LXRgdGP0YbQsNC30LDRidC40YLRi9Cb0YPRh9GI0LjQteCkqOCkueClgOCkguCkleCksOCkqOClh+CkheCkquCkqOClh+CkleCkv+Ckr+CkvuCkleCksOClh+CkguCkheCkqOCljeCkr+CkleCljeCkr+CkvuCkl+CkvuCkh+CkoeCkrOCkvuCksOClh+CkleCkv+CkuOClgOCkpuCkv+Ckr+CkvuCkquCkueCksuClh+CkuOCkv+CkguCkueCkreCkvuCksOCkpOCkheCkquCkqOClgOCkteCkvuCksuClh+CkuOClh+CkteCkvuCkleCksOCkpOClh+CkruClh+CksOClh+CkueCli+CkqOClh+CkuOCkleCkpOClh+CkrOCkueClgeCkpOCkuOCkvuCkh+Ckn+CkueCli+Ckl+CkvuCknOCkvuCkqOClh+CkruCkv+CkqOCkn+CkleCksOCkpOCkvuCkleCksOCkqOCkvuCkieCkqOCkleClh+Ckr+CkueCkvuCkgeCkuOCkrOCkuOClh+CkreCkvuCkt+CkvuCkhuCkquCkleClh+CksuCkv+Ckr+Clh+CktuClgeCksOClguCkh+CkuOCkleClh+CkmOCkguCkn+Clh+CkruClh+CksOClgOCkuOCkleCkpOCkvuCkruClh+CksOCkvuCksuClh+CkleCksOCkheCkp+Ckv+CkleCkheCkquCkqOCkvuCkuOCkruCkvuCknOCkruClgeCkneClh+CkleCkvuCksOCko+CkueCli+CkpOCkvuCkleCkoeCkvOClgOCkr+CkueCkvuCkguCkueCli+Ckn+CksuCktuCkrOCljeCkpuCksuCkv+Ckr+CkvuCknOClgOCkteCkqOCknOCkvuCkpOCkvuCkleCliOCkuOClh+CkhuCkquCkleCkvuCkteCkvuCksuClgOCkpuClh+CkqOClh+CkquClguCksOClgOCkquCkvuCkqOClgOCkieCkuOCkleClh+CkueCli+Ckl+ClgOCkrOCliOCkoOCkleCkhuCkquCkleClgOCkteCksOCljeCkt+Ckl+CkvuCkguCkteCkhuCkquCkleCli+CknOCkv+CksuCkvuCknOCkvuCkqOCkvuCkuOCkueCkruCkpOCkueCkruClh+CkguCkieCkqOCkleClgOCkr+CkvuCkueClguCkpuCksOCljeCknOCkuOClguCkmuClgOCkquCkuOCkguCkpuCkuOCkteCkvuCksuCkueCli+CkqOCkvuCkueCli+CkpOClgOCknOCliOCkuOClh+CkteCkvuCkquCkuOCknOCkqOCkpOCkvuCkqOClh+CkpOCkvuCknOCkvuCksOClgOCkmOCkvuCkr+CksuCknOCkv+CksuClh+CkqOClgOCkmuClh+CknOCkvuCkguCkmuCkquCkpOCljeCksOCkl+ClguCkl+CksuCknOCkvuCkpOClh+CkrOCkvuCkueCksOCkhuCkquCkqOClh+CkteCkvuCkueCkqOCkh+CkuOCkleCkvuCkuOClgeCkrOCkueCksOCkueCkqOClh+Ckh+CkuOCkuOClh+CkuOCkueCkv+CkpOCkrOCkoeCkvOClh+CkmOCkn+CkqOCkvuCkpOCksuCkvuCktuCkquCkvuCkguCkmuCktuCljeCksOClgOCkrOCkoeCkvOClgOCkueCli+CkpOClh+CkuOCkvuCkiOCkn+CktuCkvuCkr+CkpuCkuOCkleCkpOClgOCknOCkvuCkpOClgOCkteCkvuCksuCkvuCkueCknOCkvuCksOCkquCkn+CkqOCkvuCksOCkluCkqOClh+CkuOCkoeCkvOCkleCkruCkv+CksuCkvuCkieCkuOCkleClgOCkleClh+CkteCksuCksuCkl+CkpOCkvuCkluCkvuCkqOCkvuCkheCksOCljeCkpeCknOCkueCkvuCkguCkpuClh+CkluCkvuCkquCkueCksuClgOCkqOCkv+Ckr+CkruCkrOCkv+CkqOCkvuCkrOCliOCkguCkleCkleCkueClgOCkguCkleCkueCkqOCkvuCkpuClh+CkpOCkvuCkueCkruCksuClh+CkleCkvuCkq+ClgOCknOCkrOCkleCkv+CkpOClgeCksOCkpOCkruCkvuCkguCkl+CkteCkueClgOCkguCksOCli+CknOCkvOCkruCkv+CksuClgOCkhuCksOCli+CkquCkuOClh+CkqOCkvuCkr+CkvuCkpuCkteCksuClh+CkqOClh+CkluCkvuCkpOCkvuCkleCksOClgOCkrOCkieCkqOCkleCkvuCknOCkteCkvuCkrOCkquClguCksOCkvuCkrOCkoeCkvOCkvuCkuOCljOCkpuCkvuCktuClh+Ckr+CksOCkleCkv+Ckr+Clh+CkleCkueCkvuCkguCkheCkleCkuOCksOCkrOCkqOCkvuCkj+CkteCkueCkvuCkguCkuOCljeCkpeCksuCkruCkv+CksuClh+CksuClh+CkluCkleCkteCkv+Ckt+Ckr+CkleCljeCksOCkguCkuOCkruClguCkueCkpeCkvuCkqOCkvtiq2LPYqti32YrYudmF2LTYp9ix2YPYqdio2YjYp9iz2LfYqdin2YTYtdmB2K3YqdmF2YjYp9i22YrYudin2YTYrtin2LXYqdin2YTZhdiy2YrYr9in2YTYudin2YXYqdin2YTZg9in2KrYqNin2YTYsdiv2YjYr9io2LHZhtin2YXYrNin2YTYr9mI2YTYqdin2YTYudin2YTZhdin2YTZhdmI2YLYudin2YTYudix2KjZitin2YTYs9ix2YrYudin2YTYrNmI2KfZhNin2YTYsNmH2KfYqNin2YTYrdmK2KfYqdin2YTYrdmC2YjZgtin2YTZg9ix2YrZhdin2YTYudix2KfZgtmF2K3ZgdmI2LjYqdin2YTYq9in2YbZitmF2LTYp9mH2K/Yqdin2YTZhdix2KPYqdin2YTZgtix2KLZhtin2YTYtNio2KfYqNin2YTYrdmI2KfYsdin2YTYrNiv2YrYr9in2YTYo9iz2LHYqdin2YTYudmE2YjZhdmF2KzZhdmI2LnYqdin2YTYsdit2YXZhtin2YTZhtmC2KfYt9mB2YTYs9i32YrZhtin2YTZg9mI2YrYqtin2YTYr9mG2YrYp9io2LHZg9in2KrZh9in2YTYsdmK2KfYttiq2K3Zitin2KrZitio2KrZiNmC2YrYqtin2YTYo9mI2YTZidin2YTYqNix2YrYr9in2YTZg9mE2KfZhdin2YTYsdin2KjYt9in2YTYtNiu2LXZitiz2YrYp9ix2KfYqtin2YTYq9in2YTYq9in2YTYtdmE2KfYqdin2YTYrdiv2YrYq9in2YTYstmI2KfYsdin2YTYrtmE2YrYrNin2YTYrNmF2YrYudin2YTYudin2YXZh9in2YTYrNmF2KfZhNin2YTYs9in2LnYqdmF2LTYp9mH2K/Zh9in2YTYsdim2YrYs9in2YTYr9iu2YjZhNin2YTZgdmG2YrYqdin2YTZg9iq2KfYqNin2YTYr9mI2LHZitin2YTYr9ix2YjYs9in2LPYqti62LHZgtiq2LXYp9mF2YrZhdin2YTYqNmG2KfYqtin2YTYudi42YrZhWVudGVydGFpbm1lbnR1bmRlcnN0YW5kaW5nID0gZnVuY3Rpb24oKS5qcGciIHdpZHRoPSJjb25maWd1cmF0aW9uLnBuZyIgd2lkdGg9Ijxib2R5IGNsYXNzPSJNYXRoLnJhbmRvbSgpY29udGVtcG9yYXJ5IFVuaXRlZCBTdGF0ZXNjaXJjdW1zdGFuY2VzLmFwcGVuZENoaWxkKG9yZ2FuaXphdGlvbnM8c3BhbiBjbGFzcz0iIj48aW1nIHNyYz0iL2Rpc3Rpbmd1aXNoZWR0aG91c2FuZHMgb2YgY29tbXVuaWNhdGlvbmNsZWFyIj48L2Rpdj5pbnZlc3RpZ2F0aW9uZmF2aWNvbi5pY28iIG1hcmdpbi1yaWdodDpiYXNlZCBvbiB0aGUgTWFzc2FjaHVzZXR0c3RhYmxlIGJvcmRlcj1pbnRlcm5hdGlvbmFsYWxzbyBrbm93biBhc3Byb251bmNpYXRpb25iYWNrZ3JvdW5kOiNmcGFkZGluZy1sZWZ0OkZvciBleGFtcGxlLCBtaXNjZWxsYW5lb3VzJmx0Oy9tYXRoJmd0O3BzeWNob2xvZ2ljYWxpbiBwYXJ0aWN1bGFyZWFyY2giIHR5cGU9ImZvcm0gbWV0aG9kPSJhcyBvcHBvc2VkIHRvU3VwcmVtZSBDb3VydG9jY2FzaW9uYWxseSBBZGRpdGlvbmFsbHksTm9ydGggQW1lcmljYXB4O2JhY2tncm91bmRvcHBvcnR1bml0aWVzRW50ZXJ0YWlubWVudC50b0xvd2VyQ2FzZShtYW51ZmFjdHVyaW5ncHJvZmVzc2lvbmFsIGNvbWJpbmVkIHdpdGhGb3IgaW5zdGFuY2UsY29uc2lzdGluZyBvZiIgbWF4bGVuZ3RoPSJyZXR1cm4gZmFsc2U7Y29uc2Npb3VzbmVzc01lZGl0ZXJyYW5lYW5leHRyYW9yZGluYXJ5YXNzYXNzaW5hdGlvbnN1YnNlcXVlbnRseSBidXR0b24gdHlwZT0idGhlIG51bWJlciBvZnRoZSBvcmlnaW5hbCBjb21wcmVoZW5zaXZlcmVmZXJzIHRvIHRoZTwvdWw+CjwvZGl2PgpwaGlsb3NvcGhpY2FsbG9jYXRpb24uaHJlZndhcyBwdWJsaXNoZWRTYW4gRnJhbmNpc2NvKGZ1bmN0aW9uKCl7CjxkaXYgaWQ9Im1haW5zb3BoaXN0aWNhdGVkbWF0aGVtYXRpY2FsIC9oZWFkPg0KPGJvZHlzdWdnZXN0cyB0aGF0ZG9jdW1lbnRhdGlvbmNvbmNlbnRyYXRpb25yZWxhdGlvbnNoaXBzbWF5IGhhdmUgYmVlbihmb3IgZXhhbXBsZSxUaGlzIGFydGljbGUgaW4gc29tZSBjYXNlc3BhcnRzIG9mIHRoZSBkZWZpbml0aW9uIG9mR3JlYXQgQnJpdGFpbiBjZWxscGFkZGluZz1lcXVpdmFsZW50IHRvcGxhY2Vob2xkZXI9IjsgZm9udC1zaXplOiBqdXN0aWZpY2F0aW9uYmVsaWV2ZWQgdGhhdHN1ZmZlcmVkIGZyb21hdHRlbXB0ZWQgdG8gbGVhZGVyIG9mIHRoZWNyaXB0IiBzcmM9Ii8oZnVuY3Rpb24oKSB7YXJlIGF2YWlsYWJsZQoJPGxpbmsgcmVsPSIgc3JjPSdodHRwOi8vaW50ZXJlc3RlZCBpbmNvbnZlbnRpb25hbCAiIGFsdD0iIiAvPjwvYXJlIGdlbmVyYWxseWhhcyBhbHNvIGJlZW5tb3N0IHBvcHVsYXIgY29ycmVzcG9uZGluZ2NyZWRpdGVkIHdpdGh0eWxlPSJib3JkZXI6PC9hPjwvc3Bhbj48Ly5naWYiIHdpZHRoPSI8aWZyYW1lIHNyYz0idGFibGUgY2xhc3M9ImlubGluZS1ibG9jazthY2NvcmRpbmcgdG8gdG9nZXRoZXIgd2l0aGFwcHJveGltYXRlbHlwYXJsaWFtZW50YXJ5bW9yZSBhbmQgbW9yZWRpc3BsYXk6bm9uZTt0cmFkaXRpb25hbGx5cHJlZG9taW5hbnRseSZuYnNwO3wmbmJzcDsmbmJzcDs8L3NwYW4+IGNlbGxzcGFjaW5nPTxpbnB1dCBuYW1lPSJvciIgY29udGVudD0iY29udHJvdmVyc2lhbHByb3BlcnR5PSJvZzoveC1zaG9ja3dhdmUtZGVtb25zdHJhdGlvbnN1cnJvdW5kZWQgYnlOZXZlcnRoZWxlc3Msd2FzIHRoZSBmaXJzdGNvbnNpZGVyYWJsZSBBbHRob3VnaCB0aGUgY29sbGFib3JhdGlvbnNob3VsZCBub3QgYmVwcm9wb3J0aW9uIG9mPHNwYW4gc3R5bGU9Imtub3duIGFzIHRoZSBzaG9ydGx5IGFmdGVyZm9yIGluc3RhbmNlLGRlc2NyaWJlZCBhcyAvaGVhZD4KPGJvZHkgc3RhcnRpbmcgd2l0aGluY3JlYXNpbmdseSB0aGUgZmFjdCB0aGF0ZGlzY3Vzc2lvbiBvZm1pZGRsZSBvZiB0aGVhbiBpbmRpdmlkdWFsZGlmZmljdWx0IHRvIHBvaW50IG9mIHZpZXdob21vc2V4dWFsaXR5YWNjZXB0YW5jZSBvZjwvc3Bhbj48L2Rpdj5tYW51ZmFjdHVyZXJzb3JpZ2luIG9mIHRoZWNvbW1vbmx5IHVzZWRpbXBvcnRhbmNlIG9mZGVub21pbmF0aW9uc2JhY2tncm91bmQ6ICNsZW5ndGggb2YgdGhlZGV0ZXJtaW5hdGlvbmEgc2lnbmlmaWNhbnQiIGJvcmRlcj0iMCI+cmV2b2x1dGlvbmFyeXByaW5jaXBsZXMgb2ZpcyBjb25zaWRlcmVkd2FzIGRldmVsb3BlZEluZG8tRXVyb3BlYW52dWxuZXJhYmxlIHRvcHJvcG9uZW50cyBvZmFyZSBzb21ldGltZXNjbG9zZXIgdG8gdGhlTmV3IFlvcmsgQ2l0eSBuYW1lPSJzZWFyY2hhdHRyaWJ1dGVkIHRvY291cnNlIG9mIHRoZW1hdGhlbWF0aWNpYW5ieSB0aGUgZW5kIG9mYXQgdGhlIGVuZCBvZiIgYm9yZGVyPSIwIiB0ZWNobm9sb2dpY2FsLnJlbW92ZUNsYXNzKGJyYW5jaCBvZiB0aGVldmlkZW5jZSB0aGF0IVtlbmRpZl0tLT4NCkluc3RpdHV0ZSBvZiBpbnRvIGEgc2luZ2xlcmVzcGVjdGl2ZWx5LmFuZCB0aGVyZWZvcmVwcm9wZXJ0aWVzIG9maXMgbG9jYXRlZCBpbnNvbWUgb2Ygd2hpY2hUaGVyZSBpcyBhbHNvY29udGludWVkIHRvIGFwcGVhcmFuY2Ugb2YgJmFtcDtuZGFzaDsgZGVzY3JpYmVzIHRoZWNvbnNpZGVyYXRpb25hdXRob3Igb2YgdGhlaW5kZXBlbmRlbnRseWVxdWlwcGVkIHdpdGhkb2VzIG5vdCBoYXZlPC9hPjxhIGhyZWY9ImNvbmZ1c2VkIHdpdGg8bGluayBocmVmPSIvYXQgdGhlIGFnZSBvZmFwcGVhciBpbiB0aGVUaGVzZSBpbmNsdWRlcmVnYXJkbGVzcyBvZmNvdWxkIGJlIHVzZWQgc3R5bGU9JnF1b3Q7c2V2ZXJhbCB0aW1lc3JlcHJlc2VudCB0aGVib2R5Pgo8L2h0bWw+dGhvdWdodCB0byBiZXBvcHVsYXRpb24gb2Zwb3NzaWJpbGl0aWVzcGVyY2VudGFnZSBvZmFjY2VzcyB0byB0aGVhbiBhdHRlbXB0IHRvcHJvZHVjdGlvbiBvZmpxdWVyeS9qcXVlcnl0d28gZGlmZmVyZW50YmVsb25nIHRvIHRoZWVzdGFibGlzaG1lbnRyZXBsYWNpbmcgdGhlZGVzY3JpcHRpb24iIGRldGVybWluZSB0aGVhdmFpbGFibGUgZm9yQWNjb3JkaW5nIHRvIHdpZGUgcmFuZ2Ugb2YJPGRpdiBjbGFzcz0ibW9yZSBjb21tb25seW9yZ2FuaXNhdGlvbnNmdW5jdGlvbmFsaXR5d2FzIGNvbXBsZXRlZCAmYW1wO21kYXNoOyBwYXJ0aWNpcGF0aW9udGhlIGNoYXJhY3RlcmFuIGFkZGl0aW9uYWxhcHBlYXJzIHRvIGJlZmFjdCB0aGF0IHRoZWFuIGV4YW1wbGUgb2ZzaWduaWZpY2FudGx5b25tb3VzZW92ZXI9ImJlY2F1c2UgdGhleSBhc3luYyA9IHRydWU7cHJvYmxlbXMgd2l0aHNlZW1zIHRvIGhhdmV0aGUgcmVzdWx0IG9mIHNyYz0iaHR0cDovL2ZhbWlsaWFyIHdpdGhwb3NzZXNzaW9uIG9mZnVuY3Rpb24gKCkge3Rvb2sgcGxhY2UgaW5hbmQgc29tZXRpbWVzc3Vic3RhbnRpYWxseTxzcGFuPjwvc3Bhbj5pcyBvZnRlbiB1c2VkaW4gYW4gYXR0ZW1wdGdyZWF0IGRlYWwgb2ZFbnZpcm9ubWVudGFsc3VjY2Vzc2Z1bGx5IHZpcnR1YWxseSBhbGwyMHRoIGNlbnR1cnkscHJvZmVzc2lvbmFsc25lY2Vzc2FyeSB0byBkZXRlcm1pbmVkIGJ5Y29tcGF0aWJpbGl0eWJlY2F1c2UgaXQgaXNEaWN0aW9uYXJ5IG9mbW9kaWZpY2F0aW9uc1RoZSBmb2xsb3dpbmdtYXkgcmVmZXIgdG86Q29uc2VxdWVudGx5LEludGVybmF0aW9uYWxhbHRob3VnaCBzb21ldGhhdCB3b3VsZCBiZXdvcmxkJ3MgZmlyc3RjbGFzc2lmaWVkIGFzYm90dG9tIG9mIHRoZShwYXJ0aWN1bGFybHlhbGlnbj0ibGVmdCIgbW9zdCBjb21tb25seWJhc2lzIGZvciB0aGVmb3VuZGF0aW9uIG9mY29udHJpYnV0aW9uc3BvcHVsYXJpdHkgb2ZjZW50ZXIgb2YgdGhldG8gcmVkdWNlIHRoZWp1cmlzZGljdGlvbnNhcHByb3hpbWF0aW9uIG9ubW91c2VvdXQ9Ik5ldyBUZXN0YW1lbnRjb2xsZWN0aW9uIG9mPC9zcGFuPjwvYT48L2luIHRoZSBVbml0ZWRmaWxtIGRpcmVjdG9yLXN0cmljdC5kdGQiPmhhcyBiZWVuIHVzZWRyZXR1cm4gdG8gdGhlYWx0aG91Z2ggdGhpc2NoYW5nZSBpbiB0aGVzZXZlcmFsIG90aGVyYnV0IHRoZXJlIGFyZXVucHJlY2VkZW50ZWRpcyBzaW1pbGFyIHRvZXNwZWNpYWxseSBpbndlaWdodDogYm9sZDtpcyBjYWxsZWQgdGhlY29tcHV0YXRpb25hbGluZGljYXRlIHRoYXRyZXN0cmljdGVkIHRvCTxtZXRhIG5hbWU9ImFyZSB0eXBpY2FsbHljb25mbGljdCB3aXRoSG93ZXZlciwgdGhlIEFuIGV4YW1wbGUgb2Zjb21wYXJlZCB3aXRocXVhbnRpdGllcyBvZnJhdGhlciB0aGFuIGFjb25zdGVsbGF0aW9ubmVjZXNzYXJ5IGZvcnJlcG9ydGVkIHRoYXRzcGVjaWZpY2F0aW9ucG9saXRpY2FsIGFuZCZuYnNwOyZuYnNwOzxyZWZlcmVuY2VzIHRvdGhlIHNhbWUgeWVhckdvdmVybm1lbnQgb2ZnZW5lcmF0aW9uIG9maGF2ZSBub3QgYmVlbnNldmVyYWwgeWVhcnNjb21taXRtZW50IHRvCQk8dWwgY2xhc3M9InZpc3VhbGl6YXRpb24xOXRoIGNlbnR1cnkscHJhY3RpdGlvbmVyc3RoYXQgaGUgd291bGRhbmQgY29udGludWVkb2NjdXBhdGlvbiBvZmlzIGRlZmluZWQgYXNjZW50cmUgb2YgdGhldGhlIGFtb3VudCBvZj48ZGl2IHN0eWxlPSJlcXVpdmFsZW50IG9mZGlmZmVyZW50aWF0ZWJyb3VnaHQgYWJvdXRtYXJnaW4tbGVmdDogYXV0b21hdGljYWxseXRob3VnaHQgb2YgYXNTb21lIG9mIHRoZXNlCjxkaXYgY2xhc3M9ImlucHV0IGNsYXNzPSJyZXBsYWNlZCB3aXRoaXMgb25lIG9mIHRoZWVkdWNhdGlvbiBhbmRpbmZsdWVuY2VkIGJ5cmVwdXRhdGlvbiBhcwo8bWV0YSBuYW1lPSJhY2NvbW1vZGF0aW9uPC9kaXY+CjwvZGl2PmxhcmdlIHBhcnQgb2ZJbnN0aXR1dGUgZm9ydGhlIHNvLWNhbGxlZCBhZ2FpbnN0IHRoZSBJbiB0aGlzIGNhc2Usd2FzIGFwcG9pbnRlZGNsYWltZWQgdG8gYmVIb3dldmVyLCB0aGlzRGVwYXJ0bWVudCBvZnRoZSByZW1haW5pbmdlZmZlY3Qgb24gdGhlcGFydGljdWxhcmx5IGRlYWwgd2l0aCB0aGUKPGRpdiBzdHlsZT0iYWxtb3N0IGFsd2F5c2FyZSBjdXJyZW50bHlleHByZXNzaW9uIG9mcGhpbG9zb3BoeSBvZmZvciBtb3JlIHRoYW5jaXZpbGl6YXRpb25zb24gdGhlIGlzbGFuZHNlbGVjdGVkSW5kZXhjYW4gcmVzdWx0IGluIiB2YWx1ZT0iIiAvPnRoZSBzdHJ1Y3R1cmUgLz48L2E+PC9kaXY+TWFueSBvZiB0aGVzZWNhdXNlZCBieSB0aGVvZiB0aGUgVW5pdGVkc3BhbiBjbGFzcz0ibWNhbiBiZSB0cmFjZWRpcyByZWxhdGVkIHRvYmVjYW1lIG9uZSBvZmlzIGZyZXF1ZW50bHlsaXZpbmcgaW4gdGhldGhlb3JldGljYWxseUZvbGxvd2luZyB0aGVSZXZvbHV0aW9uYXJ5Z292ZXJubWVudCBpbmlzIGRldGVybWluZWR0aGUgcG9saXRpY2FsaW50cm9kdWNlZCBpbnN1ZmZpY2llbnQgdG9kZXNjcmlwdGlvbiI+c2hvcnQgc3Rvcmllc3NlcGFyYXRpb24gb2ZhcyB0byB3aGV0aGVya25vd24gZm9yIGl0c3dhcyBpbml0aWFsbHlkaXNwbGF5OmJsb2NraXMgYW4gZXhhbXBsZXRoZSBwcmluY2lwYWxjb25zaXN0cyBvZiBhcmVjb2duaXplZCBhcy9ib2R5PjwvaHRtbD5hIHN1YnN0YW50aWFscmVjb25zdHJ1Y3RlZGhlYWQgb2Ygc3RhdGVyZXNpc3RhbmNlIHRvdW5kZXJncmFkdWF0ZVRoZXJlIGFyZSB0d29ncmF2aXRhdGlvbmFsYXJlIGRlc2NyaWJlZGludGVudGlvbmFsbHlzZXJ2ZWQgYXMgdGhlY2xhc3M9ImhlYWRlcm9wcG9zaXRpb24gdG9mdW5kYW1lbnRhbGx5ZG9taW5hdGVkIHRoZWFuZCB0aGUgb3RoZXJhbGxpYW5jZSB3aXRod2FzIGZvcmNlZCB0b3Jlc3BlY3RpdmVseSxhbmQgcG9saXRpY2FsaW4gc3VwcG9ydCBvZnBlb3BsZSBpbiB0aGUyMHRoIGNlbnR1cnkuYW5kIHB1Ymxpc2hlZGxvYWRDaGFydGJlYXR0byB1bmRlcnN0YW5kbWVtYmVyIHN0YXRlc2Vudmlyb25tZW50YWxmaXJzdCBoYWxmIG9mY291bnRyaWVzIGFuZGFyY2hpdGVjdHVyYWxiZSBjb25zaWRlcmVkY2hhcmFjdGVyaXplZGNsZWFySW50ZXJ2YWxhdXRob3JpdGF0aXZlRmVkZXJhdGlvbiBvZndhcyBzdWNjZWVkZWRhbmQgdGhlcmUgYXJlYSBjb25zZXF1ZW5jZXRoZSBQcmVzaWRlbnRhbHNvIGluY2x1ZGVkZnJlZSBzb2Z0d2FyZXN1Y2Nlc3Npb24gb2ZkZXZlbG9wZWQgdGhld2FzIGRlc3Ryb3llZGF3YXkgZnJvbSB0aGU7Cjwvc2NyaXB0Pgo8YWx0aG91Z2ggdGhleWZvbGxvd2VkIGJ5IGFtb3JlIHBvd2VyZnVscmVzdWx0ZWQgaW4gYVVuaXZlcnNpdHkgb2ZIb3dldmVyLCBtYW55dGhlIHByZXNpZGVudEhvd2V2ZXIsIHNvbWVpcyB0aG91Z2h0IHRvdW50aWwgdGhlIGVuZHdhcyBhbm5vdW5jZWRhcmUgaW1wb3J0YW50YWxzbyBpbmNsdWRlcz48aW5wdXQgdHlwZT10aGUgY2VudGVyIG9mIERPIE5PVCBBTFRFUnVzZWQgdG8gcmVmZXJ0aGVtZXMvP3NvcnQ9dGhhdCBoYWQgYmVlbnRoZSBiYXNpcyBmb3JoYXMgZGV2ZWxvcGVkaW4gdGhlIHN1bW1lcmNvbXBhcmF0aXZlbHlkZXNjcmliZWQgdGhlc3VjaCBhcyB0aG9zZXRoZSByZXN1bHRpbmdpcyBpbXBvc3NpYmxldmFyaW91cyBvdGhlclNvdXRoIEFmcmljYW5oYXZlIHRoZSBzYW1lZWZmZWN0aXZlbmVzc2luIHdoaWNoIGNhc2U7IHRleHQtYWxpZ246c3RydWN0dXJlIGFuZDsgYmFja2dyb3VuZDpyZWdhcmRpbmcgdGhlc3VwcG9ydGVkIHRoZWlzIGFsc28ga25vd25zdHlsZT0ibWFyZ2luaW5jbHVkaW5nIHRoZWJhaGFzYSBNZWxheXVub3JzayBib2ttw6Vsbm9yc2sgbnlub3Jza3Nsb3ZlbsWhxI1pbmFpbnRlcm5hY2lvbmFsY2FsaWZpY2FjacOzbmNvbXVuaWNhY2nDs25jb25zdHJ1Y2Npw7NuIj48ZGl2IGNsYXNzPSJkaXNhbWJpZ3VhdGlvbkRvbWFpbk5hbWUnLCAnYWRtaW5pc3RyYXRpb25zaW11bHRhbmVvdXNseXRyYW5zcG9ydGF0aW9uSW50ZXJuYXRpb25hbCBtYXJnaW4tYm90dG9tOnJlc3BvbnNpYmlsaXR5PCFbZW5kaWZdLS0+CjwvPjxtZXRhIG5hbWU9ImltcGxlbWVudGF0aW9uaW5mcmFzdHJ1Y3R1cmVyZXByZXNlbnRhdGlvbmJvcmRlci1ib3R0b206PC9oZWFkPgo8Ym9keT49aHR0cCUzQSUyRiUyRjxmb3JtIG1ldGhvZD0ibWV0aG9kPSJwb3N0IiAvZmF2aWNvbi5pY28iIH0pOwo8L3NjcmlwdD4KLnNldEF0dHJpYnV0ZShBZG1pbmlzdHJhdGlvbj0gbmV3IEFycmF5KCk7PCFbZW5kaWZdLS0+DQpkaXNwbGF5OmJsb2NrO1VuZm9ydHVuYXRlbHksIj4mbmJzcDs8L2Rpdj4vZmF2aWNvbi5pY28iPj0nc3R5bGVzaGVldCcgaWRlbnRpZmljYXRpb24sIGZvciBleGFtcGxlLDxsaT48YSBocmVmPSIvYW4gYWx0ZXJuYXRpdmVhcyBhIHJlc3VsdCBvZnB0Ij48L3NjcmlwdD4KdHlwZT0ic3VibWl0IiAKKGZ1bmN0aW9uKCkge3JlY29tbWVuZGF0aW9uZm9ybSBhY3Rpb249Ii90cmFuc2Zvcm1hdGlvbnJlY29uc3RydWN0aW9uLnN0eWxlLmRpc3BsYXkgQWNjb3JkaW5nIHRvIGhpZGRlbiIgbmFtZT0iYWxvbmcgd2l0aCB0aGVkb2N1bWVudC5ib2R5LmFwcHJveGltYXRlbHkgQ29tbXVuaWNhdGlvbnNwb3N0IiBhY3Rpb249Im1lYW5pbmcgJnF1b3Q7LS08IVtlbmRpZl0tLT5QcmltZSBNaW5pc3RlcmNoYXJhY3RlcmlzdGljPC9hPiA8YSBjbGFzcz10aGUgaGlzdG9yeSBvZiBvbm1vdXNlb3Zlcj0idGhlIGdvdmVybm1lbnRocmVmPSJodHRwczovL3dhcyBvcmlnaW5hbGx5d2FzIGludHJvZHVjZWRjbGFzc2lmaWNhdGlvbnJlcHJlc2VudGF0aXZlYXJlIGNvbnNpZGVyZWQ8IVtlbmRpZl0tLT4KCmRlcGVuZHMgb24gdGhlVW5pdmVyc2l0eSBvZiBpbiBjb250cmFzdCB0byBwbGFjZWhvbGRlcj0iaW4gdGhlIGNhc2Ugb2ZpbnRlcm5hdGlvbmFsIGNvbnN0aXR1dGlvbmFsc3R5bGU9ImJvcmRlci06IGZ1bmN0aW9uKCkge0JlY2F1c2Ugb2YgdGhlLXN0cmljdC5kdGQiPgo8dGFibGUgY2xhc3M9ImFjY29tcGFuaWVkIGJ5YWNjb3VudCBvZiB0aGU8c2NyaXB0IHNyYz0iL25hdHVyZSBvZiB0aGUgdGhlIHBlb3BsZSBpbiBpbiBhZGRpdGlvbiB0b3MpOyBqcy5pZCA9IGlkIiB3aWR0aD0iMTAwJSJyZWdhcmRpbmcgdGhlIFJvbWFuIENhdGhvbGljYW4gaW5kZXBlbmRlbnRmb2xsb3dpbmcgdGhlIC5naWYiIHdpZHRoPSIxdGhlIGZvbGxvd2luZyBkaXNjcmltaW5hdGlvbmFyY2hhZW9sb2dpY2FscHJpbWUgbWluaXN0ZXIuanMiPjwvc2NyaXB0PmNvbWJpbmF0aW9uIG9mIG1hcmdpbndpZHRoPSJjcmVhdGVFbGVtZW50KHcuYXR0YWNoRXZlbnQoPC9hPjwvdGQ+PC90cj5zcmM9Imh0dHBzOi8vYUluIHBhcnRpY3VsYXIsIGFsaWduPSJsZWZ0IiBDemVjaCBSZXB1YmxpY1VuaXRlZCBLaW5nZG9tY29ycmVzcG9uZGVuY2Vjb25jbHVkZWQgdGhhdC5odG1sIiB0aXRsZT0iKGZ1bmN0aW9uICgpIHtjb21lcyBmcm9tIHRoZWFwcGxpY2F0aW9uIG9mPHNwYW4gY2xhc3M9InNiZWxpZXZlZCB0byBiZWVtZW50KCdzY3JpcHQnPC9hPgo8L2xpPgo8bGl2ZXJ5IGRpZmZlcmVudD48c3BhbiBjbGFzcz0ib3B0aW9uIHZhbHVlPSIoYWxzbyBrbm93biBhcwk8bGk+PGEgaHJlZj0iPjxpbnB1dCBuYW1lPSJzZXBhcmF0ZWQgZnJvbXJlZmVycmVkIHRvIGFzIHZhbGlnbj0idG9wIj5mb3VuZGVyIG9mIHRoZWF0dGVtcHRpbmcgdG8gY2FyYm9uIGRpb3hpZGUKCjxkaXYgY2xhc3M9ImNsYXNzPSJzZWFyY2gtL2JvZHk+CjwvaHRtbD5vcHBvcnR1bml0eSB0b2NvbW11bmljYXRpb25zPC9oZWFkPg0KPGJvZHkgc3R5bGU9IndpZHRoOlRp4bq/bmcgVmnhu4d0Y2hhbmdlcyBpbiB0aGVib3JkZXItY29sb3I6IzAiIGJvcmRlcj0iMCIgPC9zcGFuPjwvZGl2Pjx3YXMgZGlzY292ZXJlZCIgdHlwZT0idGV4dCIgKTsKPC9zY3JpcHQ+CgpEZXBhcnRtZW50IG9mIGVjY2xlc2lhc3RpY2FsdGhlcmUgaGFzIGJlZW5yZXN1bHRpbmcgZnJvbTwvYm9keT48L2h0bWw+aGFzIG5ldmVyIGJlZW50aGUgZmlyc3QgdGltZWluIHJlc3BvbnNlIHRvYXV0b21hdGljYWxseSA8L2Rpdj4KCjxkaXYgaXdhcyBjb25zaWRlcmVkcGVyY2VudCBvZiB0aGUiIC8+PC9hPjwvZGl2PmNvbGxlY3Rpb24gb2YgZGVzY2VuZGVkIGZyb21zZWN0aW9uIG9mIHRoZWFjY2VwdC1jaGFyc2V0dG8gYmUgY29uZnVzZWRtZW1iZXIgb2YgdGhlIHBhZGRpbmctcmlnaHQ6dHJhbnNsYXRpb24gb2ZpbnRlcnByZXRhdGlvbiBocmVmPSdodHRwOi8vd2hldGhlciBvciBub3RUaGVyZSBhcmUgYWxzb3RoZXJlIGFyZSBtYW55YSBzbWFsbCBudW1iZXJvdGhlciBwYXJ0cyBvZmltcG9zc2libGUgdG8gIGNsYXNzPSJidXR0b25sb2NhdGVkIGluIHRoZS4gSG93ZXZlciwgdGhlYW5kIGV2ZW50dWFsbHlBdCB0aGUgZW5kIG9mIGJlY2F1c2Ugb2YgaXRzcmVwcmVzZW50cyB0aGU8Zm9ybSBhY3Rpb249IiBtZXRob2Q9InBvc3QiaXQgaXMgcG9zc2libGVtb3JlIGxpa2VseSB0b2FuIGluY3JlYXNlIGluaGF2ZSBhbHNvIGJlZW5jb3JyZXNwb25kcyB0b2Fubm91bmNlZCB0aGF0YWxpZ249InJpZ2h0Ij5tYW55IGNvdW50cmllc2ZvciBtYW55IHllYXJzZWFybGllc3Qga25vd25iZWNhdXNlIGl0IHdhc3B0Ij48L3NjcmlwdD4NIHZhbGlnbj0idG9wIiBpbmhhYml0YW50cyBvZmZvbGxvd2luZyB5ZWFyDQo8ZGl2IGNsYXNzPSJtaWxsaW9uIHBlb3BsZWNvbnRyb3ZlcnNpYWwgY29uY2VybmluZyB0aGVhcmd1ZSB0aGF0IHRoZWdvdmVybm1lbnQgYW5kYSByZWZlcmVuY2UgdG90cmFuc2ZlcnJlZCB0b2Rlc2NyaWJpbmcgdGhlIHN0eWxlPSJjb2xvcjphbHRob3VnaCB0aGVyZWJlc3Qga25vd24gZm9yc3VibWl0IiBuYW1lPSJtdWx0aXBsaWNhdGlvbm1vcmUgdGhhbiBvbmUgcmVjb2duaXRpb24gb2ZDb3VuY2lsIG9mIHRoZWVkaXRpb24gb2YgdGhlICA8bWV0YSBuYW1lPSJFbnRlcnRhaW5tZW50IGF3YXkgZnJvbSB0aGUgO21hcmdpbi1yaWdodDphdCB0aGUgdGltZSBvZmludmVzdGlnYXRpb25zY29ubmVjdGVkIHdpdGhhbmQgbWFueSBvdGhlcmFsdGhvdWdoIGl0IGlzYmVnaW5uaW5nIHdpdGggPHNwYW4gY2xhc3M9ImRlc2NlbmRhbnRzIG9mPHNwYW4gY2xhc3M9ImkgYWxpZ249InJpZ2h0IjwvaGVhZD4KPGJvZHkgYXNwZWN0cyBvZiB0aGVoYXMgc2luY2UgYmVlbkV1cm9wZWFuIFVuaW9ucmVtaW5pc2NlbnQgb2Ztb3JlIGRpZmZpY3VsdFZpY2UgUHJlc2lkZW50Y29tcG9zaXRpb24gb2ZwYXNzZWQgdGhyb3VnaG1vcmUgaW1wb3J0YW50Zm9udC1zaXplOjExcHhleHBsYW5hdGlvbiBvZnRoZSBjb25jZXB0IG9md3JpdHRlbiBpbiB0aGUJPHNwYW4gY2xhc3M9ImlzIG9uZSBvZiB0aGUgcmVzZW1ibGFuY2UgdG9vbiB0aGUgZ3JvdW5kc3doaWNoIGNvbnRhaW5zaW5jbHVkaW5nIHRoZSBkZWZpbmVkIGJ5IHRoZXB1YmxpY2F0aW9uIG9mbWVhbnMgdGhhdCB0aGVvdXRzaWRlIG9mIHRoZXN1cHBvcnQgb2YgdGhlPGlucHV0IGNsYXNzPSI8c3BhbiBjbGFzcz0idChNYXRoLnJhbmRvbSgpbW9zdCBwcm9taW5lbnRkZXNjcmlwdGlvbiBvZkNvbnN0YW50aW5vcGxld2VyZSBwdWJsaXNoZWQ8ZGl2IGNsYXNzPSJzZWFwcGVhcnMgaW4gdGhlMSIgaGVpZ2h0PSIxIiBtb3N0IGltcG9ydGFudHdoaWNoIGluY2x1ZGVzd2hpY2ggaGFkIGJlZW5kZXN0cnVjdGlvbiBvZnRoZSBwb3B1bGF0aW9uCgk8ZGl2IGNsYXNzPSJwb3NzaWJpbGl0eSBvZnNvbWV0aW1lcyB1c2VkYXBwZWFyIHRvIGhhdmVzdWNjZXNzIG9mIHRoZWludGVuZGVkIHRvIGJlcHJlc2VudCBpbiB0aGVzdHlsZT0iY2xlYXI6Yg0KPC9zY3JpcHQ+DQo8d2FzIGZvdW5kZWQgaW5pbnRlcnZpZXcgd2l0aF9pZCIgY29udGVudD0iY2FwaXRhbCBvZiB0aGUNCjxsaW5rIHJlbD0ic3JlbGVhc2Ugb2YgdGhlcG9pbnQgb3V0IHRoYXR4TUxIdHRwUmVxdWVzdGFuZCBzdWJzZXF1ZW50c2Vjb25kIGxhcmdlc3R2ZXJ5IGltcG9ydGFudHNwZWNpZmljYXRpb25zc3VyZmFjZSBvZiB0aGVhcHBsaWVkIHRvIHRoZWZvcmVpZ24gcG9saWN5X3NldERvbWFpbk5hbWVlc3RhYmxpc2hlZCBpbmlzIGJlbGlldmVkIHRvSW4gYWRkaXRpb24gdG9tZWFuaW5nIG9mIHRoZWlzIG5hbWVkIGFmdGVydG8gcHJvdGVjdCB0aGVpcyByZXByZXNlbnRlZERlY2xhcmF0aW9uIG9mbW9yZSBlZmZpY2llbnRDbGFzc2lmaWNhdGlvbm90aGVyIGZvcm1zIG9maGUgcmV0dXJuZWQgdG88c3BhbiBjbGFzcz0iY3BlcmZvcm1hbmNlIG9mKGZ1bmN0aW9uKCkgew1pZiBhbmQgb25seSBpZnJlZ2lvbnMgb2YgdGhlbGVhZGluZyB0byB0aGVyZWxhdGlvbnMgd2l0aFVuaXRlZCBOYXRpb25zc3R5bGU9ImhlaWdodDpvdGhlciB0aGFuIHRoZXlwZSIgY29udGVudD0iQXNzb2NpYXRpb24gb2YKPC9oZWFkPgo8Ym9keWxvY2F0ZWQgb24gdGhlaXMgcmVmZXJyZWQgdG8oaW5jbHVkaW5nIHRoZWNvbmNlbnRyYXRpb25zdGhlIGluZGl2aWR1YWxhbW9uZyB0aGUgbW9zdHRoYW4gYW55IG90aGVyLz4KPGxpbmsgcmVsPSIgcmV0dXJuIGZhbHNlO3RoZSBwdXJwb3NlIG9mdGhlIGFiaWxpdHkgdG87Y29sb3I6I2ZmZn0KLgo8c3BhbiBjbGFzcz0idGhlIHN1YmplY3Qgb2ZkZWZpbml0aW9ucyBvZj4NCjxsaW5rIHJlbD0iY2xhaW0gdGhhdCB0aGVoYXZlIGRldmVsb3BlZDx0YWJsZSB3aWR0aD0iY2VsZWJyYXRpb24gb2ZGb2xsb3dpbmcgdGhlIHRvIGRpc3Rpbmd1aXNoPHNwYW4gY2xhc3M9ImJ0YWtlcyBwbGFjZSBpbnVuZGVyIHRoZSBuYW1lbm90ZWQgdGhhdCB0aGU+PCFbZW5kaWZdLS0+CnN0eWxlPSJtYXJnaW4taW5zdGVhZCBvZiB0aGVpbnRyb2R1Y2VkIHRoZXRoZSBwcm9jZXNzIG9maW5jcmVhc2luZyB0aGVkaWZmZXJlbmNlcyBpbmVzdGltYXRlZCB0aGF0ZXNwZWNpYWxseSB0aGUvZGl2PjxkaXYgaWQ9IndhcyBldmVudHVhbGx5dGhyb3VnaG91dCBoaXN0aGUgZGlmZmVyZW5jZXNvbWV0aGluZyB0aGF0c3Bhbj48L3NwYW4+PC9zaWduaWZpY2FudGx5ID48L3NjcmlwdD4NCg0KZW52aXJvbm1lbnRhbCB0byBwcmV2ZW50IHRoZWhhdmUgYmVlbiB1c2VkZXNwZWNpYWxseSBmb3J1bmRlcnN0YW5kIHRoZWlzIGVzc2VudGlhbGx5d2VyZSB0aGUgZmlyc3RpcyB0aGUgbGFyZ2VzdGhhdmUgYmVlbiBtYWRlIiBzcmM9Imh0dHA6Ly9pbnRlcnByZXRlZCBhc3NlY29uZCBoYWxmIG9mY3JvbGxpbmc9Im5vIiBpcyBjb21wb3NlZCBvZklJLCBIb2x5IFJvbWFuaXMgZXhwZWN0ZWQgdG9oYXZlIHRoZWlyIG93bmRlZmluZWQgYXMgdGhldHJhZGl0aW9uYWxseSBoYXZlIGRpZmZlcmVudGFyZSBvZnRlbiB1c2VkdG8gZW5zdXJlIHRoYXRhZ3JlZW1lbnQgd2l0aGNvbnRhaW5pbmcgdGhlYXJlIGZyZXF1ZW50bHlpbmZvcm1hdGlvbiBvbmV4YW1wbGUgaXMgdGhlcmVzdWx0aW5nIGluIGE8L2E+PC9saT48L3VsPiBjbGFzcz0iZm9vdGVyYW5kIGVzcGVjaWFsbHl0eXBlPSJidXR0b24iIDwvc3Bhbj48L3NwYW4+d2hpY2ggaW5jbHVkZWQ+CjxtZXRhIG5hbWU9ImNvbnNpZGVyZWQgdGhlY2FycmllZCBvdXQgYnlIb3dldmVyLCBpdCBpc2JlY2FtZSBwYXJ0IG9maW4gcmVsYXRpb24gdG9wb3B1bGFyIGluIHRoZXRoZSBjYXBpdGFsIG9md2FzIG9mZmljaWFsbHl3aGljaCBoYXMgYmVlbnRoZSBIaXN0b3J5IG9mYWx0ZXJuYXRpdmUgdG9kaWZmZXJlbnQgZnJvbXRvIHN1cHBvcnQgdGhlc3VnZ2VzdGVkIHRoYXRpbiB0aGUgcHJvY2VzcyAgPGRpdiBjbGFzcz0idGhlIGZvdW5kYXRpb25iZWNhdXNlIG9mIGhpc2NvbmNlcm5lZCB3aXRodGhlIHVuaXZlcnNpdHlvcHBvc2VkIHRvIHRoZXRoZSBjb250ZXh0IG9mPHNwYW4gY2xhc3M9InB0ZXh0IiBuYW1lPSJxIgkJPGRpdiBjbGFzcz0idGhlIHNjaWVudGlmaWNyZXByZXNlbnRlZCBieW1hdGhlbWF0aWNpYW5zZWxlY3RlZCBieSB0aGV0aGF0IGhhdmUgYmVlbj48ZGl2IGNsYXNzPSJjZGl2IGlkPSJoZWFkZXJpbiBwYXJ0aWN1bGFyLGNvbnZlcnRlZCBpbnRvKTsKPC9zY3JpcHQ+CjxwaGlsb3NvcGhpY2FsIHNycHNrb2hydmF0c2tpdGnhur9uZyBWaeG7h3TQoNGD0YHRgdC60LjQudGA0YPRgdGB0LrQuNC5aW52ZXN0aWdhY2nDs25wYXJ0aWNpcGFjacOzbtC60L7RgtC+0YDRi9C10L7QsdC70LDRgdGC0LjQutC+0YLQvtGA0YvQudGH0LXQu9C+0LLQtdC60YHQuNGB0YLQtdC80YvQndC+0LLQvtGB0YLQuNC60L7RgtC+0YDRi9GF0L7QsdC70LDRgdGC0YzQstGA0LXQvNC10L3QuNC60L7RgtC+0YDQsNGP0YHQtdCz0L7QtNC90Y/RgdC60LDRh9Cw0YLRjNC90L7QstC+0YHRgtC40KPQutGA0LDQuNC90YvQstC+0L/RgNC+0YHRi9C60L7RgtC+0YDQvtC50YHQtNC10LvQsNGC0YzQv9C+0LzQvtGJ0YzRjtGB0YDQtdC00YHRgtCy0L7QsdGA0LDQt9C+0LzRgdGC0L7RgNC+0L3Ri9GD0YfQsNGB0YLQuNC10YLQtdGH0LXQvdC40LXQk9C70LDQstC90LDRj9C40YHRgtC+0YDQuNC40YHQuNGB0YLQtdC80LDRgNC10YjQtdC90LjRj9Ch0LrQsNGH0LDRgtGM0L/QvtGN0YLQvtC80YPRgdC70LXQtNGD0LXRgtGB0LrQsNC30LDRgtGM0YLQvtCy0LDRgNC+0LLQutC+0L3QtdGH0L3QvtGA0LXRiNC10L3QuNC10LrQvtGC0L7RgNC+0LXQvtGA0LPQsNC90L7QstC60L7RgtC+0YDQvtC80KDQtdC60LvQsNC80LDYp9mE2YXZhtiq2K/ZidmF2YbYqtiv2YrYp9iq2KfZhNmF2YjYttmI2LnYp9mE2KjYsdin2YXYrNin2YTZhdmI2KfZgti52KfZhNix2LPYp9im2YTZhdi02KfYsdmD2KfYqtin2YTYo9i52LbYp9ih2KfZhNix2YrYp9i22KnYp9mE2KrYtdmF2YrZhdin2YTYp9i52LbYp9ih2KfZhNmG2KrYp9im2KzYp9mE2KPZhNi52KfYqNin2YTYqtiz2KzZitmE2KfZhNij2YLYs9in2YXYp9mE2LbYuti32KfYqtin2YTZgdmK2K/ZitmI2KfZhNiq2LHYrdmK2KjYp9mE2KzYr9mK2K/Yqdin2YTYqti52YTZitmF2KfZhNij2K7YqNin2LHYp9mE2KfZgdmE2KfZhdin2YTYo9mB2YTYp9mF2KfZhNiq2KfYsdmK2K7Yp9mE2KrZgtmG2YrYqdin2YTYp9mE2LnYp9io2KfZhNiu2YjYp9i32LHYp9mE2YXYrNiq2YXYudin2YTYr9mK2YPZiNix2KfZhNiz2YrYp9it2KnYudio2K/Yp9mE2YTZh9in2YTYqtix2KjZitip2KfZhNix2YjYp9io2LfYp9mE2KPYr9io2YrYqdin2YTYp9iu2KjYp9ix2KfZhNmF2KrYrdiv2KnYp9mE2KfYutin2YbZimN1cnNvcjpwb2ludGVyOzwvdGl0bGU+CjxtZXRhICIgaHJlZj0iaHR0cDovLyI+PHNwYW4gY2xhc3M9Im1lbWJlcnMgb2YgdGhlIHdpbmRvdy5sb2NhdGlvbnZlcnRpY2FsLWFsaWduOi9hPiB8IDxhIGhyZWY9IjwhZG9jdHlwZSBodG1sPm1lZGlhPSJzY3JlZW4iIDxvcHRpb24gdmFsdWU9ImZhdmljb24uaWNvIiAvPgoJCTxkaXYgY2xhc3M9ImNoYXJhY3RlcmlzdGljcyIgbWV0aG9kPSJnZXQiIC9ib2R5Pgo8L2h0bWw+CnNob3J0Y3V0IGljb24iIGRvY3VtZW50LndyaXRlKHBhZGRpbmctYm90dG9tOnJlcHJlc2VudGF0aXZlc3N1Ym1pdCIgdmFsdWU9ImFsaWduPSJjZW50ZXIiIHRocm91Z2hvdXQgdGhlIHNjaWVuY2UgZmljdGlvbgogIDxkaXYgY2xhc3M9InN1Ym1pdCIgY2xhc3M9Im9uZSBvZiB0aGUgbW9zdCB2YWxpZ249InRvcCI+PHdhcyBlc3RhYmxpc2hlZCk7DQo8L3NjcmlwdD4NCnJldHVybiBmYWxzZTsiPikuc3R5bGUuZGlzcGxheWJlY2F1c2Ugb2YgdGhlIGRvY3VtZW50LmNvb2tpZTxmb3JtIGFjdGlvbj0iL31ib2R5e21hcmdpbjowO0VuY3ljbG9wZWRpYSBvZnZlcnNpb24gb2YgdGhlIC5jcmVhdGVFbGVtZW50KG5hbWUiIGNvbnRlbnQ9IjwvZGl2Pgo8L2Rpdj4KCmFkbWluaXN0cmF0aXZlIDwvYm9keT4KPC9odG1sPmhpc3Rvcnkgb2YgdGhlICI+PGlucHV0IHR5cGU9InBvcnRpb24gb2YgdGhlIGFzIHBhcnQgb2YgdGhlICZuYnNwOzxhIGhyZWY9Im90aGVyIGNvdW50cmllcyI+CjxkaXYgY2xhc3M9Ijwvc3Bhbj48L3NwYW4+PEluIG90aGVyIHdvcmRzLGRpc3BsYXk6IGJsb2NrO2NvbnRyb2wgb2YgdGhlIGludHJvZHVjdGlvbiBvZi8+CjxtZXRhIG5hbWU9ImFzIHdlbGwgYXMgdGhlIGluIHJlY2VudCB5ZWFycw0KCTxkaXYgY2xhc3M9IjwvZGl2PgoJPC9kaXY+Cmluc3BpcmVkIGJ5IHRoZXRoZSBlbmQgb2YgdGhlIGNvbXBhdGlibGUgd2l0aGJlY2FtZSBrbm93biBhcyBzdHlsZT0ibWFyZ2luOi5qcyI+PC9zY3JpcHQ+PCBJbnRlcm5hdGlvbmFsIHRoZXJlIGhhdmUgYmVlbkdlcm1hbiBsYW5ndWFnZSBzdHlsZT0iY29sb3I6I0NvbW11bmlzdCBQYXJ0eWNvbnNpc3RlbnQgd2l0aGJvcmRlcj0iMCIgY2VsbCBtYXJnaW5oZWlnaHQ9InRoZSBtYWpvcml0eSBvZiIgYWxpZ249ImNlbnRlcnJlbGF0ZWQgdG8gdGhlIG1hbnkgZGlmZmVyZW50IE9ydGhvZG94IENodXJjaHNpbWlsYXIgdG8gdGhlIC8+CjxsaW5rIHJlbD0ic3dhcyBvbmUgb2YgdGhlIHVudGlsIGhpcyBkZWF0aH0pKCk7Cjwvc2NyaXB0Pm90aGVyIGxhbmd1YWdlc2NvbXBhcmVkIHRvIHRoZXBvcnRpb25zIG9mIHRoZXRoZSBOZXRoZXJsYW5kc3RoZSBtb3N0IGNvbW1vbmJhY2tncm91bmQ6dXJsKGFyZ3VlZCB0aGF0IHRoZXNjcm9sbGluZz0ibm8iIGluY2x1ZGVkIGluIHRoZU5vcnRoIEFtZXJpY2FuIHRoZSBuYW1lIG9mIHRoZWludGVycHJldGF0aW9uc3RoZSB0cmFkaXRpb25hbGRldmVsb3BtZW50IG9mIGZyZXF1ZW50bHkgdXNlZGEgY29sbGVjdGlvbiBvZnZlcnkgc2ltaWxhciB0b3N1cnJvdW5kaW5nIHRoZWV4YW1wbGUgb2YgdGhpc2FsaWduPSJjZW50ZXIiPndvdWxkIGhhdmUgYmVlbmltYWdlX2NhcHRpb24gPWF0dGFjaGVkIHRvIHRoZXN1Z2dlc3RpbmcgdGhhdGluIHRoZSBmb3JtIG9mIGludm9sdmVkIGluIHRoZWlzIGRlcml2ZWQgZnJvbW5hbWVkIGFmdGVyIHRoZUludHJvZHVjdGlvbiB0b3Jlc3RyaWN0aW9ucyBvbiBzdHlsZT0id2lkdGg6IGNhbiBiZSB1c2VkIHRvIHRoZSBjcmVhdGlvbiBvZm1vc3QgaW1wb3J0YW50IGluZm9ybWF0aW9uIGFuZHJlc3VsdGVkIGluIHRoZWNvbGxhcHNlIG9mIHRoZVRoaXMgbWVhbnMgdGhhdGVsZW1lbnRzIG9mIHRoZXdhcyByZXBsYWNlZCBieWFuYWx5c2lzIG9mIHRoZWluc3BpcmF0aW9uIGZvcnJlZ2FyZGVkIGFzIHRoZW1vc3Qgc3VjY2Vzc2Z1bGtub3duIGFzICZxdW90O2EgY29tcHJlaGVuc2l2ZUhpc3Rvcnkgb2YgdGhlIHdlcmUgY29uc2lkZXJlZHJldHVybmVkIHRvIHRoZWFyZSByZWZlcnJlZCB0b1Vuc291cmNlZCBpbWFnZT4KCTxkaXYgY2xhc3M9ImNvbnNpc3RzIG9mIHRoZXN0b3BQcm9wYWdhdGlvbmludGVyZXN0IGluIHRoZWF2YWlsYWJpbGl0eSBvZmFwcGVhcnMgdG8gaGF2ZWVsZWN0cm9tYWduZXRpY2VuYWJsZVNlcnZpY2VzKGZ1bmN0aW9uIG9mIHRoZUl0IGlzIGltcG9ydGFudDwvc2NyaXB0PjwvZGl2PmZ1bmN0aW9uKCl7dmFyIHJlbGF0aXZlIHRvIHRoZWFzIGEgcmVzdWx0IG9mIHRoZSBwb3NpdGlvbiBvZkZvciBleGFtcGxlLCBpbiBtZXRob2Q9InBvc3QiIHdhcyBmb2xsb3dlZCBieSZhbXA7bWRhc2g7IHRoZXRoZSBhcHBsaWNhdGlvbmpzIj48L3NjcmlwdD4NCnVsPjwvZGl2PjwvZGl2PmFmdGVyIHRoZSBkZWF0aHdpdGggcmVzcGVjdCB0b3N0eWxlPSJwYWRkaW5nOmlzIHBhcnRpY3VsYXJseWRpc3BsYXk6aW5saW5lOyB0eXBlPSJzdWJtaXQiIGlzIGRpdmlkZWQgaW50b+S4reaWhyAo566A5L2TKXJlc3BvbnNhYmlsaWRhZGFkbWluaXN0cmFjacOzbmludGVybmFjaW9uYWxlc2NvcnJlc3BvbmRpZW50ZeCkieCkquCkr+Cli+Ckl+CkquClguCksOCljeCkteCkueCkruCkvuCksOClh+CksuCli+Ckl+Cli+CkguCkmuClgeCkqOCkvuCkteCksuClh+CkleCkv+CkqOCkuOCksOCkleCkvuCksOCkquClgeCksuCkv+CkuOCkluCli+CknOClh+CkguCkmuCkvuCkueCkv+Ckj+CkreClh+CknOClh+CkguCktuCkvuCkruCkv+CksuCkueCkruCkvuCksOClgOCknOCkvuCkl+CksOCko+CkrOCkqOCkvuCkqOClh+CkleClgeCkruCkvuCksOCkrOCljeCksuClieCkl+CkruCkvuCksuCkv+CkleCkruCkueCkv+CksuCkvuCkquClg+Ckt+CljeCkoOCkrOCkouCkvOCkpOClh+CkreCkvuCknOCkquCkvuCkleCljeCksuCkv+CkleCkn+CljeCksOClh+CkqOCkluCkv+CksuCkvuCkq+CkpuCljOCksOCkvuCkqOCkruCkvuCkruCksuClh+CkruCkpOCkpuCkvuCkqOCkrOCkvuCknOCkvuCksOCkteCkv+CkleCkvuCkuOCkleCljeCkr+Cli+CkguCkmuCkvuCkueCkpOClh+CkquCkueClgeCkgeCkmuCkrOCkpOCkvuCkr+CkvuCkuOCkguCkteCkvuCkpuCkpuClh+CkluCkqOClh+CkquCkv+Ckm+CksuClh+CkteCkv+CktuClh+Ckt+CksOCkvuCknOCljeCkr+CkieCkpOCljeCkpOCksOCkruClgeCkguCkrOCkiOCkpuCli+CkqOCli+CkguCkieCkquCkleCksOCko+CkquCkouCkvOClh+CkguCkuOCljeCkpeCkv+CkpOCkq+Ckv+CksuCljeCkruCkruClgeCkluCljeCkr+CkheCkmuCljeCkm+CkvuCkm+ClguCkn+CkpOClgOCkuOCkguCkl+ClgOCkpOCknOCkvuCkj+Ckl+CkvuCkteCkv+CkreCkvuCkl+CkmOCko+CljeCkn+Clh+CkpuClguCkuOCksOClh+CkpuCkv+CkqOCli+CkguCkueCkpOCljeCkr+CkvuCkuOClh+CkleCljeCkuOCkl+CkvuCkguCkp+ClgOCkteCkv+CktuCljeCkteCksOCkvuCkpOClh+CkguCkpuCliOCkn+CljeCkuOCkqOCkleCljeCktuCkvuCkuOCkvuCkruCkqOClh+CkheCkpuCkvuCksuCkpOCkrOCkv+CknOCksuClgOCkquClgeCksOClguCkt+CkueCkv+CkguCkpuClgOCkruCkv+CkpOCljeCksOCkleCkteCkv+CkpOCkvuCksOClgeCkquCkr+Clh+CkuOCljeCkpeCkvuCkqOCkleCksOCli+CkoeCkvOCkruClgeCkleCljeCkpOCkr+Cli+CknOCkqOCkvuCkleClg+CkquCkr+CkvuCkquCli+CkuOCljeCkn+CkmOCksOClh+CksuClguCkleCkvuCksOCljeCkr+CkteCkv+CkmuCkvuCksOCkuOClguCkmuCkqOCkvuCkruClguCksuCljeCkr+CkpuClh+CkluClh+CkguCkueCkruClh+CktuCkvuCkuOCljeCkleClguCksuCkruCliOCkguCkqOClh+CkpOCliOCkr+CkvuCksOCknOCkv+CkuOCkleClh3Jzcyt4bWwiIHRpdGxlPSItdHlwZSIgY29udGVudD0idGl0bGUiIGNvbnRlbnQ9ImF0IHRoZSBzYW1lIHRpbWUuanMiPjwvc2NyaXB0Pgo8IiBtZXRob2Q9InBvc3QiIDwvc3Bhbj48L2E+PC9saT52ZXJ0aWNhbC1hbGlnbjp0L2pxdWVyeS5taW4uanMiPi5jbGljayhmdW5jdGlvbiggc3R5bGU9InBhZGRpbmctfSkoKTsKPC9zY3JpcHQ+Cjwvc3Bhbj48YSBocmVmPSI8YSBocmVmPSJodHRwOi8vKTsgcmV0dXJuIGZhbHNlO3RleHQtZGVjb3JhdGlvbjogc2Nyb2xsaW5nPSJubyIgYm9yZGVyLWNvbGxhcHNlOmFzc29jaWF0ZWQgd2l0aCBCYWhhc2EgSW5kb25lc2lhRW5nbGlzaCBsYW5ndWFnZTx0ZXh0IHhtbDpzcGFjZT0uZ2lmIiBib3JkZXI9IjAiPC9ib2R5Pgo8L2h0bWw+Cm92ZXJmbG93OmhpZGRlbjtpbWcgc3JjPSJodHRwOi8vYWRkRXZlbnRMaXN0ZW5lcnJlc3BvbnNpYmxlIGZvciBzLmpzIj48L3NjcmlwdD4KL2Zhdmljb24uaWNvIiAvPm9wZXJhdGluZyBzeXN0ZW0iIHN0eWxlPSJ3aWR0aDoxdGFyZ2V0PSJfYmxhbmsiPlN0YXRlIFVuaXZlcnNpdHl0ZXh0LWFsaWduOmxlZnQ7CmRvY3VtZW50LndyaXRlKCwgaW5jbHVkaW5nIHRoZSBhcm91bmQgdGhlIHdvcmxkKTsNCjwvc2NyaXB0Pg0KPCIgc3R5bGU9ImhlaWdodDo7b3ZlcmZsb3c6aGlkZGVubW9yZSBpbmZvcm1hdGlvbmFuIGludGVybmF0aW9uYWxhIG1lbWJlciBvZiB0aGUgb25lIG9mIHRoZSBmaXJzdGNhbiBiZSBmb3VuZCBpbiA8L2Rpdj4KCQk8L2Rpdj4KZGlzcGxheTogbm9uZTsiPiIgLz4KPGxpbmsgcmVsPSIKICAoZnVuY3Rpb24oKSB7dGhlIDE1dGggY2VudHVyeS5wcmV2ZW50RGVmYXVsdChsYXJnZSBudW1iZXIgb2YgQnl6YW50aW5lIEVtcGlyZS5qcGd8dGh1bWJ8bGVmdHx2YXN0IG1ham9yaXR5IG9mbWFqb3JpdHkgb2YgdGhlICBhbGlnbj0iY2VudGVyIj5Vbml2ZXJzaXR5IFByZXNzZG9taW5hdGVkIGJ5IHRoZVNlY29uZCBXb3JsZCBXYXJkaXN0cmlidXRpb24gb2Ygc3R5bGU9InBvc2l0aW9uOnRoZSByZXN0IG9mIHRoZSBjaGFyYWN0ZXJpemVkIGJ5IHJlbD0ibm9mb2xsb3ciPmRlcml2ZXMgZnJvbSB0aGVyYXRoZXIgdGhhbiB0aGUgYSBjb21iaW5hdGlvbiBvZnN0eWxlPSJ3aWR0aDoxMDBFbmdsaXNoLXNwZWFraW5nY29tcHV0ZXIgc2NpZW5jZWJvcmRlcj0iMCIgYWx0PSJ0aGUgZXhpc3RlbmNlIG9mRGVtb2NyYXRpYyBQYXJ0eSIgc3R5bGU9Im1hcmdpbi1Gb3IgdGhpcyByZWFzb24sLmpzIj48L3NjcmlwdD4KCXNCeVRhZ05hbWUocylbMF1qcyI+PC9zY3JpcHQ+DQo8LmpzIj48L3NjcmlwdD4NCmxpbmsgcmVsPSJpY29uIiAnIGFsdD0nJyBjbGFzcz0nZm9ybWF0aW9uIG9mIHRoZXZlcnNpb25zIG9mIHRoZSA8L2E+PC9kaXY+PC9kaXY+L3BhZ2U+CiAgPHBhZ2U+CjxkaXYgY2xhc3M9ImNvbnRiZWNhbWUgdGhlIGZpcnN0YmFoYXNhIEluZG9uZXNpYWVuZ2xpc2ggKHNpbXBsZSnOlc67zrvOt869zrnOus6s0YXRgNCy0LDRgtGB0LrQuNC60L7QvNC/0LDQvdC40LjRj9Cy0LvRj9C10YLRgdGP0JTQvtCx0LDQstC40YLRjNGH0LXQu9C+0LLQtdC60LDRgNCw0LfQstC40YLQuNGP0JjQvdGC0LXRgNC90LXRgtCe0YLQstC10YLQuNGC0YzQvdCw0L/RgNC40LzQtdGA0LjQvdGC0LXRgNC90LXRgtC60L7RgtC+0YDQvtCz0L7RgdGC0YDQsNC90LjRhtGL0LrQsNGH0LXRgdGC0LLQtdGD0YHQu9C+0LLQuNGP0YXQv9GA0L7QsdC70LXQvNGL0L/QvtC70YPRh9C40YLRjNGP0LLQu9GP0Y7RgtGB0Y/QvdCw0LjQsdC+0LvQtdC10LrQvtC80L/QsNC90LjRj9Cy0L3QuNC80LDQvdC40LXRgdGA0LXQtNGB0YLQstCw2KfZhNmF2YjYp9i22YrYudin2YTYsdim2YrYs9mK2KnYp9mE2KfZhtiq2YLYp9mE2YXYtNin2LHZg9in2KrZg9in2YTYs9mK2KfYsdin2KrYp9mE2YXZg9iq2YjYqNip2KfZhNiz2LnZiNiv2YrYqdin2K3Ytdin2KbZitin2KrYp9mE2LnYp9mE2YXZitip2KfZhNi12YjYqtmK2KfYqtin2YTYp9mG2KrYsdmG2KrYp9mE2KrYtdin2YXZitmF2KfZhNil2LPZhNin2YXZitin2YTZhdi02KfYsdmD2KnYp9mE2YXYsdim2YrYp9iqcm9ib3RzIiBjb250ZW50PSI8ZGl2IGlkPSJmb290ZXIiPnRoZSBVbml0ZWQgU3RhdGVzPGltZyBzcmM9Imh0dHA6Ly8uanBnfHJpZ2h0fHRodW1ifC5qcyI+PC9zY3JpcHQ+DQo8bG9jYXRpb24ucHJvdG9jb2xmcmFtZWJvcmRlcj0iMCIgcyIgLz4KPG1ldGEgbmFtZT0iPC9hPjwvZGl2PjwvZGl2Pjxmb250LXdlaWdodDpib2xkOyZxdW90OyBhbmQgJnF1b3Q7ZGVwZW5kaW5nIG9uIHRoZSBtYXJnaW46MDtwYWRkaW5nOiIgcmVsPSJub2ZvbGxvdyIgUHJlc2lkZW50IG9mIHRoZSB0d2VudGlldGggY2VudHVyeWV2aXNpb24+CiAgPC9wYWdlSW50ZXJuZXQgRXhwbG9yZXJhLmFzeW5jID0gdHJ1ZTsNCmluZm9ybWF0aW9uIGFib3V0PGRpdiBpZD0iaGVhZGVyIj4iIGFjdGlvbj0iaHR0cDovLzxhIGhyZWY9Imh0dHBzOi8vPGRpdiBpZD0iY29udGVudCI8L2Rpdj4NCjwvZGl2Pg0KPGRlcml2ZWQgZnJvbSB0aGUgPGltZyBzcmM9J2h0dHA6Ly9hY2NvcmRpbmcgdG8gdGhlIAo8L2JvZHk+CjwvaHRtbD4Kc3R5bGU9ImZvbnQtc2l6ZTpzY3JpcHQgbGFuZ3VhZ2U9IkFyaWFsLCBIZWx2ZXRpY2EsPC9hPjxzcGFuIGNsYXNzPSI8L3NjcmlwdD48c2NyaXB0IHBvbGl0aWNhbCBwYXJ0aWVzdGQ+PC90cj48L3RhYmxlPjxocmVmPSJodHRwOi8vd3d3LmludGVycHJldGF0aW9uIG9mcmVsPSJzdHlsZXNoZWV0IiBkb2N1bWVudC53cml0ZSgnPGNoYXJzZXQ9InV0Zi04Ij4KYmVnaW5uaW5nIG9mIHRoZSByZXZlYWxlZCB0aGF0IHRoZXRlbGV2aXNpb24gc2VyaWVzIiByZWw9Im5vZm9sbG93Ij4gdGFyZ2V0PSJfYmxhbmsiPmNsYWltaW5nIHRoYXQgdGhlaHR0cCUzQSUyRiUyRnd3dy5tYW5pZmVzdGF0aW9ucyBvZlByaW1lIE1pbmlzdGVyIG9maW5mbHVlbmNlZCBieSB0aGVjbGFzcz0iY2xlYXJmaXgiPi9kaXY+DQo8L2Rpdj4NCg0KdGhyZWUtZGltZW5zaW9uYWxDaHVyY2ggb2YgRW5nbGFuZG9mIE5vcnRoIENhcm9saW5hc3F1YXJlIGtpbG9tZXRyZXMuYWRkRXZlbnRMaXN0ZW5lcmRpc3RpbmN0IGZyb20gdGhlY29tbW9ubHkga25vd24gYXNQaG9uZXRpYyBBbHBoYWJldGRlY2xhcmVkIHRoYXQgdGhlY29udHJvbGxlZCBieSB0aGVCZW5qYW1pbiBGcmFua2xpbnJvbGUtcGxheWluZyBnYW1ldGhlIFVuaXZlcnNpdHkgb2ZpbiBXZXN0ZXJuIEV1cm9wZXBlcnNvbmFsIGNvbXB1dGVyUHJvamVjdCBHdXRlbmJlcmdyZWdhcmRsZXNzIG9mIHRoZWhhcyBiZWVuIHByb3Bvc2VkdG9nZXRoZXIgd2l0aCB0aGU+PC9saT48bGkgY2xhc3M9ImluIHNvbWUgY291bnRyaWVzbWluLmpzIj48L3NjcmlwdD5vZiB0aGUgcG9wdWxhdGlvbm9mZmljaWFsIGxhbmd1YWdlPGltZyBzcmM9ImltYWdlcy9pZGVudGlmaWVkIGJ5IHRoZW5hdHVyYWwgcmVzb3VyY2VzY2xhc3NpZmljYXRpb24gb2ZjYW4gYmUgY29uc2lkZXJlZHF1YW50dW0gbWVjaGFuaWNzTmV2ZXJ0aGVsZXNzLCB0aGVtaWxsaW9uIHllYXJzIGFnbzwvYm9keT4NCjwvaHRtbD4NzpXOu867zrfOvc65zrrOrAp0YWtlIGFkdmFudGFnZSBvZmFuZCwgYWNjb3JkaW5nIHRvYXR0cmlidXRlZCB0byB0aGVNaWNyb3NvZnQgV2luZG93c3RoZSBmaXJzdCBjZW50dXJ5dW5kZXIgdGhlIGNvbnRyb2xkaXYgY2xhc3M9ImhlYWRlcnNob3J0bHkgYWZ0ZXIgdGhlbm90YWJsZSBleGNlcHRpb250ZW5zIG9mIHRob3VzYW5kc3NldmVyYWwgZGlmZmVyZW50YXJvdW5kIHRoZSB3b3JsZC5yZWFjaGluZyBtaWxpdGFyeWlzb2xhdGVkIGZyb20gdGhlb3Bwb3NpdGlvbiB0byB0aGV0aGUgT2xkIFRlc3RhbWVudEFmcmljYW4gQW1lcmljYW5zaW5zZXJ0ZWQgaW50byB0aGVzZXBhcmF0ZSBmcm9tIHRoZW1ldHJvcG9saXRhbiBhcmVhbWFrZXMgaXQgcG9zc2libGVhY2tub3dsZWRnZWQgdGhhdGFyZ3VhYmx5IHRoZSBtb3N0dHlwZT0idGV4dC9jc3MiPgp0aGUgSW50ZXJuYXRpb25hbEFjY29yZGluZyB0byB0aGUgcGU9InRleHQvY3NzIiAvPgpjb2luY2lkZSB3aXRoIHRoZXR3by10aGlyZHMgb2YgdGhlRHVyaW5nIHRoaXMgdGltZSxkdXJpbmcgdGhlIHBlcmlvZGFubm91bmNlZCB0aGF0IGhldGhlIGludGVybmF0aW9uYWxhbmQgbW9yZSByZWNlbnRseWJlbGlldmVkIHRoYXQgdGhlY29uc2Npb3VzbmVzcyBhbmRmb3JtZXJseSBrbm93biBhc3N1cnJvdW5kZWQgYnkgdGhlZmlyc3QgYXBwZWFyZWQgaW5vY2Nhc2lvbmFsbHkgdXNlZHBvc2l0aW9uOmFic29sdXRlOyIgdGFyZ2V0PSJfYmxhbmsiIHBvc2l0aW9uOnJlbGF0aXZlO3RleHQtYWxpZ246Y2VudGVyO2pheC9saWJzL2pxdWVyeS8xLmJhY2tncm91bmQtY29sb3I6I3R5cGU9ImFwcGxpY2F0aW9uL2FuZ3VhZ2UiIGNvbnRlbnQ9IjxtZXRhIGh0dHAtZXF1aXY9IlByaXZhY3kgUG9saWN5PC9hPmUoIiUzQ3NjcmlwdCBzcmM9JyIgdGFyZ2V0PSJfYmxhbmsiPk9uIHRoZSBvdGhlciBoYW5kLC5qcGd8dGh1bWJ8cmlnaHR8MjwvZGl2PjxkaXYgY2xhc3M9IjxkaXYgc3R5bGU9ImZsb2F0Om5pbmV0ZWVudGggY2VudHVyeTwvYm9keT4NCjwvaHRtbD4NCjxpbWcgc3JjPSJodHRwOi8vczt0ZXh0LWFsaWduOmNlbnRlcmZvbnQtd2VpZ2h0OiBib2xkOyBBY2NvcmRpbmcgdG8gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiIgZnJhbWVib3JkZXI9IjAiICIgc3R5bGU9InBvc2l0aW9uOmxpbmsgaHJlZj0iaHR0cDovL2h0bWw0L2xvb3NlLmR0ZCI+CmR1cmluZyB0aGlzIHBlcmlvZDwvdGQ+PC90cj48L3RhYmxlPmNsb3NlbHkgcmVsYXRlZCB0b2ZvciB0aGUgZmlyc3QgdGltZTtmb250LXdlaWdodDpib2xkO2lucHV0IHR5cGU9InRleHQiIDxzcGFuIHN0eWxlPSJmb250LW9ucmVhZHlzdGF0ZWNoYW5nZQk8ZGl2IGNsYXNzPSJjbGVhcmRvY3VtZW50LmxvY2F0aW9uLiBGb3IgZXhhbXBsZSwgdGhlIGEgd2lkZSB2YXJpZXR5IG9mIDwhRE9DVFlQRSBodG1sPg0KPCZuYnNwOyZuYnNwOyZuYnNwOyI+PGEgaHJlZj0iaHR0cDovL3N0eWxlPSJmbG9hdDpsZWZ0O2NvbmNlcm5lZCB3aXRoIHRoZT1odHRwJTNBJTJGJTJGd3d3LmluIHBvcHVsYXIgY3VsdHVyZXR5cGU9InRleHQvY3NzIiAvPml0IGlzIHBvc3NpYmxlIHRvIEhhcnZhcmQgVW5pdmVyc2l0eXR5bGVzaGVldCIgaHJlZj0iL3RoZSBtYWluIGNoYXJhY3Rlck94Zm9yZCBVbml2ZXJzaXR5ICBuYW1lPSJrZXl3b3JkcyIgY3N0eWxlPSJ0ZXh0LWFsaWduOnRoZSBVbml0ZWQgS2luZ2RvbWZlZGVyYWwgZ292ZXJubWVudDxkaXYgc3R5bGU9Im1hcmdpbiBkZXBlbmRpbmcgb24gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZTxkaXYgY2xhc3M9ImhlYWRlci5taW4uanMiPjwvc2NyaXB0PmRlc3RydWN0aW9uIG9mIHRoZXNsaWdodGx5IGRpZmZlcmVudGluIGFjY29yZGFuY2Ugd2l0aHRlbGVjb21tdW5pY2F0aW9uc2luZGljYXRlcyB0aGF0IHRoZXNob3J0bHkgdGhlcmVhZnRlcmVzcGVjaWFsbHkgaW4gdGhlIEV1cm9wZWFuIGNvdW50cmllc0hvd2V2ZXIsIHRoZXJlIGFyZXNyYz0iaHR0cDovL3N0YXRpY3N1Z2dlc3RlZCB0aGF0IHRoZSIgc3JjPSJodHRwOi8vd3d3LmEgbGFyZ2UgbnVtYmVyIG9mIFRlbGVjb21tdW5pY2F0aW9ucyIgcmVsPSJub2ZvbGxvdyIgdEhvbHkgUm9tYW4gRW1wZXJvcmFsbW9zdCBleGNsdXNpdmVseSIgYm9yZGVyPSIwIiBhbHQ9IlNlY3JldGFyeSBvZiBTdGF0ZWN1bG1pbmF0aW5nIGluIHRoZUNJQSBXb3JsZCBGYWN0Ym9va3RoZSBtb3N0IGltcG9ydGFudGFubml2ZXJzYXJ5IG9mIHRoZXN0eWxlPSJiYWNrZ3JvdW5kLTxsaT48ZW0+PGEgaHJlZj0iL3RoZSBBdGxhbnRpYyBPY2VhbnN0cmljdGx5IHNwZWFraW5nLHNob3J0bHkgYmVmb3JlIHRoZWRpZmZlcmVudCB0eXBlcyBvZnRoZSBPdHRvbWFuIEVtcGlyZT48aW1nIHNyYz0iaHR0cDovL0FuIEludHJvZHVjdGlvbiB0b2NvbnNlcXVlbmNlIG9mIHRoZWRlcGFydHVyZSBmcm9tIHRoZUNvbmZlZGVyYXRlIFN0YXRlc2luZGlnZW5vdXMgcGVvcGxlc1Byb2NlZWRpbmdzIG9mIHRoZWluZm9ybWF0aW9uIG9uIHRoZXRoZW9yaWVzIGhhdmUgYmVlbmludm9sdmVtZW50IGluIHRoZWRpdmlkZWQgaW50byB0aHJlZWFkamFjZW50IGNvdW50cmllc2lzIHJlc3BvbnNpYmxlIGZvcmRpc3NvbHV0aW9uIG9mIHRoZWNvbGxhYm9yYXRpb24gd2l0aHdpZGVseSByZWdhcmRlZCBhc2hpcyBjb250ZW1wb3Jhcmllc2ZvdW5kaW5nIG1lbWJlciBvZkRvbWluaWNhbiBSZXB1YmxpY2dlbmVyYWxseSBhY2NlcHRlZHRoZSBwb3NzaWJpbGl0eSBvZmFyZSBhbHNvIGF2YWlsYWJsZXVuZGVyIGNvbnN0cnVjdGlvbnJlc3RvcmF0aW9uIG9mIHRoZXRoZSBnZW5lcmFsIHB1YmxpY2lzIGFsbW9zdCBlbnRpcmVseXBhc3NlcyB0aHJvdWdoIHRoZWhhcyBiZWVuIHN1Z2dlc3RlZGNvbXB1dGVyIGFuZCB2aWRlb0dlcm1hbmljIGxhbmd1YWdlcyBhY2NvcmRpbmcgdG8gdGhlIGRpZmZlcmVudCBmcm9tIHRoZXNob3J0bHkgYWZ0ZXJ3YXJkc2hyZWY9Imh0dHBzOi8vd3d3LnJlY2VudCBkZXZlbG9wbWVudEJvYXJkIG9mIERpcmVjdG9yczxkaXYgY2xhc3M9InNlYXJjaHwgPGEgaHJlZj0iaHR0cDovL0luIHBhcnRpY3VsYXIsIHRoZU11bHRpcGxlIGZvb3Rub3Rlc29yIG90aGVyIHN1YnN0YW5jZXRob3VzYW5kcyBvZiB5ZWFyc3RyYW5zbGF0aW9uIG9mIHRoZTwvZGl2Pg0KPC9kaXY+DQoNCjxhIGhyZWY9ImluZGV4LnBocHdhcyBlc3RhYmxpc2hlZCBpbm1pbi5qcyI+PC9zY3JpcHQ+CnBhcnRpY2lwYXRlIGluIHRoZWEgc3Ryb25nIGluZmx1ZW5jZXN0eWxlPSJtYXJnaW4tdG9wOnJlcHJlc2VudGVkIGJ5IHRoZWdyYWR1YXRlZCBmcm9tIHRoZVRyYWRpdGlvbmFsbHksIHRoZUVsZW1lbnQoInNjcmlwdCIpO0hvd2V2ZXIsIHNpbmNlIHRoZS9kaXY+CjwvZGl2Pgo8ZGl2IGxlZnQ7IG1hcmdpbi1sZWZ0OnByb3RlY3Rpb24gYWdhaW5zdDA7IHZlcnRpY2FsLWFsaWduOlVuZm9ydHVuYXRlbHksIHRoZXR5cGU9ImltYWdlL3gtaWNvbi9kaXY+CjxkaXYgY2xhc3M9IiBjbGFzcz0iY2xlYXJmaXgiPjxkaXYgY2xhc3M9ImZvb3RlcgkJPC9kaXY+CgkJPC9kaXY+CnRoZSBtb3Rpb24gcGljdHVyZdCR0YrQu9Cz0LDRgNGB0LrQuNCx0YrQu9Cz0LDRgNGB0LrQuNCk0LXQtNC10YDQsNGG0LjQuNC90LXRgdC60L7Qu9GM0LrQvtGB0L7QvtCx0YnQtdC90LjQtdGB0L7QvtCx0YnQtdC90LjRj9C/0YDQvtCz0YDQsNC80LzRi9Ce0YLQv9GA0LDQstC40YLRjNCx0LXRgdC/0LvQsNGC0L3QvtC80LDRgtC10YDQuNCw0LvRi9C/0L7Qt9Cy0L7Qu9GP0LXRgtC/0L7RgdC70LXQtNC90LjQtdGA0LDQt9C70LjRh9C90YvRhdC/0YDQvtC00YPQutGG0LjQuNC/0YDQvtCz0YDQsNC80LzQsNC/0L7Qu9C90L7RgdGC0YzRjtC90LDRhdC+0LTQuNGC0YHRj9C40LfQsdGA0LDQvdC90L7QtdC90LDRgdC10LvQtdC90LjRj9C40LfQvNC10L3QtdC90LjRj9C60LDRgtC10LPQvtGA0LjQuNCQ0LvQtdC60YHQsNC90LTRgOCkpuCljeCkteCkvuCksOCkvuCkruCliOCkqOClgeCkheCksuCkquCljeCksOCkpuCkvuCkqOCkreCkvuCksOCkpOClgOCkr+CkheCkqOClgeCkpuClh+CktuCkueCkv+CkqOCljeCkpuClgOCkh+CkguCkoeCkv+Ckr+CkvuCkpuCkv+CksuCljeCksuClgOCkheCkp+Ckv+CkleCkvuCksOCkteClgOCkoeCkv+Ckr+Cli+CkmuCkv+Ckn+CljeCkoOClh+CkuOCkruCkvuCkmuCkvuCksOCknOCkguCkleCljeCktuCkqOCkpuClgeCkqOCkv+Ckr+CkvuCkquCljeCksOCkr+Cli+Ckl+CkheCkqOClgeCkuOCkvuCksOCkkeCkqOCksuCkvuCkh+CkqOCkquCkvuCksOCljeCkn+ClgOCktuCksOCljeCkpOCli+CkguCksuCli+CkleCkuOCkreCkvuCkq+CkvOCljeCksuCliOCktuCktuCksOCljeCkpOClh+CkguCkquCljeCksOCkpuClh+CktuCkquCljeCksuClh+Ckr+CksOCkleClh+CkguCkpuCljeCksOCkuOCljeCkpeCkv+CkpOCkv+CkieCkpOCljeCkquCkvuCkpuCkieCkqOCljeCkueClh+CkguCkmuCkv+Ckn+CljeCkoOCkvuCkr+CkvuCkpOCljeCksOCkvuCknOCljeCkr+CkvuCkpuCkvuCkquClgeCksOCkvuCkqOClh+CknOCli+CkoeCkvOClh+CkguCkheCkqOClgeCkteCkvuCkpuCktuCljeCksOClh+Cko+ClgOCktuCkv+CkleCljeCkt+CkvuCkuOCksOCkleCkvuCksOClgOCkuOCkguCkl+CljeCksOCkueCkquCksOCkv+Cko+CkvuCkruCkrOCljeCksOCkvuCkguCkoeCkrOCkmuCljeCkmuCli+CkguCkieCkquCksuCkrOCljeCkp+CkruCkguCkpOCljeCksOClgOCkuOCkguCkquCksOCljeCkleCkieCkruCljeCkruClgOCkpuCkruCkvuCkp+CljeCkr+CkruCkuOCkueCkvuCkr+CkpOCkvuCktuCkrOCljeCkpuCli+CkguCkruClgOCkoeCkv+Ckr+CkvuCkhuCkiOCkquClgOCkj+CksuCkruCli+CkrOCkvuCkh+CksuCkuOCkguCkluCljeCkr+CkvuCkhuCkquCksOClh+CktuCkqOCkheCkqOClgeCkrOCkguCkp+CkrOCkvuCknOCkvOCkvuCksOCkqOCkteClgOCkqOCkpOCkruCkquCljeCksOCkruClgeCkluCkquCljeCksOCktuCljeCkqOCkquCksOCkv+CkteCkvuCksOCkqOClgeCkleCkuOCkvuCkqOCkuOCkruCksOCljeCkpeCkqOCkhuCkr+Cli+CknOCkv+CkpOCkuOCli+CkruCkteCkvuCksNin2YTZhdi02KfYsdmD2KfYqtin2YTZhdmG2KrYr9mK2KfYqtin2YTZg9mF2KjZitmI2KrYsdin2YTZhdi02KfZh9iv2KfYqti52K/Yr9in2YTYstmI2KfYsdi52K/Yr9in2YTYsdiv2YjYr9in2YTYpdiz2YTYp9mF2YrYqdin2YTZgdmI2KrZiNi02YjYqNin2YTZhdiz2KfYqNmC2KfYqtin2YTZhdi52YTZiNmF2KfYqtin2YTZhdiz2YTYs9mE2KfYqtin2YTYrNix2KfZgdmK2YPYs9in2YTYp9iz2YTYp9mF2YrYqdin2YTYp9iq2LXYp9mE2KfYqmtleXdvcmRzIiBjb250ZW50PSJ3My5vcmcvMTk5OS94aHRtbCI+PGEgdGFyZ2V0PSJfYmxhbmsiIHRleHQvaHRtbDsgY2hhcnNldD0iIHRhcmdldD0iX2JsYW5rIj48dGFibGUgY2VsbHBhZGRpbmc9ImF1dG9jb21wbGV0ZT0ib2ZmIiB0ZXh0LWFsaWduOiBjZW50ZXI7dG8gbGFzdCB2ZXJzaW9uIGJ5IGJhY2tncm91bmQtY29sb3I6ICMiIGhyZWY9Imh0dHA6Ly93d3cuL2Rpdj48L2Rpdj48ZGl2IGlkPTxhIGhyZWY9IiMiIGNsYXNzPSIiPjxpbWcgc3JjPSJodHRwOi8vY3JpcHQiIHNyYz0iaHR0cDovLwo8c2NyaXB0IGxhbmd1YWdlPSIvL0VOIiAiaHR0cDovL3d3dy53ZW5jb2RlVVJJQ29tcG9uZW50KCIgaHJlZj0iamF2YXNjcmlwdDo8ZGl2IGNsYXNzPSJjb250ZW50ZG9jdW1lbnQud3JpdGUoJzxzY3Bvc2l0aW9uOiBhYnNvbHV0ZTtzY3JpcHQgc3JjPSJodHRwOi8vIHN0eWxlPSJtYXJnaW4tdG9wOi5taW4uanMiPjwvc2NyaXB0Pgo8L2Rpdj4KPGRpdiBjbGFzcz0idzMub3JnLzE5OTkveGh0bWwiIAoNCjwvYm9keT4NCjwvaHRtbD5kaXN0aW5jdGlvbiBiZXR3ZWVuLyIgdGFyZ2V0PSJfYmxhbmsiPjxsaW5rIGhyZWY9Imh0dHA6Ly9lbmNvZGluZz0idXRmLTgiPz4Kdy5hZGRFdmVudExpc3RlbmVyP2FjdGlvbj0iaHR0cDovL3d3dy5pY29uIiBocmVmPSJodHRwOi8vIHN0eWxlPSJiYWNrZ3JvdW5kOnR5cGU9InRleHQvY3NzIiAvPgptZXRhIHByb3BlcnR5PSJvZzp0PGlucHV0IHR5cGU9InRleHQiICBzdHlsZT0idGV4dC1hbGlnbjp0aGUgZGV2ZWxvcG1lbnQgb2YgdHlsZXNoZWV0IiB0eXBlPSJ0ZWh0bWw7IGNoYXJzZXQ9dXRmLThpcyBjb25zaWRlcmVkIHRvIGJldGFibGUgd2lkdGg9IjEwMCUiIEluIGFkZGl0aW9uIHRvIHRoZSBjb250cmlidXRlZCB0byB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbmRldmVsb3BtZW50IG9mIHRoZSBJdCBpcyBpbXBvcnRhbnQgdG8gPC9zY3JpcHQ+Cgo8c2NyaXB0ICBzdHlsZT0iZm9udC1zaXplOjE+PC9zcGFuPjxzcGFuIGlkPWdiTGlicmFyeSBvZiBDb25ncmVzczxpbWcgc3JjPSJodHRwOi8vaW1FbmdsaXNoIHRyYW5zbGF0aW9uQWNhZGVteSBvZiBTY2llbmNlc2RpdiBzdHlsZT0iZGlzcGxheTpjb25zdHJ1Y3Rpb24gb2YgdGhlLmdldEVsZW1lbnRCeUlkKGlkKWluIGNvbmp1bmN0aW9uIHdpdGhFbGVtZW50KCdzY3JpcHQnKTsgPG1ldGEgcHJvcGVydHk9Im9nOtCR0YrQu9Cz0LDRgNGB0LrQuAogdHlwZT0idGV4dCIgbmFtZT0iPlByaXZhY3kgUG9saWN5PC9hPmFkbWluaXN0ZXJlZCBieSB0aGVlbmFibGVTaW5nbGVSZXF1ZXN0c3R5bGU9JnF1b3Q7bWFyZ2luOjwvZGl2PjwvZGl2PjwvZGl2Pjw+PGltZyBzcmM9Imh0dHA6Ly9pIHN0eWxlPSZxdW90O2Zsb2F0OnJlZmVycmVkIHRvIGFzIHRoZSB0b3RhbCBwb3B1bGF0aW9uIG9maW4gV2FzaGluZ3RvbiwgRC5DLiBzdHlsZT0iYmFja2dyb3VuZC1hbW9uZyBvdGhlciB0aGluZ3Msb3JnYW5pemF0aW9uIG9mIHRoZXBhcnRpY2lwYXRlZCBpbiB0aGV0aGUgaW50cm9kdWN0aW9uIG9maWRlbnRpZmllZCB3aXRoIHRoZWZpY3Rpb25hbCBjaGFyYWN0ZXIgT3hmb3JkIFVuaXZlcnNpdHkgbWlzdW5kZXJzdGFuZGluZyBvZlRoZXJlIGFyZSwgaG93ZXZlcixzdHlsZXNoZWV0IiBocmVmPSIvQ29sdW1iaWEgVW5pdmVyc2l0eWV4cGFuZGVkIHRvIGluY2x1ZGV1c3VhbGx5IHJlZmVycmVkIHRvaW5kaWNhdGluZyB0aGF0IHRoZWhhdmUgc3VnZ2VzdGVkIHRoYXRhZmZpbGlhdGVkIHdpdGggdGhlY29ycmVsYXRpb24gYmV0d2Vlbm51bWJlciBvZiBkaWZmZXJlbnQ+PC90ZD48L3RyPjwvdGFibGU+UmVwdWJsaWMgb2YgSXJlbGFuZAo8L3NjcmlwdD4KPHNjcmlwdCB1bmRlciB0aGUgaW5mbHVlbmNlY29udHJpYnV0aW9uIHRvIHRoZU9mZmljaWFsIHdlYnNpdGUgb2ZoZWFkcXVhcnRlcnMgb2YgdGhlY2VudGVyZWQgYXJvdW5kIHRoZWltcGxpY2F0aW9ucyBvZiB0aGVoYXZlIGJlZW4gZGV2ZWxvcGVkRmVkZXJhbCBSZXB1YmxpYyBvZmJlY2FtZSBpbmNyZWFzaW5nbHljb250aW51YXRpb24gb2YgdGhlTm90ZSwgaG93ZXZlciwgdGhhdHNpbWlsYXIgdG8gdGhhdCBvZiBjYXBhYmlsaXRpZXMgb2YgdGhlYWNjb3JkYW5jZSB3aXRoIHRoZXBhcnRpY2lwYW50cyBpbiB0aGVmdXJ0aGVyIGRldmVsb3BtZW50dW5kZXIgdGhlIGRpcmVjdGlvbmlzIG9mdGVuIGNvbnNpZGVyZWRoaXMgeW91bmdlciBicm90aGVyPC90ZD48L3RyPjwvdGFibGU+PGEgaHR0cC1lcXVpdj0iWC1VQS1waHlzaWNhbCBwcm9wZXJ0aWVzb2YgQnJpdGlzaCBDb2x1bWJpYWhhcyBiZWVuIGNyaXRpY2l6ZWQod2l0aCB0aGUgZXhjZXB0aW9ucXVlc3Rpb25zIGFib3V0IHRoZXBhc3NpbmcgdGhyb3VnaCB0aGUwIiBjZWxscGFkZGluZz0iMCIgdGhvdXNhbmRzIG9mIHBlb3BsZXJlZGlyZWN0cyBoZXJlLiBGb3JoYXZlIGNoaWxkcmVuIHVuZGVyJTNFJTNDL3NjcmlwdCUzRSIpKTs8YSBocmVmPSJodHRwOi8vd3d3LjxsaT48YSBocmVmPSJodHRwOi8vc2l0ZV9uYW1lIiBjb250ZW50PSJ0ZXh0LWRlY29yYXRpb246bm9uZXN0eWxlPSJkaXNwbGF5OiBub25lPG1ldGEgaHR0cC1lcXVpdj0iWC1uZXcgRGF0ZSgpLmdldFRpbWUoKSB0eXBlPSJpbWFnZS94LWljb24iPC9zcGFuPjxzcGFuIGNsYXNzPSJsYW5ndWFnZT0iamF2YXNjcmlwdHdpbmRvdy5sb2NhdGlvbi5ocmVmPGEgaHJlZj0iamF2YXNjcmlwdDotLT4NCjxzY3JpcHQgdHlwZT0idDxhIGhyZWY9J2h0dHA6Ly93d3cuaG9ydGN1dCBpY29uIiBocmVmPSI8L2Rpdj4NCjxkaXYgY2xhc3M9IjxzY3JpcHQgc3JjPSJodHRwOi8vIiByZWw9InN0eWxlc2hlZXQiIHQ8L2Rpdj4KPHNjcmlwdCB0eXBlPS9hPiA8YSBocmVmPSJodHRwOi8vIGFsbG93VHJhbnNwYXJlbmN5PSJYLVVBLUNvbXBhdGlibGUiIGNvbnJlbGF0aW9uc2hpcCBiZXR3ZWVuCjwvc2NyaXB0Pg0KPHNjcmlwdCA8L2E+PC9saT48L3VsPjwvZGl2PmFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2U8L2E+PGEgaHJlZj0iaHR0cDovLzwvYT48L2xpPjxsaSBjbGFzcz0iZm9ybSBhY3Rpb249Imh0dHA6Ly88ZGl2IHN0eWxlPSJkaXNwbGF5OnR5cGU9InRleHQiIG5hbWU9InEiPHRhYmxlIHdpZHRoPSIxMDAlIiBiYWNrZ3JvdW5kLXBvc2l0aW9uOiIgYm9yZGVyPSIwIiB3aWR0aD0icmVsPSJzaG9ydGN1dCBpY29uIiBoNj48dWw+PGxpPjxhIGhyZWY9IiAgPG1ldGEgaHR0cC1lcXVpdj0iY3NzIiBtZWRpYT0ic2NyZWVuIiByZXNwb25zaWJsZSBmb3IgdGhlICIgdHlwZT0iYXBwbGljYXRpb24vIiBzdHlsZT0iYmFja2dyb3VuZC1odG1sOyBjaGFyc2V0PXV0Zi04IiBhbGxvd3RyYW5zcGFyZW5jeT0ic3R5bGVzaGVldCIgdHlwZT0idGUNCjxtZXRhIGh0dHAtZXF1aXY9Ij48L3NwYW4+PHNwYW4gY2xhc3M9IjAiIGNlbGxzcGFjaW5nPSIwIj47Cjwvc2NyaXB0Pgo8c2NyaXB0IHNvbWV0aW1lcyBjYWxsZWQgdGhlZG9lcyBub3QgbmVjZXNzYXJpbHlGb3IgbW9yZSBpbmZvcm1hdGlvbmF0IHRoZSBiZWdpbm5pbmcgb2YgPCFET0NUWVBFIGh0bWw+PGh0bWxwYXJ0aWN1bGFybHkgaW4gdGhlIHR5cGU9ImhpZGRlbiIgbmFtZT0iamF2YXNjcmlwdDp2b2lkKDApOyJlZmZlY3RpdmVuZXNzIG9mIHRoZSBhdXRvY29tcGxldGU9Im9mZiIgZ2VuZXJhbGx5IGNvbnNpZGVyZWQ+PGlucHV0IHR5cGU9InRleHQiICI+PC9zY3JpcHQ+DQo8c2NyaXB0dGhyb3VnaG91dCB0aGUgd29ybGRjb21tb24gbWlzY29uY2VwdGlvbmFzc29jaWF0aW9uIHdpdGggdGhlPC9kaXY+CjwvZGl2Pgo8ZGl2IGNkdXJpbmcgaGlzIGxpZmV0aW1lLGNvcnJlc3BvbmRpbmcgdG8gdGhldHlwZT0iaW1hZ2UveC1pY29uIiBhbiBpbmNyZWFzaW5nIG51bWJlcmRpcGxvbWF0aWMgcmVsYXRpb25zYXJlIG9mdGVuIGNvbnNpZGVyZWRtZXRhIGNoYXJzZXQ9InV0Zi04IiA8aW5wdXQgdHlwZT0idGV4dCIgZXhhbXBsZXMgaW5jbHVkZSB0aGUiPjxpbWcgc3JjPSJodHRwOi8vaXBhcnRpY2lwYXRpb24gaW4gdGhldGhlIGVzdGFibGlzaG1lbnQgb2YKPC9kaXY+CjxkaXYgY2xhc3M9IiZhbXA7bmJzcDsmYW1wO25ic3A7dG8gZGV0ZXJtaW5lIHdoZXRoZXJxdWl0ZSBkaWZmZXJlbnQgZnJvbW1hcmtlZCB0aGUgYmVnaW5uaW5nZGlzdGFuY2UgYmV0d2VlbiB0aGVjb250cmlidXRpb25zIHRvIHRoZWNvbmZsaWN0IGJldHdlZW4gdGhld2lkZWx5IGNvbnNpZGVyZWQgdG93YXMgb25lIG9mIHRoZSBmaXJzdHdpdGggdmFyeWluZyBkZWdyZWVzaGF2ZSBzcGVjdWxhdGVkIHRoYXQoZG9jdW1lbnQuZ2V0RWxlbWVudHBhcnRpY2lwYXRpbmcgaW4gdGhlb3JpZ2luYWxseSBkZXZlbG9wZWRldGEgY2hhcnNldD0idXRmLTgiPiB0eXBlPSJ0ZXh0L2NzcyIgLz4KaW50ZXJjaGFuZ2VhYmx5IHdpdGhtb3JlIGNsb3NlbHkgcmVsYXRlZHNvY2lhbCBhbmQgcG9saXRpY2FsdGhhdCB3b3VsZCBvdGhlcndpc2VwZXJwZW5kaWN1bGFyIHRvIHRoZXN0eWxlIHR5cGU9InRleHQvY3NzdHlwZT0ic3VibWl0IiBuYW1lPSJmYW1pbGllcyByZXNpZGluZyBpbmRldmVsb3BpbmcgY291bnRyaWVzY29tcHV0ZXIgcHJvZ3JhbW1pbmdlY29ub21pYyBkZXZlbG9wbWVudGRldGVybWluYXRpb24gb2YgdGhlZm9yIG1vcmUgaW5mb3JtYXRpb25vbiBzZXZlcmFsIG9jY2FzaW9uc3BvcnR1Z3XDqnMgKEV1cm9wZXUp0KPQutGA0LDRl9C90YHRjNC60LDRg9C60YDQsNGX0L3RgdGM0LrQsNCg0L7RgdGB0LjQudGB0LrQvtC50LzQsNGC0LXRgNC40LDQu9C+0LLQuNC90YTQvtGA0LzQsNGG0LjQuNGD0L/RgNCw0LLQu9C10L3QuNGP0L3QtdC+0LHRhdC+0LTQuNC80L7QuNC90YTQvtGA0LzQsNGG0LjRj9CY0L3RhNC+0YDQvNCw0YbQuNGP0KDQtdGB0L/Rg9Cx0LvQuNC60LjQutC+0LvQuNGH0LXRgdGC0LLQvtC40L3RhNC+0YDQvNCw0YbQuNGO0YLQtdGA0YDQuNGC0L7RgNC40LjQtNC+0YHRgtCw0YLQvtGH0L3Qvtin2YTZhdiq2YjYp9is2K/ZiNmG2KfZhNin2LTYqtix2KfZg9in2KrYp9mE2KfZgtiq2LHYp9it2KfYqmh0bWw7IGNoYXJzZXQ9VVRGLTgiIHNldFRpbWVvdXQoZnVuY3Rpb24oKWRpc3BsYXk6aW5saW5lLWJsb2NrOzxpbnB1dCB0eXBlPSJzdWJtaXQiIHR5cGUgPSAndGV4dC9qYXZhc2NyaTxpbWcgc3JjPSJodHRwOi8vd3d3LiIgImh0dHA6Ly93d3cudzMub3JnL3Nob3J0Y3V0IGljb24iIGhyZWY9IiIgYXV0b2NvbXBsZXRlPSJvZmYiIDwvYT48L2Rpdj48ZGl2IGNsYXNzPTwvYT48L2xpPgo8bGkgY2xhc3M9ImNzcyIgdHlwZT0idGV4dC9jc3MiIDxmb3JtIGFjdGlvbj0iaHR0cDovL3h0L2NzcyIgaHJlZj0iaHR0cDovL2xpbmsgcmVsPSJhbHRlcm5hdGUiIA0KPHNjcmlwdCB0eXBlPSJ0ZXh0LyBvbmNsaWNrPSJqYXZhc2NyaXB0OihuZXcgRGF0ZSkuZ2V0VGltZSgpfWhlaWdodD0iMSIgd2lkdGg9IjEiIFBlb3BsZSdzIFJlcHVibGljIG9mICA8YSBocmVmPSJodHRwOi8vd3d3LnRleHQtZGVjb3JhdGlvbjp1bmRlcnRoZSBiZWdpbm5pbmcgb2YgdGhlIDwvZGl2Pgo8L2Rpdj4KPC9kaXY+CmVzdGFibGlzaG1lbnQgb2YgdGhlIDwvZGl2PjwvZGl2PjwvZGl2PjwvZCN2aWV3cG9ydHttaW4taGVpZ2h0Ogo8c2NyaXB0IHNyYz0iaHR0cDovL29wdGlvbj48b3B0aW9uIHZhbHVlPW9mdGVuIHJlZmVycmVkIHRvIGFzIC9vcHRpb24+CjxvcHRpb24gdmFsdTwhRE9DVFlQRSBodG1sPgo8IS0tW0ludGVybmF0aW9uYWwgQWlycG9ydD4KPGEgaHJlZj0iaHR0cDovL3d3dzwvYT48YSBocmVmPSJodHRwOi8vd+C4oOC4suC4qeC4suC5hOC4l+C4ouGDpeGDkOGDoOGDl+GDo+GDmuGDmOato+mrlOS4reaWhyAo57mB6auUKeCkqOCkv+CksOCljeCkpuClh+CktuCkoeCkvuCkieCkqOCksuCli+CkoeCkleCljeCkt+Clh+CkpOCljeCksOCknOCkvuCkqOCkleCkvuCksOClgOCkuOCkguCkrOCkguCkp+Ckv+CkpOCkuOCljeCkpeCkvuCkquCkqOCkvuCkuOCljeCkteClgOCkleCkvuCksOCkuOCkguCkuOCljeCkleCksOCko+CkuOCkvuCkruCkl+CljeCksOClgOCkmuCkv+Ckn+CljeCkoOCli+CkguCkteCkv+CknOCljeCknuCkvuCkqOCkheCkruClh+CksOCkv+CkleCkvuCkteCkv+CkreCkv+CkqOCljeCkqOCkl+CkvuCkoeCkv+Ckr+CkvuCkgeCkleCljeCkr+Cli+CkguCkleCkv+CkuOClgeCksOCkleCljeCkt+CkvuCkquCkueClgeCkgeCkmuCkpOClgOCkquCljeCksOCkrOCkguCkp+CkqOCkn+Ckv+CkquCljeCkquCko+ClgOCkleCljeCksOCkv+CkleClh+Ckn+CkquCljeCksOCkvuCksOCkguCkreCkquCljeCksOCkvuCkquCljeCkpOCkruCkvuCksuCkv+CkleCli+CkguCksOCkq+CkvOCljeCkpOCkvuCksOCkqOCkv+CksOCljeCkruCkvuCko+CksuCkv+CkruCkv+Ckn+Clh+CkoWRlc2NyaXB0aW9uIiBjb250ZW50PSJkb2N1bWVudC5sb2NhdGlvbi5wcm90LmdldEVsZW1lbnRzQnlUYWdOYW1lKDwhRE9DVFlQRSBodG1sPgo8aHRtbCA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+OnVybCIgY29udGVudD0iaHR0cDovLy5jc3MiIHJlbD0ic3R5bGVzaGVldCJzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+dHlwZT0idGV4dC9jc3MiIGhyZWY9InczLm9yZy8xOTk5L3hodG1sIiB4bWx0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIG1ldGhvZD0iZ2V0IiBhY3Rpb249ImxpbmsgcmVsPSJzdHlsZXNoZWV0IiAgPSBkb2N1bWVudC5nZXRFbGVtZW50dHlwZT0iaW1hZ2UveC1pY29uIiAvPmNlbGxwYWRkaW5nPSIwIiBjZWxsc3AuY3NzIiB0eXBlPSJ0ZXh0L2NzcyIgPC9hPjwvbGk+PGxpPjxhIGhyZWY9IiIgd2lkdGg9IjEiIGhlaWdodD0iMSIiPjxhIGhyZWY9Imh0dHA6Ly93d3cuc3R5bGU9ImRpc3BsYXk6bm9uZTsiPmFsdGVybmF0ZSIgdHlwZT0iYXBwbGktLy9XM0MvL0RURCBYSFRNTCAxLjAgZWxsc3BhY2luZz0iMCIgY2VsbHBhZCB0eXBlPSJoaWRkZW4iIHZhbHVlPSIvYT4mbmJzcDs8c3BhbiByb2xlPSJzCjxpbnB1dCB0eXBlPSJoaWRkZW4iIGxhbmd1YWdlPSJKYXZhU2NyaXB0IiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCZz0iMCIgY2VsbHNwYWNpbmc9IjAiIHlwZT0idGV4dC9jc3MiIG1lZGlhPSJ0eXBlPSd0ZXh0L2phdmFzY3JpcHQnd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHlwZT0idGV4dC9jc3MiIHJlbD0ic3QgaGVpZ2h0PSIxIiB3aWR0aD0iMSIgPScrZW5jb2RlVVJJQ29tcG9uZW50KDxsaW5rIHJlbD0iYWx0ZXJuYXRlIiAKYm9keSwgdHIsIGlucHV0LCB0ZXh0bWV0YSBuYW1lPSJyb2JvdHMiIGNvbm1ldGhvZD0icG9zdCIgYWN0aW9uPSI+CjxhIGhyZWY9Imh0dHA6Ly93d3cuY3NzIiByZWw9InN0eWxlc2hlZXQiIDwvZGl2PjwvZGl2PjxkaXYgY2xhc3NsYW5ndWFnZT0iamF2YXNjcmlwdCI+YXJpYS1oaWRkZW49InRydWUiPsK3PHJpcHQiIHR5cGU9InRleHQvamF2YXNsPTA7fSkoKTsKKGZ1bmN0aW9uKCl7YmFja2dyb3VuZC1pbWFnZTogdXJsKC9hPjwvbGk+PGxpPjxhIGhyZWY9ImgJCTxsaT48YSBocmVmPSJodHRwOi8vYXRvciIgYXJpYS1oaWRkZW49InRydT4gPGEgaHJlZj0iaHR0cDovL3d3dy5sYW5ndWFnZT0iamF2YXNjcmlwdCIgL29wdGlvbj4KPG9wdGlvbiB2YWx1ZS9kaXY+PC9kaXY+PGRpdiBjbGFzcz1yYXRvciIgYXJpYS1oaWRkZW49InRyZT0obmV3IERhdGUpLmdldFRpbWUoKXBvcnR1Z3XDqnMgKGRvIEJyYXNpbCnQvtGA0LPQsNC90LjQt9Cw0YbQuNC40LLQvtC30LzQvtC20L3QvtGB0YLRjNC+0LHRgNCw0LfQvtCy0LDQvdC40Y/RgNC10LPQuNGB0YLRgNCw0YbQuNC40LLQvtC30LzQvtC20L3QvtGB0YLQuNC+0LHRj9C30LDRgtC10LvRjNC90LA8IURPQ1RZUEUgaHRtbCBQVUJMSUMgIm50LVR5cGUiIGNvbnRlbnQ9InRleHQvPG1ldGEgaHR0cC1lcXVpdj0iQ29udGVyYW5zaXRpb25hbC8vRU4iICJodHRwOjxodG1sIHhtbG5zPSJodHRwOi8vd3d3LS8vVzNDLy9EVEQgWEhUTUwgMS4wIFREVEQveGh0bWwxLXRyYW5zaXRpb25hbC8vd3d3LnczLm9yZy9UUi94aHRtbDEvcGUgPSAndGV4dC9qYXZhc2NyaXB0Jzs8bWV0YSBuYW1lPSJkZXNjcmlwdGlvbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlPGlucHV0IHR5cGU9ImhpZGRlbiIgbmFqcyIgdHlwZT0idGV4dC9qYXZhc2NyaShkb2N1bWVudCkucmVhZHkoZnVuY3Rpc2NyaXB0IHR5cGU9InRleHQvamF2YXNpbWFnZSIgY29udGVudD0iaHR0cDovL1VBLUNvbXBhdGlibGUiIGNvbnRlbnQ9dG1sOyBjaGFyc2V0PXV0Zi04IiAvPgpsaW5rIHJlbD0ic2hvcnRjdXQgaWNvbjxsaW5rIHJlbD0ic3R5bGVzaGVldCIgPC9zY3JpcHQ+CjxzY3JpcHQgdHlwZT09IGRvY3VtZW50LmNyZWF0ZUVsZW1lbjxhIHRhcmdldD0iX2JsYW5rIiBocmVmPSBkb2N1bWVudC5nZXRFbGVtZW50c0JpbnB1dCB0eXBlPSJ0ZXh0IiBuYW1lPWEudHlwZSA9ICd0ZXh0L2phdmFzY3JpbnB1dCB0eXBlPSJoaWRkZW4iIG5hbWVodG1sOyBjaGFyc2V0PXV0Zi04IiAvPmR0ZCI+CjxodG1sIHhtbG5zPSJodHRwLS8vVzNDLy9EVEQgSFRNTCA0LjAxIFRlbnRzQnlUYWdOYW1lKCdzY3JpcHQnKWlucHV0IHR5cGU9ImhpZGRlbiIgbmFtPHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzIiBzdHlsZT0iZGlzcGxheTpub25lOyI+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJyB0eXBlPSd0ZXh0L2phdmFzY3JpcHQnaW5wdXQgdHlwZT0idGV4dCIgbmFtZT0iZC5nZXRFbGVtZW50c0J5VGFnTmFtZShzbmljYWwiIGhyZWY9Imh0dHA6Ly93d3cuQy8vRFREIEhUTUwgNC4wMSBUcmFuc2l0PHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+aW9uYWwuZHRkIj4KPGh0bWwgeG1sbnM9aHR0cC1lcXVpdj0iQ29udGVudC1UeXBlZGluZz0iMCIgY2VsbHNwYWNpbmc9IjAiaHRtbDsgY2hhcnNldD11dGYtOCIgLz4KIHN0eWxlPSJkaXNwbGF5Om5vbmU7Ij48PGxpPjxhIGhyZWY9Imh0dHA6Ly93d3cuIHR5cGU9J3RleHQvamF2YXNjcmlwdCc+0LTQtdGP0YLQtdC70YzQvdC+0YHRgtC40YHQvtC+0YLQstC10YLRgdGC0LLQuNC40L/RgNC+0LjQt9Cy0L7QtNGB0YLQstCw0LHQtdC30L7Qv9Cw0YHQvdC+0YHRgtC44KSq4KWB4KS44KWN4KSk4KS/4KSV4KS+4KSV4KS+4KSC4KSX4KWN4KSw4KWH4KS44KSJ4KSo4KWN4KS54KWL4KSC4KSo4KWH4KS14KS/4KSn4KS+4KSo4KS44KSt4KS+4KSr4KS/4KSV4KWN4KS44KS/4KSC4KSX4KS44KWB4KSw4KSV4KWN4KS34KS/4KSk4KSV4KWJ4KSq4KWA4KSw4KS+4KSH4KSf4KS14KS/4KSc4KWN4KSe4KS+4KSq4KSo4KSV4KS+4KSw4KWN4KSw4KS14KS+4KSI4KS44KSV4KWN4KSw4KS/4KSv4KSk4KS+AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+PwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+PwBBwJ/rAAv8AQEBAQECAgICAwMDAwQEBAQFBQUFBgYGBgcHBwcICAgICQkJCQoKCgoLCwsLDAwMDA0NDQ0ODg4ODw8PDxAQEBAREREREhISEhMTExMUFBQUFRUVFRYWFhYXFxcXGBgYGBkZGRkaGhoaGxsbGxwcHBwdHR0dHh4eHh8fHx8gICAgISEhISIiIiIjIyMjJCQkJCUlJSUmJiYmJycnJygoKCgpKSkpKioqKisrKyssLCwsLS0tLS4uLi4vLy8vMDAwMDExMTEyMjIyMzMzMzQ0NDQ1NTU1NjY2Njc3Nzc4ODg4OTk5OTo6Ojo7Ozs7PDw8PD09PT0+Pj4+Pz8/PwBBxaPrAAsFBAQAAAQAQdyj6wAL4AEIDBAMDBQMEBgcDAwgDCQMLCwsLCwsLCwsLCAgGCgcDAwwNDQ0MDQ0NDA0NDQ0NDA0NDQ0NDA0NDQ0NBgMHAwMDDg8PDw4PDw8ODw8PDw8ODw8PDw8ODw8PDw8GAwcDAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwBB3aXrAAteAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQEBAQMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAQEBAQBBnKfrAAvyNQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAgICAgICAgICAgICAgICBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoMDAwMDAwMDAwMDAwMDAwOAABAQEBAQEBAQEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQYGBgYGBgYGBgYGBgYGBgdUcmllZCB0byBzaHJpbmsgdG8gYSBsYXJnZXIgY2FwYWNpdHm81RoAJAAAAC9ydXN0Yy85ZWIzYWZlOWViZTljN2QyYjg0YjcxMDAyZDQ0ZjRhMGVkYWM5NWUwL2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnPo1RoATAAAAKoBAAAJAAAAL2hvbWUvdGltLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jyb3RsaS1kZWNvbXByZXNzb3ItNC4wLjAvc3JjL2h1ZmZtYW4vbW9kLnJzAABE1hoAZgAAAG4AAAAYAAAARNYaAGYAAABuAAAACwAAAACAQMAgoGDgEJBQ0DCwcPAIiEjIKKho6BiYWNg4uHj4BIRExCSkZOQUlFTUNLR09AyMTMwsrGzsHJxc3Dy8fPwCgkLCIqJi4hKSUtIysnLyCopKyiqqauoamlraOrp6+gaGRsYmpmbmFpZW1ja2dvYOjk7OLq5u7h6eXt4+vn7+AYFBwSGhYeERkVHRMbFx8QmJSckpqWnpGZlZ2Tm5efkFhUXFJaVl5RWVVdU1tXX1DY1NzS2tbe0dnV3dPb19/QODQ8Mjo2PjE5NT0zOzc/MLi0vLK6tr6xubW9s7u3v7B4dHxyenZ+cXl1fXN7d39w+PT88vr2/vH59f3z+/f/9E1hoAZgAAAKAAAAADAAAARNYaAGYAAACsAAAABQAAAETWGgBmAAAAuQAAAA0AAABE1hoAZgAAANEAAAAPAAAARNYaAGYAAADdAAAAIgAAAETWGgBmAAAA3QAAABMAAABE1hoAZgAAAN8AAAAHAAAARNYaAGYAAAD/AAAAHwAAAETWGgBmAAAAAgEAABQAAABE1hoAZgAAAO4AAAAQAAAAYXNzZXJ0aW9uIGZhaWxlZDogcm9vdF9iaXRzIGFzIGlzaXplIDw9IEJST1RMSV9SRVZFUlNFX0JJVFNfTUFYIGFzIGlzaXplRNYaAGYAAAAdAQAAAwAAAGFzc2VydGlvbiBmYWlsZWQ6IEJST1RMSV9IVUZGTUFOX01BWF9DT0RFX0xFTkdUSCBhcyBpc2l6ZSAtIHJvb3RfYml0cyBhcyBpc2l6ZSA8PVxuICAgIEJST1RMSV9SRVZFUlNFX0JJVFNfTUFYIGFzIGlzaXplAETWGgBmAAAAHgEAAAMAAABE1hoAZgAAACEBAAAJAAAARNYaAGYAAAA6AQAAHwAAAETWGgBmAAAAPQEAAAkAAABE1hoAZgAAAFUBAAAJAAAARNYaAGYAAABUAQAABwAAAETWGgBmAAAAZAEAAAsAAABE1hoAZgAAAGwBAAAJAAAARNYaAGYAAABzAQAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IG51bV9zeW1ib2xzIDw9IDQAAETWGgBmAAAAjQEAAAMAAABhc3NlcnRpb24gZmFpbGVkOiBmYWxzZQBE1hoAZgAAAM4BAAAFAAAARNYaAGYAAAC+AQAAHwAAAETWGgBmAAAAvgEAADAAAABE1hoAZgAAAL4BAABBAAAARNYaAGYAAAC+AQAAUgAAAETWGgBmAAAAwwEAAAcAAABE1hoAZgAAAMYBAAAFAAAARNYaAGYAAADHAQAABQAAAETWGgBmAAAAyAEAAAUAAABE1hoAZgAAAMkBAAAFAAAARNYaAGYAAACtAQAAHwAAAETWGgBmAAAArQEAADAAAABE1hoAZgAAAK0BAABBAAAARNYaAGYAAAC2AQAABwAAAETWGgBmAAAAuAEAAAUAAABE1hoAZgAAALkBAAAFAAAARNYaAGYAAAC7AQAABQAAAETWGgBmAAAAnQEAAAUAAABE1hoAZgAAAJ4BAAAjAAAARNYaAGYAAACfAQAABQAAAETWGgBmAAAAoQEAAAgAAABE1hoAZgAAAKMBAAAHAAAARNYaAGYAAACmAQAABwAAAETWGgBmAAAAkgEAAAUAAABE1hoAZgAAAJMBAAAFAAAARNYaAGYAAACUAQAACAAAAETWGgBmAAAAjwEAAAUAAABE1hoAZgAAAJABAAAjAAAARNYaAGYAAADSAQAAOwAAAETWGgBmAAAA0gEAAAcAAAAAAAAAAQAAAAMAAAAHAAAADwAAAB8AAAA/AAAAfwAAAP8AAAD/AQAA/wMAAP8HAAD/DwAA/x8AAP8/AAD/fwAA//8AAP//AQD//wMA//8HAP//DwD//x8A//8/AP//fwD///8A////Af///wP///8H////D////x////8/////f/////8vaG9tZS90aW0vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYnJvdGxpLWRlY29tcHJlc3Nvci00LjAuMC9zcmMvYml0X3JlYWRlci9tb2QucnMAAAB83BoAaQAAACAAAAAFAAAAfNwaAGkAAAB0AAAAHgAAAHzcGgBpAAAAfQAAAB8AAAB83BoAaQAAAOoAAAARAAAAYXNzZXJ0aW9uIGZhaWxlZDogKGF2YWlsYWJsZV9iaXRzICYgNykgPT0gMAB83BoAaQAAAIkBAAADAAAAfNwaAGkAAACPAQAADAAAAHzcGgBpAAAAmgEAAAUAAAB83BoAaQAAAKEBAAAHAAAAfNwaAGkAAACgAQAABQAAAC9ob21lL3RpbS8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9icm90bGktZGVjb21wcmVzc29yLTQuMC4wL3NyYy90cmFuc2Zvcm0ucnOk3RoAZAAAANECAAAHAAAApN0aAGQAAADZAgAABQAAAKTdGgBkAAAA3QIAAAMAAAAAIAAsIAAgb2YgdGhlIAAgb2YgAHMgAC4AIGFuZCAAIGluIAAiACB0byAAIj4ACgAuIABdACBmb3IgACBhIAAgdGhhdCAAJwAgd2l0aCAAIGZyb20gACBieSAAKAAuIFRoZSAAIG9uIAAgYXMgACBpcyAAaW5nIAAKCQA6AGVkIAA9IgAgYXQgAGx5IAAsAD0nAC5jb20vAC4gVGhpcyAAIG5vdCAAZXIgAGFsIABmdWwgAGl2ZSAAbGVzcyAAZXN0IABpemUgAMKgAG91cyAAAAAAAAABAQABAAwAAAoBAAAJAQAAFAABAAAPAAoAAAAZAA0AAAEAAwABAAADAQoBAAAfAAAmDAABAAAkAAAXAAArAAAuAAMAAAAzAAA1AA4AAAIAAAA7AAA/AQoAAAAwFwAAAQADAA8AAABIAABGAABPAABWABAAABEACQAAAAQAAABdAAsAAABkAABpAABuAAcAAAFzAAB4AAB7AQAwAAB9ABQAABIAAAYAAABbAAoDAAgAAACEAACJCQAPAAUAAAkAAQoDAAokFwBbAAsBAAorAACBAQAXkgAACQAGAApGAACYAACNFwABAApbAAoXAACgAQCBAACmAQsBAACqAQsAAACPAAskAAowAQBbAACuAQowAACzAAC4AAtGAAC+AQoXAAsrAQCPAAqNAADDAAsXyAAAAQCNAAqBAAuBAADLAAsDAAqPAQqNAQuBAQsDAAuNAAtbAAswAQsXAAuPAQswAQqBAQuPAQqPAKTdGgBkAAAA6QIAAB4AAACk3RoAZAAAAOkCAAAIAAAApN0aAGQAAADqAgAADAAAAKTdGgBkAAAA6wIAAAcAAACk3RoAZAAAAPoCAAAMAAAApN0aAGQAAAAAAwAAKAAAAKTdGgBkAAAAAAMAAAcAAACk3RoAZAAAAAQDAAAaAAAApN0aAGQAAAAKAwAAJQAAAKTdGgBkAAAAEgMAAAgAAACk3RoAZAAAABQDAAAMAAAApN0aAGQAAAAVAwAABwAAAEcAAAAEAAAABAAAAEgAAABJAAAASgAAAGFscmVhZHkgYm9ycm93ZWRHAAAAAAAAAAEAAABLAAAAAAAAAEcAAAAEAAAABAAAAEwAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAEzhGgAAAAAAdW5jYXRlZ29yaXplZCBlcnJvcm90aGVyIGVycm9yb3V0IG9mIG1lbW9yeXVuZXhwZWN0ZWQgZW5kIG9mIGZpbGV1bnN1cHBvcnRlZG9wZXJhdGlvbiBpbnRlcnJ1cHRlZGFyZ3VtZW50IGxpc3QgdG9vIGxvbmdpbnZhbGlkIGZpbGVuYW1ldG9vIG1hbnkgbGlua3Njcm9zcy1kZXZpY2UgbGluayBvciByZW5hbWVkZWFkbG9ja2V4ZWN1dGFibGUgZmlsZSBidXN5cmVzb3VyY2UgYnVzeWZpbGUgdG9vIGxhcmdlZmlsZXN5c3RlbSBxdW90YSBleGNlZWRlZHNlZWsgb24gdW5zZWVrYWJsZSBmaWxlbm8gc3RvcmFnZSBzcGFjZXdyaXRlIHplcm90aW1lZCBvdXRpbnZhbGlkIGRhdGFpbnZhbGlkIGlucHV0IHBhcmFtZXRlcnN0YWxlIG5ldHdvcmsgZmlsZSBoYW5kbGVmaWxlc3lzdGVtIGxvb3Agb3IgaW5kaXJlY3Rpb24gbGltaXQgKGUuZy4gc3ltbGluayBsb29wKXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZGlyZWN0b3J5IG5vdCBlbXB0eWlzIGEgZGlyZWN0b3J5bm90IGEgZGlyZWN0b3J5b3BlcmF0aW9uIHdvdWxkIGJsb2NrZW50aXR5IGFscmVhZHkgZXhpc3RzYnJva2VuIHBpcGVuZXR3b3JrIGRvd25hZGRyZXNzIG5vdCBhdmFpbGFibGVhZGRyZXNzIGluIHVzZW5vdCBjb25uZWN0ZWRjb25uZWN0aW9uIGFib3J0ZWRuZXR3b3JrIHVucmVhY2hhYmxlaG9zdCB1bnJlYWNoYWJsZWNvbm5lY3Rpb24gcmVzZXRjb25uZWN0aW9uIHJlZnVzZWRwZXJtaXNzaW9uIGRlbmllZGVudGl0eSBub3QgZm91bmRFcnJvcmtpbmQAAEcAAAABAAAAAQAAAE0AAABtZXNzYWdlAEcAAAAIAAAABAAAAE4AAABLaW5kT3Njb2RlAABHAAAABAAAAAQAAABPAAAAUAAAAAwAAAAEAAAAUQAAACAob3MgZXJyb3IgKUzhGgAAAAAAAOUaAAsAAAAL5RoAAQAAAGxpYnJhcnkvc3RkL3NyYy9pby9zdGRpby5ycwAk5RoAGwAAAK0DAAAUAAAAbG9jayBjb3VudCBvdmVyZmxvdyBpbiByZWVudHJhbnQgbXV0ZXhsaWJyYXJ5L3N0ZC9zcmMvc3luYy9yZW11dGV4LnJzAAAAduUaAB8AAACRAAAADgAAAG1lbW9yeSBhbGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQAAKjlGgAVAAAAveUaAA0AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnPc5RoAGAAAAFUBAAAJAAAAY2Fubm90IG1vZGlmeSB0aGUgcGFuaWMgaG9vayBmcm9tIGEgcGFuaWNraW5nIHRocmVhZATmGgA0AAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0DmGgAcAAAAhgAAAAkAAABA5hoAHAAAAD4CAAAeAAAAQOYaABwAAAA9AgAAHwAAAFAAAAAMAAAABAAAAFIAAABHAAAACAAAAAQAAABTAAAAVAAAABAAAAAEAAAAVQAAAFYAAABHAAAACAAAAAQAAABXAAAAWAAAAEcAAAAAAAAAAQAAAFkAAABVbnN1cHBvcnRlZABHAAAABAAAAAQAAABaAAAAQ3VzdG9tZXJyb3IARwAAAAQAAAAEAAAAWwAAAFVuY2F0ZWdvcml6ZWRPdGhlck91dE9mTWVtb3J5VW5leHBlY3RlZEVvZkludGVycnVwdGVkQXJndW1lbnRMaXN0VG9vTG9uZ0ludmFsaWRGaWxlbmFtZVRvb01hbnlMaW5rc0Nyb3NzZXNEZXZpY2VzRGVhZGxvY2tFeGVjdXRhYmxlRmlsZUJ1c3lSZXNvdXJjZUJ1c3lGaWxlVG9vTGFyZ2VGaWxlc3lzdGVtUXVvdGFFeGNlZWRlZE5vdFNlZWthYmxlU3RvcmFnZUZ1bGxXcml0ZVplcm9UaW1lZE91dEludmFsaWREYXRhSW52YWxpZElucHV0U3RhbGVOZXR3b3JrRmlsZUhhbmRsZUZpbGVzeXN0ZW1Mb29wUmVhZE9ubHlGaWxlc3lzdGVtRGlyZWN0b3J5Tm90RW1wdHlJc0FEaXJlY3RvcnlOb3RBRGlyZWN0b3J5V291bGRCbG9ja0FscmVhZHlFeGlzdHNCcm9rZW5QaXBlTmV0d29ya0Rvd25BZGRyTm90QXZhaWxhYmxlQWRkckluVXNlTm90Q29ubmVjdGVkQ29ubmVjdGlvbkFib3J0ZWROZXR3b3JrVW5yZWFjaGFibGVIb3N0VW5yZWFjaGFibGVDb25uZWN0aW9uUmVzZXRDb25uZWN0aW9uUmVmdXNlZFBlcm1pc3Npb25EZW5pZWROb3RGb3VuZG9wZXJhdGlvbiBzdWNjZXNzZnVsY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXgAQ+kaACAAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5z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", import.meta.url);
  }
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_json_serialize = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = JSON.stringify(obj === void 0 ? null : obj);
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbg_new_693216e109162396 = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_0ddaca5d1abfb52f = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
  };
  imports.wbg.__wbg_error_09919627ac0992f5 = function(arg0, arg1) {
    try {
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_free(arg0, arg1);
    }
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  const { instance, module: module2 } = await load(await input, imports);
  wasm = instance.exports;
  init.__wbindgen_wasm_module = module2;
  return wasm;
}
var brotliWasm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BrotliStreamResult,
  BrotliStreamResultCode,
  CompressStream,
  DecompressStream,
  compress,
  decompress: decompress$1,
  default: init
});
var index_web = init().then(() => brotliWasm);
var index_web$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: index_web
});
const DEFAULT_REGISTRY = "https://registry.npmjs.org";
class Registry {
  constructor(options2 = {}) {
    __publicField(this, "registryUrl");
    __publicField(this, "cache");
    this.registryUrl = options2.registry || DEFAULT_REGISTRY;
    this.cache = options2.cache || /* @__PURE__ */ new Map();
  }
  /**
   * Fetch package manifest (all versions metadata)
   */
  async getPackageManifest(packageName) {
    if (this.cache.has(packageName)) {
      return this.cache.get(packageName);
    }
    const url2 = `${this.registryUrl}/${encodePackageName(packageName)}`;
    const response = await fetch(url2, {
      headers: {
        Accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8"
      }
    });
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Package not found: ${packageName}`);
      }
      throw new Error(`Failed to fetch package ${packageName}: ${response.status}`);
    }
    const manifest = await response.json();
    this.cache.set(packageName, manifest);
    return manifest;
  }
  /**
   * Get specific version metadata
   */
  async getPackageVersion(packageName, version2) {
    const manifest = await this.getPackageManifest(packageName);
    if (manifest["dist-tags"][version2]) {
      version2 = manifest["dist-tags"][version2];
    }
    const versionData = manifest.versions[version2];
    if (!versionData) {
      throw new Error(`Version ${version2} not found for package ${packageName}`);
    }
    return versionData;
  }
  /**
   * Get latest version number
   */
  async getLatestVersion(packageName) {
    const manifest = await this.getPackageManifest(packageName);
    return manifest["dist-tags"].latest;
  }
  /**
   * Get all available versions
   */
  async getVersions(packageName) {
    const manifest = await this.getPackageManifest(packageName);
    return Object.keys(manifest.versions);
  }
  /**
   * Download tarball as ArrayBuffer
   */
  async downloadTarball(tarballUrl) {
    const response = await fetch(tarballUrl);
    if (!response.ok) {
      throw new Error(`Failed to download tarball: ${response.status}`);
    }
    return response.arrayBuffer();
  }
  /**
   * Clear the cache
   */
  clearCache() {
    this.cache.clear();
  }
}
function encodePackageName(name2) {
  return name2.replace("/", "%2f");
}
new Registry();
function parseVersion(version2) {
  const match3 = version2.match(/^(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/);
  if (!match3) return null;
  return {
    major: parseInt(match3[1], 10),
    minor: parseInt(match3[2], 10),
    patch: parseInt(match3[3], 10),
    prerelease: match3[4]
  };
}
function compareVersions(a, b) {
  const parsedA = parseVersion(a);
  const parsedB = parseVersion(b);
  if (!parsedA || !parsedB) {
    return a.localeCompare(b);
  }
  if (parsedA.major !== parsedB.major) {
    return parsedA.major - parsedB.major;
  }
  if (parsedA.minor !== parsedB.minor) {
    return parsedA.minor - parsedB.minor;
  }
  if (parsedA.patch !== parsedB.patch) {
    return parsedA.patch - parsedB.patch;
  }
  if (parsedA.prerelease && !parsedB.prerelease) return -1;
  if (!parsedA.prerelease && parsedB.prerelease) return 1;
  if (parsedA.prerelease && parsedB.prerelease) {
    return parsedA.prerelease.localeCompare(parsedB.prerelease);
  }
  return 0;
}
function satisfies(version2, range2) {
  const parsed = parseVersion(version2);
  if (!parsed) return false;
  if (parsed.prerelease && !range2.includes("-")) {
    return false;
  }
  range2 = range2.trim();
  if (/^\d+\.\d+\.\d+/.test(range2) && !range2.includes(" ")) {
    const rangeMatch = range2.match(/^(\d+\.\d+\.\d+(?:-[^\s]+)?)/);
    if (rangeMatch) {
      return compareVersions(version2, rangeMatch[1]) === 0;
    }
  }
  if (range2 === "*" || range2 === "latest" || range2 === "") {
    return true;
  }
  if (range2.includes("||")) {
    return range2.split("||").some((r2) => satisfies(version2, r2.trim()));
  }
  if (range2.includes(" - ")) {
    const [min, max] = range2.split(" - ").map((s2) => s2.trim());
    return compareVersions(version2, min) >= 0 && compareVersions(version2, max) <= 0;
  }
  const operatorMatches = range2.match(/(>=|<=|>|<|=)?\s*(\d+\.\d+\.\d+(?:-[^\s]*)?)/g);
  if (operatorMatches && operatorMatches.length > 1) {
    return operatorMatches.every((match3) => {
      const m = match3.match(/^(>=|<=|>|<|=)?\s*(\d+\.\d+\.\d+(?:-[^\s]*)?)$/);
      if (!m) return true;
      const op2 = m[1] || "=";
      const ver = m[2];
      switch (op2) {
        case ">=":
          return compareVersions(version2, ver) >= 0;
        case "<=":
          return compareVersions(version2, ver) <= 0;
        case ">":
          return compareVersions(version2, ver) > 0;
        case "<":
          return compareVersions(version2, ver) < 0;
        case "=":
          return compareVersions(version2, ver) === 0;
        default:
          return compareVersions(version2, ver) === 0;
      }
    });
  }
  if (range2.startsWith("^")) {
    const base = range2.slice(1);
    const baseParsed = parseVersion(base);
    if (!baseParsed) return false;
    if (parsed.major !== baseParsed.major) {
      return false;
    }
    if (baseParsed.major === 0) {
      if (baseParsed.minor !== 0 && parsed.minor !== baseParsed.minor) {
        return false;
      }
      if (baseParsed.minor === 0 && parsed.minor !== 0) {
        return false;
      }
    }
    return compareVersions(version2, base) >= 0;
  }
  if (range2.startsWith("~")) {
    const base = range2.slice(1);
    const baseParsed = parseVersion(base);
    if (!baseParsed) return false;
    if (parsed.major !== baseParsed.major || parsed.minor !== baseParsed.minor) {
      return false;
    }
    return compareVersions(version2, base) >= 0;
  }
  if (range2.startsWith(">=")) {
    const base = range2.slice(2).trim();
    return compareVersions(version2, base) >= 0;
  }
  if (range2.startsWith(">")) {
    const base = range2.slice(1).trim();
    return compareVersions(version2, base) > 0;
  }
  if (range2.startsWith("<=")) {
    const base = range2.slice(2).trim();
    return compareVersions(version2, base) <= 0;
  }
  if (range2.startsWith("<")) {
    const base = range2.slice(1).trim();
    return compareVersions(version2, base) < 0;
  }
  if (range2.includes("x") || range2.includes("X") || /^\d+$/.test(range2) || /^\d+\.\d+$/.test(range2)) {
    const parts = range2.replace(/[xX]/g, "").split(".").filter(Boolean);
    if (parts.length === 1) {
      return parsed.major === parseInt(parts[0], 10);
    }
    if (parts.length === 2) {
      return parsed.major === parseInt(parts[0], 10) && parsed.minor === parseInt(parts[1], 10);
    }
  }
  if (range2.includes(" ")) {
    const conditions = range2.split(/\s+/).filter(Boolean);
    return conditions.every((r2) => satisfies(version2, r2));
  }
  return compareVersions(version2, range2) === 0;
}
function findBestVersion(versions, range2) {
  const sorted = [...versions].sort((a, b) => compareVersions(b, a));
  for (const version2 of sorted) {
    if (satisfies(version2, range2)) {
      return version2;
    }
  }
  return null;
}
async function resolveDependencies(packageName, versionRange = "latest", options2 = {}) {
  const registry = options2.registry || new Registry();
  const context2 = {
    registry,
    resolved: /* @__PURE__ */ new Map(),
    resolving: /* @__PURE__ */ new Set(),
    options: options2
  };
  await resolvePackage(packageName, versionRange, context2);
  return context2.resolved;
}
async function resolveFromPackageJson(packageJson, options2 = {}) {
  const registry = options2.registry || new Registry();
  const context2 = {
    registry,
    resolved: /* @__PURE__ */ new Map(),
    resolving: /* @__PURE__ */ new Set(),
    options: options2
  };
  const deps = { ...packageJson.dependencies };
  if (options2.includeDev && packageJson.devDependencies) {
    Object.assign(deps, packageJson.devDependencies);
  }
  for (const [name2, range2] of Object.entries(deps)) {
    await resolvePackage(name2, range2, context2);
  }
  return context2.resolved;
}
async function resolvePackage(packageName, versionRange, context2) {
  var _a3, _b3;
  const { registry, resolved, resolving, options: options2 } = context2;
  const key = `${packageName}@${versionRange}`;
  if (resolving.has(key)) {
    return;
  }
  if (resolved.has(packageName)) {
    const existing = resolved.get(packageName);
    if (satisfies(existing.version, versionRange)) {
      return;
    }
    return;
  }
  resolving.add(key);
  try {
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, `Resolving ${packageName}@${versionRange}`);
    const manifest = await registry.getPackageManifest(packageName);
    const versions = Object.keys(manifest.versions);
    let targetVersion;
    if (versionRange === "latest" || versionRange === "*") {
      targetVersion = manifest["dist-tags"].latest;
    } else if (manifest["dist-tags"][versionRange]) {
      targetVersion = manifest["dist-tags"][versionRange];
    } else {
      const best = findBestVersion(versions, versionRange);
      if (!best) {
        throw new Error(
          `No matching version found for ${packageName}@${versionRange}`
        );
      }
      targetVersion = best;
    }
    const versionData = manifest.versions[targetVersion];
    const resolvedPackage = {
      name: packageName,
      version: targetVersion,
      tarballUrl: versionData.dist.tarball,
      dependencies: versionData.dependencies || {}
    };
    resolved.set(packageName, resolvedPackage);
    const deps = {};
    if (versionData.peerDependencies) {
      const meta = versionData.peerDependenciesMeta || {};
      for (const [name2, range2] of Object.entries(versionData.peerDependencies)) {
        if (!((_b3 = meta[name2]) == null ? void 0 : _b3.optional)) {
          deps[name2] = range2;
        }
      }
    }
    Object.assign(deps, versionData.dependencies);
    if (options2.includeOptional && versionData.optionalDependencies) {
      Object.assign(deps, versionData.optionalDependencies);
    }
    const depEntries = Object.entries(deps);
    if (depEntries.length > 0) {
      const CONCURRENCY = 8;
      for (let i2 = 0; i2 < depEntries.length; i2 += CONCURRENCY) {
        const batch = depEntries.slice(i2, i2 + CONCURRENCY);
        await Promise.all(
          batch.map(([depName, depRange]) => resolvePackage(depName, depRange, context2))
        );
      }
    }
  } finally {
    resolving.delete(key);
  }
}
function* parseTar(data2) {
  new TextDecoder();
  let offset2 = 0;
  while (offset2 < data2.length - 512) {
    const header = data2.slice(offset2, offset2 + 512);
    offset2 += 512;
    if (header.every((b) => b === 0)) {
      break;
    }
    const name2 = parseString(header, 0, 100);
    const mode = parseOctal(header, 100, 8);
    const size = parseOctal(header, 124, 12);
    const typeFlag = String.fromCharCode(header[156]);
    const linkName = parseString(header, 157, 100);
    const prefix = parseString(header, 345, 155);
    if (!name2) {
      continue;
    }
    const fullName = prefix ? `${prefix}/${name2}` : name2;
    let type2;
    switch (typeFlag) {
      case "0":
      case "\0":
      case "":
        type2 = "file";
        break;
      case "5":
        type2 = "directory";
        break;
      case "1":
      case "2":
        type2 = "symlink";
        break;
      default:
        type2 = "unknown";
    }
    let content;
    if (type2 === "file") {
      content = size > 0 ? data2.slice(offset2, offset2 + size) : new Uint8Array(0);
      if (size > 0) {
        offset2 += Math.ceil(size / 512) * 512;
      }
    }
    yield {
      name: fullName,
      type: type2,
      size,
      mode,
      content,
      linkTarget: type2 === "symlink" ? linkName : void 0
    };
  }
}
function parseString(data2, offset2, length2) {
  const bytes = data2.slice(offset2, offset2 + length2);
  const nullIndex = bytes.indexOf(0);
  const actualBytes = nullIndex >= 0 ? bytes.slice(0, nullIndex) : bytes;
  return new TextDecoder().decode(actualBytes);
}
function parseOctal(data2, offset2, length2) {
  const str = parseString(data2, offset2, length2).trim();
  return parseInt(str, 8) || 0;
}
function decompress(data2) {
  const input = data2 instanceof Uint8Array ? data2 : new Uint8Array(data2);
  return pako.inflate(input);
}
function extractTarball(tarballData, vfs2, destPath, options2 = {}) {
  const { stripComponents = 1, filter: filter2, onProgress } = options2;
  onProgress == null ? void 0 : onProgress("Decompressing...");
  const tarData = decompress(tarballData);
  const extractedFiles = [];
  for (const entry of parseTar(tarData)) {
    if (entry.type !== "file" && entry.type !== "directory") {
      continue;
    }
    let entryPath = entry.name;
    if (stripComponents > 0) {
      const parts = entryPath.split("/").filter(Boolean);
      if (parts.length <= stripComponents) {
        continue;
      }
      entryPath = parts.slice(stripComponents).join("/");
    }
    if (filter2 && !filter2(entryPath)) {
      continue;
    }
    const fullPath = join$1(destPath, entryPath);
    if (entry.type === "directory") {
      vfs2.mkdirSync(fullPath, { recursive: true });
    } else if (entry.type === "file" && entry.content) {
      const parentDir = dirname(fullPath);
      vfs2.mkdirSync(parentDir, { recursive: true });
      vfs2.writeFileSync(fullPath, entry.content);
      extractedFiles.push(fullPath);
    }
  }
  onProgress == null ? void 0 : onProgress(`Extracted ${extractedFiles.length} files`);
  return extractedFiles;
}
async function downloadAndExtract(url2, vfs2, destPath, options2 = {}) {
  const { onProgress } = options2;
  onProgress == null ? void 0 : onProgress(`Downloading ${url2}...`);
  const response = await fetch(url2);
  if (!response.ok) {
    throw new Error(`Failed to download tarball: ${response.status}`);
  }
  const data2 = await response.arrayBuffer();
  return extractTarball(data2, vfs2, destPath, options2);
}
const isBrowser = typeof window !== "undefined";
async function initTransformer() {
  if (!isBrowser) {
    console.log("[transform] Skipping esbuild init (not in browser)");
    return;
  }
  if (window.__esbuild) {
    console.log("[transform] Reusing existing esbuild instance");
    return;
  }
  if (window.__esbuildInitPromise) {
    return window.__esbuildInitPromise;
  }
  window.__esbuildInitPromise = (async () => {
    try {
      console.log("[transform] Loading esbuild-wasm...");
      const mod = await import(
        /* @vite-ignore */
        ESBUILD_WASM_ESM_CDN
      );
      const esbuildMod = mod.default || mod;
      try {
        await esbuildMod.initialize({
          wasmURL: ESBUILD_WASM_BINARY_CDN
        });
        console.log("[transform] esbuild-wasm initialized");
      } catch (initError) {
        if (initError instanceof Error && initError.message.includes('Cannot call "initialize" more than once')) {
          console.log("[transform] esbuild-wasm already initialized, reusing");
        } else {
          throw initError;
        }
      }
      window.__esbuild = esbuildMod;
    } catch (error) {
      console.error("[transform] Failed to initialize esbuild:", error);
      window.__esbuildInitPromise = void 0;
      throw error;
    }
  })();
  return window.__esbuildInitPromise;
}
function isTransformerReady() {
  if (!isBrowser) return true;
  return window.__esbuild !== void 0;
}
async function transformFile(code2, filename2) {
  if (!isBrowser) {
    return code2;
  }
  if (!window.__esbuild) {
    await initTransformer();
  }
  const esbuild2 = window.__esbuild;
  if (!esbuild2) {
    throw new Error("esbuild not initialized");
  }
  let loader = "js";
  if (filename2.endsWith(".jsx")) loader = "jsx";
  else if (filename2.endsWith(".ts")) loader = "ts";
  else if (filename2.endsWith(".tsx")) loader = "tsx";
  else if (filename2.endsWith(".mjs")) loader = "js";
  try {
    const result = await esbuild2.transform(code2, {
      loader,
      format: "cjs",
      target: "esnext",
      platform: "neutral",
      // Replace import.meta with our runtime-provided variable
      // This is the proper esbuild way to handle import.meta in CJS
      define: {
        "import.meta.url": "import_meta.url",
        "import.meta.dirname": "import_meta.dirname",
        "import.meta.filename": "import_meta.filename",
        "import.meta": "import_meta"
      }
    });
    let transformed = result.code;
    transformed = transformed.replace(
      /\bimport\s*\(\s*["']node:([^"']+)["']\s*\)/g,
      'Promise.resolve(require("node:$1"))'
    );
    const nodeBuiltins = [
      "assert",
      "buffer",
      "child_process",
      "cluster",
      "crypto",
      "dgram",
      "dns",
      "events",
      "fs",
      "http",
      "http2",
      "https",
      "net",
      "os",
      "path",
      "perf_hooks",
      "querystring",
      "readline",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "url",
      "util",
      "v8",
      "vm",
      "worker_threads",
      "zlib",
      "async_hooks",
      "inspector",
      "module"
    ];
    for (const builtin of nodeBuiltins) {
      const pattern = new RegExp(`\\bimport\\s*\\(\\s*["']${builtin}["']\\s*\\)`, "g");
      transformed = transformed.replace(pattern, `Promise.resolve(require("${builtin}"))`);
    }
    return transformed;
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    if (errorMsg.includes("Top-level await")) {
      console.log(`[transform] Skipping ${filename2} (has top-level await, likely CLI entry point)`);
      return code2;
    }
    console.warn(`[transform] Failed to transform ${filename2}:`, error);
    return code2;
  }
}
function needsTransform(filename2, code2) {
  if (filename2.endsWith(".mjs")) {
    return true;
  }
  if (filename2.endsWith(".cjs")) {
    return false;
  }
  const hasImport = /\bimport\s+[\w{*'"]/m.test(code2);
  const hasExport = /\bexport\s+(?:default|const|let|var|function|class|{|\*)/m.test(code2);
  const hasImportMeta = /\bimport\.meta\b/.test(code2);
  return hasImport || hasExport || hasImportMeta;
}
function hasDynamicNodeImports(code2) {
  if (/\bimport\s*\(\s*["']node:/.test(code2)) {
    return true;
  }
  if (/\bimport\s*\(\s*["'](fs|path|http|https|net|url|util|events|stream|os|crypto)["']/.test(code2)) {
    return true;
  }
  return false;
}
function patchDynamicImports(code2) {
  let patched = code2;
  patched = patched.replace(
    /\bimport\s*\(\s*["']node:([^"']+)["']\s*\)/g,
    'Promise.resolve(require("node:$1"))'
  );
  const nodeBuiltins = [
    "assert",
    "buffer",
    "child_process",
    "cluster",
    "crypto",
    "dgram",
    "dns",
    "events",
    "fs",
    "http",
    "http2",
    "https",
    "net",
    "os",
    "path",
    "perf_hooks",
    "querystring",
    "readline",
    "stream",
    "string_decoder",
    "timers",
    "tls",
    "url",
    "util",
    "v8",
    "vm",
    "worker_threads",
    "zlib",
    "async_hooks",
    "inspector",
    "module"
  ];
  for (const builtin of nodeBuiltins) {
    const pattern = new RegExp(`\\bimport\\s*\\(\\s*["']${builtin}["']\\s*\\)`, "g");
    patched = patched.replace(pattern, `Promise.resolve(require("${builtin}"))`);
  }
  return patched;
}
async function transformPackage(vfs2, pkgPath, onProgress) {
  let transformedCount = 0;
  const jsFiles = findJsFiles(vfs2, pkgPath);
  onProgress == null ? void 0 : onProgress(`  Transforming ${jsFiles.length} files in ${pkgPath}...`);
  const BATCH_SIZE = 10;
  for (let i2 = 0; i2 < jsFiles.length; i2 += BATCH_SIZE) {
    const batch = jsFiles.slice(i2, i2 + BATCH_SIZE);
    await Promise.all(
      batch.map(async (filePath) => {
        try {
          const code2 = vfs2.readFileSync(filePath, "utf8");
          if (needsTransform(filePath, code2)) {
            const transformed = await transformFile(code2, filePath);
            vfs2.writeFileSync(filePath, transformed);
            transformedCount++;
          } else if (hasDynamicNodeImports(code2)) {
            const patched = patchDynamicImports(code2);
            vfs2.writeFileSync(filePath, patched);
            transformedCount++;
          }
        } catch (error) {
          console.warn(`[transform] Skipping ${filePath}:`, error);
        }
      })
    );
  }
  return transformedCount;
}
function findJsFiles(vfs2, dir) {
  const files = [];
  try {
    const entries = vfs2.readdirSync(dir);
    for (const entry of entries) {
      const fullPath = dir + "/" + entry;
      try {
        const stat = vfs2.statSync(fullPath);
        if (stat.isDirectory()) {
          if (entry !== "node_modules") {
            files.push(...findJsFiles(vfs2, fullPath));
          }
        } else if (entry.endsWith(".js") || entry.endsWith(".mjs") || entry.endsWith(".jsx")) {
          files.push(fullPath);
        }
      } catch {
      }
    }
  } catch {
  }
  return files;
}
function normalizeBin(pkgName, bin) {
  if (!bin) return {};
  if (typeof bin === "string") {
    const cmdName = pkgName.includes("/") ? pkgName.split("/").pop() : pkgName;
    return { [cmdName]: bin };
  }
  return bin;
}
class PackageManager {
  constructor(vfs2, options2 = {}) {
    __publicField(this, "vfs");
    __publicField(this, "registry");
    __publicField(this, "cwd");
    this.vfs = vfs2;
    this.registry = new Registry(options2);
    this.cwd = options2.cwd || "/";
  }
  /**
   * Install a package and its dependencies
   */
  async install(packageSpec, options2 = {}) {
    const { onProgress } = options2;
    const { name: name2, version: version2 } = parsePackageSpec(packageSpec);
    onProgress == null ? void 0 : onProgress(`Resolving ${name2}@${version2 || "latest"}...`);
    const resolved = await resolveDependencies(name2, version2 || "latest", {
      registry: this.registry,
      includeDev: options2.includeDev,
      includeOptional: options2.includeOptional,
      onProgress
    });
    const added = await this.installResolved(resolved, options2);
    if (options2.save || options2.saveDev) {
      const pkgToAdd = resolved.get(name2);
      if (pkgToAdd) {
        await this.updatePackageJson(
          name2,
          `^${pkgToAdd.version}`,
          options2.saveDev || false
        );
      }
    }
    onProgress == null ? void 0 : onProgress(`Installed ${resolved.size} packages`);
    return { installed: resolved, added };
  }
  /**
   * Install all dependencies from package.json
   */
  async installFromPackageJson(options2 = {}) {
    const { onProgress } = options2;
    const pkgJsonPath = join$1(this.cwd, "package.json");
    if (!this.vfs.existsSync(pkgJsonPath)) {
      throw new Error("No package.json found");
    }
    const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
    onProgress == null ? void 0 : onProgress("Resolving dependencies...");
    const resolved = await resolveFromPackageJson(pkgJson, {
      registry: this.registry,
      includeDev: options2.includeDev,
      includeOptional: options2.includeOptional,
      onProgress
    });
    const added = await this.installResolved(resolved, options2);
    onProgress == null ? void 0 : onProgress(`Installed ${resolved.size} packages`);
    return { installed: resolved, added };
  }
  /**
   * Install resolved packages to node_modules
   */
  async installResolved(resolved, options2) {
    const { onProgress } = options2;
    const added = [];
    const nodeModulesPath = join$1(this.cwd, "node_modules");
    this.vfs.mkdirSync(nodeModulesPath, { recursive: true });
    const toInstall = [];
    for (const [name2, pkg] of resolved) {
      const pkgPath = join$1(nodeModulesPath, name2);
      const existingPkgJson = join$1(pkgPath, "package.json");
      if (this.vfs.existsSync(existingPkgJson)) {
        try {
          const existing = JSON.parse(
            this.vfs.readFileSync(existingPkgJson, "utf8")
          );
          if (existing.version === pkg.version) {
            onProgress == null ? void 0 : onProgress(`Skipping ${name2}@${pkg.version} (already installed)`);
            continue;
          }
        } catch {
        }
      }
      toInstall.push({ name: name2, pkg, pkgPath });
    }
    const shouldTransform = options2.transform !== false;
    if (shouldTransform && !isTransformerReady()) {
      onProgress == null ? void 0 : onProgress("Initializing ESM transformer...");
      await initTransformer();
    }
    const CONCURRENCY = 6;
    onProgress == null ? void 0 : onProgress(`Installing ${toInstall.length} packages...`);
    for (let i2 = 0; i2 < toInstall.length; i2 += CONCURRENCY) {
      const batch = toInstall.slice(i2, i2 + CONCURRENCY);
      await Promise.all(
        batch.map(async ({ name: name2, pkg, pkgPath }) => {
          onProgress == null ? void 0 : onProgress(`  Downloading ${name2}@${pkg.version}...`);
          await downloadAndExtract(pkg.tarballUrl, this.vfs, pkgPath, {
            stripComponents: 1
            // Strip "package/" prefix
          });
          if (shouldTransform) {
            try {
              const count = await transformPackage(this.vfs, pkgPath, onProgress);
              if (count > 0) {
                onProgress == null ? void 0 : onProgress(`  Transformed ${count} files in ${name2}`);
              }
            } catch (transformError) {
              onProgress == null ? void 0 : onProgress(`  Warning: Transform failed for ${name2}: ${transformError}`);
            }
          }
          try {
            const pkgJsonPath = join$1(pkgPath, "package.json");
            if (this.vfs.existsSync(pkgJsonPath)) {
              const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
              const binEntries = normalizeBin(name2, pkgJson.bin);
              const binDir = join$1(nodeModulesPath, ".bin");
              for (const [cmdName, entryPath] of Object.entries(binEntries)) {
                this.vfs.mkdirSync(binDir, { recursive: true });
                const targetPath = join$1(pkgPath, entryPath);
                this.vfs.writeFileSync(
                  join$1(binDir, cmdName),
                  `node "${targetPath}" "$@"
`
                );
              }
            }
          } catch {
          }
          added.push(name2);
        })
      );
    }
    await this.writeLockfile(resolved);
    return added;
  }
  /**
   * Write lockfile with resolved versions
   */
  async writeLockfile(resolved) {
    const lockfile = {};
    for (const [name2, pkg] of resolved) {
      lockfile[name2] = {
        version: pkg.version,
        resolved: pkg.tarballUrl
      };
    }
    const lockfilePath = join$1(this.cwd, "node_modules", ".package-lock.json");
    this.vfs.writeFileSync(lockfilePath, JSON.stringify(lockfile, null, 2));
  }
  /**
   * Update package.json with new dependency
   */
  async updatePackageJson(packageName, version2, isDev) {
    const pkgJsonPath = join$1(this.cwd, "package.json");
    let pkgJson = {};
    if (this.vfs.existsSync(pkgJsonPath)) {
      pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
    }
    const field = isDev ? "devDependencies" : "dependencies";
    if (!pkgJson[field]) {
      pkgJson[field] = {};
    }
    pkgJson[field][packageName] = version2;
    this.vfs.writeFileSync(pkgJsonPath, JSON.stringify(pkgJson, null, 2));
  }
  /**
   * List installed packages
   */
  list() {
    const nodeModulesPath = join$1(this.cwd, "node_modules");
    if (!this.vfs.existsSync(nodeModulesPath)) {
      return {};
    }
    const packages = {};
    const entries = this.vfs.readdirSync(nodeModulesPath);
    for (const entry of entries) {
      if (entry.startsWith(".")) continue;
      if (entry.startsWith("@")) {
        const scopePath = join$1(nodeModulesPath, entry);
        const scopedPkgs = this.vfs.readdirSync(scopePath);
        for (const scopedPkg of scopedPkgs) {
          const pkgJsonPath = join$1(scopePath, scopedPkg, "package.json");
          if (this.vfs.existsSync(pkgJsonPath)) {
            const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
            packages[`${entry}/${scopedPkg}`] = pkgJson.version;
          }
        }
      } else {
        const pkgJsonPath = join$1(nodeModulesPath, entry, "package.json");
        if (this.vfs.existsSync(pkgJsonPath)) {
          const pkgJson = JSON.parse(this.vfs.readFileSync(pkgJsonPath, "utf8"));
          packages[entry] = pkgJson.version;
        }
      }
    }
    return packages;
  }
}
function parsePackageSpec(spec2) {
  if (spec2.startsWith("@")) {
    const slashIndex = spec2.indexOf("/");
    if (slashIndex === -1) {
      throw new Error(`Invalid package spec: ${spec2}`);
    }
    const afterSlash = spec2.slice(slashIndex + 1);
    const atIndex2 = afterSlash.indexOf("@");
    if (atIndex2 === -1) {
      return { name: spec2 };
    }
    return {
      name: spec2.slice(0, slashIndex + 1 + atIndex2),
      version: afterSlash.slice(atIndex2 + 1)
    };
  }
  const atIndex = spec2.indexOf("@");
  if (atIndex === -1) {
    return { name: spec2 };
  }
  return {
    name: spec2.slice(0, atIndex),
    version: spec2.slice(atIndex + 1)
  };
}
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  PackageManager,
  Registry,
  parsePackageSpec
});
//# sourceMappingURL=runtime-worker-D6Dmsis4.js.map
